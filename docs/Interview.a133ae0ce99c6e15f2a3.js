(window.webpackJsonp=window.webpackJsonp||[]).push([[5],Array(135).concat([function(r,n,e){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var t=a(e(1)),o=e(994),s=a(e(995));function a(r){return r&&r.__esModule?r:{default:r}}n.default=function(r){var n=r.component,e=r.menuConfig,a=r.defaultOpenKeys,i=void 0===a?[]:a,c=r.hiddenLeftNav,l=function(r,n){var e={};for(var t in r)n.indexOf(t)>=0||Object.prototype.hasOwnProperty.call(r,t)&&(e[t]=r[t]);return e}(r,["component","menuConfig","defaultOpenKeys","hiddenLeftNav"]),u=!(0,o.isPC)()&&c;return t.default.createElement("div",{className:"all-content"},u||t.default.createElement(s.default,{menuConfig:e,defaultOpenKeys:i}),t.default.createElement("div",{className:"right-content"},t.default.createElement(n,l)))}},function(r,n,e){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.default=void 0;var t,o,s=function(){function r(r,n){for(var e=0;e<n.length;e++){var t=n[e];t.enumerable=t.enumerable||!1,t.configurable=!0,"value"in t&&(t.writable=!0),Object.defineProperty(r,t.key,t)}}return function(n,e,t){return e&&r(n.prototype,e),t&&r(n,t),n}}(),a=e(1),i=d(a),c=e(96),l=e(72),u=d(e(269));function d(r){return r&&r.__esModule?r:{default:r}}function p(r,n){if(!(r instanceof n))throw new TypeError("Cannot call a class as a function")}function m(r,n){if(!r)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!n||"object"!=typeof n&&"function"!=typeof n?r:n}var f=(t=(0,c.connect)((function(r){return{isLogin:r.loginStore.isLogin,permission:r.loginStore.permission}}),null),(0,l.withRouter)(o=t(o=function(r){function n(){return p(this,n),m(this,(n.__proto__||Object.getPrototypeOf(n)).apply(this,arguments))}return function(r,n){if("function"!=typeof n&&null!==n)throw new TypeError("Super expression must either be null or a function, not "+typeof n);r.prototype=Object.create(n&&n.prototype,{constructor:{value:r,enumerable:!1,writable:!0,configurable:!0}}),n&&(Object.setPrototypeOf?Object.setPrototypeOf(r,n):r.__proto__=n)}(n,r),s(n,[{key:"render",value:function(){var r=this.props,n=r.routePermission,e=r.permission,t=!n||"normal"===n||n===e;return r.isLogin&&!e&&"manager"===n?i.default.createElement(u.default,null):t?i.default.createElement(l.Route,this.props):i.default.createElement(l.Redirect,{to:"/nopermission"})}}]),n}(a.Component))||o)||o);n.default=f},,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,function(r,n,e){var t={"./Immutable/Immutable Data.md":426,"./Immutable/react中使用Immutable Data.md":427,"./Web Worker/Service Worker.md":428,"./Web Worker/Shared Worker.md":429,"./Web Worker/Web Worker.md":430,"./Web Worker/react中使用Web Worker.md":431,"./WebSocket/SSE.md":432,"./WebSocket/WebSocket.md":433,"./WebSocket/WebSocket心跳.md":434,"./WebSocket/断网时现象.md":435,"./babel/Babel.md":436,"./babel/Babel配置.md":437,"./cli/cli.md":438,"./css/bfc.md":439,"./css/css.md":440,"./css/css3.md":441,"./css/css变量.md":442,"./css/css选择器-child和-of-type的使用差异.md":443,"./css/css选择器.md":444,"./css/flex.md":445,"./css/grid.md":446,"./css/scss变量.md":447,"./css/伪类伪元素.md":448,"./css/居中.md":449,"./css/换行.md":450,"./css/样式隔离.md":451,"./css/浮动.md":452,"./css/父元素使用max-height，子元素使用百分比不生效.md":453,"./css/盒子模型.md":454,"./css/网页变黑白颜色.md":455,"./css/雪碧图.md":456,"./diff/React、Vue3、Vue2 列表的 Diff 算法对比.md":457,"./diff/react Diff.md":458,"./diff/react Diff更新.md":459,"./docker/copy命令.md":460,"./docker/docker.md":461,"./docker/docker常用命令.md":462,"./docker/docker镜像.md":463,"./fiber/FiberNode.md":464,"./git/fetch和merge的区别.md":465,"./git/git提交规范.md":466,"./git/rebase和merge的区别.md":467,"./html/css加载.md":468,"./html/meta.md":469,"./html/修改页签icon.md":470,"./html/搜索引擎优化.md":471,"./html/页面可见性.md":472,"./html/页面生命周期.md":473,"./http/Accept系列字段.md":474,"./http/URI.md":475,"./http/dns.md":476,"./http/http.md":477,"./http/http2.md":478,"./http/https.md":479,"./http/http代理.md":480,"./http/http状态码.md":481,"./http/http请求方法.md":482,"./http/三次握手.md":483,"./http/四次挥手.md":484,"./http/头.md":485,"./http/定长不定长的数据处理.md":486,"./http/队头阻塞.md":487,"./http缓存/http缓存.md":488,"./http缓存/协商缓存.md":489,"./http缓存/启发式缓存.md":490,"./http缓存/强缓存.md":491,"./http缓存/最佳实践.md":492,"./http缓存/浏览器刷新.md":493,"./http缓存/缓存位置.md":494,"./js/==和===.md":495,"./js/Array.md":496,"./js/ES6.md":497,"./js/Generator和协程.md":498,"./js/Map.md":499,"./js/Object.defineProperty.md":500,"./js/ResizeObserver.md":501,"./js/Set.md":502,"./js/Symbol.md":503,"./js/WebComponent.md":504,"./js/a == 1 && a == 2 && a == 3.md":505,"./js/arguments.md":506,"./js/async在循环中使用的问题.md":507,"./js/async的错误捕获.md":508,"./js/beforeunload事件.md":509,"./js/encodeURI和encodeURIComponent的异同.md":510,"./js/esModule和commonjs的区别.md":511,"./js/forEach的局限.md":512,"./js/hasOwnProperty与in的区别.md":513,"./js/js事件流.md":514,"./js/js加载方式.md":515,"./js/new操作符.md":516,"./js/promise.md":517,"./js/promiseAll控制并发.md":518,"./js/requestIdleCallback.md":519,"./js/setTimeout和setInterval.md":520,"./js/this.md":521,"./js/var let const差异.md":522,"./js/事件委托.md":523,"./js/事件循环eventLoop.md":524,"./js/作用域.md":525,"./js/前端获取网络信息.md":526,"./js/图像懒加载和预加载.md":527,"./js/实现准时的setTimeout.md":528,"./js/对象创建.md":529,"./js/异步处理方案.md":530,"./js/数据类型及判断方法.md":531,"./js/浏览器页面不可见时定时器是否准时.md":532,"./js/浮点数精度丢失.md":533,"./js/深浅拷贝.md":534,"./js/渲染大量数据.md":535,"./js/箭头函数与普通函数的区别.md":536,"./js/类和原型实现相同功能.md":537,"./js/类型转换.md":538,"./js/继承.md":539,"./js/节流与防抖.md":540,"./js/运算符.md":541,"./js/闭包.md":542,"./js/预解析.md":543,"./js/高级函数用法.md":544,"./js内存/优化内存使用.md":545,"./js内存/内存泄漏场景.md":546,"./js内存/内存管理机制.md":547,"./js内存/垃圾回收.md":548,"./monorepo/lerna + Yarn Workspace.md":549,"./monorepo/pnpm-monorepo.md":550,"./monorepo/项目依赖管理.md":551,"./nginx/IP黑白名单.md":552,"./nginx/gzip压缩.md":553,"./nginx/location.md":554,"./nginx/nginx.md":555,"./nginx/proxy_pass.md":556,"./nginx/root和alias.md":557,"./nginx/try_files.md":558,"./nginx/常用命令.md":559,"./nginx/常用配置.md":560,"./nginx/正向代理反向代理.md":561,"./nginx/解决跨域问题.md":562,"./nginx/负载均衡.md":563,"./nginx/配置SSL证书.md":564,"./nginx/防盗链.md":565,"./node/node安装.md":566,"./node/node执行命令添加参数.md":567,"./node/nvm.md":568,"./node/path.md":569,"./npm/npm run xxx.md":570,"./npm/npm源管理.md":571,"./npm/npm版本符号.md":572,"./npm/package-lock.md":573,"./npm/package.md":574,"./npm/yarn.md":575,"./npm/修改npm包逻辑.md":576,"./npm/常用命令.md":577,"./react/Context.md":578,"./react/api.md":579,"./react/class组件的super.md":580,"./react/fiber.md":581,"./react/hooks.md":582,"./react/hooks中使用防抖节流.md":583,"./react/hooks作用.md":584,"./react/hooks模拟class生命周期.md":585,"./react/hooks生命周期.md":586,"./react/jsx.md":587,"./react/jsx转换的变化.md":588,"./react/key.md":589,"./react/key的作用.md":590,"./react/re-render.md":591,"./react/react-router4 Prompt实现路由跳转前的提示.md":592,"./react/react-router6组件外部路由跳转.md":593,"./react/react.md":594,"./react/react18变化.md":595,"./react/react18并发模式.md":596,"./react/react为什么需要一个根标签包裹.md":597,"./react/react事件机制.md":598,"./react/react架构.md":599,"./react/react模式.md":600,"./react/react渲染.md":601,"./react/react错误捕获.md":602,"./react/ref.md":603,"./react/renderProps.md":604,"./react/router.md":605,"./react/setState.md":606,"./react/state和props.md":607,"./react/useEffect和useLayoutEffect.md":608,"./react/useMemo和useCallback.md":609,"./react/useReducer.md":610,"./react/不依赖客户端时间的倒计时.md":611,"./react/受控和非受控组件.md":612,"./react/状态管理.md":613,"./react/生命周期.md":614,"./react/简单react.md":615,"./react/类组件中方法绑定到类实例.md":616,"./react/组件封装.md":617,"./react/组件通信.md":618,"./react/自定义hooks.md":619,"./react/虚拟DOM.md":620,"./react/高阶组件.md":621,"./react/高阶组件和hooks对比.md":622,"./react源码/Component.md":623,"./react源码/commit阶段.md":624,"./react源码/createElement.md":625,"./react源码/源码调试.md":626,"./react状态管理/react-redux实现.md":627,"./react状态管理/redux.md":628,"./react状态管理/redux与mobx对比.md":629,"./react状态管理/redux实现.md":630,"./seo/seo.md":631,"./sourcemap/sourcemap.md":632,"./sourcemap/webpack中使用sourcemap.md":633,"./ssr/react服务端渲染.md":634,"./ssr/ssr.md":635,"./todo.md":636,"./typescript/export和export type的区别.md":637,"./typescript/interface和type的异同.md":638,"./typescript/tsconfig.md":639,"./typescript/typescript.md":640,"./typescript/unknown和any.md":641,"./typescript/常用示例.md":642,"./typescript/映射类型.md":643,"./typescript/泛型.md":644,"./typescript/类型声明文件.md":645,"./vite/esbuild构建速度快于webpack.md":646,"./vite/vite VS webpack.md":647,"./vite/vite配置项.md":648,"./vite/依赖预构建.md":649,"./vue/defineProperty缺陷.md":650,"./vue/v-for中加入条件判断.md":651,"./vue/vue3.md":652,"./vue/vue的data是通过方法返回.md":653,"./vue/生命周期.md":654,"./vue/简易vue实现.md":655,"./webpack使用/chunk.md":656,"./webpack使用/css-loader.md":657,"./webpack使用/css文件提取成单独的文件.md":658,"./webpack使用/loader.md":659,"./webpack使用/output.md":660,"./webpack使用/output的hash.md":661,"./webpack使用/plugin.md":662,"./webpack使用/proxy.md":663,"./webpack使用/splitChunksPlugin.md":664,"./webpack使用/webpack5变化.md":665,"./webpack使用/webpack5搭建react+ts项目.md":666,"./webpack使用/webpack的作用.md":667,"./webpack使用/构建体积优化.md":668,"./webpack使用/构建时间优化.md":669,"./webpack使用/配置项.md":670,"./webpack原理/plugin.md":671,"./webpack原理/异步加载(懒加载).md":672,"./webpack原理/热更新.md":673,"./webrtc/mediaDevices.md":674,"./web安全/csrf.md":675,"./web安全/react防御xss.md":676,"./web安全/sql注入.md":677,"./web安全/xss.md":678,"./web安全/接口加密.md":679,"./代码优化/减少if-else的使用.md":680,"./前端主题切换/antd v5实现主题切换.md":681,"./前端主题切换/前端主题切换方案.md":682,"./前端回滚/前端回滚.md":683,"./前端回滚/秒级回滚-未使用docker.md":684,"./前端工程化/BFF.md":685,"./前端工程化/Eslint + Prettier + husky + lint-staged规范前端工程.md":686,"./前端工程化/browserslist.md":687,"./前端工程化/cdn.md":688,"./前端工程化/dayjs代替moment.md":689,"./前端工程化/前端工程化.md":690,"./前端工程化/前端规范.md":691,"./前端工程化/统一node版本.md":692,"./前端工程化/统一npm版本.md":693,"./前端工程化/负载均衡.md":694,"./前端异常/try-catch.md":695,"./前端异常/前端异常.md":696,"./前端异常/异常处理.md":697,"./前端异常/异常监控.md":698,"./前端文件处理/ArrayBuffer.md":699,"./前端文件处理/Base64.md":700,"./前端文件处理/Blob.md":701,"./前端文件处理/File.md":702,"./前端文件处理/FileReader.md":703,"./前端文件处理/ObjectURL.md":704,"./前端文件处理/前端请求文件数据流.md":705,"./前端文件处理/大文件切片上传.md":706,"./前端文件处理/大文件断点续传.md":707,"./前端文件处理/文件上传.md":708,"./前端文件处理/文件下载.md":709,"./前端文件处理/文件预览.md":710,"./前端文件处理/格式转化.md":711,"./前端模块化/ES Module.md":712,"./前端模块化/export和export default的区别.md":713,"./前端模块化/module.exports和exports的区别.md":714,"./前端模块化/umd.md":715,"./前端模块化/前端模块化.md":716,"./前端监控/webpack插件上传sourcemap.md":717,"./前端监控/前端监控.md":718,"./前端监控/性能数据采集.md":719,"./前端监控/接口请求错误数据采集.md":720,"./前端监控/数据上报.md":721,"./前端监控/行为数据采集.md":722,"./前端监控/解析错误信息源码.md":723,"./前端监控/错误数据采集.md":724,"./前端调试-react/React Profiler.md":725,"./前端调试-react/Redux DevTools.md":726,"./前端调试-移动端/inspect调试.md":727,"./前端调试-移动端/whistle.md":728,"./前端调试-移动端/微信h5调试.md":729,"./前端调试/修改线上代码调试.md":730,"./前端调试/断点调试.md":731,"./前端调试/生产环境使用本地sourcemap调试.md":732,"./前端调试/线上问题调试.md":733,"./前端部署/docker部署项目.md":734,"./前端部署/gitlab runner部署项目.md":735,"./前端部署/html引用资源部署.md":736,"./前端部署/nginx配置前端项目.md":737,"./前端部署/版本更新提示.md":738,"./原型原型链/api.md":739,"./原型原型链/原型原型链.md":740,"./原型原型链/原型对象值修改.md":741,"./原型原型链/对象的属性和方法查找.md":742,"./国际化/react-intl国际化.md":743,"./国际化/项目国际化工作项.md":744,"./开发功能总结/react-markdown渲染markdown文件.md":745,"./开发功能总结/复制粘贴功能.md":746,"./开发功能总结/复制网页内容为图片.md":747,"./微前端/qiankun微前端.md":748,"./微前端/qiankun微前端各应用分别部署.md":749,"./微前端/qiankun微前端部署同级目录.md":750,"./微前端/qiankun微前端部署非同级目录.md":751,"./微前端/微前端.md":752,"./性能优化-react/PureComponent比较逻辑.md":753,"./性能优化-react/react性能优化.md":754,"./性能优化-react/优化场景.md":755,"./性能优化-react/更快的完成Diff比较.md":756,"./性能优化-react/跳过不必要的组件更新.md":757,"./性能优化-react/通用优化.md":758,"./性能优化/前端处理高并发.md":759,"./性能优化/图片资源优化.md":760,"./性能优化/客户端优化H5加载速度.md":761,"./性能优化/性能优化.md":762,"./性能优化/性能指标.md":763,"./性能优化/网络请求优化.md":764,"./性能优化/资源体积优化.md":765,"./性能优化/项目细节优化.md":766,"./手写代码/手写ES6数组方法.md":767,"./手写代码/手写bind、call、apply.md":768,"./手写代码/手写instanceof.md":769,"./手写代码/手写promise.md":770,"./数据结构/字典.md":771,"./数据结构/栈.md":772,"./数据结构/树.md":773,"./数据结构/链表.md":774,"./数据结构/队列.md":775,"./数据结构/集合.md":776,"./数据请求/refreshToken.md":777,"./数据请求/sendBeacon.md":778,"./数据请求/数据请求.md":779,"./数据请求/数据请求轮询.md":780,"./数组排序/冒泡排序.md":781,"./数组排序/归并排序.md":782,"./数组排序/快速排序.md":783,"./数组排序/插入排序.md":784,"./数组排序/选择排序.md":785,"./框架/react和vue的异同.md":786,"./框架/使用EventBus进行跨组件通信.md":787,"./浏览器/Cookie.md":788,"./浏览器/WebStorage.md":789,"./浏览器/回流和重绘.md":790,"./浏览器/复合图层.md":791,"./浏览器/多进程的浏览器.md":792,"./浏览器/浏览器渲染流程.md":793,"./浏览器/浏览器渲染进程(浏览器内核).md":794,"./浏览器/输入URL到显示.md":795,"./浏览器/进程和线程.md":796,"./混合开发/Android使用WebView.md":797,"./混合开发/JSBridge.md":798,"./混合开发/WebView.md":799,"./混合开发/dsbridge.md":800,"./混合开发/安卓应用和H5相互调用.md":801,"./混合开发/混合开发.md":802,"./登录/JWT.md":803,"./登录/Session-Cookie.md":804,"./登录/Token.md":805,"./登录/单点登录.md":806,"./登录/唯一登录.md":807,"./登录/扫码登录.md":808,"./登录/第三方登录.md":809,"./移动端/像素.md":810,"./移动端/兼容问题.md":811,"./移动端/点击问题.md":812,"./移动端/移动端适配.md":813,"./移动端/视口.md":814,"./移动端/软键盘弹起.md":815,"./算法-二叉树/二叉搜索树中的搜索.md":816,"./算法-二叉树/二叉树中序遍历.md":817,"./算法-二叉树/二叉树先序遍历.md":818,"./算法-二叉树/二叉树后序遍历.md":819,"./算法-二叉树/二叉树层序遍历.md":820,"./算法-二叉树/二叉树的最大深度.md":821,"./算法-二叉树/二叉树的最小深度.md":822,"./算法-二叉树/二叉树的最近公共祖先.md":823,"./算法-二叉树/对称二叉树.md":824,"./算法-二叉树/相同的树.md":825,"./算法-二叉树/翻转二叉树.md":826,"./算法-链表/二进制链表转整数.md":827,"./算法-链表/从尾到头打印链表.md":828,"./算法-链表/删除中间节点.md":829,"./算法-链表/删除排序链表中的重复元素.md":830,"./算法-链表/反转链表.md":831,"./算法-链表/合并两个有序链表.md":832,"./算法-链表/回文链表.md":833,"./算法-链表/环形链表.md":834,"./算法-链表/相交链表.md":835,"./算法-链表/移除链表元素.md":836,"./算法-链表/移除链表重复节点.md":837,"./算法-链表/链表中倒数第k个节点.md":838,"./算法-链表/链表的中间结点.md":839,"./算法/两数之和.md":840,"./算法/买卖股票最佳时机.md":841,"./算法/二进制求和.md":842,"./算法/全排列.md":843,"./算法/删除有序数组中的重复项.md":844,"./算法/判断html标签是否匹配.md":845,"./算法/判断是否为有效的字母异位词.md":846,"./算法/加一.md":847,"./算法/十进制转二进制.md":848,"./算法/回文字符串.md":849,"./算法/回文数.md":850,"./算法/子集.md":851,"./算法/字符串是否为子序列.md":852,"./算法/将0移动到数组末尾.md":853,"./算法/搜索插入位置.md":854,"./算法/数组中字符串翻转.md":855,"./算法/数组中最长的连续递增序列并返回长度.md":856,"./算法/斐波那契数列.md":857,"./算法/最后一个单词长度.md":858,"./算法/最大子数组和.md":859,"./算法/最小覆盖字串.md":860,"./算法/最近的请求次数.md":861,"./算法/最长公共前缀.md":862,"./算法/有序数组二分搜索.md":863,"./算法/有效的括号.md":864,"./算法/杨辉三角.md":865,"./算法/爬楼梯.md":866,"./算法/版本号比较.md":867,"./算法/盛最多水的容器.md":868,"./算法/移除数组元素.md":869,"./算法/约瑟夫环.md":870,"./算法/罗马数字转整数.md":871,"./算法/设计哈希映射.md":872,"./算法/设计哈希集合.md":873,"./算法思想/LRU(最少最近使用).md":874,"./算法思想/分而治之.md":875,"./算法思想/动态规划.md":876,"./算法思想/回溯算法.md":877,"./算法思想/复杂度.md":878,"./算法思想/贪心算法.md":879,"./设计模式/代理模式.md":880,"./设计模式/单例模式.md":881,"./设计模式/发布订阅和观察者模式.md":882,"./设计模式/发布订阅模式.md":883,"./设计模式/策略模式.md":884,"./设计模式/装饰者模式.md":885,"./设计模式/观察者模式.md":886,"./设计模式/设计模式.md":887,"./跨域/cors.md":888,"./跨域/跨域.md":889,"./跨域/跨域解决方案.md":890,"./路由/hash路由.md":891,"./路由/history路由.md":892,"./路由/路由.md":893,"./音视频/flvjs播放直播流.md":894,"./音视频/video.md":895,"./音视频/xgplayer.md":896,"./音视频/回放直播流支持进度条拖拽.md":897};function o(r){var n=s(r);return e(n)}function s(r){if(!e.o(t,r)){var n=new Error("Cannot find module '"+r+"'");throw n.code="MODULE_NOT_FOUND",n}return t[r]}o.keys=function(){return Object.keys(t)},o.resolve=s,r.exports=o,o.id=425},function(r,n,e){"use strict";e.r(n),n.default="## Immutable Data\r\n### JavaScript中的对象是可变的\r\n- JavaScript中的对象一般是可变的(Mutable)，因为使用了引用赋值，新的对象简单的引用了原始对象，改变新的对象将影响到原始对象。\r\n- 引用赋值可以节约内存，但当应用复杂后这就造成了非常大的隐患，Mutable带来的优点变得得不偿失。\r\n- 为了解决Mutable带来的隐患，一般的做法是使用shallowCopy(浅拷贝)或deepCopy(深拷贝)来避免原始对象被修改，但这样做造成了CPU和内存的浪费。\r\n- Immutable Data可以很好的解决JavaScript中对象是可变带来的问题。\r\n### Immutable Data\r\n- Immutable Data是一种一旦创建就不能再被更改的数据，对Immutable Data的任何修改或添加删除操作都会返回一个新的Immutable Data。\r\n- 主要原理是采用Persistent Data Structure(持久化数据结构)，当每次修改后我们都会得到一个新的版本，且旧版本可以完好保留。\r\n- 使用旧数据创建新数据时可以保证旧数据同时可用且不变。同时为了避免deepCopy把所有节点都复制一遍带来的性能损耗，Immutable Data使用了Structural Sharing(结构共享)，对于本次操作没有修改的部分会直接共享避免内存浪费。\r\n- Immutable Data内部采用是多叉树的结构，凡是有节点被改变，那么它和与它相关的所有上级节点都更新，并且更新后返回了一个全新的引用，即使是浅比对也能感知到数据的改变。\r\n### Immutable Data优点\r\n- 降低复杂度，避免多个变量指向同一个内存地址引发不可控的副作用。\r\n```\r\n// 如果不查看fn的代码是不能确定打印的结果的，因为不确定它对data做了什么。但如果data是Immutable Data的，是可以确定打印的结果是value。\r\nfunction andLog(fn) {\r\n  let data = { key: 'value' };\r\n  fn(data);\r\n  console.log(data.key);\r\n}\r\n```\r\n- 节省内存，Immutable Data采用了结构共享机制，所以会尽量复用内存。\r\n```\r\n// a和b共享了没有变化的info节点\r\nimport { produce } from 'immer';\r\nconst a = {\r\n  name: 'dyx',\r\n  info: { age: 26 }\r\n}\r\nconst b = produce(a, draft => {\r\n  draft.name = 'douyaxing';\r\n});\r\n\r\na === b; // false\r\na.info === b.info; // true\r\n```\r\n- 方便回溯，Immutable Data每次修改都会创建一个新对象，那么变更的记录就能够被保存下来，应用的状态变得可控、可追溯，方便撤销和重做功能的实现。\r\n- 函数式编程，Immutable本身就是函数式编程中的概念，纯函数式编程比面向对象更适用于前端开发。因为只要输入一致，输出必然一致，这样开发的组件更易于调试和组装。"},function(r,n,e){"use strict";e.r(n),n.default="### [react中使用Immutable Data](https://juejin.cn/post/6976798974757830687)\r\n- React父组件更新会引起子组件重新render，当我们传入组件的props和state只有一层时，我们可以直接使用React.PureComponent，它会自动帮我们进行浅比较，从而控制shouldComponentUpdate的返回值。当传入的props或state不止一层，或者传入的是Array和Object类型时，浅比较就失效了。当然我们也可以在 shouldComponentUpdate()中使用使用deepCopy和deepCompare来避免不必要的render()，但deepCopy和deepCompare一般都是非常耗性能的。这个时候我们就需要 Immutable Data。\r\n### 在react中使用Immutable Data的好处\r\n- 修改引用类型数据，当属性值没有变化时不会生成新的引用，组件不会重新渲染，减少不必要的渲染。\r\n- 判断组件是否要更新时，对于引用类型数据比较不再需要深比较，提升性能。\r\n- 操作引用类型数据，不需要再浅拷贝或者深拷贝，提升性能。\r\n- 操作引用类型数据，简化修改引用类型数据的写法，尤其数据层次比较深的情况。\r\n### PureComponent(React.memo)进行浅比较\r\n- 当引用类型数据的属性值变化，但是引用没有变化时，浅比较无法识别变化，导致不更新。\r\n- 当引用类型数据的属性值没有变化，但是引用变化时，浅比较会识别出变化，导致多余更新。\r\n### shouldComponentUpdate中进行深比较\r\n- 把引用类型数据的所有属性和值进行递归比较，当引用类型数据层次比较复杂时比较浪费性能。\r\n### Immutable Data + PureComponent(React.memo)浅比较\r\n- 使用Immutable Data凡是有节点被改变，那么它和与它相关的所有上级节点都更新，并且更新后返回了一个全新的引用，即使是浅比对也能感知到数据的改变。\r\n### 使用immer减少因为引用类型数据的引用变化但是数据值没有变化造成的重复render\r\n- 每一次触发change方法组件都会重新render，因为每一次触发change方法即使age没有变化也都生成了一个新的对象。\r\n```\r\nconst [data, setData] = useState({\r\n  name: 'dyx',\r\n  info: { age: 26 }\r\n});\r\nconst change = () => {\r\n  const newData = { ...data, info: { ...data.info, age: 27 }};\r\n  setData(newData);\r\n}\r\n```\r\n- 使用immer后只有age变化时才会生成新的对象，组件才会重新render。\r\n```\r\nimport produce from 'immer';\r\n\r\nconst [data, setData] = useState({\r\n  name: 'dyx',\r\n  info: { age: 26 }\r\n});\r\nconst change = () => {\r\n  const newData = produce(data, draft => {\r\n    draft.info.age = 27;\r\n  });\r\n  setData(newData);\r\n}\r\n```\r\n### 在shouldComponentUpdate中判断组件是否需要更新不再需要deepCompare，只需要使用===判断即可，相较于deepCompare可以极大提高性能。\r\n```\r\nshouldComponentUpdate(nextProps = {}, nextState = {}) {\r\n  const thisProps = this.props || {}, thisState = this.state || {};\r\n\r\n  if (Object.keys(thisProps).length !== Object.keys(nextProps).length ||\r\n    Object.keys(thisState).length !== Object.keys(nextState).length\r\n  ) {\r\n    return true;\r\n  }\r\n\r\n  for (const key in nextProps) {\r\n    if (thisProps[key] !== nextProps[key]) {\r\n      return true;\r\n    }\r\n  }\r\n\r\n  for (const key in nextState) {\r\n    if (thisState[key] !== nextState[key]) {\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n}\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## Service Worker\r\n> 一个服务器与浏览器之间的中间人角色，如果网站中注册了Service Worker那么它可以拦截当前网站所有的请求，进行判断(需要编写相应的判断程序)，如果需要向服务器发起请求的就转给服务器，如果可以直接使用缓存的就直接返回缓存不再转给服务器。从而大大提高浏览体验。\r\n\r\n- 基于Web Worker(一个独立于JavaScript主线程的独立线程，在里面执行需要消耗大量资源的操作不会堵塞主线程)。\r\n- 在Web Worker的基础上增加了离线缓存的能力。\r\n- 本质上充当Web应用程序(服务器)与浏览器之间的代理服务器(可以拦截全站的请求，并作出相应的动作 -> 由开发者指定的动作)。\r\n- 创建有效的离线体验(将一些不常更新的内容缓存在浏览器，提高访问体验)。\r\n- 由事件驱动的，具有生命周期。\r\n- 可以访问cache和indexDB。\r\n- 支持推送。\r\n- 可以让开发者自己控制管理缓存的内容以及版本。\r\n- Service Worker运行在Worker上下文，不能访问DOM。\r\n- 设计为完全异步，同步API(如XHR和localStorage)不能在Service Worker中使用。\r\n- 出于安全考量，Service Workers只能由HTTPS承载。\r\n- 在Firefox浏览器的用户隐私模式下Service Worker不可用。\r\n- 其生命周期与页面无关(关联页面未关闭时，它也可以退出，没有关联页面时，它也可以启动)。\r\n### 使用Service Worker\r\n- 注册Service Worker\r\n```\r\nif ('serviceWorker' in navigator) {\r\n  /* 当页面加载完成就创建一个serviceWorker */\r\n  window.addEventListener('load', function () {\r\n    /* 创建并指定对应的执行内容 */\r\n    /* scope参数是可选的，可以用来指定你想让Service Worker控制的内容的子目录。在这个例子里指定了'/'(默认值)，表示根网域下的所有内容。 */\r\n    navigator.serviceWorker.register('./serviceWorker.js', { scope: './' })\r\n      .then(function(registration) {\r\n        console.log('ServiceWorker registration successful with scope: ', registration.scope);\r\n      })\r\n      .catch(function(err) {\r\n        console.log('ServiceWorker registration failed: ', err);\r\n      });\r\n  });\r\n}\r\n```\r\n- 安装Service Worker并完成Service Worker要实现的逻辑\r\n```\r\nthis.addEventListener('install', function(event) {\r\n  /* 通过这个方法可以防止缓存未完成，就关闭serviceWorker */\r\n  event.waitUntil(\r\n    /* 创建一个名叫V1的缓存版本 */\r\n    caches.open('v1').then(function(cache) {\r\n      /* 指定要缓存的内容，地址为相对于跟域名的访问路径 */\r\n      return cache.addAll([\r\n        './index.html'\r\n      ]);\r\n    })\r\n  );\r\n});\r\n\r\n/* 注册fetch事件，拦截全站的请求 */\r\nthis.addEventListener('fetch', function(event) {\r\n  event.respondWith(  \r\n    /* 在缓存中匹配对应请求资源直接返回 */\r\n    caches.match(event.request);\r\n  );\r\n});\r\n```\r\n\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## Web Worker与Shared Worker\r\n> 本质上就是进程和线程的区别。Shared Worker由独立的进程管理，Web Worker只是属于某个渲染进程(浏览器内核)下的一个线程。\r\n\r\n- Web Worker只属于某个页面，不会和其它页面的渲染进程(浏览器内核)共享，所以Chrome会在渲染进程(每一个Tab页就是一个渲染进程)中创建一个新的线程来运行Worker中的JavaScript程序。\r\n- Shared Worker是浏览器所有页面共享的，不能采用与Worker同样的方式实现，因为它不隶属于某个渲染进程(浏览器内核)，可以为多个渲染进程共享使用，所以Chrome浏览器为Shared Worker单独创建一个进程来运行JavaScript程序，在浏览器中每个相同的JavaScript只存在一个SharedWorker进程，不管它被创建多少次。"},function(r,n,e){"use strict";e.r(n),n.default="## Web Worker\r\n- Web Worker在一个单独的线程中运行任务，这使得JavaScript代码可以在后台执行，不会阻塞任何用户交互。\r\n- Web Worker具有自己的引擎实例和事件循环，它与主线程并行运行，不会阻塞主线程也不会阻塞事件循环。\r\n- Web Worker主要用于在Web浏览器中执行耗时任务，如大量数据处理、CSV导出、图像处理等。\r\n- 创建Worker时JS引擎向浏览器申请开一个子线程(子线程是浏览器开的，完全受主线程控制，而且不能操作DOM)。\r\n- JS引擎线程与Worker线程间通过特定的方式通信(postMessage API，需要通过序列化对象来与线程交互特定的数据)。\r\n- JS引擎是单线程的，这一点的本质仍然未改变，Worker可以理解是浏览器给JS引擎开的外挂，专门用来解决那些大量计算问题。\r\n### Web Worker的限制\r\n- Web Worker没有访问DOM的权限。\r\n- Web Worker在与主线程分离的沙箱环境中运行，对系统资源的访问会受到限制，无法访问window对象和document。\r\n- 当Worker正在运行时法再次调用它，直到它完成或被终止。可以创建多个Worker实例解决这个问题。\r\n- Web Worker会受到终端用户机器可用CPU核心和内存的限制。\r\n- Web Worker无法返回函数，因为响应是序列化的。\r\n### JavaScript执行耗时任务阻塞UI交互\r\n- 将耗时任务分割成多个短任务，并让其在多个渲染帧内执行，给UI交互留有时间。\r\n- 通过回调的方式，在UI交互触发后再进行耗时任务的操作。\r\n- 指定一个优先队列，当高优先级任务被执行时，低优先级任务(耗时任务)被降级处理(冷处理)，直到高优先级任务被执行后再执行剩余低优先级任务(React并发的核心要点)。\r\n- 上述处理方式只是将一些耗时任务从一个渲染帧分割成多个渲染帧或者延后到多个渲染帧内，本质上还是单线程的处理方式。\r\n### Web Worker使用\r\n1. 创建一个新的JavaScript文件，其中包含要运行的代码(耗时任务)。\r\n2. 在主JavaScript文件中，使用Worker构造函数创建一个新的worker对象。此构造函数接收一个参数，即在步骤1中创建的JavaScript文件的URL。\r\n```\r\nconst worker = new Worker('worker.js');\r\n```\r\n3. 向worker对象添加事件监听以处理主线程和Web Worker之间发送的消息。onmessage用于处理从Web Worker发送来的消息，postMessage用于向Web Worker发送消息。\r\n```\r\nworker.onmessage = function(event) {\r\n  console.log('Worker: ' + event.data);\r\n};\r\n\r\nworker.postMessage('Hello, worker!');\r\n```\r\n4. 在Web Worker的JavaScript文件中，使用self对象的onmessage属性添加事件监听来处理从主线程发来的消息，postMessage用于向主线程发送消息。\r\n```\r\nself.onmessage = function(event) {\r\n  console.log('Main: ' + event.data);\r\n  self.postMessage('Hello, Main!');\r\n};\r\n```\r\n### 终止Web Worker\r\n- 使用terminate()函数来终止。\r\n```\r\n// 主JavaScript文件中终止Web Worker\r\nworker.terminate();\r\n```\r\n- 通过调用self上的close()函数使其自行终止。\r\n```\r\n// Web Worker自行终止\r\nself.close();\r\n```\r\n### 使用onerror函数来处理Web Worker抛出的错误\r\n```\r\nworker.onerror = function(err) {\r\n  console.log(\"遇到错误\")\r\n}\r\n```\r\n### demo\r\n- 不使用Web Worker：点击btn1时，js会进行大量计算，页面无法响应用户操作，点击input不会有任何反应。\r\n- 使用Web Worker：点击btn2时，页面正常响应用户操作，可以正常的对input进行输入操作。开启了一个单独的worker线程来进行js计算，通过postMessage和onmessage进行两个线程间的通信。\r\n```\r\n<button id=\"btn1\">js</button>\r\n<button id=\"btn2\">worker</button>\r\n<input type=\"text\">\r\n\r\nconst btn1 = document.getElementById('btn1');\r\nbtn1.addEventListener('click', function() {\r\n  let total = 1;\r\n  for (let i = 0; i < 5000000000; i++) {\r\n    total += i;\r\n  }\r\n  console.log(total);\r\n})\r\n\r\nif (window.Worker) {\r\n  const myWorker = new Worker('./worker.js');\r\n  myWorker.onmessage = function (e) {\r\n    // e.data就是postMessage传递的数据\r\n    console.log('total', e.data);\r\n  };\r\n  const btn2 = document.getElementById('btn2');\r\n  btn2.addEventListener('click', function () {\r\n    myWorker.postMessage('total');\r\n  });\r\n}\r\n\r\n\r\n// worker.js\r\nself.onmessage = function(e) {\r\n  // e.data就是postMessage传递的数据\r\n  if (e.data === 'total') {\r\n    let total = 1;\r\n    for (let i = 0; i < 5000000000; i++) {\r\n      total += i;\r\n    }\r\n    postMessage(total);\r\n  }\r\n}\r\n```\r\n### Web Worker实现大文件切片上传\r\n> [https://juejin.cn/post/7351300892572745764](https://juejin.cn/post/7351300892572745764)\r\n\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## react中使用Web Worker\r\n### new URL()方式\r\n- vite/webpack都支持\r\n```\r\nconst myWorker = new Worker(\r\n  new URL('./worker.js', import.meta.url)\r\n);\r\n```\r\n### import方式\r\n- 只有vite支持\r\n```\r\nimport worker from './worker?worker';\r\n\r\nconst myWorker = new worker();\r\n```\r\n### useworker库\r\n- 向useWorker传递回调函数，该回调函数会在对应的Web Worker中执行。\r\n- 安装依赖\r\n```\r\n// useworker源码中使用peerDependencies指定了React版本为^16.8.0。在17/18版本的React环境下会发生错误。可以使用--force忽略版本限制\r\nnpm  install @koale/useworker --force\r\n```\r\n- 使用\r\n```\r\nconst sortNumbers = numbers => ([...numbers].sort());\r\n\r\nconst [\r\n  sortWorker, \r\n  { \r\n    status: sortStatus, \r\n    kill: killSortWorker \r\n  }\r\n] = useWorker(sortNumbers);\r\n```\r\n### 通过引入文件路径实例化Worker对象\r\n- index.js\r\n```\r\n// 创建一个新的Worker对象，指定要在Worker线程中执行的脚本文件路径\r\nconst myWorker = new Worker(\r\n  new URL('./worker.js', import.meta.url)\r\n);\r\n\r\n// 向Worker发送消息\r\nmyWorker.postMessage(123);\r\n\r\n// 监听来自Worker的消息\r\nmyWorker.onmessage = function(event) {\r\n  console.log(\"来自worker的消息: \", event.data);\r\n};\r\n```\r\n- worker.js\r\n```\r\n// 在Worker脚本中接收并处理消息\r\nself.onmessage = function(event) {\r\n  console.log(\"来自主线程的消息: \", event.data);\r\n  // 执行一些计算密集型的任务\r\n  const result = doSomeHeavyTask(event.data);\r\n  // 将结果发送回主线程\r\n  self.postMessage(result);\r\n};\r\n```\r\n### 通过Blob方式实例化Worker对象\r\n- 使用Blob构建方式生成Web Worker更灵活、便捷和安全。\r\n- index.js\r\n```\r\n// 定义要在Worker中执行的脚本内容\r\nconst workerScript = `\r\n  self.onmessage = function(event) {\r\n    console.log(\"来自主线程的消息: \", event.data);\r\n    // 执行一些计算密集型的任务\r\n    const result = doSomeHeavyTask(event.data);\r\n    // 将结果发送回主线程\r\n    self.postMessage(result);\r\n  };\r\n`;\r\n\r\n// 创建一个Blob对象，指定脚本内容和类型\r\nconst blob = new Blob(\r\n  [workerScript], \r\n  { type: 'application/javascript' }\r\n);\r\n\r\n// 使用URL.createObjectURL()方法创建一个URL，用于生成Worker\r\nconst blobURL = URL.createObjectURL(blob);\r\n\r\n// 生成一个新的Worker\r\nconst myWorker = new Worker(blobURL);\r\n\r\n// 向Worker发送消息\r\nworker.postMessage(123);\r\n\r\n// 监听来自Worker的消息\r\nmyWorker.onmessage = function(event) {\r\n  console.log(\"来自worker的消息: \", event.data);\r\n};\r\n```\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## SSE(服务器发送事件)\r\n- 服务器发送事件部署在EventSource对象上，除了IE其它主流浏览器都支持。\r\n- 浏览器向服务器发送一个HTTP请求，然后服务器不断单向地向浏览器推送“信息”。这种信息在格式上很简单，就是“信息”加上前缀“data: ”，然后以“\\n\\n”结尾。\r\n- 适用于服务端持续流式输出的形式，比如AI对话场景。\r\n### SSE与WebSocket\r\n- WebSocket是全双工通道，可以双向通信，功能更强；SSE是单向通道，只能服务器向浏览器端发送。\r\n- WebSocket是一个新的协议，需要服务器端支持；SSE则是部署在HTTP协议之上的，现有的服务器软件都支持。\r\n- SSE是一个轻量级协议，相对简单；WebSocket是一种较重的协议，相对复杂。\r\n- SSE默认支持断线重连，WebSocket则需要额外处理。\r\n- SSE支持发送自定义的数据类型。\r\n### 建立连接\r\n```\r\nif (!!window.EventSource) {\r\n  const source = new EventSource('http://127.0.0.1/sse');\r\n}\r\n```\r\n### 关闭连接\r\n```\r\nsource.close();\r\n```\r\n### readyState属性\r\n- 0：相当于常量EventSource.CONNECTING，表示连接还未建立，或者连接断线。\r\n- 1：相当于常量EventSource.OPEN，表示连接已经建立，可以接受数据。\r\n- 2：相当于常量EventSource.CLOSED，表示连接已断，且不会重连。\r\n### open事件\r\n- 连接一旦建立，就会触发open事件，可以定义相应的回调函数。\r\n```\r\nsource.onopen = function(event) {\r\n  // handle open event\r\n};\r\n\r\n// 或者\r\nsource.addEventListener(\"open\", function(event) {\r\n  // handle open event\r\n}, false);\r\n```\r\n### message事件\r\n- 收到数据就会触发message事件。\r\n- data：服务器端传回的数据（文本格式）。\r\n- origin：服务器端URL的域名部分，即协议、域名和端口。\r\n- lastEventId：数据的编号，由服务器端发送。如果没有编号，这个属性为空。\r\n```\r\nsource.onmessage = function(event) {\r\n  var data = event.data;\r\n  var origin = event.origin;\r\n  var lastEventId = event.lastEventId;\r\n  // handle message\r\n};\r\n\r\n// 或者\r\nsource.addEventListener(\"message\", function(event) {\r\n  var data = event.data;\r\n  var origin = event.origin;\r\n  var lastEventId = event.lastEventId;\r\n  // handle message\r\n}, false);\r\n```\r\n### error事件\r\n- 如果发生通信错误（比如连接中断），就会触发error事件。\r\n```\r\nsource.onerror = function(event) {\r\n  // handle error event\r\n};\r\n\r\n// 或者\r\nsource.addEventListener(\"error\", function(event) {\r\n  // handle error event\r\n}, false);\r\n```\r\n### [POST请求](https://juejin.cn/post/7401011618043838474)\r\n- EventSource API不支持发起POST请求，借助第三方库的fetchEventSource方法可以实现POST请求。\r\n```\r\nconst ctrlAbout = new AbortController();\r\n\r\nfetchEventSource('/ai/chat', {\r\n  method: 'POST',\r\n  headers: {\r\n    'Authorization': getToken(),\r\n    'Content-Type': 'application/json'\r\n  },\r\n  body: JSON.stringify(params),\r\n  signal: ctrlAbout.signal,\r\n  openWhenHidden: true,\r\n  onmessage: (res) => {\r\n    // 添加try catch防止处理数据有异常时一直重试\r\n    try {\r\n      const parseData = JSON.parse(res.data);\r\n      // 处理数据\r\n    } catch(e) {\r\n      this.$message.error('解析失败，请重试！');\r\n    }\r\n  },\r\n  onerror: () => {\r\n    ctrlAbout.abort();\r\n  }\r\n})\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## WebSocket\r\n- WebSocket是一种在单个TCP连接上进行全双工通信的协议，它可以让客户端和服务器之间进行实时的双向通信，客户端和服务器之间可以互相发送消息。\r\n- 与传统的HTTP请求不同，WebSocket使用了一个长连接，在客户端和服务器之间保持持久的连接，从而可以实时地发送和接收数据。\r\n- WebSocket不存在跨域问题。\r\n### WebSocket与HTTP的区别\r\n- WebSocket是一种双向通信的协议，通过一次握手即可建立持久性的连接，服务器和客户端可以随时发送和接收数据。\r\n- HTTP协议是一种请求-响应模式的协议，每次通信都需要发送一条请求并等待服务器的响应。\r\n- WebSocket的实时性更好，延迟更低，并且在服务器和客户端之间提供双向的即时通信能力，适用于需要实时数据传输的场景。\r\n### WebSocket readyState属性\r\n- 0 表示连接尚未建立。\r\n- 1 表示连接已建立，可以进行通信。\r\n- 2 表示连接正在进行关闭。\r\n- 3 表示连接已经关闭或者连接不能打开。\r\n### 前端使用WebSocket\r\n- 创建WebSocket对象\r\n> 通过JavaScript中的new WebSocket(URL)方法创建WebSocket对象，其中URL是WebSocket服务器的地址。\r\n\r\n```\r\nconst socket = new WebSocket('ws://localhost:8000');\r\n```\r\n- 监听WebSocket事件\r\n  1. open：当与服务器建立连接时触发。\r\n  2. message：当收到服务器发送的消息时触发。\r\n  3. close：当与服务器断开连接时触发。\r\n  4. error：当连接或通信过程中发生错误时触发。\r\n```\r\nsocket.addEventListener('open', () => {\r\n  console.log('WebSocket连接已建立');\r\n});\r\n\r\nsocket.addEventListener('message', (event) => {\r\n  const message = event.data;\r\n  console.log('收到消息：', message);\r\n});\r\n\r\nsocket.addEventListener('close', () => {\r\n  console.log('WebSocket连接已断开');\r\n});\r\n\r\nsocket.addEventListener('error', (error) => {\r\n  console.error('发生错误：', error);\r\n});\r\n```\r\n- 发送消息\r\n> 通过WebSocket对象的send(data)方法发送消息，其中data是要发送的数据，可以是字符串、JSON对象等。\r\n\r\n```\r\nconst message = 'Hello, server!';\r\nsocket.send(message);\r\n```\r\n- 关闭WebSocket连接\r\n> 当通信结束或不再需要与服务器通信时，需要关闭WebSocket连接以释放资源。通过调用WebSocket对象的close()方法可以主动关闭连接。\r\n\r\n```\r\nsocket.close();\r\n```\r\n### WebSocket断开原因\r\n- code: 错误码，是整数类型。\r\n- reason: 断开原因，是字符串。\r\n- wasClean: 是否正常断开，是布尔值。一般异常断开时，该值为false；自己手动断开时该值为true。\r\n```\r\nsocket.addEventListener('close', (e) => {\r\n  console.log('websocket 断开: ' + e.code + ' ' + e.reason + ' ' + e.wasClean)\r\n});\r\n```\r\n### WebSocket的应用场景\r\n- 实时聊天应用：WebSocket能够提供双向、实时的通信机制，使得实时聊天应用能够快速、高效地发送和接收消息，实现即时通信。\r\n- 实时协作应用：WebSocket可以用于实时协作工具，如协同编辑文档、白板绘画、团队任务管理等，团队成员可以实时地在同一页面上进行互动和实时更新。\r\n- 实时数据推送：WebSocket可以用于实时数据推送场景，如股票行情、新闻快讯、实时天气信息等，服务器可以实时将数据推送给客户端，确保数据的及时性和准确性。\r\n- 在线客服和客户支持：WebSocket可以用于在线客服和客户支持系统，实现实时的客户沟通和问题解决，提供更好的用户体验，减少等待时间。\r\n### WebSocket的缺点和不足\r\n- WebSocket需要浏览器和服务器端都支持该协议。\r\n- WebSocket会增加服务器的负担，不适合大规模连接的应用场景。\r\n\r\n\r\n\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## WebSocket心跳\r\n### WebSocket心跳包机制\r\n> WebSocket心跳包是WebSocket协议的保活机制，用于维持长连接。有效的心跳包可以防止长时间不通讯时WebSocket自动断开连接。\r\n\r\n- 客户端定时向服务器发送心跳数据包，以保持长连接。\r\n- 服务器定时向客户端发送心跳数据包，以检测客户端连接是否正常。\r\n- 双向发送心跳数据包。\r\n### WebSocket心跳机制作用\r\n- 使WebSocket连接保持长连接，保持WebSocket连接不被断开。\r\n- 检测WebSocket连接状态，及时处理异常情况。\r\n- 减少WebSocket连接及服务器资源的消耗。\r\n### 前端实现WebSocket心跳机制的方式\r\n- 使用setInterval定时发送心跳包。\r\n> 会对服务器造成很大的压力，因为即使WebSocket连接正常，也要定时发送心跳包，从而消耗服务器资源。\r\n\r\n- 在监听到WebSocket的onclose()事件时，重新创建WebSocket连接。\r\n> 这种方式虽然减轻了服务器的负担，但是在重连时可能会丢失一些数据。\r\n\r\n### WebSocket重连机制\r\n> WebSocket在发送和接收数据时，可能会因为网络原因、服务器宕机等因素而断开连接，此时需要使用WebSocket重连机制进行重新连接。\r\n\r\n- 前端监听WebSocket的onclose()事件，重新创建WebSocket连接。\r\n- 使用WebSocket插件或库，例如Sockjs、Stompjs等。\r\n- 使用心跳机制检测WebSocket连接状态，自动重连。\r\n- 使用断线重连插件或库，例如ReconnectingWebSocket等。\r\n### WebSocket重连时判断正常断开的场景\r\n```\r\nwsRef.current.onclose = (event: any) => {\r\n  if (event.wasClean && (event.code === 1000 || event.code === 1001)) {\r\n    // 正常断开\r\n    console.log(`${webSocketFlag}WebSocket连接正常断开`, event);\r\n  } else {\r\n    console.log(`${webSocketFlag}WebSocket连接异常断开`, event);\r\n  }\r\n};\r\n```\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## 断网时现象\r\n- 断网之后WebSocket有各种与常规不同的逻辑。\r\n  - onClose方法并不能触发，websocket.readystate检测仍然会返回1。\r\n  - 调用close方法不会立即触发onClose事件。\r\n  - 网络断开WebSocket是不会触发任何事件的，前端程序无法得知当前连接是否断开。但是这个时候使用WebSocket.send方法的时候，浏览器会发现消息发不出去，隔一段时间之后(貌似每个浏览器隔的时间不相同)，会触发onClose函数"},function(r,n,e){"use strict";e.r(n),n.default='## [Babel](https://juejin.cn/post/7190312484492804156)\r\n> Babel是一个JavaScript编译器，主要用于将使用ECMAScript 2015+(ES6+)语法编写的代码转换为向后兼容的JavaScript语法，以便能够运行在当前和旧版本的浏览器或其他环境中。\r\n\r\n- ES6+最新语法转化(let、class、箭头函数等)。\r\n- 实现旧版本浏览器不支持的ES6+的API(Promise、Symbol、Array.prototype.includes等)。\r\n- 实现ES6+最新语法转化只需要使用@babel/preset-env就可以。\r\n- 实现旧版本浏览器不支持的ES6+的API就需要用core-js这个包来提供polyfill，并与@babel/preset-env或者@babel/plugin-transform-runtime的配置功能相互配合使用。\r\n### Babel配置文件大致架构\r\n> 一般主要用到的是presets、plugins这两个配置。\r\n\r\n```\r\n// babel.config.js\r\nmodule.exports = {\r\n  ...,\r\n  sourceType: "unambiguous",\r\n  envName: "development",\r\n  presets: [],\r\n  plugins: [],\r\n  passPerPreset: false,\r\n  targets: {},\r\n  browserslistConfigFile: true,\r\n  browserslistEnv: undefined,\r\n  inputSourceMap: true\r\n  ...\r\n}\r\n```\r\n### @babel/core\r\n> Babel实现编译的核心库。要使用Babel，@babel/core一定是必不可少的。平常说的babel版本指的就是@babel/core的版本。\r\n\r\n```\r\nnpm install @babel/core -D\r\n```\r\n### @babel/cli\r\n> cli命令行工具，可通过命令行编译文件。\r\n\r\n### @babel/preset-env\r\n- @babel/preset-env是一个智能预设，通过@babel/preset-env我们可以使用最新的JavaScript，而无需微观管理目标环境需要哪些语法转换(以及可选的浏览器polyfill)，也可以让JavaScript的包更小。\r\n- @babel/preset-env只编译ES6+语法并不提供polyfill，但是可以通过配置我们代码运行的目标环境，从而控制polyfill的导入跟语法编译，使ES6+的新特性可以在我们想要的目标环境中顺利运行。\r\n- 可以通过@babel/preset-env --\x3e package.json --\x3e dependencies查看@babel/preset-env包含了哪些预设。\r\n```\r\nnpm install @babel/preset-env -D\r\n```\r\n#### preset预设\r\n- Babel编译ES6+语法是通过一个个plugin去实现的，@babel/preset-env是一个语法插件集合包，通过@babel/preset-env我们只用安装这一个包，不需要一个个配插件，就可以编译ES6+语法了。\r\n#### env环境\r\n- @babel/preset-env还有一个配置功能，我们可以通过配置我们代码运行的目标环境，来控制polyfill(一个提供低版本浏览器缺失的ES6+新特性的方法与实现的集合)的导入跟语法编译，从而使ES6+新的特性可以在我们想要的目标环境中顺利运行。\r\n### polyfill\r\n- ES6+除了提供很多简洁的语法(let、class、箭头函数等)外，还为我们提供了很多便捷的API(Promise、Symbol、Array.prototype.includes等)。但旧版本浏览器是不支持这些API的，而polyfill存放了这些API方法的实现，所以通过polyfill可以在不支持ES6+ API的浏览器中正常使用这些API。这种存放了ES6+的API方法实现的集合叫做polyfill，也就是我们经常说的垫片。\r\n- polyfill分很多种，像core-js是会提供旧版本浏览器缺失的所有的API。还有一些只提供某个API的polyfill，例如promise-polyfill、proxy-polyfill等。\r\n- Babel配置polyfill的过程就是实现旧版本浏览器对这些API支持的过程。\r\n### @babel/polyfill\r\n```\r\nnpm install @babel/polyfill -S\r\n```\r\n- 这个包由core-js(版本为2.x.x，放了很多ES6+ API的实现)与regenerator-runtime(Async、Generator函数使用)两个包组成。\r\n- 这个包在Babel 7.4.0以后就废弃了，所以在Babel 7.4.0以后，想让一些不支持ES6+ API的旧版本浏览器支持这些API，直接安装core-js@3.x.x的包即可。\r\n- 在Babel 7.18.0及其以后的版本，regenerator-runtime包里面的内容会以局部变量的方式内联注入到我们的代码中，所以我们只用引入import "core-js/stable"这一个包就可以了。\r\n- Babel 7.4.0版本之前引入polyfill\r\n```\r\nimport \'@babel/polyfill\';\r\n```\r\n- Babel 7.18.0版本之前引入polyfill形式\r\n```\r\nimport "core-js/stable"; // core-js必须是3.x.x版本，因为2.x.x版本，不包含stable文件夹\r\nimport "regenerator-runtime/runtime";\r\n```\r\n- Babel 7.18.0及其以后的版本引入polyfill形式\r\n```\r\n// 不需要再 import "regenerator-runtime/runtime";\r\nimport "core-js/stable"; // core-js必须是3.x.x版本，因为2.x.x版本，不包含stable文件夹\r\n```\r\n### core-js\r\n> 会提供旧版本浏览器缺失的所有的ES6+的API。\r\n\r\n```\r\nnpm install core-js -S\r\n```\r\n- 当我们想垫平所有的ES6+的API(包括提案阶段)，可以导入core-js所有内容。\r\n```\r\nimport \'core-js\';\r\n```\r\n- 当需要垫平所有稳定版本的ES6+的API，可以导入stable文件夹。\r\n```\r\nimport \'core-js/stable\';\r\n```\r\n- 当只需要垫平某个稳定的ES6+的API，可以导入es这个文件夹里的polyfill来垫平。\r\n```\r\nimport X from \'core-js/es/xx\';\r\n```\r\n- 当需要用到提案阶段的API时，可以导入proposals这个文件夹里的polyfill来垫平。\r\n```\r\nimport X from \'core-js/proposals/xx\';\r\n```\r\n### @babel/runtime\r\n> 在Babel编译的时候，编译以后会生成很多辅助函数，这些函数就是ES6+一些语法糖的实现，并且会以内联的方式插入到我们的代码中。@babel/runtime是存放了Babel辅助函数的一个集合包。\r\n\r\n```\r\nnpm install @babel/runtime -S\r\n```\r\n### @babel/plugin-transform-runtime\r\n- @babel/plugin-transform-runtime会将我们用到的辅助函数，从@babel/runtime中以require的方式引入到我们的文件中实现复用，避免多个文件使用ES6+语法糖辅助函数生成多次内联插入多次的问题，从而减小我们最终输出包的体积。\r\n- @babel/runtime跟@babel/plugin-transform-runtime通常是配合一起使用。\r\n- 也有一个配置功能，用来处理polyfill如何垫平。\r\n```\r\nnpm install @babel/plugin-transform-runtime -D\r\n```\r\n### @babel/preset-react\r\n> 使用@babel/preset-react转化jsx语法。\r\n\r\n```\r\nnpm install @babel/preset-react -D\r\n```\r\n### @babel/preset-typescript\r\n> 使用@babel/preset-typescript将ts语法转化为js语法。\r\n\r\n```\r\nnpm install @babel/preset-typescript -D\r\n```\r\n\r\n### babel-loader\r\n> webpack中loader的本质就是一个函数，接受我们的源代码作为入参同时返回新的内容。babel-loader的作用就是将匹配到的js相关文件进行编译。babel-loader支持直接通过loader的参数形式注入，同时也支持在loader函数内部自动读取`.babelrc、babel.config.js、babel.config.json`等文件配置。\r\n\r\n```\r\nnpm install babel-loader -D\r\n```\r\n'},function(r,n,e){"use strict";e.r(n),n.default="## [Babel配置](https://juejin.cn/post/7197666704435920957)\r\n### @bable/preset-env\r\n#### modules\r\n- 启用ES模块语法向另一种模块类型的转换。\r\n- 默认值：auto。可取的值：\"amd\" | \"umd\" | \"systemjs\" | \"commonjs\" | \"cjs\" | \"auto\" | false。\r\n- 当我们设置成false的时候，Babel编译使用的一些辅助函数的引入方式会变成ES6模块方式import。可以对代码静态分析很好地tree shaking减少代码体积，所以我们配置Babel的时候建议设置modules: false。\r\n#### targets\r\n- 用来设置我们的代码需要兼容的目标环境，可以有效地减少ES6+的语法编译，也可以有效控制polyfill导入的多少。\r\n- 如果没有设置这个配置项时会去Babel配置文件找顶层的targets。如果顶层没有设置targets则会去package.json里的browserslist或者根目录找.browserslistrc文件。如果还没有则默认值为{}。\r\n- 如果没有设置这个配置项时Babel会假设我们要兼容的目标环境是最旧的浏览器，所以会将所有的ES6+语法代码转化为ES5。所以在配置Babel的时候，要设置targets以减少输出代码大小。\r\n#### useBuiltIns\r\n> 这个配置就是用来设置我们core-js的垫平方式的。\r\n\r\n- entry\r\n  - 我们需要手动import所有或者某块polyfill。\r\n  - Babel会根据我们设置的targets(目标环境)，来判断我们手动import的所有或者某块polyfill是不是当前缺失的，如果是的话就会把我们手动import所有或者某块polyfill拆分成很多小模块，引入我们目标环境不支持的模块。\r\n  - 为了避免一些奇奇怪怪的问题，我们手动import的polyfill应该统一在入口文件。\r\n  - 如果我们想一劳永逸，直接把当前环境所有不支持的ES6+ API垫平，那我们就import 'core-js/stable'(这会垫平当前targets不支持的所有稳定版本的ES6+ API，所以也会导致包变大)。\r\n  - 如果我们只想垫平某个ES6+ API(前提是targets不支持这个API，否则手动import了也没用)。例如只想垫平Promise那我们import 'core-js/es/promise就可以了。\r\n  - 如果想垫平提案阶段的API，则也需要手动import对应提案的polyfill(import \"core-js/proposals/string-replace-all)。\r\n  - 垫平的polyfill都是注入到window全局的，或者是某个内置对象的原型(prototype)上，这影响到了全局。\r\n- usage\r\n  - 不需要手动import所有或者某块polyfill。\r\n  - Babel会根据我们当前代码中用到的ES6+ API，并判断当前的targets支不支持我们用到的这个ES6+ API，如果不支持的话则自动导入这个ES6+ API对应的polyfill。\r\n  - 如果第三方库用到了我们当前targets不支持的ES6+ API，但我们自己的代码没有用到这个API，那么这个API是不会被垫平的，这会导致我们项目报错。如果判断出哪块polyfill缺失，我们可以自己手动import去垫平。\r\n  - 垫平的polyfill都是注入到window全局的，或者是某个内置对象的原型(prototype)上，这影响到了全局。\r\n- false\r\n  - 默认值，不会自动添加polyfill也不会根据targets判断缺不缺失，也不会将我们手动import所有或者某块polyfill拆分为单个polyfill引入。\r\n  - 对我们的垫平方式没作用，源码是什么样，输出就是什么样。设置targets无效。\r\n- entry VS usage\r\n  - Promise还有很多例如Promise.any、Promise.all、Promise.finally的方法，示例代码只使用Promise不使用Promise的其它方法。\r\n  - IE11不支持Promise，Chrome80中Promise大部分方法已经实现，只有Promise.any没有实现。\r\n  - 使用entry手动导入import 'core-js/es/promise'的表现为：IE11下把Promise所有不支持的方法都垫平了；Chrome80下Promise大部分方法已经实现，只有Promise.any没有实现，所以此时只垫平了promise.any方法。\r\n  - 使用usage自动导入的表现为：IE下只垫平了Promise这个对象，不会垫平它其它相关的方法，因为示例代码中只用到了单一的Promise对象没有用到其它相关方法；Chrome80下没有任何关于Promise的垫平，因为单一的Promise对象在Chrome80已经实现只有Promise.any没有实现，但是示例代码中没有用Promise.any方法，所以不会垫平Promise.any。\r\n#### corejs\r\n- 当我们的useBuiltIns不为false的时候，需要设置corejs这个配置项。\r\n- 2版本的core-js已经不建议使用了，要尽可能的使用最新的版本。越新的包包含的polyfill才会越多。\r\n- 我们设置corejs的版本号时，不要直接指定2或者3，它会被解析为2.0或者3.0。我们应该带上子版本号(3.27.2)，这样才会有最新的polyfill。\r\n- core-js默认用稳定版的polyfill来垫平，但如果有时我们想用还处在提案阶段的API时\r\n  - 如果我们配置的是useBuiltIns: entry，我们得手动引入core-js提案的polyfill来垫平。提案的polyfill放在core-js/proposals文件夹中(import 'core-js/proposals/array-last')。\r\n  - 如果我们配置的是useBuiltIns: 'usage'，需要把corejs的proposals配置项设为true。\r\n```\r\n{\r\n  useBuiltIns: 'usage',\r\n  corejs: {\r\n    version: '3.27.2',\r\n    // 是否编译提案阶段ES6+ API\r\n    proposals: true\r\n  },\r\n}\r\n```\r\n### @babel/plugin-transform-runtime\r\n#### helpers\r\n- 控制的是我们的辅助函数，是否不内联进我们的代码中。\r\n- 默认值是true，true的话是不内联，而是引用@babel/runtime辅助函数集合包；false的话，则会内联。\r\n#### regenerator\r\n- 控制的是我们regenerator-runtime这个包的代码，是否不内联进我们的代码中。\r\n- 默认值是true，true的话是不内联，而是引用@babel/runtime辅助函数集合包；false的话，则会内联。\r\n#### corejs\r\n> 不想以全局的方式、污染的方式垫平我们的ES6+ API，我们corejs就不能为false，并且优先使用@babel/runtime-corejs3这个包来垫平(设置为3)。\r\n\r\n- corejs这个配置项一旦不为false，就是用来设置我们要垫平的ES6+ API以不污染全局的方式垫平。\r\n- false：默认值，对应依赖@babel/runtime。\r\n- 2：对应依赖@babel/runtime-corejs2，只能支持编译全局变量(如Promise)和静态属性(如Array.from)，不能编译实例相关方法([].includes)。\r\n- 3：对应依赖@babel/runtime-corejs3，既能支持编译全局变量和静态属性，又能编译实例方法，开启proposals: true还可以编译提案阶段的API。\r\n### 总结\r\n- @babel/preset-env是以全局注入方式垫平，@babel/plugin-transform-runtime是以局部变量方式垫平，两者我们应该选择其一，不要又用@babel/preset-env配置方式，又用@babel/plugin-transform-runtime配置方式，这样会出现一些奇奇怪怪的问题。\r\n- 因为使用@babel/plugin-transform-runtime垫平是以局部变量的方式来垫平，所以@babel/plugin-transform-runtime这种配置方式更适合来做三方库的开发。它可以很好的帮我们的库与使用者的项目解耦。\r\n### 开发的项目是应用程序可以这么配置\r\n- 安装依赖\r\n```\r\nnpm install @babel/core @babel/preset-env @babel/plugin-transform-runtime @babel/runtime -D\r\nnpm install core-js -S\r\n```\r\n- babel.config.js\r\n```\r\nmodule.exports = {\r\n  presets: [\r\n    [\r\n      \"@babel/preset-env\",\r\n      {\r\n        modules: false,\r\n        useBuiltIns: \"usage\",\r\n        corejs: {\r\n          version: '3.27.2',\r\n          proposals: true\r\n        }\r\n      }\r\n    ],\r\n  ],\r\n  plugins: [\r\n    \"@babel/plugin-transform-runtime\",\r\n  ]\r\n}\r\n```\r\n- .browserslistrc\r\n```\r\n> 0.2% in CN\r\nlast 10 versions\r\n```\r\n- 入口文件(如果useBuiltIns设置为entry时需要引入以下)\r\n```\r\n// 垫平全部ES6+稳定版API\r\nimport 'core-js/stable';\r\n\r\n// 垫平所有ES6+ API，包括提案阶段\r\nimport 'core-js';\r\n```\r\n- 如果useBuiltIns设置为usage时在某些浏览器下特殊的API无法使用使用时可以单独在入口文件垫平特殊的API\r\n```\r\n// 特殊垫平Object.hasOwn方法\r\nimport 'core-js/stable/object/has-own';\r\n```\r\n### 开发一个第三方库可以这样配置\r\n- 安装依赖\r\n```\r\nnpm install @babel/core @babel/preset-env @babel/plugin-transform-runtime @babel/runtime -D\r\nnpm install @babel/runtime-corejs3 -S\r\n```\r\n- babel.config.js\r\n```\r\nmodule.exports = {\r\n  presets: [\r\n    [\r\n      \"@babel/preset-env\",\r\n      {\r\n        modules: false,\r\n      }\r\n    ],\r\n  ],\r\n  plugins: [\r\n    [\r\n      '@babel/plugin-transform-runtime',\r\n      {\r\n        corejs: {\r\n          version: 3,\r\n          proposals: true\r\n        }\r\n      }\r\n    ]\r\n  ]\r\n}\r\n```\r\n- .browserslistrc\r\n```\r\n> 0.2% in CN\r\nlast 10 versions\r\n```"},function(r,n,e){"use strict";e.r(n),n.default='## CLI\r\n> CLI全称Command Line Interface，是一类通过命令行交互的终端工具。CLI可以帮助我们更高效的操作计算机系统，我们可以将有规律可循的、重复的、繁琐的、模板化的工作集成到CLI工具中。一个命令即可快速的完成一些列操作。\r\n\r\n- GUI：更侧重易用性，用户通过点击图形界面，完成相关操作。\r\n- CLI：更侧重操作效率，通过命令组合自动化操作、批量操作等。\r\n### Node CLI开发\r\n1. npm init初始化项目。\r\n2. 定义js命令文件\r\n> 文件头部必须有#!/usr/bin/env node，告诉系统使用NodeJS执行脚本，如不声明默认按shell去解析执行。\r\n\r\n```\r\n#!/usr/bin/env node\r\n\r\nconsole.log(\'Hello Node CLI\');\r\n```\r\n3. 定义终端命令\r\n> package.json文件中声明bin字段；格式为："command": "js file"。\r\n\r\n```\r\n// package.json\r\n{\r\n  "bin": {\r\n    "test-cli": "./bin/command.js"\r\n  }\r\n}\r\n```\r\n4. 调试CLI工具\r\n> 通过软链接进行本地调试，在CLI根目录下执行npm link创建软链接，终端运行命令test-cli即可调试。\r\n\r\n5. 发布CLI工具\r\n> 登录npm：npm login；发布CLI：npm publish。\r\n\r\n### 终端命令行切换选项时，点击空格然后输入选项最后回车确认。'},function(r,n,e){"use strict";e.r(n),n.default="## bfc(块级格式化上下文)\r\n> BFC就是页面上一个单独的容器，容器内部的元素不会影响到外面的元素。\r\n\r\n### 创建bfc\r\n- float的值不是none\r\n- position的值是absolute、fixed\r\n- display的值是inline-block、flow-root、table-cell、table-caption、flex或者inline-flex、grid或者inline-grid\r\n- overflow的值不是visible\r\n### bfc的作用\r\n- 用BFC包住浮动的子元素，子元素浮动，脱离了普通文档流，父元素包不住子元素。\r\n  1. 父元素浮动\r\n  2. 父元素绝对定位\r\n  3. 父元素变为行内块级元素\r\n  4. 父元素的overflow设置为hidden\r\n- 和浮动元素产生边界，兄弟元素之间，其中左边元素浮动，右边元素会覆盖左边元素\r\n  1. 右侧兄弟元素margin-left设置为浮动元素宽度+想要产生的边距宽度\r\n  2. 让右侧兄弟元素的overflow设置为hidden\r\n  3. 右侧元素浮动"},function(r,n,e){"use strict";e.r(n),n.default="## css\r\n### css3新增的伪类\r\n- -child 类\r\n- -of-type 类\r\n- first-line 选择元素中的第一行（伪元素）\r\n- first-letter 选择元素中的第一个字符（伪元素）\r\n- after 在元素在该元素之后添加内容（伪元素）\r\n- before 在元素在该元素之前添加内容（伪元素）\r\n### position的值\r\n- relative（相对定位）： 生成相对定位的元素，定位原点是元素本身所在的位置；\r\n- absolute（绝对定位）：生成绝对定位的元素，定位原点是离自己这一级元素最近的一级position设置为absolute或者relative的父元素的左上角为原点的，否则是html元素。\r\n- fixed （固定定位）：生成绝对定位的元素，相对于浏览器窗口进行定位。\r\n- static：默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right、z-index 声明）。\r\n- inherit：规定从父元素继承 position 属性的值。\r\n- sticky (粘贴定位)：必须指定top、bottom、left、right4个值之一\r\n### 创建三角\r\n> 利用border的特性，隐藏其中三条边。\r\n\r\n### 为什么要初始化CSS样式\r\n> 因为浏览器的兼容问题，不同浏览器对标签的默认值是不同的，如果没有对浏览器的CSS初始化，会造成相同页面在不同浏览器的显示存在差异。\r\n\r\n### CSS预处理器/后处理器\r\n- 预处理器，如：less，sass，增加了css代码的复用性，还有层级，变量，循环， 函数等，对编写以及开发UI组件都极为方便。\r\n- 后处理器，如：postCss，目前最常做的是给css属性添加浏览器私有前缀，实现跨浏览器兼容性的问题。\r\n### rgba 和 opacity 的透明效果有什么不同\r\n- opacity 作用于元素以及元素内的所有内容（包括文字）的透明度\r\n- rgba 只作用于元素自身的颜色或其背景色，子元素不会继承透明效果\r\n### 外边距重叠\r\n- 两个相邻的外面边距是正数时，折叠结果就是他们之中的较大值\r\n- 两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值\r\n- 两个外边距一正一负时，折叠结果是两者的相加的和\r\n### 解析css\r\n> CSS选择器的解析是从右向左解析的，这样会提高查找选择器所对应的元素的效率。若从左向右的匹配，发现不符合规则，需要进行回溯，会损失很多性能。若从右向左匹配，先找到所有的最右节点，对于每一个节点，向上寻找其父节点直到找到根元素或满足条件的匹配规则。\r\n\r\n### others\r\n- transform移动之后有锯齿 加 translateZ(0) 可解决\r\n- rgba的背景色的透明度不影响文字的显示，opacity会影响。\r\n- cursor: not-allowed;  和  pointer-events: none;  共用前面不生效， 两层元素可解决此问题，外层使用前者，内层使用后者\r\n- 鼠标穿透当前元素并且被其下面的元素捕获，可以对当前元素设置pointer-events: none;\r\n- sass继承另一个类的样式 @extend\r\n```\r\n.button-basic  {\r\n  border: none;\r\n  padding: 15px 30px;\r\n  text-align: center;\r\n  font-size: 16px;\r\n  cursor: pointer;\r\n}\r\n\r\n.button-report  {\r\n  @extend .button-basic;\r\n  background-color: red;\r\n}\r\n```\r\n\r\n\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## css3\r\n- 过渡  transition\r\n- 动画  animation\r\n- 形状转化  transform\r\n- 选择器\r\n- flex   弹性布局\r\n- grid   栅格布局\r\n- column 多列布局\r\n- 阴影 box-shadow\r\n- 圆角 border-raduis\r\n- 文字特效 text-shadow\r\n- 媒体查询 @media\r\n- RGBA和透明度\r\n- 盒子类型 box-sizing"},function(r,n,e){"use strict";e.r(n),n.default="## css变量\r\n### css变量有全局作用域和非全局作用域。\r\n- 使用:root或html、body标签定义的css变量是全局享用的。\r\n```\r\n:root {\r\n  --color: red;\r\n}\r\n\r\nbody {\r\n  --color: red;\r\n}\r\n```\r\n- 设置在特定元素或样式类上的css变量，只能在该元素及其子元素上生效。且优先级高于全局设置的css变量。\r\n```\r\n.box {\r\n  --color: yellow;\r\n}\r\n```\r\n"},function(r,n,e){"use strict";e.r(n),n.default='## css选择器-child和-of-type的使用差异\r\n> 平时开发中经常 -child 和 -of-type 傻傻分不清楚，本文将以:first-child和:first-of-type为例说明其差异。\r\n\r\n### 选择器\r\n- :first-child         :first-of-type\r\n- :last-child          :last-of-type\r\n- :nth-child(n)        :nth-of-type(n)\r\n- :nth-last-child(n)   :nth-last-of-type(n)\r\n- only-child           :only-of-type\r\n### :first-child\r\n> :first-child 选择器用于选取属于其父元素的首个子元素的指定选择器\r\n\r\n### :first-of-type\r\n> :first-of-type 选择器匹配属于其父元素的特定类型的首个子元素的每个元素\r\n\r\n### 使用示例\r\n**使用元素选择器**\r\n> p:first-child 可以理解为查找p元素的父元素中第一个子元素，如果为p元素则应用，否则不应用。p:first-of-type 可以理解为查找p元素的父元素中第一个为p的元素，找到并应用。\r\n\r\n- :first-child\r\n> 没有任何子元素应用背景色，因为p标签的父元素的第一个子元素是div不是p，所以选择器不生效。\r\n\r\n```\r\np:first-child {\r\n  background: #ff0000;\r\n}\r\n<div>\r\n  <div>div</div>\r\n  <p>1</p>\r\n  <p>2</p>\r\n  <p>3</p>\r\n</div>\r\n```\r\n- :first-of-type\r\n> 查找p元素的父元素中第一个为p的元素，所以第一个p元素应用背景色。\r\n\r\n```\r\np:first-of-type {\r\n  background: #ff0000;\r\n}\r\n<div>\r\n  <div>div</div>\r\n  <p>1</p> // 应用背景色\r\n  <p>2</p>\r\n  <p>3</p>\r\n</div>\r\n```\r\n\r\n**使用class或者id选择器**\r\n> .exer:first-child 可以理解为查找.exer元素的父元素中第一个子元素，如果为该元素元素有.exer类则应用，否则不应用。.exer:first-of-type 可以理解为查找.exer元素，然后根据对应元素的标签开始找同类型标签的兄弟节点，如果查找到这个元素是同类型兄弟元素中的第一个，则应用，否则不应用。\r\n\r\n- :first-child\r\n> 没有任何子元素应用背景色，因为.exer的父元素的第一个子元素没有exer类，所以选择器不生效。\r\n\r\n```\r\n.exer:first-child {\r\n  background: #ff0000;\r\n}\r\n<div>\r\n  <p>p</p>\r\n  <p class="exer">1</p>\r\n  <p class="exer">2</p>\r\n  <p class="exer">3</p>\r\n</div>\r\n```\r\n- :first-of-type\r\n> 没有任何子元素应用背景色，因为.exer的元素类型是p元素，该元素在同为p的兄弟元素中不是第一个所以没有任何元素应用背景色。\r\n\r\n```\r\n.exer:first-of-type {\r\n  background: #ff0000;\r\n}\r\n<div>\r\n  <p>p</p>\r\n  <p class="exer">1</p>\r\n  <p class="exer">2</p>\r\n  <p class="exer">3</p>\r\n</div>\r\n```\r\n\r\n**使用class或者id选择器搭配:first-of-type查找到的元素节点有很多种**\r\n- :first-child\r\n> .exer:first-child 因为.exer的父元素的第一个子元素有exer类，所以选择器生效。\r\n\r\n```\r\n.exer:first-child {\r\n  background: #ff0000;\r\n}\r\n<body class="body">\r\n  <h1 class="exer">标题1</h1> // 应用背景色\r\n  <h1 class="exer">标题2</h1>\r\n  <p>段落1</p>\r\n  <p class="exer">段落2</p>\r\n  <p class="exer">段落3</p>\r\n  <p class="exer">段落4</p>\r\n  <div class="exer">div 1</div>\r\n  <div>div 2</div>\r\n</body>\r\n```\r\n- :first-of-type\r\n> .exer:first-of-type 会匹配到的元素类型有h1、p、div标签但是找到的p标签不是同为p标签的兄弟元素中的第一个，所以只有h1、div标签应用背景色。\r\n\r\n```\r\n.exer:first-of-type {\r\n  background: #ff0000;\r\n}\r\n<body class="body">\r\n  <h1 class="exer">标题1</h1> // 应用背景色\r\n  <h1 class="exer">标题2</h1>\r\n  <p>段落1</p>\r\n  <p class="exer">段落2</p>\r\n  <p class="exer">段落3</p>\r\n  <p class="exer">段落4</p>\r\n  <div class="exer">div 1</div> // 应用背景色\r\n  <div>div 2</div>\r\n</body>\r\n```\r\n### 总结\r\n- first-child会判断选择器选择到的元素的第一个兄弟元素是否匹配对应的选择器，不会考虑元素的html标签类型。\r\n- first-of-type会判断选择器选择到的元素的html标签类型，判断相同html标签类型的第一个兄弟元素是否匹配对应的选择器。\r\n'},function(r,n,e){"use strict";e.r(n),n.default='## [css选择器](https://mp.weixin.qq.com/s/Zi_7pV6FkqT7U_0zLLDEkg)\r\n- 标签选择器（div, p, span等）\r\n- id选择器（#content）\r\n- 类选择器（.content）\r\n- 相邻选择器（h1+p）\r\n- 子选择器（ul>li）\r\n- 后代选择器（li a）\r\n- 通配符选择器（*）\r\n- 属性选择器（a[rel = "external"]）\r\n- 伪类选择器（a:hover, li:nth-child）\r\n### css 优先级\r\n- !important > id选择器 > 类选择器 > 标签选择器   !important 比 内联优先级高。\r\n- 考虑到就近原则，同权重情况下样式定义以最近者为准。\r\n- 同权重情况下 内联样式表（标签内部）> 嵌入样式表（当前文件中）> 外部样式表（外部文件中）'},function(r,n,e){"use strict";e.r(n),n.default='## [flex](https://mp.weixin.qq.com/s/X0NX7J7qiu2LK3wnUVxFwQ)\r\n### flex属性\r\n> flex属性是flex-grow, flex-shrink和flex-basis的简写，默认值为0 1 auto。\r\n\r\n- flex-grow定义项目的放大比例，默认为0，即如果存在剩余空间也不放大。\r\n- flex-shrink定义项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。\r\n- flex-basis定义在分配多余空间之前，项目占据的主轴空间(main size)，浏览器根据此属性计算主轴是否有多余空间，默认值为auto即项目本身的大小。\r\n### 简写\r\n- flex: none，相当于flex: 0 0 auto，表示项目不会伸缩，保持原始大小。\r\n- flex: auto，相当于flex: 1 1 auto，表示项目会根据自身大小和剩余空间进行伸缩。\r\n- flex: n(n为正整数)，相当于flex: n 1 0%，表示项目的放大比例为n，其他值默认。\r\n### flex: 1\r\n- 使用flex: 1的作用是让项目能够自动填充剩余空间，实现自适应布局。\r\n- 无论容器的宽高如何变化，项目都会自动调整，保持平均分配。\r\n- 不考虑元素自身的大小，平分剩余的空间。\r\n### felx：1和flex：auto的区别\r\n- flex: 1相当于flex: 1 1 0%，表示项目的基准大小为0%，不考虑项目本身的大小，只根据剩余空间进行伸缩。\r\n- flex: auto相当于flex: 1 1 auto，表示项目的基准大小为auto即项目本身的大小，同时也会根据剩余空间进行伸缩。\r\n- 如果容器有足够的空间，flex: 1和flex: auto都会平分剩余空间，但是flex: auto会保持项目本身的最小宽度，而flex: 1不会。\r\n- 如果容器没有足够的空间，flex: 1会优先压缩内容，使得所有项目都能等分空间，而flex: auto会优先保持内容的完整性，挤压其它项目的空间。\r\n### flex: 0\r\n- 在有剩余空间时，项目本身宽度最小化，不会分配容器的剩余空间。\r\n### 有剩余空间的示例\r\n```\r\n<style>\r\n.container {\r\n  display: flex;\r\n  width: 1000px;\r\n}\r\n.one {\r\n  width: 30%;\r\n  flex: none;\r\n  background-color: red;\r\n}\r\n.two {\r\n  width: 20%;\r\n  flex: auto;\r\n  background-color: green;\r\n}\r\n.three {\r\n  width: 40%;\r\n  flex: auto;\r\n  background-color: yellow;\r\n}\r\n</style>\r\n\r\n<div class="container">\r\n  <div class="one">1</div>\r\n  <div class="two">2</div>\r\n  <div class="three">3</div>\r\n</div>\r\n```\r\n- .one设置none时会保持自身本来的空间。\r\n- .two、.three设置auto时有剩余空间会在自身本来的空间基础上平分剩余空间。由代码可知剩余的空间为100px，.two在自身基础上增加平分的剩余空间50px为250px(200px + 50px)，.three在自身基础上增加平分的剩余空间50px为450px(400px + 50px)。\r\n- .two、.three设置1时不考虑自身本来的空间，只考虑分配剩余空间之后要保持两个元素的空间大小一致即可，.two、.three会平分除去.one占用空间后的剩余空间(700px)，所以.two、.three为350px。\r\n### 需要压缩空间的示例\r\n```\r\n<style>\r\n.container {\r\n  display: flex;\r\n  width: 1000px;\r\n}\r\n.one {\r\n  width: 30%;\r\n  flex: none;\r\n  background-color: red;\r\n}\r\n.two {\r\n  width: 40%;\r\n  flex: auto;\r\n  background-color: green;\r\n}\r\n.three {\r\n  width: 60%;\r\n  flex: auto;\r\n  background-color: yellow;\r\n}\r\n</style>\r\n\r\n<div class="container">\r\n  <div class="one">1</div>\r\n  <div class="two">2</div>\r\n  <div class="three">3</div>\r\n</div>\r\n```\r\n- .one设置none时会保持自身本来的空间。\r\n- .two、.three设置auto时会根据自身本来空间所占据的比例去压缩空间。由代码可知需要压缩的空间为300px，.two占据的比例为40%(.two和.three一共为100%，所以.two占据的比例为40%)，需要压缩的空间为120px(300px * 40%)，剩余空间为280px(400px - 120px)。.three占据的比例为60%(.two和.three一共为100%，所以.three占据的比例为60%)，需要压缩的空间为180px(300px * 60%)，剩余空间为420px(600px - 180px)。\r\n- .two、.three设置1时不考虑自身本来的空间，只考虑压缩之后要保持两个元素的空间大小一致即可，.two、.three会平分除去.one占用空间后的剩余空间(700px)，所以.two、.three为350px。'},function(r,n,e){"use strict";e.r(n),n.default="## grid网格布局\r\n### grid布局和flex布局\r\n- grid布局与flex布局的共同点是元素均存放在一个父级容器内，尺寸与位置受容器影响。\r\n- 声明grid布局之后，容器内部元素为块元素。声明flex布局之后，容器内部元素为行内元素。\r\n- flex布局使用单坐标轴的布局系统，grid布局中使用二维布局，使元素可以在二个维度上进行排列。\r\n- flex布局是以内容为基础，grid布局是以布局为基础。\r\n### 网格布局术语\r\n- 网格容器\r\n> 通过添加display: grid将一个元素设置成一个网格容器。\r\n\r\n- 网格项目\r\n> 网格容器中的每一个子元素都是网格项目。\r\n\r\n- 网格线\r\n> 网格线就是将网格划分开的线条。\r\n\r\n- 网格单元格\r\n> 网格单元格就是网格容器中划分出来最小的单元。\r\n\r\n- 网格轨道\r\n> 网格轨道就是由若干个网格单元格组成的横向或者纵向区域。\r\n\r\n- 网格区域\r\n> 网格区域也是由若干个网格单元格组成的区域，但是不同于网格轨道，网格区域的规格不局限与单个维度，可以包含横向和纵向区域。\r\n\r\n### fr单位\r\n> 表示网格容器中可用空间的一份。\r\n\r\n```\r\ngrid-template-columns: 1fr 1fr 1fr;    // 表示三列且空间三等分\r\ngrid-template-columns: 2fr 1fr 1fr;    // 表示三列且空间四等分，两份给第一列，剩下两列各占一份。\r\ngrid-template-columns: 400px 2fr 1fr;  // 表示三列，第一列400px，减去400px后剩下空间三等分，两份给第二列，剩下一份给第三列。\r\n```\r\n### repeat(time, content)\r\n> 标记重复部分，第一个参数time表示重复的次数，第二个参数content表示重复的内容。\r\n\r\n```\r\nrepeat(3, 1fr) = 1fr 1fr 1fr\r\n\r\n20px repeat(3, 1fr) 20px = 20px 1fr 1fr 1fr 20px\r\n\r\nrepeat(3, 1fr 2fr) = 1fr 2fr 1fr 2fr 1fr 2fr\r\n```\r\n### minmax(min, max)\r\n> 定义网格一个尺寸的范围，第一个参数min表示网格尺寸的最小值，第二个参数表示网格尺寸的最大值。\r\n\r\n```\r\nminmax(100px, 200px)  // 表示网格最小是100px，最大是200px\r\n\r\nminmax(100px, auto)   // 表示网格最小是100px，最大为auto，auto意思是将根据内容的大小自动变换\r\n```\r\n### grid-template-columns\r\n> 定义网格容器具体的列。\r\n\r\n```\r\n// 五列，第三列自动占用容器剩余的可用空间\r\ngrid-template-columns: 40px 50px auto 50px 40px;\r\n```\r\n### grid-template-rows\r\n> 定义网格容器具体的行。\r\n\r\n```\r\n// 三行，第三行自动占用容器剩余的可用空间\r\ngrid-template-rows: 25% 100px auto;\r\n```\r\n### grid-gap \r\n> grid-column-gap和grid-row-gap分别定义网格之间的列间距和行间距，grid-gap是简写形式，第一个值为行间距，第二个值为列间距。\r\n\r\n```\r\ngrid-column-gap: 10px;\r\ngrid-row-gap: 15px;\r\n\r\ngrid-gap: 15px 10px; // 简写形式\r\n```\r\n### grid-area\r\n- 语法\r\n  1. grid-row-start 项目的起始行。\r\n  2. grid-column-start 项目的起始列。\r\n  3. grid-row-end 项目的结束行。\r\n  4. grid-column-end 项目的结束列。\r\n```\r\ngrid-area: grid-row-start / grid-column-start / grid-row-end / grid-column-end\r\n```\r\n- 以行列的形式表达\r\n```\r\ngrid-area: 行开始 / 列开始 / 行结束 / 列结束  \r\n```\r\n- 以跨行列数的形式表达\r\n```\r\ngrid-area: 行开始 / 列开始 / span 2(跨行数) / span 2(跨列数)\r\n```\r\n- 项目占据第一行和第二行，第一列和第二列。\r\n```\r\ngrid-area: 1/1/3/3;\r\n```\r\n### 隐式网格轨道\r\n- 当声明的网格容器内的单元格数量已经不够存放网格项目时，多出的网格项目会自动放入到自动生成的网格单元中，这时原来声明的网格单元叫显示轨道，多出的网格项目显示的轨道叫隐式轨道。\r\n- 多出的项目在容器中默认按照先行后列的顺序排列即“行优先”。\r\n```\r\ngrid-auto-flow: row;\r\n```\r\n- 自动生成的隐式轨道的高度是自动的，“行优先”时要设置隐式轨道的行高。\r\n```\r\ngrid-auto-rows: 200px;\r\n```\r\n- 多出的项目在容器中按照“列优先”排列。 \r\n```\r\ngrid-auto-flow: column;\r\n```\r\n- 自动生成的隐式轨道的宽度是自动的，“列优先”时要设置隐式轨道的列宽。\r\n```\r\ngrid-auto-columns: 200px;\r\n```\r\n### 设置grid自动换行\r\n```\r\ngrid-template-columns: repeat(auto-fit, 100px);\r\n```\r\n### 控制网格项的对齐方式，用法和效果与flex布局类似\r\n- justify-items\r\n- align-items\r\n- justify-content\r\n- align-content\r\n- justify-self\r\n- align-self"},function(r,n,e){"use strict";e.r(n),n.default="## scss变量\r\n### 定义变量\r\n```\r\n// common.scss\r\n$primaryColor: #1890FF;\r\n// 使用css变量并赋默认值\r\n$primaryColor: var(--primary-color, #1890FF);\r\n$buttonSpacing: 8px;\r\n\r\n:export {\r\n  primaryColor: $primaryColor;\r\n  buttonSpacing: $buttonSpacing;\r\n}\r\n```\r\n### scss文件中使用变量\r\n```\r\n@import \"@/styles/common.scss\";\r\n\r\n.icon {\r\n  cursor: pointer;\r\n  color: $primaryColor;\r\n}\r\n```\r\n### js文件中使用变量\r\n```\r\nimport styleConfig from '@/styles/common.scss';\r\n\r\nconst { primaryColor } = styleConfig;\r\n<div style={{ color: primaryColor }}>dyx</div>\r\n```"},function(r,n,e){"use strict";e.r(n),n.default='## 伪类伪元素\r\n- ":" 是伪类，"::" 是伪元素。伪即假，伪类和伪元素都是假的，不存在于 HTML 或 DOM 元素的，他们是由 CSS 创建的。\r\n- ":" 伪类用于表示元素的一种状态，比如 :hover、:visited、:checked 等，CSS 中差不多有 30+ 种伪类。"::" 伪元素用于选择元素的一部分，比如 ::first-letter、::first-line、::before、::after 等，CSS 中目前有 17 个伪元素。\r\n'},function(r,n,e){"use strict";e.r(n),n.default="## 水平垂直居中\r\n### 固定宽高\r\n- flex布局\r\n```\r\n.outer {\r\n  height: 400px;\r\n  width: 400px;\r\n  border: 1px solid #eee;\r\n  display: flex;\r\n  justify-content: center;\r\n  align-items: center;\r\n}\r\n.inner {\r\n  width: 100px;\r\n  height: 100px;\r\n  background: red;\r\n}\r\n```\r\n- grid布局\r\n```\r\n.outer {\r\n  height: 400px;\r\n  width: 400px;\r\n  border: 1px solid #eee;\r\n  display: grid;\r\n}\r\n.inner {\r\n  width: 100px;\r\n  height: 100px;\r\n  background: red;\r\n  margin: auto;\r\n}\r\n```\r\n- 绝对定位加margin负值\r\n```\r\n.outer {\r\n  position: relative;\r\n  height: 400px;\r\n  width: 400px;\r\n  border: 1px solid #eee;\r\n}\r\n.inner {\r\n  position: absolute;\r\n  width: 100px;\r\n  height: 100px;\r\n  background: red;\r\n  left: 50%;\r\n  top: 50%;\r\n  margin-left: -50px;\r\n  margin-top: -50px; \r\n}\r\n```\r\n- 绝对定位 + transform\r\n```\r\n.outer {\r\n  position: relative;\r\n  height: 400px;\r\n  width: 400px;\r\n  border: 1px solid #eee;\r\n}\r\n.inner {\r\n  position: absolute;\r\n  width: 100px;\r\n  height: 100px;\r\n  background: red;\r\n  left: 50%;\r\n  top: 50%;\r\n  transform: translate(-50%, -50%);\r\n}\r\n```\r\n- 绝对定位 + left/right/bottom/top + margin\r\n```\r\n.outer {\r\n  position: relative;\r\n  height: 400px;\r\n  width: 400px;\r\n  border: 1px solid #eee;\r\n}\r\n.inner {\r\n  position: absolute;\r\n  width: 100px;\r\n  height: 100px;\r\n  background: red;\r\n  left: 0;\r\n  right: 0;\r\n  top: 0;\r\n  bottom: 0;\r\n  margin: auto;\r\n}\r\n```\r\n- table-cell + vertical-align + inline-block/margin: auto\r\n```\r\n.outer {\r\n  height: 400px;\r\n  width: 400px;\r\n  border: 1px solid #eee;\r\n  display: table-cell;\r\n  text-align: center;\r\n  vertical-align: middle;\r\n}\r\n.inner {\r\n  width: 100px;\r\n  height: 100px;\r\n  background: red;\r\n  /* 可以换成margin: auto; */\r\n  display: inline-block;\r\n}\r\n```\r\n### 不定宽高\r\n- flex布局\r\n```\r\n.outer {\r\n  height: 400px;\r\n  width: 400px;\r\n  border: 1px solid #eee;\r\n  display: flex;\r\n  justify-content: center;\r\n  align-items: center;\r\n}\r\n.inner {\r\n  background: red;\r\n}\r\n```\r\n- 绝对定位 + transform\r\n```\r\n.outer {\r\n  height: 400px;\r\n  width: 400px;\r\n  border: 1px solid #eee;\r\n  position: relative;\r\n}\r\n.inner {\r\n  background: red;\r\n  position: absolute;\r\n  left: 50%;\r\n  top: 50%;\r\n  transform: translate(-50%, -50%);\r\n}\r\n```\r\n- table-cell\r\n```\r\n.outer {\r\n  height: 400px;\r\n  width: 400px;\r\n  border: 1px solid #eee;\r\n  display: table-cell;\r\n  text-align: center;\r\n  vertical-align: middle;\r\n}\r\n.inner {\r\n  background: red;\r\n  display: inline-block;\r\n}\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## 换行\r\n### white-space\r\n> 这个属性是用来控制空白字符的显示的。\r\n\r\n- normal  默认情况，空格被合并，换行符不生效，自动换行。\r\n- nowrap  空格被合并，换行符无效，原本的自动换行效果也没有了，只有`<br>`才能导致换行。\r\n- pre     空格和换行符被保留了下来，原本的自动换行效果没有了。\r\n- pre-wrap  保留空格和换行符，且可以自动换行。\r\n- pre-line  空格被合并了，换行符可以发挥作用，自动换行还在。\r\n### word-break\r\n> 这个属性是控制单词如何被拆分换行的。\r\n\r\n- normal  默认情况。\r\n- keep-all   所有单词(包括连续的字符)一律不拆分换行，可以理解为只有空格可以触发自动换行。\r\n- break-all  所有单词碰到边界一律拆分换行。\r\n### word-wrap (overflow-wrap)\r\n> 这个属性也是控制单词如何被拆分换行的。\r\n\r\n- normal  默认情况。\r\n- break-word  只有当一个单词一整行都显示不下时，才会拆分换行该单词。"},function(r,n,e){"use strict";e.r(n),n.default='## [样式隔离](https://mp.weixin.qq.com/s/DZjtKB7NgIz4MKEI4IuTdA)\r\n### 运行时通过命名空间来区分，需要人为约定，出错可能性较大。\r\n### 编译时自动转换选择器名字，添加上唯一标识\r\n#### scoped\r\n> scoped 是 vue-loader 支持的方案，它是通过编译的方式在元素上添加了 data-xxx 的属性，然后给 css 选择器加上`[data-xxx]` 全局唯一的属性选择器的方式实现 css 的样式隔离。\r\n\r\n```\r\n<style scoped> \r\n  .guang { \r\n    color: red; \r\n  } \r\n</style>  \r\n<template>  \r\n  <div class="guang">hi</div>  \r\n</template>\r\n\r\n// 编译为\r\n<style> \r\n  .guang[data-v-f3f3eg9] { \r\n    color: red; \r\n  } \r\n</style> \r\n<template> \r\n  <div class="guang" data-v-f3f3eg9>hi</div> \r\n</template>\r\n```\r\n\r\n#### CSS Modules\r\n> css-modules 是 css-loader 支持的方案，在 vue、react 中都可以用，它是通过编译的方式修改选择器名字为全局唯一的方式来实现 css 的样式隔离。\r\n\r\n```\r\n<style module> \r\n  .guang {\r\n    color: red; \r\n  } \r\n</style>  \r\n<template>\r\n  <p :class="$style.guang">hi</p>  \r\n</template>\r\n\r\n<style module>\r\n  ._1yZGjg0pYkMbaHPr4wT6P__1 { \r\n    color: red; \r\n  } \r\n</style> \r\n<template> \r\n  <p class="_1yZGjg0pYkMbaHPr4wT6P__1">hi</p> \r\n</template>\r\n```\r\n#### 两者比较\r\n> 两种方案都是通过编译实现的，但是开发者的使用感受还是不太一样的：scoped 的方案是添加的 data-xxx 属性选择器，因为 data-xx 是编译时自动生成和添加的，开发者感受不到。css-modules 的方案是修改 class、id 等选择器的名字，组件里就要通过 styles.xx 的方式引用这些编译后的名字，开发者是能感受到的。\r\n\r\n#### css-in-js\r\n> 可以通过 JS 来组织 css，利用 JS 的作用域来实现 css 隔离。\r\n\r\n```\r\nimport styled from \'styled-components\';\r\n\r\nconst Wrapper = styled.div`\r\n  font-size: 50px;\r\n  color: red;\r\n`;\r\n\r\nfunction Guang {\r\n  return (\r\n    <div>\r\n      <Wrapper>内部文件写法</Wrapper>\r\n    </div>\r\n  );\r\n}\r\n```\r\n#### 实现 css-modules\r\n> css-loader 是通过 postcss 插件来实现 css-modules 的，其中最核心的是 postcss-modules-scope 插件。\r\n\r\n- 遍历所有选择器，对 :local 伪元素包裹的选择器做转化，并且收集到 exports 中。\r\n- 对 composes 的选择器做一对多的映射，也收集到 exports 中。\r\n- 根据 exports 收集到的映射关系生成 :exports 样式。\r\n- 可以用这个映射关系生成 js 模块，组件里就可以用 styles.xxx 的方式引入对应的 css 了。'},function(r,n,e){"use strict";e.r(n),n.default="## 浮动\r\n### 浮动现象\r\n- 浮动元素脱离文档流，不占据空间引起“高度塌陷”现象。\r\n- 浮动元素碰到包含它的边框或其他浮动元素的边框停留。\r\n### 浮动的问题\r\n- 父级元素的高度将会无法被撑开，会影响与父级元素同级的元素\r\n- 与浮动元素同级的非浮动元素（内联元素）会跟随其后\r\n- 若浮动的元素不是第一个元素，则该元素之前的元素也要浮动，否则会影响页面的显示结构\r\n### 清除浮动\r\n- 父级盒子定义高度height\r\n- 最后一个浮动元素后面加一个div空标签，并且添加样式clear: both\r\n- 包含浮动元素的父级标签添加样式overflow为hidden或both\r\n- 父级div定义zoom"},function(r,n,e){"use strict";e.r(n),n.default="## 父元素使用max-height，子元素使用百分比不生效\r\n### 决定元素高度的因素\r\n- 如果在不额外设置高度或者行高等外加的影响高度的css样式时，一个元素的高度就是其内部元素内容的高度之和。\r\n- 元素的高度是由内向外计算的。\r\n### 高度设置为百分比的计算效果\r\n- 当给一个元素的高度设置成百分比时那么这个元素的高度为父元素高度的百分比。\r\n- 要给一个元素设置百分比的高度，这个元素的父元素必须有一个明确的高度，如果父元素没有确定的高度(比如使用max-height)，那么子元素的高度也会无从计算。\r\n### 实现父元素使用max-height，子元素使用百分比效果\r\n- 在起初的父元素和子元素之间添加一层元素，起初的父元素设置flex布局，新添加的一层元素设置flex: 1。\r\n```\r\n.parent {\r\n  max-height: 70vh;\r\n  display: flex;\r\n}\r\n.childWrapper {\r\n  flex: 1;\r\n}\r\n.child {\r\n  height: 100%;\r\n}\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## 盒子模型\r\n- 标准盒子模型盒子的height和width是content（内容）的宽高。\r\n- 而IE盒子模型盒子的宽高则包括content+padding+border部分。\r\n### box-sizing，修改盒子模型\r\n- content-box 默认的标准(W3C)盒模型元素效果 (默认值)\r\n- border-box 触发怪异(IE)盒模型元素的效果\r\n- inherit 继承父元素 box-sizing 属性的值"},function(r,n,e){"use strict";e.r(n),n.default="## 网页变黑白颜色\r\n> 使用CSS filter属性，并使用 grayscale 对图片进行灰度转换，允许有一个参数，可以是数字（0到1）或百分比，0% 到 100% 之间的值会使灰度线性变化。如果不想完全灰掉，可以设置个相对小的数字。\r\n\r\n- 把filter样式加到body元素上通常没有问题，如果网页内有绝对和固定定位元素，要把filter样式加到html上。加在body上有时候会出现横向滚动条，建议加在html上。\r\n```\r\nhtml {\r\n  filter: grayscale(1);\r\n  // 更好的兼容性，加一个带 -webkit- 前缀的样式。\r\n  -webkit-filter: grayscale(1);\r\n}\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## css雪碧图\r\n> 一个网页可能有很多很多的小图标，浏览器在显示页面的时候，就需要像服务器发送很多次访问请求，造成资源浪费，还会导致访问速度变慢。可以把很多小图片（需要使用的小图标）放在一张图片上，按照一定的距离隔开，可以减少网页的http请求，从而大大的提高页面的性能。通过设置background-position的值，移动图片到自己想要的图标位置。\r\n\r\n### 雪碧图动画\r\n> 动画均匀地分多段执行(steps)，每次都有固定相等的偏移量。"},function(r,n,e){"use strict";e.r(n),n.default="## React、Vue2、Vue3的Diff算法对比\r\n### [React](https://juejin.cn/post/7116141318853623839#heading-9)\r\n> 在组件状态数据发生变更的时候，根据最新的状态数据先生成新的虚拟DOM，再去构建一棵新的workInProgress Fiber树，而在重新协调构建新的Fiber树的过程也就是React Diff发生的地方。\r\n\r\n1. 从左到右循环新列表和旧列表进行对比，如果节点可以匹配则复用老fiber的节点信息(标记为Update)，无需进行位置移动，存储老fiber节点的位置信息(游标位置)，用于后续判断位置是否需要移动。\r\n    - 如果新列表循环完，旧列表还有剩余节点表示剩余节点应该被删除(标识Deletion)。\r\n    - 如果旧列表循环完，新列表还有剩余节点表示剩余节点应该被新建(标识Placement)。\r\n2. 当第一步循环遇到新旧列表对比不匹配的情况时，第一轮循环对比结束，进行第二轮对比。\r\n    - 将剩下未对比的老fiber节点全部存储在一个老fiber的key或老fiber的index为key，fiber节点为value的Map中。\r\n    - 循环新列表第一轮对比后剩余未对比成功的节点，从老fiber节点的Map中寻找可以匹配成功的节点。\r\n        1. 从老fiber节点的Map找到可以匹配成功的节点时，暂存老fiber节点，将匹配成功的老fiber节点从Map中删除，再进行老fiber节点的信息复用。将匹配成功的老fiber节点的位置和之前存储游标位置进行比较。\r\n            - 如果大于或等于之前的游标位置，表示无需进行位置移动(标识为Update)，将游标位置更新为当前匹配成功的老fiber节点的位置信息。\r\n            - 如果小于之前的游标位置，表示需要进行位置移动(标识为Placement)，游标位置无需更新。\r\n            - 匹配到的老fiber节点如果和新节点位置相同或者在新节点位置的右边则不需要进行位置移动。\r\n         2. 从老fiber节点的Map未找到可以匹配成功的节点时，表示没有老fiber节点可以复用需要新建(标记为Placement)，游标位置无需更新。\r\n    - 如果新列表循环完，老fiber节点的Map中还有剩余节点表示剩余节点应该被删除(标识Deletion)。\r\n\r\n![reactDiff-第一轮对比](./img/reactDiff-第一轮对比.png)\r\n![reactDiff-第二轮对比-位置无需移动](./img/reactDiff-第二轮对比-位置无需移动.png)\r\n![reactDiff-第二轮对比-新建](./img/reactDiff-第二轮对比-新建.png)\r\n![reactDiff-第二轮对比-位置需要移动](./img/reactDiff-第二轮对比-位置需要移动.png)\r\n![reactDiff-第二轮对比-删除](./img/reactDiff-第二轮对比-删除.png)\r\n\r\n### [Vue2-双端对比](https://juejin.cn/post/6919376064833667080#heading-8)\r\n> 新列表和旧列表两个列表的头与尾互相对比，在对比的过程中指针会逐渐向内靠拢。当头尾对比失败时遍历新列表去旧列表中找可匹配的节点。当其中一个列表的节点全部遍历完成时查看另一个列表是否存在数据进行删除或添加操作即可。\r\n\r\n1. 新列表和旧列表两个列表的头与尾互相对比，寻找可匹配的节点。\r\n    - 使用旧列表的头一个节点oldStartNode与新列表的头一个节点newStartNode对比。\r\n    - 使用旧列表的最后一个节点oldEndNode与新列表的最后一个节点newEndNode对比。\r\n    - 使用旧列表的头一个节点oldStartNode与新列表的最后一个节点newEndNode对比。\r\n    - 使用旧列表的最后一个节点oldEndNode与新列表的头一个节点newStartNode对比。\r\n2. 当对比时找到了可匹配的节点时先给元素打补丁，然后将指针进行前/后移一位继续进行头与尾互相对比。根据对比节点的不同移动的指针和方向也不同，移动指针和方向如下：\r\n    - 当旧列表的头一个节点oldStartNode与新列表的头一个节点newStartNode可匹配时，那么旧列表的头指针oldStartIndex与新列表的头指针newStartIndex同时向后移动一位。\r\n    - 当旧列表的最后一个节点oldEndNode与新列表的最后一个节点newEndNode可匹配时，那么旧列表的尾指针oldEndIndex与新列表的尾指针newEndIndex同时向前移动一位。\r\n    - 当旧列表的头一个节点oldStartNode与新列表的最后一个节点newEndNode可匹配时，那么旧列表的头指针oldStartIndex向后移动一位；新列表的尾指针newEndIndex向前移动一位。\r\n    - 当旧列表的最后一个节点oldEndNode与新列表的头一个节点newStartNode可匹配时，那么旧列表的尾指针oldEndIndex向前移动一位；新列表的头指针newStartIndex向后移动一位。\r\n3. 通过循环让指针向内靠拢，循环停止的条件是当其中一个列表的节点全部遍历完成。\r\n4. 头尾节点对比到可匹配节点时的移动(理想状态下)\r\n    - 旧列表的头节点oldStartNode和新列表的头节点newStartNode可匹配时，原本在旧列表中就是头节点在新列表中也是头节点，该节点不需要移动。\r\n    - 旧列表的尾节点oldEndNode和新列表的尾节点newEndNode可匹配时，原本在旧列表中就是尾节点在新列表中也是尾节点，该节点不需要移动。\r\n    - 旧列表的头节点oldStartNode和新列表的尾节点newEndNode可匹配时，原本在旧列表头部的节点却是新列表中的末尾节点，只需要把当前的节点移动到原本旧列表中的最后一个节点之后，让它成为最后一个节点即可。\r\n    - 旧列表的尾节点oldEndNode与新列表的头节点newStartNode可匹配时，原本在旧列表末尾的节点却是新列表中的开头节点，只需要把当前的节点移动到原本旧列表中的第一个节点之前，让它成为第一个节点即可。\r\n5. 头尾节点对比没有找到可匹配的节点时(非理想状态下)，当头与尾四次对比都没找到匹配节点时，拿新列表的第一个节点去旧列表中寻找可匹配的节点。\r\n    - 如果在旧列表中找到可匹配的节点，只需要将找到的虚拟节点的DOM元素移动到开头。DOM移动后需要将旧列表中的节点改为undefined，标识已经做了节点的移动后续不需要进行再次的对比，旧列表遍历到undefind时就跳过当前节点。然后将头指针newStartIndex向后移一位。\r\n    - 如果在旧列表中没有找到可匹配的节点，直接创建一个新的节点放到最前面，然后将头指针newStartIndex向后移一位。\r\n6. 添加节点：当旧列表的oldEndIndex小于oldStartIndex时，如果新列表中还有剩余的节点，需要将剩余的节点依次插入到oldStartNode的DOM之前。因为剩余的节点在新列表的位置是位于oldStartNode之前的，如果剩余节点是在oldStartNode之后，oldStartNode就会先行对比。\r\n\r\n![vue2添加节点](./img/vue2添加节点.png)\r\n\r\n7. 移除节点：当新列表的newEndIndex小于newStartIndex时，将旧列表剩余的节点删除即可。需要注意旧列表的undefind，遇到跳过当前循环即可。\r\n### [Vue3-最长递增子序列](https://juejin.cn/post/7045976871116210213)\r\n> 新旧列表的头和头对比、尾与尾对比，指针从两端向内靠拢。通过最长递增子序列减少DOM的移动次数。\r\n\r\n1. 前置与后置的预处理\r\n    - 从左往右进行对比，如果新旧列表的节点可匹配就进行更新对比，如果不匹配则停止对比，记录停止的下标。\r\n    - 再从右往左进行对比，如果新旧列表的节点可匹配就进行更新对比，如果不匹配也停止对比，也记录停止的下标。\r\n    - 通过这样左右进行对比，可以把真正复杂部分的范围锁定。\r\n    - 左右对比完之后，如果新列表已经对比完了，旧列表还存在节点未对比，则删除旧列表上的未对比的节点；如果旧列表已经对比完了，新列表还存在未对比的节点则进行创建。\r\n2. 当前置和后置的预处理结束后，新旧列表都还有剩余节点时进行更进一步的对比处理\r\n    - 把剩下未对比的新节点处理成节点的key(或type)为key, 节点下标为value的Map。\r\n    - 初始化一个长度为剩下未对比新节点的长度的数组newIndexToOldIndexMap，初始化每个数组的下标的默认值为-1。\r\n    - 循环剩下未对比的旧节点，通过旧节点的key去刚刚创建的Map中查找是否有匹配的节点，如果旧节点没有key则需要通过循环剩下未对比的新节点进行匹配。\r\n        1. 如果旧节点在新列表中不存在，直接删除即可。\r\n        2. 使用变量记录已经匹配成功的节点，当该变量值和新列表剩余节点数量相同时，剩余旧节点直接删除即可。\r\n        3. 如果新旧节点匹配成功，将newIndexToOldIndexMap中匹配成功的新节点的值更新为对应匹配成功的旧节点的下标。\r\n    - 把剩下未对比的旧节点循环完会得到一个刚刚收集的新节点所对应旧节点的下标数组，对这个新节点所对应旧节点的下标数组进行最长递增子序列查找得到一个最长递增子序列的下标数据。\r\n    - 从后循环剩下未对比的新节点(因为使用insertBefore是将元素插入到一个元素的前面所以从后开始循环)，通过循环的下标去newIndexToOldIndexMap查找对应的值\r\n      1. 如果为-1表示没有在旧列表中匹配成功，需要新建。\r\n      2. 如果在最长递增子序列中则不需要移动。\r\n      3. 如果不在最长递增子序列中则需要对该节点进行移动操作，找到需要移动到的位置移动节点即可。\r\n### React、Vue2、Vue3的Diff算法对比\r\n- 相同点\r\n    1. 都是忽略跨级比较，只做同级比较。\r\n    2. 两个不同类型的元素会产生出不同的树，不会尝试复用。\r\n    3. Diff对比都是优先处理简单的场景，再处理复杂的场景。\r\n        - React是先处理左边部分，再进行复杂部分的处理。\r\n        - Vue2是先进行首首、尾尾、首尾、尾首部分的处理，再进行中间复杂部分的处理。\r\n        - Vue3是先处理首尾部分，再进行中间复杂部分的处理。\r\n        - Vue2和Vue3最大的区别就是在处理中间复杂部分使用了最长递增子序列算法找出稳定序列的部分。\r\n    4. 在处理老节点部分，都把节点处理成key-value的Map数据结构，方便在后续的比对中可以快速找到对应的节点。\r\n    5. 在比对两个新老节点是否相同时，key是否相同是非常重要的判断标准。\r\n    6. 在移动或者创建节点的时候都使用了insertBefore(newnode, existingnode)这个API。\r\n- 不同点\r\n    1. 对静态节点(template模板中没有使用v-bind绑定属性的标签)的处理不一样。\r\n        - 由于Vue是通过template模版进行编译的，所以在编译的时候可以很好对静态节点进行分析然后进行打补丁标记。\r\n        - 静态节点Diff的时候，Vue2判断如果是静态节点则跳过循环对比，而Vue3则是把整个静态节点进行提升处理，Diff的时候是不进入循环的，所以Vue3比Vue2的Diff性能更高效。\r\n        - React是通过JSX进行编译的，是无法进行静态节点分析的，所以React在对静态节点处理这一块是要逊色的。\r\n    2. Vue2和Vue3的比对和更新是同步进行的，跟React15是相同的，在比对的过程中如果发现了节点需要移动或者更新或删除是立即执行的，也就是React中常讲的不可中断的更新，如果比对量过大的话，就会造成卡顿。React16更改为了比对和更新是异步进行的，Diff是可以中断在内存中进行的。\r\n    3. Vue2和Vue3都使用了双端对比算法，而React的Fiber由于是单向链表的结构，所以在React不设置由右向左的链表之前无法实现双端对比。\r\n### A,B,C,D => D,A,B,C\r\n- React是从左向右进行比对的，React需要把A,B,C三个节点分别移动到D节点的后面。\r\n- Vue2在进行老节点的结尾与新节点的开始比对的时候发现这两个节点是相同的，把老节点结尾的D移动到新节点开头，剩下的就只进行老节点的开始与新节点的开始进行比对，发现它们的位置没有发生变化，不需要进行移动。\r\n- Vue3没有Vue2的新老首尾节点进行比较，只是从两组节点的开头和结尾进行比较，然后往中间靠拢，Vue3在进行新老节点的开始和结尾比对的时候没有比对成功，接下来就进行中间部分的比较，使用最长递增子序列算法找出其中的稳定序列部分(A,B,C)，然再对新节点进行循环比对发现新节点的A,B,C都在稳定序列部分不需要进行移动，只对D进行移动即可。\r\n\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## react Diff(深度优先遍历)\r\n- React在执行render过程中会产生新的虚拟DOM，在浏览器平台下为了尽量减少DOM的创建，React会对新旧虚拟DOM进行Diff算法找到它们之间的差异，尽量复用DOM从而提高性能。所以Diff算法主要就是用于查找新旧虚拟DOM之间的差异。\r\n- Diff操作本身也会带来性能损耗，React文档中提到即使在最前沿的算法中，将前后两棵树完全比对的算法的复杂程度为O(n^3)，其中n是树中元素的数量。如果在React中使用了该算法，那么展示1000个元素所需要执行的计算量将在十亿的量级范围。这个开销实在是太过高昂无法接受。\r\n### O(n^3) => O(n)\r\n- 每个节点都要去和另一棵树的全部节点对比一次，这就是n了，如果找到有变化的节点，执行插入、删除、修改也是n的复杂度。所有的节点都是这样再乘以n，所以是O(n * n * n)的复杂度。\r\n- 有了上述的限制这样只要遍历一遍，对比一下type就行了，是O(n)的复杂度，而且type变了就不再对比子节点。因为vdom中记录了关联的dom节点，执行dom的增删改也不需要遍历，是O(1)的，整体的Diff算法复杂度就是O(n)的复杂度。\r\n### Diff算法是一种对比算法\r\n> 对比两者是旧虚拟DOM和新虚拟DOM，对比出是哪个虚拟节点更改了，找出这个虚拟节点，并只更新这个虚拟节点所对应的真实节点，而不用更新其他数据没发生改变的节点，实现精准地更新真实DOM，进而提高效率。\r\n\r\n- 使用虚拟DOM算法的损耗计算\r\n> 总损耗 = 虚拟DOM增删改(与Diff算法效率有关) + 真实DOM差异增删改 + (较少的节点)排版与重绘\r\n\r\n- 直接操作真实DOM的损耗计算\r\n> 总损耗 = 真实DOM完全增删改 + (可能较多的节点)排版与重绘\r\n\r\n### 降低算法复杂度，React的Diff会预设三个限制\r\n1. 只对同级元素进行Diff，不做跨级比较。如果一个DOM节点在前后两次更新中跨越了层级，那么React不会尝试复用它，React只会简单地考虑同层级节点的位置变换，而对于不同层级的节点，只有创建和删除操作。(tree diff)\r\n2. 两个不同类型的元素会产生出不同的树。如果元素由div变为p，React会销毁div及其子孙节点，并新建p及其子孙节点。(component diff)\r\n3. 开发者可以通过key属性来告诉react哪些子元素在不同的渲染下能保持稳定。(element diff)\r\n### tree diff\r\n- tree diff主要针对的是React DOM节点跨层级的操作。由于跨层级的DOM移动操作较少，所以tree diff没有针对此种操作进行深入比较，只是简单进行了删除和创建操作。\r\n- 在开发组件时，保持稳定的DOM结构会有助于性能的提升。例如可以通过CSS隐藏或显示节点，而不是真正地移除或添加DOM节点。\r\n![tree diff](./img/treeDiff.png)\r\n- A节点（包括其子节点）整个被移动到D节点下，由于React只会简单地考虑同层级节点的位置变换，而对于不同层级的节点，只有创建和删除操作。\r\n- 当根节点发现子节点中A消失了，就会直接销毁A。当D发现多了一个子节点A，则会创建新的A（包括子节点）作为其子节点。此时diff的执行情况：create A → create B → create C → delete A。\r\n- 当出现节点跨层级移动时，并不会出现想象中的移动操作，而是以A为根节点的整个树被重新创建。这是一种影响React性能的操作，因此官方建议不要进行DOM节点跨层级的操作。\r\n### component diff\r\n- component diff是专门针对更新前后的同一层级间的React组件比较的diff算法。\r\n- 如果是同一类型的组件，按照原策略继续比较虚拟DOM树（例如继续比较组件props和组件里的子节点及其属性）即可，React设计了一个巧妙的规则，当我们判定元素节点的父节点未发生变化时就不比较props，从而跳过props的比较来提高性能(props浅比较时引用地址不同，比较时永远不相同)。\r\n- 如果不是同一类型的组件，则将该组件判断为dirty component，从而替换整个组件下的所有子节点，即销毁原组件，创建新组件。\r\n- 对于同一类型的组件，有可能其Virtual DOM没有任何变化，如果能够确切知道这点，那么就可以节省大量的diff运算时间。因此React允许用户通过shouldComponentUpdate()来判断该组件是否需要进行diff算法分析。\r\n\r\n![component diff](./img/componentDiff.png)\r\n- 当组件D变为组件G时，即使这两个组件结构相似，一旦React判断D和G是不同类型的组件，就不会比较二者的结构，而是直接删除组件D，重新创建组件G及其子节点。\r\n- 虽然当两个组件是不同类型但结构相似时，diff会影响性能，但不同类型的组件很少存在相似DOM树的情况，因此这种极端因素很难在实际开发过程中造成重大的影响。\r\n### element diff\r\n- element diff是专门针对同一层级的所有节点（包括元素节点和组件节点）的diff算法。\r\n- 当节点处于同一层级时，diff提供了3种节点操作，分别为插入、删除、移动。\r\n- 插入：新集合的某个类型组件或元素节点不存在旧集合里，即全新的节点需要对新节点执行插入操作。\r\n- 删除：旧集合的某个组件或节点类型，在新集合里也有但对应的element不同则不能直接复用和更新，需要执行删除操作，或者旧组件或节点不在新集合里的，也需要执行删除操作。\r\n- 移动：新集合的某个类型组件或元素节点存在旧集合里，且element是可更新的类型，这种情况下prevChild=nextChild，就需要做移动操作，可以复用以前的DOM节点。\r\n\r\n![element diff](./img/elementDiff.png)\r\n- 通过设置key属性使用移动操作减少元素的插入和删除操作。\r\n\r\n\r\n\r\n\r\n\r\n"},function(r,n,e){"use strict";e.r(n),n.default='## react Diff更新\r\n- react在内部使用fiber这种数据结构来作为虚拟dom(react16+)形成fiber tree，它与dom tree一一对应，一次react更新本质是fiber tree结构的更新变化。\r\n- fiber tree结构的更新，其实就是fiber tree的协调(Reconcile)。fiber tree的协调就是调整fiber tree的结构，使其和更新后的jsx结构、dom tree保持一致。\r\n### jsx => 真实dom\r\n- 从jsx生成react element。\r\n> jsx模板通过babel编译为createElement方法，执行createElement方法返回react element。\r\n\r\n- 从react element生成fiber tree。\r\n  1. fiber tree中存在三种类型的指针child、sibling、return。其中child指向第一个子节点，sibling指向兄弟节点，return指针指向父节点。\r\n  2. fiber tree采用的深度优先遍历，如果节点有子节点先遍历子节点；子节点遍历结束以后，再遍历兄弟节点；没有子节点和兄弟节点就返回父节点，遍历父节点的兄弟节点；当节点的return指针返回null时，fiber tree的遍历结束。\r\n- 从fiber tree生成真实dom。\r\n> fiber tree生成之后，从fiber tree到真实dom就是处理fiber tree上对应的副作用，包括：\r\n\r\n  1. 所有dom节点的新增。\r\n  2. componentDidMount、useEffect的callback函数的触发。\r\n  3. ref引用的初始化。\r\n### 双缓存fiber tree\r\n- react做更新处理时，会同时存在两颗fiber tree。一颗是已经存在的fiber tree，对应当前屏幕显示的内容，称为current fiber tree。另外一颗是更新过程中构建的new fiber tree，称为workInProgress fiber tree。\r\n- current fiber tree和workInProgress fiber tree可以通过alternate指针互相访问。\r\n- 当更新完成以后，使用workInProgress fiber tree替换掉current fiber tree，作为下一次更新的current fiber tree。\r\n### 协调的过程\r\n1. 为workInProgress fiber tree生成fiber node。\r\n2. 为发生变化的fiber node标记副作用effect。\r\n3. 收集带effect的fiber node。\r\n### 生成workInProgress fiber tree的fiber node的方式\r\n1. 克隆(浅拷贝)current fiber node，意味着原来的dom节点可以复用，只需要更新dom节点的属性，或者移动dom节点。\r\n2. 新建一个fiber node，意味着需要新增加一个dom节点。\r\n3. 直接复用current fiber node，表示对应的dom节点完全不用做任何处理。\r\n### 直接复用current fiber node的场景\r\n1. 当子组件的渲染方法(类组件的render、函数组件方法)没有触发(比如使用了React.memo)，没有返回新的react element，子节点就可以直接复用current fiber node。\r\n2. 通过合理使用ShouldComponentUpdate、React.memo，阻止不必要的组件重新render，通过直接复用current fiber node，加快workInProgress fiber tree的协调，达到优化的目的。\r\n### 克隆(浅拷贝)或者新建fiber node的场景\r\n1. 只要组件的渲染方法被触发返回新的react element，那么就需要根据新的react element创建fiber node(通过浅拷贝或新建)。\r\n2. 如果能在current fiber tree中找到匹配节点，那么可以通过克隆(浅拷贝)current fiber node的方式来创建新的节点。\r\n3. 如果无法在current fiber tree中找到匹配节点，那么就需要重新创建一个新的节点。\r\n### Diff算法\r\n- Diff算法比较的双方是用于构建workInProgress fiber tree中的fiber node的react element和current fiber tree中的fiber node。\r\n- 比较两者的key和type，根据比较结果来决定如何为workInProgress fiber tree创建fiber node。\r\n### key和type\r\n- key就是jsx模板中元素上的key属性，如果不写默认为undefined。\r\n- jsx模板转化为react element后，元素的key属性会作为react element的key属性。\r\n- react element转化为fiber node以后，react element的key属性也会作为fiber node的key属性。\r\n- jsx中不同的元素类型，有不同的type。jsx模板转化为react element以后，react element的type属性会根据jsx元素的类型赋不同的值，可能是组件函数，也可能是dom标签字符串，还可能是数字。react element转化为fiber node以后，react element的type属性也会作为fiber node的type属性。\r\n```\r\n<Component name="xxxx" />  // type = Component，是一个函数\r\n<div></div>    // type = "div"，是一个字符串\r\n<React.Fragment></React.Fragment>  // type = React.Fragment，是一个数字(react内部定义的)； \r\n```\r\n- 综上，判断拷贝current fiber node的逻辑是：\r\n```\r\nreactElement.key === currentFiberNode.key && reactElement.type === currentFiberNode.type // 可以克隆\r\n\r\nreactElement.key !== currentFiberNode.key // 不可克隆\r\n\r\nreactElement.key === currentFiberNode.key && reactElement.type !== currentFiberNode.type // 不可克隆；\r\n```\r\n### Diff算法流程\r\n- 不跨层级进行比较。\r\n- 通过比较key、type来判断是否需要克隆current fiber node。只有key和type都相等，才克隆current fiber node作为新的节点，否则就需要新建一个节点。key的优先级更高，如果key值不相同，那么节点不可克隆。\r\n- 当比较single react element和current fiber node list时，只需要遍历current fiber node list，比较每个current fiber node和react element的key值和type。只有key和type都相等react element和current fiber node才能匹配。如果有匹配的直接克隆current fiber node，作为react element对应的workInProgress fiber node。如果没有匹配的current fiber node，就需要为react element重新创建一个新的fiber node作为workInProgress fiber node。\r\n- 当比较react element list和current fiber node list时，还需要通过列表下标index判断wokrInProgress fiber node是否相对于克隆的current fiber node发生了移动，这也是Diff中最复杂的地方。\r\n### 为发生变化的fiber node标记effect\r\n> 节点只要是重新创建的而不是克隆自current fiber node，那么节点就百分之百发生了变化需要更新；节点克隆自current fiber node，需要比较props是否发生了变化，如果props发生了变化节点需要更新；节点克隆自current fiber node且是组件类型，还需要比较state是否发生了变化，如果state发生了变化节点需要更新。\r\n\r\n- Placement：只针对dom类型的fiber node，表示节点需要做移动或者添加操作。\r\n- Update：针对所有类型的fiber node，表示fiber node需要做更新操作。\r\n- PlacementAndUpdate：只针对dom类型的fiber node，表示节点发生了移动且props发生了变化。\r\n- Ref：表示节点存在ref，需要初始化/更新ref.current。\r\n- Deletion：针对所有类型的fiber node，表示fiber node需要移除。\r\n- Snapshot：主要是针对类组件fiber node。当类组件fiber node发生了mount或者update操作，且定义了getSnapshotBeforeUpdate方法就会标记Snapshot。\r\n- Passive：主要针对函数组件fiber node，表示函数组件使用了useEffect。当函数组件节点发生mount或者update操作，且使用了useEffect hook就会给fiber node标记Passive。\r\n- Layout：主要针对函数组件fiber node，表示函数组件使用了useLayoutEffect。当函数组件节点发生mount或者update操作，且使用了useLayoutEffect hook就会给fiber node标记Layout。\r\n- 一个fiber node可同时标记多个effect。\r\n### 收集带effect的fiber node\r\n- 如果一个fiber node被标记了effect，那么react就会在这个fiber node完成协调以后，将这个fiber node收集到effectList中。当整颗fiber tree完成协调以后，所有被标记effect的fiber node都被收集到一起。\r\n- 收集fiber node的effectList采用单链表结构存储，firstEffect指向第一个标记effect的fiber node，lastEffect标记最后一个fiber node，节点之间通过nextEffect指针连接。\r\n- 由于fiber tree协调时采用的顺序是深度优先，协调完成的顺序是子节点、子节点兄弟节点、父节点，所以收集带effect标记的fiber node时，顺序也是子节点、子节点兄弟节点、父节点。\r\n### Render\r\n> render也称为commit，是对协调过程中标记的effect的处理，effect的处理分为三个阶段，这三个阶段按照从前到后的顺序如下。不同的阶段处理的effect种类也不相同，在每个阶段react都会从effectList链表的头部firstEffect开始，按序遍历fiber node直到lastEffect。\r\n\r\n1. before mutation阶段(dom操作之前)\r\n2. mutation阶段(dom操作)\r\n3. layout阶段(dom操作之后)\r\n### before mutation阶段\r\n- before mutation阶段的主要工作是处理带Snapshot标记的fiber node。\r\n- 从firstEffect开始遍历effect列表，如果fiber node带Snapshot标记，触发getSnapshotBeforeUpdate方法。\r\n### mutation阶段\r\n- mutation阶段的主要工作是处理带Deletion、Placement、PlacementAndUpdate、Update标记的fiber node。 \r\n- 在这一阶段涉及到dom节点的更新、新增、移动、删除，组件节点删除导致的componentWillUnmount、useEffect的destory方法的触发，以及删除节点引发的ref引用的重置。\r\n- dom节点的更新。\r\n  1. 通过原生的API setAttribute、removeArrribute修改dom节点的attr。\r\n  2. 直接修改dom节点的style。\r\n  3. 直接修改dom节点的innerHtml、textContent。\r\n- dom节点的新增和移动。\r\n  1. 如果新增(移动)的节点是父节点的最后一个子节点，那么可以直接使用appendChild方法。\r\n  2. 如果不是最后一个节点，需要使用insertBefore方法。通过遍历找到第一个没有带Placement标记的节点作为insertBefore的定位元素。\r\n- dom节点的删除。\r\n  1. 如果节点是dom节点，通过removeChild移除。\r\n  2. 如果节点是组件节点，触发componentWillUnmount、useEffect的destory方法的执行。\r\n  3. 如果标记Deletion的节点的子节点中有组件节点，深度优先遍历子节点，依次触发子节点的componentWillUnmount、useEffect的destory方法的执行。\r\n  4. 如果标记Deletion的节点及子节点关联了ref引用，要将ref引用置空，及ref.current = null(也是深度优先遍历)。\r\n### layout阶段\r\n- layout阶段的主要工作是处理带update标记的组件节点和带ref标记的所有节点。\r\n- 如果类组件节点是mount操作触发componentDidMount；如果是update操作触发componentDidUpdate。\r\n- 如果函数组件节点时mount操作，触发useLayoutEffect的callback；如果是update操作，先触发上一次更新生成的useEffect的destory，再触发这一次的callback。\r\n- 异步调度函数组件的useEffect。\r\n- 如果组件节点关联了ref引用，要初始化ref.current;'},function(r,n,e){"use strict";e.r(n),n.default="## copy命令\r\n> copy命令用于将文件或目录复制到Docker镜像中。\r\n\r\n```\r\nCOPY [--chown=<user>:<group>] <源路径> <目标路径>\r\n```\r\n### WORKDIR命令\r\n> WORKDIR命令用于设置工作目录，也是后续的RUN、CMD、ENTRYPOINT、COPY、ADD命令执行时所在的目录。\r\n\r\n### 目标路径使用./\r\n- .表示当前工作目录，/表示根目录，./表示当前工作目录的相对路径。\r\n- 将当前构建上下文中的package.json文件复制到镜像的/home目录，./表示复制到当前工作目录，也就是/home目录。\r\n```\r\nWORKDIR /home\r\nCOPY package.json ./\r\n```\r\n### 相对路基\r\n- ./表示当前所在的目录。\r\n- ../表示上一层目录。\r\n- /表示根目录。"},function(r,n,e){"use strict";e.r(n),n.default="## docker\r\n> Docker是一种容器技术，可以在操作系统上创建多个相互隔离的容器。容器内独立安装软件、运行服务。但是这个容器和宿主机还是有关联的，比如可以把宿主机的端口映射到容器内的端口、宿主机某个目录挂载到容器内的目录。\r\n\r\n### [优化镜像体积](https://mp.weixin.qq.com/s/JnTmB7H-8tJuRWMosnHCKA)\r\n- 使用alpine镜像，而不是默认的linux镜像。\r\n> alpine去掉了很多linux里用不到的功能，使得镜像体积更小。\r\n\r\n```\r\n// Dockerfile\r\n\r\n// before\r\nFROM node:lts\r\nFROM nginx:stable\r\n\r\n// after\r\nFROM node:lts-alpine\r\nFROM nginx:stable-alpine\r\n```\r\n- 多阶段构建\r\n> 源码和依赖是不需要的，但是现在都保存在了镜像里。实际上我们只需要构建出来的build目录下的文件。\r\n\r\n1. FROM后面添加一个as来指定当前构建阶段的名字。\r\n2. 通过COPY --from=xxx 可以从上个阶段复制文件过来。\r\n3. docker build之后，只会留下最后一个阶段的镜像。\r\n4. 最终构建出来的镜像里是没有源码的，有的只是build的文件，这样镜像就会小很多。\r\n```\r\n# build stage\r\nFROM node:lts-alpine as build-stage\r\n\r\nWORKDIR /app\r\n\r\nCOPY package.json ./\r\n\r\nCOPY yarn.lock ./\r\n\r\nRUN yarn\r\n\r\nCOPY . . \r\n\r\nRUN npm run build\r\n\r\n# production stage \r\nFROM nginx:stable-alpine as production-stage\r\n\r\nCOPY --from=build-stage /app/build /home/admin/build/\r\n\r\nCOPY default.conf /etc/nginx/conf.d/default.conf\r\n```\r\n### 优化镜像构建速度\r\n- 充分利用缓存\r\n> docker是分层存储的，dockerfile里的每一行指令是一层，会做缓存。每次docker build的时候，只会从变化的层开始重新构建，没变的层会直接复用。现在这种写法(先复制package.json进去，安装依赖之后再复制其他文件)，如果package.json没变，就不会执行yarn，直接复用之前的。如果一开始就把所有文件复制进去那不管package.json变没变，任何一个文件变了都会重新yarn，这样没法充分利用缓存性能不好。\r\n\r\n```\r\n# build stage\r\nFROM node:lts-alpine as build-stage\r\n\r\nWORKDIR /app\r\n\r\nCOPY package.json ./\r\n\r\nCOPY yarn.lock ./\r\n\r\nRUN yarn\r\n\r\nCOPY . . \r\n\r\nRUN npm run build\r\n\r\n# production stage \r\nFROM nginx:stable-alpine as production-stage\r\n\r\nCOPY --from=build-stage /app/build /home/admin/build/\r\n\r\nCOPY default.conf /etc/nginx/conf.d/default.conf\r\n```\r\n\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## docker常用命令\r\n- docker --version 查看docker版本\r\n### 镜像相关命令\r\n- 构建镜像\r\n  1. -t 设置镜像的名字及标签name:tag，可以为一个镜像名设置多个标签。不设置tag时tag默认为latest。\r\n  2. . 表示当前路径，也可指定其他路径。\r\n```\r\n// 镜像名admin，tag为0.0.1\r\ndocker build -t admin:0.0.1 .\r\n```\r\n- docker images 列出镜像\r\n- docker rmi imageId | imageName:imageTag 删除镜像\r\n- docker rmi imageId | imageName:imageTag --force 强制删除镜像(被容器使用的镜像不可被删除)\r\n### 容器相关命令\r\n- 启动容器\r\n  1. -d 后台运行。\r\n  2. -p 指定映射端口号，前一个端口号为服务监听端口号，后一个为容器内部监听端口号，80:80将宿主服务的80端口映射到容器的80端口。\r\n  3. -v 指定数据卷挂载，/aaa:/bbb/ccc挂载宿主机的/aaa目录到容器的/bbb/ccc目录。容器内读写/bbb/ccc目录的时候改的就是宿主机的/aaa目录，改宿主机/aaa目录，容器内的/bbb/ccc也会改。\r\n  4. --name admin 容器名为admin。\r\n  5. admin:0.0.1 使用镜像名为admin的 0.0.1 tag版本，不指定tag版本默认使用latest版本。\r\n```\r\ndocker run -d -p 80:80 -v /aaa:/bbb/ccc --name admin admin:0.0.1\r\n```\r\n- docker ps 查看正在运行的容器\r\n- docker ps -a 查看所有的容器\r\n- docker start containerId | containerName 启动容器\r\n- docker restart containerId | containerName 重启容器\r\n- docker stop containerId | containerName 停止容器\r\n- docker rm containerId | containerName 删除容器 (运行中的容器不能删除，需先停止容器才删除)\r\n- docker rm -f containerId | containerName 强制删除容器 (运行中的容器能强制删除)\r\n- docker同一容器需要更换镜像，需要先将容器删除，更换镜像之后再开启容器\r\n### 进入容器内部相关命令(容器必须正在运行)\r\n- docker exec -it containerId | containerName ls  查看容器的文件目录\r\n- docker exec -it containerId | containerName sh  进入容器\r\n- exit  进入容器后退出\r\n### 容器内文件复制到服务器操作\r\n> 在docker容器中进行文件的读写，改动并不会同步到服务器的文件，需要将容器的文件复制到服务器。\r\n\r\n```\r\n// docker cp containerId:docker文件路径 服务器文件路径\r\ndocker cp containerId:/app/schedule.json /root/fe \r\n```\r\n### 查看docker部署容器的日志\r\n- docker logs containerId | containerName  查看容器日志\r\n- docker logs -f containerId | containerName  实时跟踪容器日志输出\r\n- docker logs --tail 100 containerId | containerName  查看容器最后100条日志\r\n- docker logs --since 1h containerId | containerName  查看容器最近1小时日志\r\n\r\n\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## docker镜像\r\n> 配置registry-mirrors值，可以配置多个镜像源。\r\n\r\n- DaoCloud：https://docker.m.daocloud.io           \r\n- 阿里云：https://code.mirror.aliyuncs.com (code需要登录阿里云查看)\r\n- 百度云：https://mirror.baidubce.com            \r\n- 南京大学：https://docker.nju.edu.cn              \r\n- 中科院：https://mirror.iscas.ac.cn             \r\n"},function(r,n,e){"use strict";e.r(n),n.default="## FiberNode\r\n### FiberNode包含的三层含义\r\n- 架构层面：v15的Reconciler采用递归的方式执行，被称为Stack Reconciler。v16及以后版本的Reconciler基于FiberNode实现，被称为Fiber Reconciler。\r\n- 静态的数据结构层面：每个FiberNode对应一个React元素，用于保存React元素的类型、对应的DOM元素等信息。\r\n- 动态的工作单元层面：每个FiberNode用于保存本次更新中该React元素变化的数据、要执行的工作(增、删、改、更新Ref、副作用等)。\r\n### FiberNode构造函数\r\n- FiberNode作为一个构造函数，FiberNode中包含很多属性。\r\n```\r\nfunction FiberNode(tag, pendingProps, key, mode) {\r\n  // Instance\r\n  this.tag = tag;\r\n  this.key = key;\r\n  this.elementType = null;\r\n  this.type = null;\r\n  this.stateNode = null; // Fiber\r\n\r\n  this.return = null;\r\n  this.child = null;\r\n  this.sibling = null;\r\n  this.index = 0;\r\n  this.ref = null;\r\n  this.pendingProps = pendingProps;\r\n  this.memoizedProps = null;\r\n  this.updateQueue = null;\r\n  this.memoizedState = null;\r\n  this.dependencies = null;\r\n  this.mode = mode; // Effects\r\n\r\n  this.flags = NoFlags;\r\n  this.subtreeFlags = NoFlags;\r\n  this.deletions = null;\r\n  this.lanes = NoLanes;\r\n  this.childLanes = NoLanes;\r\n  this.alternate = null;\r\n}\r\n```\r\n### 架构层面\r\n- Fiber架构是由多个FiberNode组成的树状结构，FiberNode之间由如下属性连接。\r\n- 指向父FiberNode使用return字段：作为一个工作单元，return指FiberNode执行完completeWork后返回的下一个FiberNode。子FiberNode及其兄弟FiberNode执行完completeWork后会返回父FiberNode，所以return用来指代父FiberNode。\r\n```\r\n// 指向父FiberNode \r\nthis.return = null;\r\n\r\n// 指向第一个子FiberNode \r\nthis.child = null;\r\n\r\n// 指向右边的兄弟FiberNode \r\nthis.sibling = null;\r\n```\r\n### 静态的数据结构层面\r\n> FiberNode中保存了从React元素中获取的信息。\r\n\r\n- stateNode：与Fiber节点相关的组件、DOM节点或其他React元素类型的类实例的引用。\r\n- type：定义Fiber节点与什么元素有关。\r\n- tag：定义了Fiber的类型，在调和算法中根据类型来确定需要做什么工作。\r\n- key：用于定义在一组Fiber节点中的唯一标识。\r\n- updateQueue：状态更新、回调和DOM更新的队列。\r\n- memoizedState：反映current Fiber的state。\r\n- memoizedProps：反映current Fiber的props。\r\n- pendingProps：反映workInProgress Fiber的props。\r\n### 动态的工作单元层面\r\n- FiberNode中保存了更新相关的信息，例如本次更新将在Renderer(Commit阶段)中执行的相关操作数据。\r\n```\r\n// 更新操作相关数据\r\nthis.flags = NoFlags; \r\nthis.subtreeFlags = NoFlags; \r\nthis.deletions = null;\r\n\r\n// 优先级调度相关数据\r\nthis.lanes = NoLanes; \r\nthis.childLanes = NoLanes;\r\n\r\n// Fiber架构的工作原理相关数据\r\nthis.alternate = null;\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## fetch和merge的区别\r\n> git fetch相当于从远程获取最新代码到本地，但是不会自动merge。\r\n\r\n```\r\ngit fetch origin master 将远程的master分支下载到本地\r\ngit merge origin/master 将远程的master分支进行合并\r\n\r\ngit fetch origin master:mastercopy 获取最新远程的master分支并在本地建立mastercopy分支\r\ngit merge mastercopy 将mastercopy分支合并到当前分支\r\n\r\n// 使用pull代替\r\ngit pull origin master\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## git提交规范\r\n- feat：新增功能\r\n- fix：修复bug\r\n- docs：文档变更\r\n- style：代码格式调整(不影响功能，空格、分号等格式修正)\r\n- refactor：代码重构\r\n- perf：改善性能\r\n- test：测试\r\n- build：项目构建或外部依赖变更\r\n- ci：持续集成相关调整\r\n- chore：变更构建流程或辅助工具\r\n- revert：代码回退"},function(r,n,e){"use strict";e.r(n),n.default="## rebase和merge的区别\r\n### merge\r\n- 只处理一次冲突\r\n- 会把两个分支最新的2个commit合并成一个新的commit\r\n- 合并后的所有 commit 会按照提交时间从旧到新排列\r\n### rebase\r\n- 在 dev 分支执行 git reabse master 会将 dev 分支的当前提交复制到master的最新提交之后\r\n- 可能会多次解决同一个地方的冲突\r\n- 不会产生合并的commit\r\n- 合并后的所有 commit 顺序不一定按照 commit 的提交时间排列\r\n### merge VS rebase\r\n> 当从a分支切到b分支的时候在b分支中做了多次提交，而且a分支在切到b分支之后也做了多次提交。\r\n\r\n- 将b分支merge到a分支，a分支的提交记录会按a、b分支的提交顺序记录，且有合并的一次记录。最后的分支树呈现非线性的结构。\r\n- 将b分支rebase到a分支，a分支的提交记录会先记录a分支的提交，再记录b分支的提交，且没有合并的一次记录。会形成一个线性的分支树。"},function(r,n,e){"use strict";e.r(n),n.default='## [css加载](https://mp.weixin.qq.com/s/p2VazJE7MyH645T8NjMrrg)\r\n### CSS加载不会阻塞构造文档对象模型(DOM解析)，但是CSS加载会阻塞生成渲染树(DOM渲染)。 \r\n- 构造文档对象模型和构造CSS对象模型是并行的，这解释了CSS加载不会阻塞构造文档对象模型。\r\n- 由于RenderTree是依赖于DomTree和CssomTree的，所以RenderTree必须等待CssomTree构建完成，也就是CSS资源加载完成(或者CSS资源加载失败)后，才能开始生成渲染树。因此CSS加载会阻塞生成渲染树。\r\n- 这可能也是浏览器的一种优化机制，因为加载css的时候，可能会修改DOM节点的样式，如果css加载不阻塞render树渲染的话，那么当css加载完之后render树可能又得重新重绘或者回流了，这就造成了一些没有必要的损耗。等待html和css都加载完之后，根据最终的样式来渲染render树，这种做法性能方面会比较好一点。\r\n```\r\n// network设置网络速度\r\n\r\n<!DOCTYPE html>\r\n<html lang="en">\r\n  <head>\r\n    <title>css阻塞</title>\r\n    <meta charset="UTF-8" />\r\n    <meta name="viewport" content="width=device-width, initial-scale=1" />\r\n    <style>\r\n      h1 {\r\n        color: red !important;\r\n      }\r\n    </style>\r\n    <script>\r\n      function h() {\r\n        console.log(document.querySelectorAll("h1"));\r\n      }\r\n      setTimeout(h, 0);\r\n    <\/script>\r\n    <link\r\n      href="https://cdn.bootcss.com/bootstrap/4.0.0-alpha.6/css/bootstrap.css"\r\n      rel="stylesheet"\r\n    />\r\n  </head>\r\n  <body>\r\n    <h1>这是红色的</h1>\r\n  </body>\r\n</html>\r\n```\r\n- CSS加载时JS能获取到DOM节点，说明CSS加载不会堵塞DOM的解析。\r\n- 使用Performance可以看到在css加载完成后，DOM渲染才完成，说明CSS加载会堵塞DOM渲染(CSS加载完成前，页面白屏)。\r\n### CSS加载会堵塞后面JS的执行\r\n- 由于js可能会操作之前的DOM节点和CSS样式，为了防止渲染出现不可预期的结果，因此浏览器会维持html中CSS和JS的顺序，CSS会在后面的JS执行前先加载执行完毕。\r\n- 浏览器设置GUI渲染线程与JavaScript引擎为互斥的关系，因此css加载会堵塞后面js的执行。\r\n```\r\n// network设置网络速度\r\n\r\n<!DOCTYPE html>\r\n<html lang="en">\r\n  <head>\r\n    <title>css阻塞</title>\r\n    <meta charset="UTF-8" />\r\n    <meta name="viewport" content="width=device-width, initial-scale=1" />\r\n    <script>\r\n      console.log("before css");\r\n      var startDate = new Date();\r\n    <\/script>\r\n    <link\r\n      href="https://cdn.bootcss.com/bootstrap/4.0.0-alpha.6/css/bootstrap.css"\r\n      rel="stylesheet"\r\n    />\r\n  </head>\r\n  <body>\r\n    <h1>这是红色的</h1>\r\n    <script>\r\n      var endDate = new Date();\r\n      console.log("after css");\r\n      console.log("经过了" + (endDate - startDate) + "ms");\r\n    <\/script>\r\n  </body>\r\n</html>\r\n```\r\n- before css\r\n- after css\r\n- 经过了24174ms\r\n\r\n'},function(r,n,e){"use strict";e.r(n),n.default='## meta\r\n> meta是文档级元数据元素，meta标签一般放在整个html页面的head部分。\r\n\r\n### description\r\n- 一段简短而精确对页面内容的描述。\r\n```\r\n<meta name="description" content="dyxweb个人网站">\r\n```\r\n### keywords\r\n- 与页面内容相关的关键词，使用逗号分隔。\r\n- 某些搜索引擎在遇到这些关键字时，会用这些关键字对文档进行分类。\r\n```\r\n<meta name="keywords" content="dyxweb,个人网站">\r\n```\r\n### viewport\r\n- 用来配置视口大小和缩放等。\r\n- viewport只对移动端浏览器有效，对PC端浏览器是无效的。\r\n```\r\n<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />\r\n```\r\n### author\r\n- 用来表示网页的作者的名字，例如某个组织或者机构。\r\n```\r\n<meta name="author" content="dyxweb">\r\n```\r\n### robots\r\n- 表示爬虫对此页面的处理行为，是用来做搜索引擎抓取的。content值如下。\r\n  1. all：搜索引擎将索引此网页，并继续通过此网页的链接索引搜索其它的网页。\r\n  2. none：搜索引擎将忽略此网页。\r\n  3. index：搜索引擎索引此网页。\r\n  4. follow：搜索引擎继续通过此网页的链接索引搜索其它的网页。\r\n```\r\n<meta name="robots" content="all">\r\n```\r\n### renderer\r\n- 用来指定双核浏览器的渲染方式。\r\n```\r\n<meta name="renderer" content="webkit"> // 默认webkit内核\r\n<meta name="renderer" content="ie-comp"> // 默认IE兼容模式\r\n<meta name="renderer" content="ie-stand"> // 默认IE标准模式\r\n```\r\n'},function(r,n,e){"use strict";e.r(n),n.default='## 修改页签icon\r\n### 正常显示\r\n```\r\n<head>\r\n  <link rel="shortcut icon" href="./logo.png" type="image/x-icon" />\r\n</head>\r\n```\r\n### react中使用react-helmet动态修改页签\r\n```\r\nimport Helmet from "react-helmet";\r\nimport logoImg from \'@/assets/image/logo.png\';\r\n\r\n<Helmet link={[{ rel: \'shortcut icon\', href: logoImg }]} />\r\n```'},function(r,n,e){"use strict";e.r(n),n.default='## 搜索引擎优化\r\n### 使用html的title标签\r\n- title标签对页面点击率有直接影响，因为这是用户对网站页面的第一印象，而且也是爬虫重点的爬取对象。\r\n- 填写的文字要对网页内容有准确而简洁的描述，能够吸引用户点击，而且长度要适中。\r\n```\r\n<head>\r\n  <title>页面标题</title>\r\n</head>\r\n```\r\n### 服务端渲染（SSR）\r\n- 爬虫只会爬取源码，不会执行网站的js脚本，使用了Vue或者React之类的框架后，页面大多数DOM元素都是在客户端根据js动态生成，可供爬虫抓取分析的内容大大减少。\r\n- 浏览器爬虫不会等待我们的数据完成之后再去抓取我们的页面数据。服务端渲染返回给客户端的是已经获取了异步数据并执行js脚本的最终HTML，网络爬中就可以抓取到完整页面的信息。\r\n### meta标签\r\n- keywords是排名的重要组成部分，因为早期的搜索引擎机器人使用该值对网站进行分类，但在后来逐渐被放弃了。\r\n```\r\n<meta name ="keywords" content="这是keywords的内容">\r\n```\r\n- description告诉搜索引擎网站的主要内容\r\n```\r\n<meta name ="description" content="这是description的内容">\r\n```\r\n- robots告诉搜索机器人哪些页面需要索引，哪些页面不需要索引\r\n  1. all：搜索引擎将索引此网页，并继续通过此网页的链接索引搜索其它的网页。\r\n  2. none：搜索引擎将忽略此网页。\r\n  3. index：搜索引擎索引此网页。\r\n  4. follow：搜索引擎继续通过此网页的链接索引搜索其它的网页。\r\n```\r\n<meta name ="robots" content="none">\r\n```\r\n### 语义化标签\r\n- H系列标签，从H1到H6（重要性从高到低）一共有6个，而且在页面中的作用性极高，所以不能乱用。根据内容的重要性进行排列，最好不要有断层，比如从H1直接到H3，错过了H2。H1标签最好只存在一个。\r\n- img标签的alt属性为搜索引擎提供替代文本，图片使用alt标签优化，对搜索引擎排名产生积极影响。\r\n- HTML5新出的Header、Nav、Aside、Article、Footer等语义化标签，这些都能帮助爬虫更好的获取页面内容。\r\n### sitemap(站点地图)\r\n- 站点地图一般是xml格式的文件，放在网站的根目录下。\r\n### robots文件\r\n> 一个给爬虫下指令的文本文件，能让其合理地抓取网站内资源，而且可以将网站不重要的内容、模块等进行屏蔽，从而抓取更多有价值高质量的内容和网页，提高网站排名。\r\n\r\n- User-agent: 后面填要针对的搜索引擎，*代表全部搜索引擎。\r\n- Disallow: 后面填要禁止抓取的网站内容和文件夹，/做前缀。\r\n- Allow: 后面填允许抓取的网站内容，文件夹和链接，/做前缀。\r\n- Crawl-delay: 后面填数字，意思是抓取延迟，小网站不建议使用。\r\n- Sitemap: 站点地图的存放位置。'},function(r,n,e){"use strict";e.r(n),n.default='## 页面可见性\r\n### document.visibilityState\r\n> 只读属性，返回document的可见性。\r\n\r\n- visible：此时页面内容至少是部分可见。即此页面在前景标签页中，并且窗口没有最小化。\r\n- hidden：此时页面对用户不可见。即文档处于背景标签页或者窗口处于最小化状态，或者操作系统正处于锁屏状态。\r\n- prerender：页面此时正在渲染中，因此是不可见的，文档只能从此状态开始，永远不能从其它值变为此状态。\r\n### visibilitychange监听页面可见性变化\r\n```\r\ndocument.addEventListener("visibilitychange", () => {\r\n  if (document.visibilityState === "visible") {\r\n    // 页面变为可见时的操作\r\n  } else {\r\n    // 页面变为不可见时的操作\r\n  }\r\n});\r\n```'},function(r,n,e){"use strict";e.r(n),n.default="## 页面生命周期\r\n### HTML页面的生命周期主要有三个重要事件\r\n- DOMContentLoaded：浏览器已经完全加载了HTML，DOM树已经构建完毕，但是像是`<img>`和样式表等外部资源可能并没有下载完毕。\r\n- load：浏览器已经加载了所有的资源（图像，样式表，js脚本等）。\r\n- beforeunload/unload：当用户离开页面的时候触发。\r\n### 每个事件特定的用途\r\n- DOMContentLoaded：DOM加载完毕，所以JS可以访问所有DOM节点，初始化界面。\r\n- load：附加资源已经加载完毕，可以在此事件触发时获得图像的大小。\r\n- beforeunload/unload：用户正在离开页面，可以询问用户是否保存了更改以及是否确定要离开页面。\r\n### DOMContentLoaded\r\n- DOMContentLoaded由document对象触发，可以使用addEventListener来监听它。\r\n```\r\ndocument.addEventListener(\"DOMContentLoaded\", () => {});\r\n```\r\n- 当浏览器在解析HTML页面时遇到`<script>...<\/script>`标签，将无法继续构建DOM树（UI渲染线程与JS引擎是互斥的，当JS引擎执行时UI线程会被挂起），必须立即下载、执行脚本，所以DOMContentLoaded有可能在所有脚本执行完毕后触发。带async和defer属性的外部JS脚本，JS脚本的下载会异步下载不会影响DOM树的构建。\r\n- 外部样式表并不会阻塞DOM的解析，DOMContentLoaded不会被它们影响。但是如果在样式后面有一个内联脚本，那么脚本必须等待样式先加载完。JS因为有可能会去获取DOM的样式，所以JS会等待样式表加载完毕，而JS是阻塞DOM的解析的，所以在有外部样式表的时候，JS会一直阻塞到外部样式表下载完毕。\r\n```\r\n<link type=\"text/css\" rel=\"stylesheet\" href=\"style.css\">\r\n<script>\r\n  // 脚本直到样式表加载完毕后才会执行。\r\n  alert(getComputedStyle(document.body).marginTop);\r\n<\/script>\r\n```\r\n### load\r\n- window对象上的onload事件可以监听到load事件的触发，onload事件在所有资源包括样式表、图片和其它资源下载完毕后触发。\r\n```\r\nwindow.onload = () => {};\r\n```\r\n### beforeunload/unload\r\n- 用户离开页面的时候，window对象上的unload事件会被触发，可以做一些不存在延迟的事情比如关闭弹出的窗口，但是无法阻止用户转移到另一个页面上。\r\n```\r\nwindow.onunload = () => {};\r\n```\r\n- 用户即将离开页面或者关闭窗口时，beforeunload事件将会被触发，可以在此事件中进行额外的确认。\r\n```\r\nwindow.onbeforeunload = () => {};\r\n```\r\n### readyState\r\n- 可以通过document.readyState获取页面加载的状况\r\n  1. loading：document仍在加载。\r\n  2. interactive：文档已经完成加载已被解析，但是图像、样式表和框架之类的子资源仍在加载。时间上和DOMContentLoaded同时发生，不过顺序在DOMContentLoaded之前。\r\n  3. complete：文档和所有子资源已完成加载，load事件即将被触发。时间上和window.onload同时发生，不过顺序在window.onload之前。\r\n### readystatechange\r\n- 每当文档的加载状态改变的时候就会有readystatechange事件被触发。\r\n```\r\n// current state\r\nconsole.log(document.readyState);\r\n\r\n// print state changes\r\ndocument.addEventListener('readystatechange', () => console.log(document.readyState));\r\n```\r\n### 执行顺序\r\n- document.readyState在DOMContentLoaded前一刻变为interactive，这两个事件可以认为是同时发生。\r\n- document.readyState在所有资源加载完毕后（包括 iframe 和 img）变成complete，complete、 img.onload和window.onload几乎同时发生，区别就是window.onload在所有其他的load事件之后执行。\r\n```\r\n<script>\r\n  console.log('initial readyState:' + document.readyState);\r\n\r\n  document.addEventListener('readystatechange', () => console.log('readyState:' + document.readyState));\r\n  document.addEventListener('DOMContentLoaded', () => console.log('DOMContentLoaded'));\r\n\r\n  window.onload = () => console.log('window onload');\r\n<\/script>\r\n\r\n<iframe src=\"iframe.html\" οnlοad=\"console.log('iframe onload')\"></iframe>\r\n<img src=\"img.png\" id=\"img\">\r\n\r\n<script>\r\n  img.onload = () => console.log('img onload');\r\n<\/script>\r\n```\r\n- initial readyState:loading\r\n- readyState:interactive\r\n- DOMContentLoaded\r\n- iframe onload\r\n- readyState:complete\r\n- img onload\r\n- window onload\r\n\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## Accept 系列字段\r\n### 数据格式\r\n> 类型体现在Content-Type这个字段，这是针对于发送端而言，接收端想要收到特定类型的数据，也可以用Accept字段。\r\n\r\n- text： text/html, text/plain, text/css 等\r\n- image: image/gif, image/jpeg, image/png 等\r\n- audio/video: audio/mpeg, video/mp4 等\r\n- application: application/json, application/javascript, application/pdf, application/octet-stream\r\n### 压缩方式\r\n> 体现在了发送方的Content-Encoding字段上，接收什么样的压缩方式体现在了接受方的Accept-Encoding字段上。\r\n\r\n- gzip: 当今最流行的压缩格式\r\n- deflate: 另外一种著名的压缩格式\r\n- br: 一种专门为 HTTP 发明的压缩算法\r\n### 支持语言\r\n> 发送方Content-Language字段，接受方对应的字段为Accept-Language。\r\n\r\n```\r\n// 发送端\r\nContent-Language: zh-CN, zh, en\r\n// 接收端\r\nAccept-Language: zh-CN, zh, en\r\n```\r\n### 字符集\r\n> 接收端对应为Accept-Charset，指定可以接受的字符集，而在发送端并没有对应的Content-Charset, 而是直接放在了Content-Type中，以charset属性指定。\r\n\r\n```\r\n// 发送端\r\nContent-Type: text/html; charset=utf-8\r\n// 接收端\r\nAccept-Charset: charset=utf-8\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## URI\r\n> 全称为(Uniform Resource Identifier), 统一资源标识符，它的作用就是区分互联网上不同的资源，它并不是我们常说的网址, 网址指的是URL, 实际上URI包含了URN和URL两个部分。\r\n\r\n### 结构\r\n> scheme://  user:passwd@  host:port  path  ?query  #fragment\r\n\r\n- scheme 表示协议名，比如http, https, file等等。后面必须和://连在一起。\r\n- user:passwd@ 表示登录主机时的用户信息，不过很不安全，不推荐使用，也不常用。\r\n- host:port表示主机名和端口。\r\n- path表示请求路径，标记资源所在位置。\r\n- query表示查询参数，为key=val这种形式，多个键值对之间用&隔开。\r\n- fragment表示 URI 所定位的资源内的一个锚点，浏览器可以根据这个锚点跳转到对应的位置。\r\n### 示例\r\n> https://www.baidu.com/s?wd=HTTP&rsv_spt=1。https即scheme部分，www.baidu.com为host:port部分（注意，http 和 https 的默认端口分别为80、443），/s为path部分，而wd=HTTP&rsv_spt=1就是query部分。\r\n\r\n### URI 编码\r\n> URI 只能使用ASCII, ASCII 之外的字符是不支持显示的，而且还有一部分符号是界定符，如果不加以处理就会导致解析出错。因此，URI 引入了编码机制，将所有非 ASCII 码字符和界定符转为十六进制字节值，然后在前面加个%。\r\n\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## dns\r\n> 域名系统。万维网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。\r\n\r\n### DNS解析\r\n> 通过域名，最终得到该域名对应的IP地址的过程叫做域名解析。\r\n\r\n### DNS缓存\r\n> 有dns的地方,就有缓存。浏览器、操作系统、Local DNS、根域名服务器，它们都会对DNS结果做一定程度的缓存。\r\n\r\n1. 首先搜索浏览器自身的DNS缓存,如果存在，则域名解析到此完成。\r\n2. 如果浏览器自身的缓存里面没有找到对应的条目，那么会尝试读取操作系统的hosts文件看是否存在对应的映射关系,如果存在，则域名解析到此完成。\r\n3. 如果本地hosts文件不存在映射关系，则查找本地DNS服务器(ISP服务器,或者自己手动设置的DNS服务器),如果存在,域名到此解析完成。\r\n4. 如果本地DNS服务器还没找到的话,它就会向根服务器发出请求,进行递归查询。"},function(r,n,e){"use strict";e.r(n),n.default="## http协议(超文本传输协议)\r\n> 因特网上应用最为广泛的一种网络传输协议。HTTP是一个应用层协议，由请求和响应构成，是一个标准的客户端服务器模型。HTTP是一个无状态的协议。在HTTP开始工作前，客户端首先会通过TCP/IP协议来和服务端建立链接。\r\n\r\n### 短连接\r\n> 建立连接 - 数据传输 - 关闭连接 ... 建立连接 - 数据传输 - 关闭连接。如果客户请求频繁，将在TCP的建立和关闭操作上浪费较多时间和带宽。\r\n\r\n### 长连接 Connection:keep-alive\r\n> 建立连接 - 数据传输 ...（保持连接）... 数据传输 - 关闭连接。长连接可以省去较多的TCP建立和关闭的操作，减少浪费，节约时间。长链接分为 without pipelining 和 with pipelining。\r\n\r\n- without pipelining\r\n> 客户端只在收到前一个请求的响应后，才发出新的请求。\r\n\r\n- with pipelining\r\n> 每次建立连接后无需等待请求回来就可以发送下一个请求。\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## [http2](https://zhuanlan.zhihu.com/p/26559480)\r\n> HTTP/2 是 HTTP 协议自 1999 年 HTTP 1.1 发布后的首个更新，主要基于 SPDY 协议。HTTP/2必须基于HTTPS使用。\r\n\r\n### 二进制分帧\r\n- 帧：HTTP/2 数据通信的最小单位消息：指 HTTP/2 中逻辑上的 HTTP 消息。例如请求和响应等，消息由一个或多个帧组成。\r\n- 流：存在于连接中的一个虚拟通道。流可以承载双向消息，每个流都有一个唯一的整数ID。\r\n- HTTP/2 采用二进制格式传输数据，而非 HTTP 1.x 的文本格式，二进制协议解析起来更高效。 HTTP / 1 的请求和响应报文，都是由起始行，首部和实体正文（可选）组成，各部分之间以文本换行符分隔。HTTP/2 将请求和响应数据分割为更小的帧，并且它们采用二进制编码。\r\n- HTTP/2 中，同域名下所有通信都在单个连接上完成，该连接可以承载任意数量的双向数据流。每个数据流都以消息的形式发送，而消息又由一个或多个帧组成。多个帧之间可以乱序发送，根据帧首部的流标识可以重新组装。\r\n### 多路复用\r\n> http2.0中，一个tcp/ip请求可以请求多个资源，只要一次tcp/ip请求，就可以请求若干个资源。HTTP 1.x 中，如果想并发多个请求，必须使用多个 TCP 链接，且浏览器还会对单个域名有TCP连接请求限制。\r\n\r\n#### 在 HTTP/2 中，有了二进制分帧之后，HTTP /2 不再依赖 TCP 链接去实现多流并行了。\r\n- 同域名下所有通信都在单个连接上完成。\r\n- 单个连接可以承载任意数量的双向数据流。\r\n- 数据流以消息的形式发送，而消息又由一个或多个帧组成，多个帧之间可以乱序发送，根据帧首部的流标识可以重新组装。\r\n#### 性能提升\r\n- 同个域名只需要占用一个 TCP 连接，消除了因多个 TCP 连接而带来的延时和内存消耗。\r\n- 单个连接上可以并行交错的请求和响应，之间互不干扰。\r\n- 在HTTP/2中，每个请求都可以带一个31bit的优先值，0表示最高优先级， 数值越大优先级越低。有了这个优先值，客户端和服务器就可以在处理不同的流时采取不同的策略，以最优的方式发送流、消息和帧。\r\n### 头部压缩\r\n> HTTP/2对消息头采用HPACK（专为http/2头部设计的压缩格式）进行压缩传输，能够节省消息头占用的网络的流量。HTTP/2下两个请求，请求一发送了所有的头部字段，第二个请求则只需要发送差异数据，这样可以减少冗余数据，降低开销。而HTTP/1.x每次请求，都会携带大量冗余头信息，浪费了很多带宽资源。\r\n\r\n- HTTP/2在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键－值对，对于相同的数据，不再通过每次请求和响应发送。\r\n- 首部表在HTTP/2的连接存续期内始终存在，由客户端和服务器共同渐进地更新。\r\n- 每个新的首部键－值对要么被追加到当前表的末尾，要么替换表中之前的值。\r\n### 服务器推送\r\n- 服务端可以在发送页面HTML时主动推送其它资源，而不用等到浏览器解析到相应位置，发起请求再响应。例如服务端可以主动把JS和CSS文件推送给客户端，而不需要客户端解析HTML时再发送这些请求。\r\n- 服务端可以主动推送，客户端也有权利选择是否接收。如果服务端推送的资源已经被浏览器缓存过，浏览器可以通过发送RST_STREAM帧来拒收。主动推送也遵守同源策略，服务器不会随便推送第三方资源给客户端。\r\n### 请求优先级\r\n> 如果流被赋予了优先级，它就会基于这个优先级来处理，由服务器决定需要多少资源来处理该请求。\r\n\r\n### 去除某些针对HTTP/1.x的优化\r\n#### 域名分片（domain sharding）\r\n> HTTP/1.x中，通信两端最多只有六个连接，且是通过区分不同域名来维持管理的。为了突破这个限制，通常会把请求资源至于不同的域名下（如 shard1.example.org, shard2.example.org）。而在HTTP/2中，因为不需要新开连接来解决头阻塞问题，所以不需要通过这种方式来增加通信的连接数。相反的在HTTP/2中采用域名分片会造成以下两个问题\r\n\r\n- 增加DNS域名解析时间\r\n- 增加传输中压缩头部的大小。头部压缩中的数据复用是在一个连接上维持的，域名分片后新开的连接无法复用之前已经发送过的头部数据，造成一些不必要地数据在网络上的传输。\r\n#### 雪碧图\r\n> HTTP/1.x中，为了减少请求多个图片带来的头阻塞问题，通常采用把多个图片拼接成一个大图，然后一个请求将所有图片加载在浏览器中，然后使用CSS技术将所需要的部分按需展示出来。雪碧图会带来如下问题：\r\n\r\n- 增加代码量，需要写一些本不必要地CSS代码\r\n- 在浏览器渲染过程中，内存中需要加载更多的图片内容\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## [https](https://mp.weixin.qq.com/s/I5yezHTrObblrBGAoAEGkQ)\r\n> HTTP是明文传输，因此在传输过程中数据都有可能被第三方窃取或者篡改，也就是我们常说的中间人攻击。为了防范攻击，引入新的加密方案，即 HTTPS。HTTPS就是使用SSL/TLS协议进行加密传输。\r\n\r\n### 为什么需要加密\r\n> 因为http的内容是明文传输的，明文数据会经过中间代理服务器、路由器、wifi热点、通信服务运营商等多个物理节点，如果信息在传输过程中被劫持，传输的内容就完全暴露了。劫持者还可以篡改传输的信息且不被双方察觉，这就是中间人攻击。所以我们才需要对信息进行加密。\r\n\r\n### 对称加密\r\n> 一个密钥，它可以加密一段信息，也可以对加密后的信息进行解密。\r\n\r\n**对称加密不可行**\r\n> 通信双方都各自持有同一个密钥，且没有别人知道，这两方的通信安全当然是可以被保证的。然而最大的问题就是这个密钥怎么让传输的双方知晓，同时不被别人知道。如果由服务器生成一个密钥并传输给浏览器，那在这个传输过程中密钥被别人劫持了，之后他就能用密钥解开双方传输的任何内容了，所以对称加密不可行。\r\n\r\n### 非对称加密\r\n> 有两把密钥，通常一把叫做公钥、一把叫私钥，用公钥加密的内容必须用私钥才能解开，私钥加密的内容只有公钥能解开。\r\n\r\n**非对称加密不可行**\r\n> 服务器先把公钥以明文方式传输给浏览器，之后浏览器向服务器传数据前都先用这个公钥加密好再传，这条数据的安全似乎可以保障了，因为只有服务器有相应的私钥能解开公钥加密的数据。然而反过来由服务器到浏览器的这条路无法保证安全，如果服务器用它的私钥加密数据传给浏览器，那么浏览器用公钥可以解密它，而这个公钥是一开始通过明文传输给浏览器的，若这个公钥被中间人劫持到了，那他也能用该公钥解密服务器传来的信息了。\r\n\r\n**改良的非对称加密**\r\n> 通过一组公钥私钥，可以保证单个方向传输的安全性，可以尝试使用两组公钥私钥保证双向的数据传输安全。抛开此种方法仍有的漏洞（传递公钥的过程被中间人窃取公钥，详见下述的非对称和对称加密不可以行），HTTPS的加密依然没使用这种方案的原因是非对称加密算法非常耗时，而对称加密快很多。\r\n\r\n- 某网站服务器拥有公钥A与对应的私钥A’；浏览器拥有公钥B与对应的私钥B’。\r\n- 浏览器把公钥B明文传输给服务器。\r\n- 服务器把公钥A明文给传输浏览器。\r\n- 之后浏览器向服务器传输的内容都用公钥A加密，服务器收到后用私钥A’解密。由于只有服务器拥有私钥A’，所以能保证这条数据的安全。\r\n- 同理，服务器向浏览器传输的内容都用公钥B加密，浏览器收到后用私钥B’解密。同上也可以保证这条数据的安全。\r\n### 非对称加密+对称加密\r\n- 某网站拥有用于非对称加密的公钥A、私钥A’。\r\n- 浏览器向网站服务器请求，服务器把公钥A明文给传输浏览器。\r\n- 浏览器随机生成一个用于对称加密的密钥X，用公钥A加密后传给服务器。\r\n- 服务器拿到后用私钥A’解密得到密钥X。\r\n- 这样双方就都拥有对称密钥X了，且别人无法知道它。之后双方所有数据都通过密钥X加密解密即可。\r\n### 非对称加密+对称加密不可行\r\n> 如果在数据传输过程中，中间人劫持到了数据，此时他的确无法得到浏览器生成的密钥X，这个密钥本身被公钥A加密了，只有服务器才有私钥A’解开它。但是如果中间人劫持了公钥此时后续的流程都将被中间人窃取到。非对称加密+对称加密不可行的根本原因是浏览器无法确认收到的公钥是不是网站自己的，因为公钥本身是明文传输的。\r\n\r\n- 某网站有用于非对称加密的公钥A、私钥A’。\r\n- 浏览器向网站服务器请求，服务器把公钥A明文给传输浏览器。\r\n- 中间人劫持到公钥A，保存下来，把数据包中的公钥A替换成自己伪造的公钥B（它当然也拥有公钥B对应的私钥B’）。\r\n- 浏览器生成一个用于对称加密的密钥X，用公钥B（浏览器无法得知公钥被替换了）加密后传给服务器。\r\n- 中间人劫持后用私钥B’解密得到密钥X，再用公钥A加密后传给服务器。\r\n- 服务器拿到后用私钥A’解密得到密钥X。此时对称秘钥X已被中间人窃取，后续所有的通信都有可能被中间人窃取到。\r\n### 如何证明浏览器收到的公钥一定是该网站的公钥\r\n> CA机构，它是如今互联网世界正常运作的前提，而CA机构颁发的“身份证”就是数字证书，数字证书可以证明网站信息就是该网站的。\r\n\r\n**数字证书**\r\n> 网站在使用HTTPS前，需要向CA机构申领一份数字证书，数字证书里含有证书持有者信息、公钥信息等。服务器把证书传输给浏览器，浏览器从证书里获取公钥就行了，证书就如身份证，证明“该公钥对应该网站”。\r\n\r\n**验证数字证书的真实性以及如何防止数字证书传递过程中被篡改**\r\n> 把证书原本的信息生成一份“签名”，比对证书内容和签名是否一致就能判别是否被篡改。这就是数字证书的“防伪技术”，这里的“签名”被称为数字签名。原有的证书信息和签名信息共同组成了数字证书。\r\n\r\n**数字签名的生成**\r\n1. CA机构拥有非对称加密的私钥和公钥。\r\n2. CA机构对证书明文数据进行hash加密(不可逆)。\r\n3. 对hash加密后的值用私钥加密，得到数字签名。\r\n**浏览器验证数字签名**\r\n1. 拿到证书，得到明文数据和数字签名。\r\n2. 用CA机构的公钥对数字签名解密（由于是浏览器信任的机构，所以浏览器保有它的公钥）。\r\n3. 用证书里指明的hash加密算法对明文数据进行hash加密。\r\n4. 比较第二步和第三步数据的一致性，如果一致则说明证书可信。\r\n**中间人是否可以篡改数字证书信息**\r\n> 假设中间人篡改了证书的原文，由于他没有CA机构的私钥，所以无法得到此时加密后签名，无法相应地篡改签名。浏览器收到该证书后会发现原文和签名解密后的值不一致，则说明证书已被篡改，证书不可信。\r\n\r\n**中间人是否可以掉包整个证书**\r\n> 假设有另一个网站B也拿到了CA机构认证的证书，它想劫持网站A的信息。于是它成为中间人拦截到了A传给浏览器的证书，然后替换成自己的证书。替换证书之后浏览器很容易就发现证书被替换了，因为证书里包含了网站A的信息，包括域名，浏览器把证书里的域名与自己请求的域名比对一下就知道有没有被掉包了。\r\n\r\n**为什么制作数字签名时需要hash一次**\r\n- 性能问题，非对称加密效率较差，证书信息一般较长，比较耗时。而hash后得到的是固定长度的信息（比如用md5算法hash后可以得到固定的128位的值），这样加解密就快很多。\r\n- [安全问题](crypto.stackexchange.com/a/12780)\r\n**浏览器保有的CA机构的公钥可信性**\r\n> 操作系统、浏览器本身会预装一些它们信任的根证书，如果其中会有CA机构的根证书，这样就可以拿到它对应的可信公钥了。实际上证书之间的认证也可以不止一层，可以A信任B，B信任C，以此类推，我们把它叫做信任链或数字证书链。也就是一连串的数字证书，由根证书为起点，透过层层信任，使终端实体证书的持有者可以获得转授的信任，以证明身份。\r\n\r\n**每次进行HTTPS请求时都必须在SSL/TLS层进行握手传输密钥吗**\r\n> 不用，服务器会为每个浏览器（或客户端软件）维护一个session ID，在TLS握手阶段传给浏览器，浏览器生成好密钥传给服务器后，服务器会把该密钥存到相应的session ID下，之后浏览器每次请求都会携带session ID，服务器会根据session ID找到相应的密钥并进行解密加密操作，这样就不必要每次重新制作、传输密钥了。\r\n\r\n### https加密完整过程\r\n1. 客户端发起一个HTTPS请求，连接443端口。这个过程可以理解成是「请求公钥的过程」。\r\n2. 服务器收到请求后，会把数字证书（证书信息和签名信息(将证书信息hash加密之后使用CA机构私钥加密)）发送给客户端。\r\n3. 浏览器拿到证书之后会得到证书信息和签名信息，用CA机构的公钥对数字签名解密，然后使用相同的hash加密证书信息，对比公钥解密和hash加密后的信息是否一致，一致则说明证书有效。\r\n4. 在从数字证书中安全拿到「服务器公钥」后，客户端随机生成一个「对称密钥」，使用「服务器公钥」加密这个「对称密钥」，发送给服务器。\r\n5. 服务器通过自己的私钥(数字证书信息中公钥对应的私钥)解密，至此得到了「对称密钥」，此时两者都拥有了相同的「对称密钥」。\r\n6. 之后客户端和服务器之间的通信都通过此对称秘钥进行加解密。\r\n### http和https的区别\r\n> 对数据进行加密，并建立一个信息安全通道，来保证传输过程中的数据安全，对网站服务器进行真实身份认证。\r\n\r\n1. HTTP 明文传输，数据都是未加密的，安全性较差，HTTPS（SSL/TLS+HTTP） 数据传输过程是加密的，安全性较好。\r\n2. 使用 HTTPS 协议需要到 CA（Certificate Authority，数字证书认证机构） 申请证书，一般免费证书较少，因而需要一定费用。\r\n3. HTTP 页面响应速度比 HTTPS 快，主要是因为 HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，而 HTTPS除了 TCP 的三个包，还要加上 ssl 握手需要的 9 个包，所以一共是 12 个包。\r\n4. http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。\r\n5. HTTPS 其实就是建构在 SSL/TLS 之上的 HTTP 协议，HTTPS 比 HTTP 要更耗费服务器资源。\r\n### https访问http资源会被浏览器block，http请求https资源没问题。"},function(r,n,e){"use strict";e.r(n),n.default="## http代理\r\n> HTTP 是基于请求-响应模型的协议，一般由客户端发请求，服务器来进行响应。也有特殊情况，就是代理服务器的情况。引入代理之后，作为代理的服务器相当于一个中间人的角色，对于客户端而言，表现为服务器进行响应；而对于源服务器，表现为客户端发起请求，具有双重身份。\r\n\r\n### 功能\r\n1. 负载均衡，客户端的请求会先到达代理服务器，后面到底有多少源服务器，IP 都是多少，客户端是不知道的。这个代理服务器可以拿到这个请求之后，可以通过特定的算法分发给不同的源服务器，让各台源服务器的负载尽量平均。这样的算法有很多，包括随机算法、轮询、一致性hash、LRU(最近最少使用)等等。\r\n2. 保障安全，利用心跳机制监控后台的服务器，一旦发现故障机就将其踢出集群。并且对于上下行的数据进行过滤，对非法 IP 限流，这些都是代理服务器的工作。\r\n3. 缓存代理，将内容缓存到代理服务器，使得客户端可以直接从代理服务器获得而不用到源服务器那里。\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## http状态码\r\n> HTTP 的状态码为三位数。\r\n\r\n- 1xx: 表示目前是协议处理的中间状态，还需要后续操作。\r\n- 2xx: 表示成功状态。\r\n- 3xx: 重定向状态，资源位置发生变动，需要重新请求。\r\n- 4xx: 请求报文有误。\r\n- 5xx: 服务器端发生错误。\r\n### 1xx\r\n- 101 Switching Protocols。在HTTP升级为WebSocket的时候，如果服务器同意变更，就会发送状态码 101。\r\n### 2xx\r\n- 200 OK：请求成功。\r\n- 204 No Content含义与 200 相同，但响应后没有 body 数据。\r\n- 206 Partial Content顾名思义，表示部分内容，它的使用场景为 HTTP 分块下载和断点续传，当然也会带上相应的响应头字段Content-Range。\r\n### 3xx\r\n- 301 Moved Permanently即永久重定向。比如你的网站从 HTTP 升级到了 HTTPS 了，以前的站点再也不用了，应当返回301，这个时候浏览器默认会做缓存优化，在第二次访问的时候自动访问重定向的那个地址。\r\n- 302 Found，即临时重定向。如果只是暂时不可用，那么直接返回302即可，和301不同的是，浏览器并不会做缓存优化。\r\n- 304 Not Modified  当协商缓存命中时会返回这个状态码。\r\n### 4xx\r\n- 400 Bad Request：错误请求，客户端发送的请求有错误，服务器无法理解。\r\n- 401 Unauthorized：未授权，未登录，表示请求需要用户认证，但用户未提供有效的身份验证信息。\r\n- 403 Forbidden：已登录，无权限，表示服务器理解请求但拒绝执行。与401不同的是403表示服务器知道用户是谁，但是不允许访问所请求的资源。\r\n- 404 Not Found：错误请求，未找到资源。\r\n- 405 Method Not Allowed：请求的方法不允许。\r\n- 406 Not Acceptable: 资源无法满足客户端的条件。\r\n- 408 Request Timeout：请求超时，表示服务器等待客户端发送的请求时间过长。\r\n- 409 Conflict: 多个请求发生了冲突。\r\n- 413 Request Entity Too Large: get请求体的数据过大。\r\n- 414 Request-URI Too Long: 请求行里的 URI 太大。\r\n- 429 Too Many Request: 客户端发送的请求过多。\r\n- 431 Request Header Fields Too Large请求头的字段内容太大。\r\n### 5xx\r\n- 500 Internal Server Error：服务端报错，表示服务器在处理请求时发生了意外的错误。\r\n- 501 Not Implemented：网络未实现，表示服务器不支持实现请求所需的功能。当服务器无法识别请求的方法，或者没有为该方法实现任何功能时，服务器就会返回501状态码。\r\n- 502 Bad Gateway: 服务器自身是正常的，但访问的时候出错了，具体什么错无法知道。\r\n- 502 Bad Gateway：网关错误。\r\n- 503 Service Unavailable：服务不可以使用，该状态码表示服务器暂时处于超载或正在停机维护，无法处理请求。\r\n- 504 Gateway Timeout：网关超时。\r\n- 505 HTTP Version Not Supported：HTTP协议版本不支持。\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## http 请求\r\n### 请求方法\r\n> http/1.1规定了以下请求方法(都是大写)\r\n\r\n1. GET: 通常用来获取资源\r\n2. HEAD: 获取资源的元信息\r\n3. POST: 提交数据，即上传数据\r\n4. PUT: 修改数据\r\n5. DELETE: 删除资源(几乎用不到)\r\n6. CONNECT: 建立连接隧道，用于代理服务器\r\n7. OPTIONS: 列出可对资源实行的请求方法，用来跨域请求\r\n8. TRACE: 追踪请求-响应的传输路径。\r\n### GET和POST的区别\r\n- 从缓存的角度，GET 请求会被浏览器主动缓存下来，留下历史记录，而 POST 默认不会。get请求类似于查找的过程，用户获取数据，可以不用每次都与数据库连接，所以可以使用缓存。post做的一般是修改和删除的工作，所以必须与数据库交互，所以不能使用缓存。因此get请求适合于请求缓存。\r\n- 从编码的角度，GET 只能进行 URL 编码，只能接收 ASCII 字符，而 POST 没有限制。\r\n- 从参数的角度，GET 一般放在 URL 中，因此不安全，POST 放在请求体中，更适合传输敏感信息。GET请求提交的数据有长度限制（HTTP 协议本身没有限制 URL 及正文长度，对 URL 的限制大多是浏览器和服务器的原因），POST请求没有内容长度限制。\r\n- 从幂等性的角度，GET是幂等的，而POST不是。(幂等表示执行相同的操作，结果也是相同的)\r\n- 从TCP的角度，GET 请求会把请求报文一次性发出去，而 POST 会分为两个 TCP 数据包，首先发 header 部分，如果服务器响应 100(continue)， 然后发 body 部分。(火狐浏览器除外，它的 POST 请求只发一个 TCP 包)\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## 三次握手\r\n1. 首先客户端会发送SYN报文跟服务端进行连接，并且会携带一个seq序列号(随机生成的)，客户端下次发送数据的序列号会进行+1处理。\r\n2. 服务端收到客户端连接请求报文之后，服务端会携带ACK确认号表示之前的SYN收到了，并且会携带一个对应服务端的seq序列号，还会有一个小写的ack(客户端的seq + 1)向客户端发送报文。\r\n3. 客户端收到服务端的响应报文之后，客户端会携带ACK确认号表示之前的SYN收到了，并且还会携带seq(这里的seq会通过算法计算出来是否跟服务端的ack值相等)和一个新的ack(服务端的seq值+1)向服务端发送报文。\r\n![三次握手](./img/三次握手.png)\r\n### 为什么需要三次，两次不行\r\n- 需要三次握手才能确认双方的接收与发送能力是否正常。\r\n- 第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。\r\n- 第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。\r\n- 第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。"},function(r,n,e){"use strict";e.r(n),n.default="## 四次挥手\r\n- 断开连接服务端和客户端都可以主动发起。\r\n> 建立一个连接需要三次握手，而终止一个连接要经过四次挥手（也有将四次挥手叫做四次握手的）。这由TCP的半关闭（half-close）造成的。所谓的半关闭，其实就是TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。客户端或服务器均可主动发起挥手动作。\r\n\r\n### 以客户端发起断开为例\r\n1. 客户端先发送FIN包生成客户端的seq序列号随后进入wait1状态，这是第一次挥手。\r\n2. 服务端收到FIN包表示自己进入了关闭等待状态，然后向客户端使用ack验证，验证成功打上ACK标记，随后生成服务端的seq值发送给客户端，这是第二次挥手，服务端此时还可以发送未完成的数据。\r\n3. 等待服务端所有任务操作完成之后服务端开始进入最后确认状态，向客户端发送FIN包，并且验证ack，使用客户端第一次的seq + 1去验证，验证成功打上ACK标记，并且生成一个新的序列号seq发送给客户端，这是第三次挥手。\r\n4. 客户端收到之后进入超时等待状态2MSL(1-4分钟)，经过等待后客户端向服务端发送ACK包后关闭连接，而服务端收到信息验证完成ack成功之后打上ACk标记随后将关闭连接。\r\n\r\n\r\n#### 为什么需要四次\r\n> TCP连接时是同步的，但结束时是不同步的，当主动关闭方不会再主动发送数据，但仍然可以接收数据，此时处于半关闭状态。这样被动关闭方有足够的时间去处理以前没有处理完的数据，它可能还有一部分数据没发送出去需要处理，在此之后提出主动关闭连接。所以4次挥手的设计为连接双方都提供了一定的处理扫尾工作的时间，从而显的是必要的。\r\n\r\n1. 当客户端发出FIN报文段时，只是表示客户端已经没有数据要发送了，客户端告诉服务端它的数据已经全部发送完毕了；但是这个时候客户端还是可以接受来服务端的数据；\r\n2. 当服务端返回ACK报文段时，表示它已经知道客户端没有数据发送了，但是服务端还是可以发送数据到客户端的；\r\n3. 当服务端也发送了FIN报文段时，这个时候就表示服务端也没有数据要发送了，就会告诉客户端我也没有数据要发送了。\r\n4. 客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，之后彼此就会愉快的中断这次TCP连接。"},function(r,n,e){"use strict";e.r(n),n.default="## content-type\r\n> content-type可以位于请求头、响应头。http1.0版规定头信息必须是ASCII码类型，后面的实体数据可以是任何格式。因此服务器回应的时候必须告诉客户端数据是什么格式，这就是Content-Type字段的作用。同样在请求时通过它可以告诉服务器post请求体属于哪种格式。\r\n\r\n- Request头：请求的与实体对应的MIME信息(post请求时的请求体)。\r\n- Response头：返回内容的MIME类型。\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## 定长不定长的数据处理\r\n### 定长数据\r\n> 对于定长包体而言，发送端在传输的时候会带上 Content-Length, 来指明包体的长度。\r\n\r\n- 设置长度小时，响应体会直接按照设置的长度被截去\r\n- 设置长度大时，会直接终止连接，传输失败\r\n### 不定长数据\r\n> 设置 Transfer-Encoding: chunked 字段。\r\n\r\n- Content-Length 字段会被忽略\r\n- 基于长连接持续推送动态内容"},function(r,n,e){"use strict";e.r(n),n.default="## 队头阻塞\r\n> HTTP 传输是基于请求-应答的模式进行的，报文必须是一发一收，但值得注意的是，里面的任务被放在一个任务队列中串行执行，一旦队首的请求处理太慢，就会阻塞后面请求的处理。\r\n\r\n### 并发连接\r\n> 对于一个域名允许分配多个长连接，那么相当于增加了任务队列，不至于一个队伍的任务阻塞其它所有任务。在RFC2616规定过客户端最多并发 2 个连接，事实上在现在的浏览器标准中比较多，Chrome 中是 6 个。\r\n\r\n### 域名分片\r\n> 一个域名可以并发 6 个长连接，可以多分几个域名。这样一个域名下可以分出非常多的二级域名，而它们都指向同样的一台服务器，能够并发的长连接数更多了，事实上也更好地解决了队头阻塞的问题。\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## http缓存\r\n> 浏览器当第一个请求资源完成后，根据相应的缓存机制将一些静态资源存储在本地磁盘当中，这样下次请求资源的时候浏览器直接从本地缓存中读取文件，不需要再次发送请求。HTTP缓存主要是针对html,css,js,img等静态资源，常规情况下不会去缓存一些动态资源，因为缓存动态资源的话，数据的实时性就会不太好，所以一般都只会去缓存一些不太容易被改变的静态资源。\r\n\r\n- 强缓存\r\n- 协商缓存\r\n- 启发式缓存(浏览器自带的隐式缓存)\r\n### 缓存的优点\r\n- 减少向服务器请求的的次数，减少服务器的压力，节省带宽。\r\n- 获取资源的时间更短，页面加载速度更快，增加用户体验。\r\n### 查看请求资源的缓存策略\r\n- Size栏：disk cache表示使用磁盘缓存，memory cache表示使用内存缓存。\r\n- Cache-Control栏：查看缓存策略，默认是没有Cache-Control这一栏的，需要手动勾选上。\r\n### 检查缓存过程\r\n1. 浏览器在加载资源时，先判断它是否命中强缓存，强缓存如果命中浏览器直接从自己的缓存中读取资源，不会发请求到服务器。\r\n2. 当强缓存没有命中的时候，浏览器一定会发送一个请求到服务器，通过服务器端依据资源的另外一些http header验证这个资源是否命中协商缓存，如果协商缓存命中，服务器会将这个请求返回，但是不会返回这个资源的数据，而是告诉客户端可以直接从缓存中加载这个资源，于是浏览器就又会从自己的缓存中去加载这个资源。\r\n3. 当协商缓存也没有命中的时候，\r\n直接从服务器加载资源数据。"},function(r,n,e){"use strict";e.r(n),n.default="## 协商缓存\r\n- 当浏览器对某个资源的请求没有命中强缓存，就会发一个请求到服务器，验证协商缓存是否命中，如果协商缓存命中，请求响应返回的http状态为304并且会显示一个Not Modified的字符串。\r\n- 协商缓存是利用的是【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】这两对header来管理的。协商缓存跟强缓存不一样，强缓存不发请求到服务器，所以有时候资源更新了浏览器还不知道，但是协商缓存会发请求到服务器，资源是否更新服务器肯定知道，所以浏览器会请求到更新后的资源。\r\n- 这两个header可以只启用一个也可以同时启用，同时存在时ETag优先级高于Last-Modified。ETag并不是last-modified的完全替代方案，而是last-modified的补充方案。项目中到底是用ETag还是last-modified完全取决于业务场景更合适使用哪个。\r\n### 【Last-Modified，If-Modified-Since】\r\n> 如果服务器上资源有变化，但是最后修改时间却没有变化时就会影响协商缓存的可靠性。Last-Modified能够感知的单位时间是秒，如果文件在1秒内改变了多次，那么这时候的Last-Modified并没有体现出修改了。性能上Last-Modified优于ETag。\r\n\r\n1. 浏览器第一次请求某一资源，如果response的header加上了Last-Modified字段，这个字段表示这个资源在服务器上的最后修改时间。\r\n2. 再次请求此资源时，在request的header上加上If-Modified-Since字段，这个字段的值就是上一次请求时返回的Last-Modified的值。\r\n3. 服务器再次收到资源请求时，根据浏览器传过来If-Modified-Since和资源在服务器上的最后修改时间判断资源是否有变化，如果没有变化则返回304 Not Modified，但是不会返回资源内容，response header中不会再添加Last-Modified的header，因为资源没有变化，Last-Modified不会改变；如果有变化，就正常返回资源内容。\r\n4. 浏览器收到304的响应后，就会从缓存中加载资源。\r\n5. 如果协商缓存没有命中，浏览器直接从服务器加载资源时，Last-Modified Header在重新加载资源的时候会被更新，下次请求时If-Modified-Since会使用上次返回的Last-Modified值。\r\n### 【ETag、If-None-Match】\r\n> ETag就是比较文件指纹(根据文件内容计算出的唯一哈希值)，文件内容一旦改变则ETag会改变。ETag需要计算文件指纹意味着服务端需要更多的计算开销。\r\n\r\n1. 浏览器第一次请求某一资源，如果response的header加上ETag字段，这个header是服务器根据当前请求的资源生成的一个唯一标识，这个唯一标识是一个字符串，只要资源有变化这个字符串就不同，跟最后修改时间没有关系。\r\n2. 再次请求此资源时，在request的header上加上If-None-Match字段，这个字段的值就是上一次请求时返回的ETag的值。\r\n3. 服务器再次收到资源请求时，根据浏览器传过来If-None-Match的值然后再根据资源生成一个新的ETag，如果这两个值相同就说明资源没有变化，否则就是有变化；如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化就正常返回资源内容。与Last-Modified不一样的是当服务器返回304 Not Modified的响应时，由于ETag重新生成过，response header中还会把这个ETag返回，即使这个ETag跟之前的没有变化。\r\n4. 浏览器收到304的响应后，就会从缓存中加载资源。\r\n5. 如果协商缓存没有命中，浏览器直接从服务器加载资源时，ETag Header在重新加载资源的时候会被更新，下次请求时If-None-Match会使用上次返回的ETag值。\r\n### 协商缓存使用注意事项\r\n- 分布式系统里多台机器间文件的Last-Modified必须保持一致，以免负载均衡到不同机器导致比对失败。\r\n- 分布式系统尽量关闭掉ETag(每台机器生成的ETag都会不一样)。\r\n### 强缓存和协商缓存的区别\r\n- 强缓存与协商缓存的共同点是如果命中都是从客户端缓存中加载资源，而不是从服务器加载资源。区别是强缓存不发请求到服务器，协商缓存会发请求到服务器。\r\n- 强缓存不能缓存直接通过地址栏访问的文件(跟强制刷新一样会在请求头中添加Cache-Control: no-cache)，协商缓存可以缓存直接通过地址栏访问的文件。"},function(r,n,e){"use strict";e.r(n),n.default="## 启发式缓存\r\n- 缓存的默认行为，对于没有Cache-Control的响应不是简单的“不缓存”，而是根据所谓的“启发式缓存”进行隐式缓存。\r\n- HTTP旨在尽可能多的缓存，因此即使没有给出Cache-Control，如果满足某些条件，响应也会被存储和重用。\r\n- 启发式缓存是在Cache-Control被广泛采用之前出现的一种解决方法，基本上所有响应都应明确指定Cache-Control响应头。\r\n- 如果不指明Cache-Control字段会导致不必要的缓存，或是无谓的流量消耗，也会出现获取不到最新内容的情况(没有设置协商缓存，文件名也没有hash)。\r\n### 缓存时间\r\n- 公式为：(Date - Last-Modified) * 0.1；Date：当前请求的时间；Last-Modified：服务器中资源最后被修改的时间。\r\n- 如果浏览器判断文件在很长一段时间没有更新，浏览器会存储此响应(尽管缺少max-age)并重用它一段时间。复用多长时间取决于实现，但规范建议存储大约10%的时间(文件没有更新的时间)。如果十天没有更新的资源，会缓存一天的时间，在这段时间内浏览器请求走的都是本地缓存，超出这个时间则向服务器请求资源。\r\n### 启发式缓存和强缓存的区别\r\n- 启发式缓存的缓存时间是不可控的，根据用户请求的Date和Last-Modified决定缓存的时间。\r\n- 强缓存是只要在设置的时间范围内，缓存一直都生效。\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## 强缓存\r\n- 强缓存是利用Expires或者Cache-Control这两个响应头实现的，它们都用来表示资源在客户端缓存的有效期。\r\n- 这两个响应头可以只启用一个，也可以同时启用，同时存在时Cache-Control优先级高于Expires。Cache-Control是Expires的完全替代方案，能用Cache-Control就不要用Expires。\r\n### Expires\r\n> Expires是HTTP 1.0提出的一个表示资源过期时间的响应头，它描述的是一个绝对时间，由服务器返回。由于是一个绝对时间当客户端的时间被修改后或者客户端时间不准时就会影响缓存命中的结果。\r\n\r\n1. 浏览器第一次请求某一资源，如果response的header加上了Expires的header，浏览器会将资源和header都缓存下来。\r\n2. 再次请求此资源时，找到此资源后，用Expires的时间和当前时间对比，没有过期则使用缓存的资源，如果过期重新请求资源后会更新Expires。\r\n### Cache-Control\r\n> 在配置缓存的时候以秒为单位用数值表示，如：Cache-Control: max-age=24000000000。Cache-Control描述的是一个相对时间，在进行缓存命中的时候，都是利用客户端时间进行判断，所以相比较Expires，Cache-Control的缓存管理更准确一些。\r\n\r\n1. 浏览器第一次请求某一资源，如果response的header加上Cache-Control的header，浏览器会将资源和header都缓存下来。\r\n2. 再次请求此资源时，找到此资源后，根据它**第一次**的请求时间和Cache-Control设定的有效期，计算出一个资源过期时间，过期时间和当前时间对比没有过期则使用缓存的资源，如果过期重新请求资源后会更新Cache-Control。\r\n### Cache-Control的参数\r\n- max-age: 决定客户端资源被缓存多久，在多少秒内有效，是一个相对时间比Expires的绝对时间就更精确了。\r\n- s-maxage: 决定代理服务器缓存的时长，并只对public缓存有效。\r\n- no-cache：表示是强制进行协商缓存。\r\n- no-store：表示禁止任何缓存策略，每次用户请求该资源都会向服务器发送一个请求，每次都会下载完整的资源。\r\n- public：表示资源既可以被浏览器缓存也可以被代理服务器缓存。\r\n- private：表示资源只能被浏览器缓存。\r\n### no-store\r\n- no-store不但不进行强缓存和协商缓存，连浏览器自带的启发式缓存策略也没了，不建议随意使用no-store，因为会失去HTTP和浏览器所拥有的许多优势，比如浏览器的后退/前进缓存。\r\n### immutable(避免重新验证)\r\n- 永远不会改变的内容应该被赋予一个较长的max-age，但是当设定的缓存时间到了之后依然会向服务器发送请求，immutable指令可用于明确指示不需要重新验证，因为内容永远不会改变。\r\n```\r\nCache-Control: max-age=10086,immutable\r\n```\r\n### no-cache和no-store\r\n- no-cache表示强制进行协商缓存，如果某一资源的Cache-Control中设置了no-cache，那么该资源会直接跳过强缓存的校验，直接去服务器进行协商缓存。而no-store表示禁止所有的缓存策略，向服务器发送请求下载完整的资源。\r\n- no-cache和no-store是一组互斥属性，它们两个不能同时出现在响应头的Cache-Control字段中。\r\n### public和private\r\n- public和private就是决定资源是否可以在代理服务器进行缓存的属性。public表示资源在客户端和代理服务器都可以被缓存。private则表示资源只能在客户端被缓存，拒绝资源在代理服务器缓存。\r\n- 如果这两个属性值都没有被设置，则默认为private。\r\n- public和private是一组互斥属性，它们两个不能同时出现在响应头的Cache-Control字段中。\r\n### max-age和s-maxage\r\n- max-age表示资源在客户端缓存的时长，而s-maxage表示资源在代理服务器可以缓存的时长。\r\n- s-maxage因为是设置代理服务器的缓存时长，它必须和public属性一起使用(public属性表示资源可以在代理服务器中缓存)。\r\n- max-age和s-maxage并不互斥，它们可以一起使用。\r\n"},function(r,n,e){"use strict";e.r(n),n.default='## 最佳实践\r\n> 由于强缓存可能会导致获取不到最新的内容，但是协商缓存每一次都要请求服务器也不太理想，借助构建工具可以做到每一次构建后的前端静态文件的名字不同(文件名带有hash)，所以请求资源时请求的路径也就不同，相当于第一次请求，不存在缓存的问题。\r\n\r\n- HTML&配置文件：使用协商缓存。\r\n- CSS&JS&图片：使用强缓存，文件命名带上hash值。设置Cache-Control: private，这可以禁用掉所有Public Cache(比如代理)，这就减少了攻击者跨界访问到公共缓存的可能性。**\r\n```\r\n// nginx配置示例\r\nlocation / {\r\n  # 其它配置\r\n  ...\r\n\r\n  if ($request_uri ~* .*[.](js|css|map|jpg|png|svg|ico)$) {\r\n    #非html缓存1个月\r\n    add_header Cache-Control "private, max-age=2592000";\r\n  }\r\n\r\n  if ($request_filename ~* ^.*[.](html|htm)$) {\r\n    #html文件使用协商缓存\r\n    add_header Cache-Control "private, no-cache";\r\n  }\r\n}\r\n```'},function(r,n,e){"use strict";e.r(n),n.default="## 浏览器刷新\r\n### 正常重新加载\r\n- 方法：地址栏回车、页面链接跳转、打开新窗口/标签页、history前进后退、点击刷新按钮、页面右键重新加载、F5、ctrl+R。\r\n- 遇到需要加载的资源时，资源有缓存且缓存不过期会使用缓存的资源。\r\n### 硬性重新加载\r\n- 方法：点击硬性重新加载、Ctrl+F5、Ctrl+Shift+R。\r\n- 遇到需要加载的资源时不会使用缓存的资源，而是重新发起请求。\r\n- 本地的缓存资源不会删除，这种方式浏览器会在Request Header里添加Cache-Control: no-cache和Pragma: no-cache。\r\n### 清空缓存并硬性重新加载\r\n- 方法：点击清空缓存并硬性重新加载。\r\n- 这种方式会将该页面的缓存清空再执行硬性重新加载。\r\n- 效果等同于在devtools的network面板中勾选Disable cache并刷新。\r\n- 当页面加载后还可能通过JS加载资源时，普通的硬性重新加载这部分的资源仍然是从缓存中加载的，清空缓存则可以保证页面所有资源都是重新发起请求的。\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## 缓存位置\r\n### 优先级从高到低(操作系统的常理：先读内存再读硬盘)\r\n1. Service Worker\r\n2. Memory Cache\r\n3. Disk Cache\r\n4. Push Cache\r\n### Service Worker\r\n- Service Worker借鉴了Web Worker的思路，即让JS运行在主线程之外，由于它脱离了浏览器的窗体，因此无法直接访问DOM。\r\n- Service Worker能帮助我们完成很多有用的功能，比如离线缓存、消息推送和网络代理等功能。\r\n- 离线缓存就是Service Worker Cache。这个缓存是永久性的，关闭TAB页或者浏览器下次打开依然还在。有两种情况会导致这个缓存中的资源被清除：手动调用API cache.delete(resource)或者容量超过限制会被浏览器全部清空。\r\n### Memory Cache\r\n- Memory Cache指的是内存缓存，从效率上讲它是最快的。但是从存活时间来讲又是最短的，**当渲染进程结束后，内存缓存也就不存在了, 关闭TAB页或者关闭浏览器缓存就不在了**。\r\n### Disk Cache\r\n- Disk Cache就是存储在磁盘中的缓存，从存取效率上讲是比内存缓存慢的，但是他的优势在于存储容量和存储时长。\r\n### Memory Cache VS Disk Cache\r\n- 比较大的JS、CSS文件会直接被丢进磁盘，反之丢进内存，内存使用率比较高的时候文件优先进入磁盘。\r\n### Push Cache\r\n- 推送缓存，这是HTTP缓存的最后一道防线。它是HTTP/2中的内容。\r\n### 访问缓存优先级\r\n1. 先在内存中查找，如果有直接加载。\r\n2. 如果内存中不存在，则在磁盘中查找，如果有直接加载。\r\n3. 如果磁盘中也没有那么就进行网络请求。\r\n4. 请求获取的资源缓存到硬盘或内存。\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## ==和===\r\n### ===\r\n> 严格全等，不会类型转换，必须要数据类型和值完全一致，类型不同就不相等。\r\n\r\n- 基本数据类型\r\n  1. Number, String, Boolean, null 和 undefined 两边的值要一样, 才相等;\r\n  2. NaN === NaN // false; NaN不会等于任何数据,包括自己。\r\n- 引用数据类型\r\n> Object, Array, Function 如果两边的引用地址一样则是相等的。\r\n\r\n### ==\r\n> 非严格相等，会先进行类型转换，在进行值的比较。\r\n\r\n- 两边是undefined或null，返回true\r\n```\r\nconsole.log (null == undefined); // true\r\nconsole.log (null == null); // true\r\nconsole.log (undefined == undefined); // true\r\n```\r\n- 两边是String，Boolean，Number其中一种\r\n> 会将不是Number类型的数据转成Number类型，true转为1， false转为0。Number()会将非数值型字符串结果为NaN。\r\n\r\n```\r\nconsole.log (1 == true); // true  Number(true)的结果为1\r\nconsole.log ( 1 == \"true\" ); // false  Number()会将非数值型字符串结果为NaN，数值型字符串为数值，空字符串为0;\r\nconsole.log ( 1 == !\"true\" ); // false  !先将\"true\"转为布尔型false Number(false)的结果为0\r\nconsole.log ( 0 == !\"true\" ); // true\r\nconsole.log(true == 'true') // false\r\n```\r\n- 只要有一边是NaN则返回false\r\n```\r\nconsole.log ( NaN == NaN ); //false\r\n```\r\n- 只有一边为引用类型\r\n> 获取引用类型数据的原始值之后再比较；先调用valueOf方法，然后调用toString方法，valueOf:一般默认返回自身，数组的toString：默认会调用join方法拼接每个元素并且返回拼接后的字符串。\r\n\r\n```\r\n// 空数组的toString()方法会得到空字符串,而空对象的toString()方法会得到字符串[object Object]\r\nconsole.log ([].toString ()); // 空字符串\r\nconsole.log ({}.toString ()); // '[object Object]'\r\n\r\nconsole.log ([1, 2, 3].valueOf().toString()); // '1，2，3'\r\nconsole.log ([1, 2, 3] == \"1,2,3\" ); //true  (1)[1,2,3].toString() == '1,2,3'  (2)'1,2,3' == '1,2,3'\r\nconsole.log({} == '[object Object]'); //true\r\n```\r\n- 两边都是引用类型\r\n> 只比较引用地址，如果地址一致则返回true，否则返回false.\r\n\r\n### Object.is()\r\n> Object.is()，其行为与===基本一致，有两处不同。\r\n\r\n- +0不等于-0。\r\n- NaN等于自身。\r\n```\r\nif (!Object.is) {\r\n  Object.is = function(x, y) {\r\n    if (x === y) { \r\n      // 运行到1/x === 1/y的时候x和y都为0，但是1/+0 = +Infinity， 1/-0 = -Infinity, 是不一样的\r\n      return x !== 0 || 1 / x === 1 / y;\r\n    } else {\r\n      // NaN===NaN是false,这是不对的，我们在这里做一个拦截，x !== x，那么一定是 NaN, y 同理\r\n      return x !== x && y !== y;\r\n    }\r\n  };\r\n}\r\n```\r\n### 示例\r\n> == 是非严格比较操作符，false会转换为0，[]会转换成''，{}会转换为\"[object Object]\"，所以会输出1，不输出2，[]和{}是“空”的对象，不是“空”，所以会输出3,最后一个引用地址不一致，不是同一个对象，所以不会输出4;\r\n\r\n```\r\n// 输出1，3\r\nif([] == false) { console.log(1) }; // false会转换为0，[]会转换成'',空字符串转为Number型后为0。\r\nif({} == false) { console.log(2) }; // {}会转换为\"[object Object]\" 所以不会等于false\r\nif([]) { console.log(3) }; // 空对象和空数组转为Bollean类型都是true\r\nif([1] == [1]){ console.log(4) }; // 两个引用类型的数据的引用地址不同\r\n```\r\n\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## [Array](https://mp.weixin.qq.com/s/lTpFXhII7LitooRamMbLIA)\r\n### every\r\n> every 方法为数组中的每个元素执行一次 callback 函数，直到它找到一个会使 callback 返回 false 的元素。如果发现了一个这样的元素，every 方法将会立即返回 false，不再继续循环下去。否则，callback 为每一个元素返回 true，every 就会返回 true。空数组使用every永远返回true。\r\n\r\n```\r\n// 只会console一个1，因为every方法中的函数没有返回值，默认返回undefined，理解为false，所以执行一次之后就会终止循环\r\n[1,2,3].every(item => {\r\n  console.log(1);\r\n}) // false\r\n\r\n// console两个1，因为运行到2时return的false，所以不会继续运行下去\r\n[1,2,3].every(item => {\r\n  console.log(1);\r\n  return item < 2;\r\n}) // false\r\n```\r\n### some\r\n> some 为数组中的每一个元素执行一次 callback 函数，直到找到一个使得 callback 返回一个true（即可转换为布尔值 true 的值）。如果找到了这样一个值，some() 将会立即返回 true,不再往下执行。否则将返回false。空数组使用some永远返回false。\r\n\r\n```\r\n// 会console三个1，因为some方法中的函数没有返回值，默认返回undefined，理解为false，所以会一直执行下去\r\n[1,2,3].some(item => {\r\n  console.log(1);\r\n}) // false\r\n\r\n// console一个1，因为运行到1时return的true，所以不会继续运行下去\r\n[1,2,3].some(item => {\r\n  console.log(1);\r\n  return item < 2;\r\n})  // true\r\n```\r\n### Array.from()\r\n> 用于将类对象或具有length属性的对象转为真正的数组,类数组的对象和可遍历的对象（ES6的Set和Map）。也可以将字符串逐个解析生成数组。\r\n\r\n```\r\nArray.from('dyx') // [\"d\",\"y\",\"x\"]\r\nlet arrayLike = {\r\n '0': 'a',\r\n '1': 'b',\r\n '2': 'c',\r\n length: 3\r\n};\r\n// ES5的写法\r\nvar arr1 = Array.prototype.slice.call(arrayLike); // ['a', 'b', 'c']\r\n// ES6的写法\r\nlet arr2 = Array.from(arrayLike); // ['a', 'b', 'c']\r\n\r\n// NodeList对象\r\nlet ps = document.querySelectorAll('p');\r\nArray.from(ps).filter(p => {\r\n return p.textContent.length > 100;\r\n});\r\n// arguments对象\r\nfunction foo() {\r\n var args = Array.from(arguments);\r\n // ...\r\n}\r\n```\r\n### find\r\n> 查找数组中第一个符合规则的元素，如果没有找到返回undefined\r\n\r\n```\r\nconst arr = [1, 2, 3];\r\narr.find(item => item > 1) // 2\r\narr.find(item => item > 3) // undefined\r\n``` \r\n### slice\r\n> 根据规则截取数组，不会改变原数组，返回截取后的数组\r\n\r\n```\r\nconst arr = [1, 2, 3, 4, 5];\r\narr.slice(2, 4) // [3, 4]\r\narr.slice(0, -2) // [1, 2, 3] 截取直倒数第二位\r\n```\r\n### forEach\r\n- 在forEach中用return不会返回，函数会继续执行。使用try监视代码块，在需要中断的地方抛出异常。或使用every和some替代forEach函数。every在碰到return false的时候，中止循环。some在碰到return true的时候，中止循环。\r\n- 对于异步代码，forEach 并不能保证按顺序执行，因为forEach的实现是直接循环调用传入的函数，无法保证异步任务的执行顺序。使用for of 解决，for...of并不像forEach那么简单粗暴的方式去遍历执行，而是采用迭代器的形式去遍历。\r\n### Array.isArray()\r\n> 判断是否为数组类型\r\n\r\n### fill\r\n> 使用一个固定值填充或替换数组的元素。\r\n\r\n```\r\nnew Array(5).fill('dyx');\r\n```\r\n### flat\r\n> 将一个多维数组进行压平处理,默认使用一次只有一次压平处理\r\n\r\n```\r\nconst arr = [1, [2, [3, 4] ] ];\r\nconsole.log(arr.flat()); // [1, 2, [3, 4]]\r\nconsole.log(arr.flat().flat()); // [1, 2, 3, 4]\r\nconsole.log(arr.flat(Infinity)); // [1, 2, 3, 4]\r\n```\r\n### flatMap\r\n```\r\n[1, 2].flatMap(item => [item, item + 1]) // [1, 2, 2, 3]\r\n```\r\n### reduce, reduceRight\r\n> 可以使用该方法实现数组的递归，\r\n\r\n- 没有初始值时该方法的第一次迭代发生在数组第二项，方法的第一个参数是第一项，第二个参数是第二项\r\n- 有初始值时该方法的第一次迭代发生在数组第一项，方法的第一个参数是初始值，第二个参数是第一项\r\n- 空数组使用reduce必须有初始值否则会报错\r\n\r\n```\r\n// prev代表后面的初始值-1，或者每一次循环后返回的值，current代表当前循环的值\r\nconsole.log([1,2,3].reduce(\r\n  (prev, current) => {\r\n    console.log(prev, current); \r\n    return Math.max(prev,current);\r\n  }, -1));\r\n\r\n// 数组连接\r\nvar newArr = [[0, 1], [2, 3], [4, 5]].reduce((a, b) => {\r\n  return a.concat(b);\r\n});\r\n// [0, 1, 2, 3, 4, 5]\r\n\r\n// 同一个数组有无初始值循环的次数不同\r\nconst a = [1,2,3].reduce((prev, current) => {\r\n  console.log(prev, current);\r\n  return prev + current\r\n}); // 1 2; 3 3;\r\nconsole.log(a)  // 6\r\n\r\nconst a = [1,2,3].reduce((prev, current) => {\r\n  console.log(prev, current);\r\n  return prev + current\r\n}, 0); // 0 1; 1 2; 3 3;\r\nconsole.log(a)  // 6\r\n\r\nconst a = [].reduce((prev, current) => {\r\n  console.log(prev, current);\r\n  return prev + current\r\n}, 0); // 没有console，空数组必须有初始值否则报错\r\nconsole.log(a)  // 0\r\n```\r\n### 数组去重\r\n> 利用set去重没有将空对象去除，利用indexOf没有将空对象和NaN去除，使用对象属性不能相同去重可以完美去重。\r\n\r\n#### set\r\n> 利用set简单实现数组去重,去完之后不是数组要注意\r\n\r\n```\r\nconst item = new Set([1, 2, 3, 1]) // 去重\r\nconst arr = Array.from(item) // 重新转为数组\r\n\r\nconst item = new Set([1, 2, 3, 1]) // 去重\r\nconst arr = [...item] // 重新转为数组\r\n```\r\n#### 对象属性不能相同去重\r\n```\r\nconst unique = arr => {\r\n  let newArr = [];\r\n  let obj = {};\r\n  for(var i = 0; i < arr.length; i++) {\r\n    if(!obj[arr[i]]) {\r\n      newArr.push(arr[i])\r\n      obj[arr[i]] = 1;\r\n    } else {\r\n      obj[arr[i]]++;\r\n    }\r\n  }\r\n  return newArr;\r\n}\r\n```\r\n#### indexOf去重\r\n```\r\nconst unique = arr => {\r\n  var newArr = [];\r\n  for(var i in arr){\r\n    if(newArr.indexOf(arr[i]) === -1) {\r\n      newArr.push(arr[i]);\r\n    }\r\n  }\r\n  return newArr;\r\n}\r\n```\r\n```\r\nconst unique = arr => {\r\n  var len = arr.length;\r\n  var newArr = [];\r\n  for(i = 0; i < len; i++) {\r\n    for(j = i + 1; j < len; j++){\r\n      if(arr[i] === arr[j]){\r\n        j = ++i; // 先找到第一个后面没有重复的值，最外层循环不是循环了数组的长度的次数，而是循环了去重之后数组长度的次数\r\n      }\r\n    }\r\n    newArr.push(arr[i]);\r\n  }\r\n  return newArr; \r\n}\r\n```\r\n### 数组最大最小值\r\n```\r\nfor(var i = 0; i < arr.length; i++) {\r\n  if(amin > arr[i]) {\r\n    amin = arr[i];\r\n  }\r\n  if(amax < arr[i]) {\r\n    amax = arr[i];\r\n  }\r\n}\r\nconsole.log(`最小值：${amin} 最大值：${amax}`);\r\n```\r\n### 数组最大值\r\n```\r\nconst arr = [1, 2, 4, 6, 3, 4]\r\nconst max = arr.reduce((x, y) => x > y ? x : y);\r\nconst max = arr.reduce((x, y) => Math.max(x, y));\r\n```\r\n### 数组最小值\r\n```\r\nconst arr = [1, 2, 2, 4, 6, 3, 4]\r\nconst min = arr.reduce((x, y) => x > y ? y : x);\r\nconst min = arr.reduce((x, y) => Math.min(x, y));\r\n```\r\n### 将数组某一元素全部放在数组前面\r\n```\r\nconst arr = ['*','黄','红','白','红','*','白','*','黄','*','红','*','黄','白'];\r\nfor (let i in arr){\r\n  if(arr[i] === '*'){\r\n    arr.splice(i, 1)\r\n    arr.unshift('*')\r\n  }\r\n}\r\n```\r\n### 两个有序的数组组成一个有序的数组\r\n```\r\nconst a = [1, 3, 5, 7];\r\nconst b = [2, 4, 6, 8];\r\nlet i = 0;\r\nlet j = 0;\r\nlet al = a.length;\r\nlet bl = b.length;\r\nlet c = []; // 新的数组\r\nwhile (i < al || j < bl) {\r\n  if (a[i] <= b[j]) {\r\n    c.push(a[i]);\r\n    i++\r\n  } else {\r\n    c.push(b[j]);\r\n    j++\r\n  }\r\n}\r\n```\r\n### indexOf 和 findIndex 的区别\r\n- indexOf：查找值作为第一个参数，采用 === 比较，更多的是用于查找基本类型，如果是对象类型，则是判断是否是同一个对象的引用。\r\n- findIndex：比较函数作为第一个参数，多用于非基本类型(例如对象)的数组索引查找，或查找条件很复杂。"},function(r,n,e){"use strict";e.r(n),n.default="## ES6\r\n> ES6是新一代的JS语言标准，对分JS语言核心内容做了升级优化，规范了JS使用标准，新增了JS原生方法，使得JS使用更加规范，更加优雅，更适合大型应用的开发。\r\n\r\n### ES5、ES6和ES2015的区别\r\n> ES2015特指在2015年发布的新一代JS语言标准，ES6泛指下一代JS语言标准，包含ES2015、ES2016、ES2017、ES2018等。现阶段在绝大部分场景下，ES2015默认等同ES6。ES5泛指上一代语言标准。ES2015可以理解为ES5和ES6的时间分界线。\r\n\r\n### babel的作用\r\n> babel是一个 ES6 转码器，可以将 ES6 代码转为 ES5 代码，以便兼容那些还没支持ES6的平台。\r\n\r\n### ES6新增内容\r\n#### let 块作用域\r\n#### 字符串相关\r\n- 模板字符串\r\n- 新增方法\r\n  1. includes\r\n  2. startsWith、endsWith\r\n  3. padStart、padEnd\r\n  4. repeat\r\n#### 数组\r\n- 新增方法\r\n  1. find\r\n  2. includes\r\n  3. fill\r\n  4. flat\r\n#### 对象\r\n- 新增方法\r\n  1. assign\r\n  2. keys、values、entries\r\n#### 解构赋值\r\n#### 扩展运算符\r\n#### 箭头函数\r\n#### Promise\r\n#### 类 class\r\n#### 模块\r\n#### Symbol\r\n#### 函数默认参数\r\n#### Map Set 数据结构"},function(r,n,e){"use strict";e.r(n),n.default="## Generator和协程\r\n### Generator迭代器\r\n> ES6 新引入了 Generator 函数，可以通过 yield 关键字，把函数的执行流挂起，通过next()方法可以切换到下一个状态，为改变执行流程提供了可能，从而为异步编程提供解决方案。\r\n\r\n```\r\nfunction* myGenerator() {\r\n  yield '1';\r\n  yield '2';\r\n  return '3';\r\n}\r\n\r\nconst gen = myGenerator();  // 获取迭代器\r\ngen.next()  // { value: \"1\", done: false }\r\ngen.next()  // { value: \"2\", done: false }\r\ngen.next()  // { value: \"3\", done: true }\r\n```\r\n- 可以通过给next()传参, 让yield具有返回值\r\n```\r\nfunction* myGenerator() {\r\n  console.log(yield '1');  // test1\r\n  console.log(yield '2');  // test2\r\n  console.log(yield '3');  // test3\r\n}\r\n\r\nconst gen = myGenerator(); // 获取迭代器\r\ngen.next()\r\ngen.next('test1')\r\ngen.next('test2')\r\ngen.next('test3')\r\n```\r\n### 协程\r\n> 生成器实现机制，协程是一种比线程更加轻量级的存在，协程处在线程的环境中，一个线程可以存在多个协程，可以将协程理解为线程中的一个个任务。不像进程和线程，协程并不受操作系统的管理，而是被具体的应用程序代码所控制。一个线程一次只能执行一个协程。比如当前执行 A 协程，另外还有一个 B 协程，如果想要执行 B 的任务，就必须在 A 协程中将 JS 线程的控制权转交给 B协程，那么现在 B 执行，A 就相当于处于暂停的状态。\r\n\r\n### 示例\r\n> A 将执行权交给 B，也就是 A 启动 B，我们也称 A 是 B 的父协程。因此 B 当中最后return 100其实是将 100 传给了父协程。对于协程来说，它并不受操作系统的控制，完全由用户自定义切换。\r\n\r\n```\r\nfunction* A() {\r\n  console.log(\"我是A\");\r\n  yield B(); // A停住，在这里转交线程执行权给B\r\n  console.log(\"结束了\");\r\n}\r\nfunction B() {\r\n  console.log(\"我是B\");\r\n  return 100;// 返回，并且将线程执行权还给A\r\n}\r\nlet gen = A();\r\ngen.next();\r\ngen.next();\r\n\r\n// 我是A\r\n// 我是B\r\n// 结束了\r\n```"},function(r,n,e){"use strict";e.r(n),n.default='## Map\r\n> 它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。\r\n\r\n### 属性\r\n- size属性返回 Map 结构的成员总数。\r\n```\r\nconst map = new Map();\r\nmap.set(\'foo\', true);\r\nmap.set(\'bar\', false);\r\n\r\nmap.size // 2\r\n```\r\n### 方法\r\n- set(key, value)  set方法设置键名key对应的键值为value，然后返回整个 Map 结构。如果key已经有值，则键值会被更新，否则就新生成该键。\r\n- get(key)  get方法读取key对应的键值，如果找不到key，返回undefined。\r\n- has(key)  has方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。\r\n- delete(key)  delete方法删除某个键，返回true。如果删除失败，返回false。\r\n- clear()   clear方法清除所有成员，没有返回值。\r\n\r\n### 遍历方法\r\n> Map 的遍历顺序就是插入顺序。\r\n\r\n- keys()，values()，entries()\r\n```\r\nconst map = new Map([\r\n  [\'F\', \'no\'],\r\n  [\'T\',  \'yes\'],\r\n]);\r\n\r\nfor (let key of map.keys()) {\r\n  console.log(key);\r\n}\r\n// "F"\r\n// "T"\r\n\r\nfor (let value of map.values()) {\r\n  console.log(value);\r\n}\r\n// "no"\r\n// "yes"\r\n\r\nfor (let item of map.entries()) {\r\n  console.log(item[0], item[1]);\r\n}\r\n// "F" "no"\r\n// "T" "yes"\r\n```\r\n- forEach()，与数组的forEach方法类似\r\n### Map获取最先存入Map的键\r\n```\r\nmap.keys().next().value 获取第一个键（最先存入map集合的键）\r\nmap.delete(map.keys().next().value) 删除第一个键\r\n```\r\n### Map转数组\r\n> Map 转为数组最方便的方法，就是使用扩展运算符。\r\n\r\n```\r\nconst myMap = new Map().set(true, 7).set({foo: 3}, [\'abc\']);\r\n\r\n// [\r\n//   [ true, 7 ],\r\n//   [\r\n//     { foo: 3 },\r\n//     [\'abc\'] \r\n//   ]\r\n// ]\r\n[...myMap]\r\n```\r\n### 数组转Map\r\n> 将数组传入 Map 构造函数，就可以转为 Map。\r\n\r\n```\r\nnew Map([\r\n  [true, 7],\r\n  [{foo: 3}, [\'abc\']]\r\n])\r\n// Map {\r\n//   true => 7,\r\n//   Object {foo: 3} => [\'abc\']\r\n// }\r\n```\r\n### Map转对象\r\n> 如果所有 Map 的键都是字符串，它可以无损地转为对象。如果有非字符串的键名，那么这个键名会被转成字符串，再作为对象的键名。\r\n\r\n```\r\nfunction strMapToObj(strMap) {\r\n  let obj = Object.create(null);\r\n  for (let [k,v] of strMap) {\r\n    obj[k] = v;\r\n  }\r\n  return obj;\r\n}\r\n\r\nconst myMap = new Map().set(\'yes\', true).set(\'no\', false);\r\n\r\n// { yes: true, no: false }\r\nstrMapToObj(myMap)\r\n```\r\n### 对象转Map\r\n> 对象转为 Map 可以通过Object.entries()。也可以自己实现一个转换函数。\r\n\r\n```\r\nlet obj = {"a":1, "b":2};\r\nlet map = new Map(Object.entries(obj));\r\n\r\n// 自定义转化方法\r\nfunction objToStrMap(obj) {\r\n  let strMap = new Map();\r\n  for (let k of Object.keys(obj)) {\r\n    strMap.set(k, obj[k]);\r\n  }\r\n  return strMap;\r\n}\r\n\r\nobjToStrMap({yes: true, no: false})\r\n// Map {"yes" => true, "no" => false}\r\n```\r\n### WeakMap\r\n> WeakMap结构与Map结构类似，也是用于生成键值对的集合。但是它与 Map 有一些区别。\r\n\r\n1. WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名。\r\n2. WeakMap的键名所指向的对象，不计入垃圾回收机制。\r\n3. WeakMap不可遍历。\r\n\r\n```\r\n// Map\r\nlet dyx = { name: "dyx" };\r\nlet map = new Map();\r\nmap.set(dyx, "test");\r\n\r\n// dyx 被存储在 map 中，我们可以使用 map.keys() 来获取它\r\ndyx = null; // 覆盖引用\r\n\r\n\r\n// WeakMap\r\nlet dyx = { name: "dyx" };\r\nlet weakMap = new WeakMap();\r\nweakMap.set(dyx, "test");\r\n\r\n// john 被从内存中删除了！\r\ndyx = null; // 覆盖引用\r\n```\r\n### JSON.stringify方法不能转化Map数据类型。\r\n\r\n'},function(r,n,e){"use strict";e.r(n),n.default="## Object.defineProperty\r\n> Object.defineProperty(obj, prop, descriptor)\r\n\r\n1. value  该属性对应的值\r\n2. configurable  配置对象，删除属性\r\n3. writable  修改对象\r\n4. enumerable  可以枚举\r\n5. get  获取属性值的时候就会调用get方法\r\n6. set  设置属性值的时候就会调用set方法\r\n\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## ResizeObserver\r\n- 监听元素的尺寸变化，相较于window的resize事件可以监听具体的元素尺寸变化，同时有更好的性能。\r\n- 所监听元素的父元素设置隐藏(比如Tab切换)也可以通过ResizeObserver监听到尺寸变化。\r\n### ResizeObserver.observe()\r\n- 开始对指定元素的监听，可以调用多次监听多个元素。\r\n- entries是数组格式，每一项是调用resizeObserver.observe传入的元素。即使只调用一次resizeObserver.observe，entries也是数组格式。\r\n```\r\nconst resizeObserver = new ResizeObserver(entries => {\r\n  for (const entry of entries) {\r\n    if (entry?.contentRect?.width && entry?.contentRect?.height) {\r\n      echartsRef.current?.resize();\r\n    }\r\n  }\r\n});\r\nresizeObserver.observe(echartsWrapperRef.current);\r\n```\r\n### ResizeObserver.unobserve()\r\n- 结束对指定元素的监听。\r\n```\r\nresizeObserver.unobserve(echartsWrapperRef.current);\r\n```\r\n### ResizeObserver.disconnect()\r\n- 取消对所有元素的监听。\r\n```\r\nresizeObserver.disconnect();\r\n```"},function(r,n,e){"use strict";e.r(n),n.default='## Set\r\n> 类似于数组，但是成员的值都是唯一的，没有重复的值。\r\n\r\n### Set函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。\r\n```\r\nconst set = new Set([1, 2, 3, 4, 4]);\r\n[...set] // [1, 2, 3, 4]\r\n\r\nconst set = new Set(document.querySelectorAll(\'div\'));\r\nset.size // 56\r\n```\r\n### 成员的值是唯一的\r\n> 向 Set 加入值的时候，不会发生类型转换。Set 内部判断两个值是否不同，使用的算法叫做“Same-value-zero equality”，它类似于精确相等运算符（===），主要的区别是向 Set 加入值时认为NaN等于自身，而精确相等运算符认为NaN不等于自身。\r\n\r\n### 属性\r\n- size：返回Set实例的成员总数。\r\n### 方法\r\n- add(value)：添加某个值，返回 Set 结构本身。\r\n- delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。\r\n- has(value)：返回一个布尔值，表示该值是否为Set的成员。\r\n- clear()：清除所有成员，没有返回值。\r\n### 遍历操作\r\n- keys()，values()，entries()\r\n> keys方法、values方法、entries方法返回的都是遍历器对象。由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以keys方法和values方法的行为完全一致。\r\n\r\n```\r\nlet set = new Set([\'red\', \'green\', \'blue\']);\r\n\r\nfor (let item of set.keys()) {\r\n  console.log(item);\r\n}\r\n// red\r\n// green\r\n// blue\r\n\r\nfor (let item of set.values()) {\r\n  console.log(item);\r\n}\r\n// red\r\n// green\r\n// blue\r\n\r\nfor (let item of set.entries()) {\r\n  console.log(item);\r\n}\r\n// ["red", "red"]\r\n// ["green", "green"]\r\n// ["blue", "blue"]\r\n```\r\n- forEach\r\n> forEach方法的参数就是一个处理函数。该函数的参数与数组的forEach一致，依次为键值、键名、集合本身（上例省略了该参数）。这里需要注意，Set 结构的键名就是键值（两者是同一个值），因此第一个参数与第二个参数的值永远都是一样的。\r\n\r\n```\r\nlet set = new Set([1, 4, 9]);\r\nset.forEach((value, key) => console.log(key + \' : \' + value))\r\n// 1 : 1\r\n// 4 : 4\r\n// 9 : 9\r\n```\r\n### WeakSet\r\n> WeakSet 结构与 Set 类似，也是不重复的值的集合。但是它与 Set 有一些区别。\r\n\r\n1. WeakSet 的成员只能是对象，而不能是其他类型的值。\r\n2. WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。\r\n3. WeakSet 不可遍历。'},function(r,n,e){"use strict";e.r(n),n.default="## [Symbol](https://mp.weixin.qq.com/s/qSo66z9mQ4CwY6E5gfDmjw)\r\n- Symbol是一种基本数据类型。Symbol()函数返回symbol类型的值。\r\n- 通过Symbol创建返回的symbol值都是唯一的。一个symbol值能作为对象属性的标识符，这是该数据类型仅有的目的。\r\n### 创建symbol值\r\n```\r\nconst symbol1 = Symbol();\r\nconst symbol2 = Symbol(123);\r\nconst symbol3 = Symbol('test');\r\n\r\nconsole.log(symbol2); // Symbol(123)\r\nconsole.log(typeof symbol1); // symbol\r\nconsole.log(symbol2 === 123); // 永远输出是false\r\nconsole.log(Symbol('test') === Symbol('test')); // 永远输出是false\r\n```\r\n### Symbol特点\r\n- Symbol不可以使用new创建，使用new创建会抛出TypeError错误。\r\n- Symbol创建的值是不可枚举的。\r\n- for in循环会遍历对象的可枚举属性，会忽略不可枚举的属性。\r\n```\r\nconst symbol = Symbol('test');\r\nconst obj = {[symbol]: 123};\r\nfor (const key in obj) {\r\n  console.log(key); // 无打印信息\r\n}\r\n```\r\n- Object.keys()方法返回一个数组，其中包含对象的所有可枚举属性的名称。不可枚举的属性不会被包含在返回的数组中。\r\n```\r\nconst symbol = Symbol('test');\r\nconst obj = {[symbol]: 123};\r\nconsole.log(Object.keys(obj)); // []\r\n```\r\n- Object.getOwnPropertySymbols、Reflect.ownKeys方法可以获取指定对象的所有Symbol属性名。\r\n```\r\nconst symbol = Symbol('test');\r\nconst obj = {[symbol]: 123};\r\nconsole.log(Object.getOwnPropertySymbols(obj)); // [Symbol(test)]\r\nconsole.log(Reflect.ownKeys(obj)); // [Symbol(test)]\r\n```\r\n- Object.assign()将源对象中可枚举属性复制到目标对象，但会包含Symbol类型作为key的属性。\r\n```\r\nconst symbolKey = Symbol('key');\r\nconst source = {\r\n  [symbolKey]: 'Symbol Property',\r\n  regularProperty: 'Regular Property'\r\n};\r\nObject.defineProperty(source, \"w\", {\r\n  value: 456,\r\n  enumerable: true,\r\n  configurable: true,\r\n  writable: true\r\n})\r\nObject.defineProperty(source, \"r\", {\r\n  value: 123,\r\n  enumerable: false,\r\n  configurable: false,\r\n  writable: false\r\n})\r\n\r\nconst target = {};\r\nObject.assign(target, source);\r\n// Symbol(key)类型会被打印，但是不可枚举属性不会打印\r\nconsole.log(target); // {regularProperty: \"Regular Property\", w: 456, Symbol(key): 'Symbol Property'}\r\n```\r\n- JSON.stringify()只会序列化对象的可枚举属性，不会包含不可枚举属性。\r\n  - JSON.stringify()转换的是一个对象时无论key还是value中有symbol类型，都会忽略掉。\r\n  - JSON.stringify()直接转换symbol类型数据，转换后的结果为undefined。\r\n  ```\r\n  const symbol = Symbol('test');\r\n  const obj = {name: symbol};\r\n  const obj1 = {[symbol]: 123};\r\n  console.log(JSON.stringify(symbol)); // undefined\r\n  console.log(JSON.stringify(obj)); // {}\r\n  console.log(JSON.stringify(obj1)); // {}\r\n  ```\r\n- 对象中声明的Symbol属性获取必须使用[]方式获取属性。\r\n```\r\nconst symbol = Symbol('test');\r\nconst obj = {[symbol]: 123};\r\nconsole.log(obj[symbol]); // 123\r\n```\r\n- 使用Symbol直接传入一个函数，会调用toString函数，将函数内容转换为字符串。\r\n```\r\nconst a = function() {\r\n  console.log('哈哈哈');\r\n}\r\nconsole.log(Symbol(a)); // Symbol(function() { console.log('哈哈哈'); })\r\nconsole.log(typeof Symbol(a)); // symbol\r\n```\r\n- Object.getOwnPropertyNames()返回一个数组，其中包含对象的所有属性（包括不可枚举属性）的名称，但是不包括使用symbol值作为名称的属性。\r\n```\r\nconst symbolKey = Symbol('key');\r\nconst obj = {\r\n  [symbolKey]: 'Symbol Property',\r\n  regularProperty: 'Regular Property'\r\n};\r\nObject.defineProperty(obj, \"w\", {\r\n  value: 456,\r\n  enumerable: true,\r\n  configurable: true,\r\n  writable: true\r\n})\r\nObject.defineProperty(obj, \"r\", {\r\n  value: 123,\r\n  enumerable: false,\r\n  configurable: false,\r\n  writable: false\r\n})\r\nconsole.log(Object.getOwnPropertyNames(obj))\r\n```\r\n### Symbol.For \r\n- 如果想要使用同一个Symbol值，可以使用Symbol.for。\r\n- 它接受一个字符串作为参数，用Symbol.for()方法创建的symbol会被放入一个全局的symbol注册表。Symbol.for()不是每次都创建新的symbol，会先搜索有没有以该参数作为名称的Symbol值。如果有就返回这个Symbol值，否则就新建并返回一个以该字符串为名称的Symbol值。\r\n```\r\nconsole.log(Symbol.for('test') === Symbol.for('test')); // true\r\nconsole.log(Symbol(\"test\") === Symbol(\"test\")); // false\r\n```\r\n### Symbol 应用场景\r\n> 应用场景不止针对的symbol这个基础的数据类型，还会针对Symbol中提供的一些函数，比如Symbol.iterator, Symbol.toStringTag等。\r\n\r\n#### 自定义迭代器之Symbol.iterator\r\n- 使用Symbol实现普通对象迭代器，普通的对象是不支持迭代器功能的，也就是普通对象不能直接使用for of功能，有了它可以让一个普通对象支持for of遍历。\r\n```\r\nconst symbolObjTest1 = {\r\n  0: \"a\",\r\n  1: \"b\",\r\n  2: \"c\",\r\n  length: 3,\r\n  [Symbol.iterator]: function() {\r\n    let index = 0;\r\n    return {\r\n      next() { // 迭代器返回的对象需要有next函数\r\n        return {\r\n          value: symbolObjTest1[index++], // value为迭代器生成的值\r\n          done: index>symbolObjTest1.length // 迭代器的终止条件，done为true时终止遍历\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfor (const iterator1 of symbolObjTest1) {\r\n  console.log(iterator1); // 打印 a b c\r\n}\r\n```\r\n#### Symbol.toStringTag\r\n- Symbol.toStringTag官方描述是一个字符串值属性，用于创建对象的默认字符串描述。由Object.property.toString()方法内部访问。\r\n- Object.property.toString()方法在开发过程中最常用场景是判断数据类型。\r\n- 自己创建的类，toString()方法只会默认返回Object标签。给类增加一个toStringTag属性，自定义的类也就拥有了自定义的类型标签。\r\n```\r\nclass TestClass {}\r\nconsole.log(Object.prototype.toString.call(new TestClass())); // '[object Object]'\r\n\r\nclass TestClass {\r\n  get [Symbol.toStringTag]() {\r\n    return \"TestToStringTag\";\r\n  }\r\n}\r\nconsole.log(Object.prototype.toString.call(new TestClass())); // '[object TestToStringTag]'\r\n```\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## WebComponent\r\n> Web Component是一种W3C标准支持的组件化方案，通过它可以编写可复用的组件，同时我们也可以对自己的组件做更精细化的控制。\r\n\r\n- Custom elements：自定义元素，通过使用对应的 api，可以在不依赖框架的情况下开发原生层面的自定义元素，它将包含独立的生命周期，以及提供了自定义属性的监听。\r\n- ShadowDOM：影子dom(最大的特点是不暴露给全局)，可以通过对应的 api，将 shadow dom 附加给自定义元素，并控制其相关功能。利用 shadow dom 的特性，起到隔离的作用，使特性保密，不用再担心所编写的脚本及样式与文档其他部分冲突。\r\n- HTML 模版：通过`<template/>、<slot/>`去实现内容分发。\r\n\r\n### 定义 TextReverse 组件，TextReverse 只有一个很简单的功能，就是把传入的 字符串颠倒显示。\r\n> 使用`<text-reverse text='123'></text-reverse>` 将会显示 321。\r\n\r\n#### 定义组件\r\n- 继承 HTMLElement，然后在 构造函数 中编写自己的初始化逻辑。\r\n  1. 初始化过程中首先创建了一个shadowRoot相当于是整个组件的一个根结点。\r\n  2. 我们获取到自身的 text 属性，并且将其倒置放入新创建的 span 元素中。\r\n  3. 我们把带有 text 的 span 塞入 shadowRoot。\r\n```\r\nclass TextReverse extends HTMLElement {\r\n  constructor() {\r\n    super();\r\n    const shadowRoot = this.attachShadow({ mode: 'open' });\r\n    const text = this.getAttribute('text') || '';\r\n    const wrapper = document.createElement('span');\r\n    wrapper.textContent = text.split('').reverse().join('');\r\n    shadowRoot.appendChild(wrapper);\r\n  }\r\n}\r\n```\r\n- 定义完成之后，需要组件注册(注册的名字必须是带短横线的)。\r\n```\r\ncustomElements.define(\r\n  'text-reverse',\r\n  TextReverse\r\n)\r\n```\r\n### Shadow Dom\r\n> 上面的例子中，我们用到了 shadow root，它承载着我们组件所有的内容。这是 Web Component 核心技术。Dom 其实就是一棵树，而我们的组件则是树上的一个节点。我们可以称组件节点为 shadow host。shadow host 中含有一颗与外界隔离的 dom 树，我们称之为 shadow tree。shadow tree 中的内容不会影响到外界。Shadow Root 则是这一课shadow tree 的根节点。\r\n\r\n![Shadow Dom](./img/webComponent.png)\r\n- shadow dom 一大亮点就是样式隔离。这种样式隔离的特性很好地避免了不同组件之间的样式干扰。\r\n\r\n### Template\r\n> 在上面的例子中，采用代码的方式来创建修改节点。这种方法比较低效。可以使用 Template 来解决这问题。 html中定义了一个 template，然后，就和操作普通元素一样获取到 template 节点，然后深拷贝一份节点内容,最后直接操作这个节点。\r\n\r\n```\r\n<template id='text-reverse'>\r\n  <style>\r\n    *{\r\n      background: red;\r\n    }\r\n  </style>\r\n  <span id='text'></span>\r\n</template>\r\nclass TextReverse extends HTMLElement {\r\n  constructor() {\r\n    super();\r\n    const shadowRoot = this.attachShadow({ mode: 'open' });\r\n    const text = this.getAttribute('text') || '';\r\n    const template = document.getElementById('text-reverse').content.cloneNode(true);\r\n    template.getElementById('text').textContent = text.split('').reverse().join('');\r\n    shadowRoot.appendChild(template);\r\n  }\r\n}\r\n```\r\n### Slot\r\n> 和 Vue 的 Slot 相似，Slot 赋予了组件更高的可扩展性。通过 Slot，可以给组件传入更多的自定义内容。模版中定义一个 slot 元素，命名为 title，并且设置一个无内容时的默认值 default title。使用的时候，我们在元素中添加一个 slot 属性来与模版中的 slot 相匹配。\r\n\r\n```\r\n<text-reverse text='12345'>\r\n  <span slot='title'>text reverse</span>\r\n</text-reverse>\r\n\r\n<template id='text-reverse'>\r\n  <h1><slot name='title'>default title</slot></h1>\r\n  <span id='text'></span>\r\n</template>\r\n```\r\n### 继承现有元素\r\n> 假如我们想扩展现有系统元素，那就需要定义一个 内置自定义元素。 以一个屏蔽数字的 p 元素为例。不再是继承 HTMLElement，而是继承需要扩展的 p节点 HTMLParagraphElement。不同于独立自定义组件，我们还是需要用原有元素名去声明，并且在 is 属性中填写我们的组件名。\r\n\r\n```\r\nclass PFilter extends HTMLParagraphElement {\r\n  constructor() {\r\n    super();\r\n    const textContent = this.textContent;\r\n    this.textContent = textContent.replace(/\\d/g, '*');\r\n  }\r\n}\r\ncustomElements.define(\r\n  'p-filter',\r\n  PFilter,\r\n  {\r\n    extends: 'p'\r\n  }\r\n)\r\n\r\n// 使用\r\n<p is='p-filter'>我的手机号是：10086</p>\r\n```\r\n### 生命周期\r\n> Web Component 也含有许多控制组件生命周期的方法。 只需在定义组件的类中声明对应的方法即可。attributeChangedCallback 相对与别的属性比较特别，他需要 搭配 observedAttributes 使用。\r\n\r\n1. connectedCallback：当 custom element首次被插入 DOM 时被调用。 \r\n2. disconnectedCallback：当 custom element 从 DOM 中删除时被调用。 \r\n3. adoptedCallback：当 custom element 被移动到新的文档时被调用。 \r\n4. attributeChangedCallback: 当 custom element 增加、删除、修改自身属性时被调用。\r\n```\r\n// 我们在 observedAttributes静态方法中添加需要监听的属性值。然后，在 text 改变的时候，触发 attributeChangedCallback方法来更新 text的值。\r\nclass TextReverse extends HTMLElement {\r\n  //...\r\n  static get observedAttributes () {\r\n    return ['text'];\r\n  }\r\n  attributeChangedCallback () {\r\n    const text = this.getAttribute('text') || '';\r\n    this.shadowRoot.getElementById('text').textContent = text.split('').reverse().join('');\r\n  }\r\n}\r\n```\r\n### 优缺点\r\n- 优点\r\n  1. 浏览器原生支持，不用加入任何依赖。\r\n  2. 多种场景适用，天生组件隔离。\r\n- 缺点\r\n  1. 跟主流的框架相比，书写较为复杂，需要开发者自己进行原生 dom 操作。\r\n  2. 若要写成单文件组件，需要采用模板字符串的写法，没有语法高亮，代码提示等。"},function(r,n,e){"use strict";e.r(n),n.default="## a == 1 && a == 2 && a == 3的值为true\r\n### a 为 Object\r\n> == 会进行隐式转化，对象通过方法valueOf和toString方法转化，重写a的对应方法即可。\r\n\r\n```\r\nconst a = {\r\n  i: 1,\r\n  // valueOf 也可达到相同效果\r\n  toString: function () {\r\n    return a.i++;\r\n  }\r\n}\r\na == 1 && a == 2 && a == 3; // true\r\n```\r\n### a 为 Array\r\n> 对于数组对象，toString方法返回一个字符串，该字符串由数组中的每个元素的toString方法返回值经调用join方法连接（由逗号隔开）组成，所以重写join方法即可。\r\n\r\n```\r\nconst a = [1, 2, 3];\r\na.join = a.shift;\r\na == 1 && a == 2 && a == 3; // true\r\n```\r\n### a 为 Number\r\n> 使用defineProperty修改读取a时的逻辑。\r\n\r\n```\r\nlet val = 0;\r\nObject.defineProperty(window, 'a', {\r\n  get: function() {\r\n    return ++val;\r\n  }\r\n});\r\na == 1 && a == 2 && a == 3 // true\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## arguments\r\n> arguments对象不能显式的创建，它只有在函数中才可用，表示当前函数的实参。它可以像访问数组那样去访问每一个子元素。arguments[0],arguments[1],....arguments[n]；通过arguments.length与funcName.length(函数的length属性表示函数形参的个数)进行比较可以判断形参与实参个数是否相等。arguments不是数组而是一个类似数组的对象。类数组只能使用for循环，不能调用数组的API。\r\n\r\n1. arguments.length 为函数实参个数。\r\n2. arguments.callee 获取函数名字，引用函数自身。使用该方法调用函数本身不用考虑函数名字变化的问题，可以用此属性实现递归，详情见下。arguments.callee.length为形参的个数。\r\n```\r\nvar sum = function(n) {\r\n  if (n === 1) {\r\n    return 1\r\n  } else {\r\n    return n + arguments.callee(n - 1)\r\n  }\r\n}\r\nconsole.log(sum(5)) // 15\r\n```\r\n### 将arguments转为数组形式\r\n- [...arguments]\r\n```\r\nfunction test(num1, num2) {\r\n  console.log(arguments); // [1, 2]\r\n  const args = [...arguments];\r\n  args.push(3);\r\n  console.log(args); // [1, 2, 3]\r\n}\r\ntest(1,2);\r\n```\r\n- Array.from(arguments)\r\n```\r\nfunction test(num1, num2) {\r\n  console.log(arguments); // [1, 2]\r\n  const args = Array.from(arguments);\r\n  args.push(3);\r\n  console.log(args); // [1, 2, 3]\r\n}\r\ntest(1,2);\r\n```\r\n- Array.prototype.slice.call()\r\n```\r\nfunction test(num1, num2) {\r\n  console.log(arguments); // [1, 2]\r\n  const args = Array.prototype.slice.call(arguments);\r\n  args.push(3);\r\n  console.log(args); // [1, 2, 3]\r\n}\r\ntest(1,2);\r\n```\r\n### 箭头函数不能使用arguments,箭头函数使用剩余参数获取实参\r\n> 箭头函数无法获取arguments对象,使用剩余参数(rest)来达到获取所有形参的目的,如果没有剩余参数,rest为空数组\r\n\r\n```\r\n// ...rest表示剩余参数\r\nconst test = (...rest) => {\r\n  console.log(rest); // [1, 2]\r\n}\r\ntest(1,2)\r\n\r\n// 必须写在形参的后面，否则会报错\r\nconst test = (num1, ...rest) => {\r\n  console.log(rest); // [2]\r\n}\r\ntest(1,2)\r\n```\r\n### 类数组\r\n- 用getElementsByTagName/ClassName()获得的HTMLCollection\r\n- 用querySelector获得的nodeList"},function(r,n,e){"use strict";e.r(n),n.default="## [async在循环中使用的问题](https://zhuanlan.zhihu.com/p/68117645)\r\n### for循环中使用async\r\n> 可以正常的使用，等待await结果才会进行下一次循环。\r\n\r\n```\r\nconst arrIds = [1, 2, 3];\r\n\r\n// 写一个sleep方法模拟异步操作\r\nconst sleep = ms => {\r\n  return new Promise(resolve => setTimeout(resolve, ms));\r\n}\r\n\r\n// 假设根据id获取count的过程是异步的\r\nconst getCount = id => {\r\n  return sleep(2000).then(() => id + 10);\r\n}\r\n\r\nconst loop_for = async () => {\r\n  console.log('start');\r\n  let result = 0;\r\n  for(let i = 0; i < arrIds.length; i++) {\r\n    const count = await getCount(arrIds[i]);\r\n    console.log(count);\r\n    result += count;\r\n  }\r\n  console.log('result', result);\r\n  console.log('end');\r\n}\r\n\r\nloop_for()\r\n\r\n// start\r\n// 11\r\n// 12\r\n// 13\r\n// result 36\r\n// end\r\n```\r\n### forEach中使用\r\n> 使用forEach发现没有达到我们预期的效果。\r\n\r\n```\r\nconst arrIds = [1, 2, 3];\r\n\r\n// 写一个sleep方法模拟异步操作\r\nconst sleep = ms => {\r\n  return new Promise(resolve => setTimeout(resolve, ms));\r\n}\r\n\r\n// 假设根据id获取count的过程是异步的\r\nconst getCount = id => {\r\n  return sleep(2000).then(() => id + 10);\r\n}\r\n\r\nconst loop_forEach = () => {\r\n  console.log('start');\r\n  let result = 0;\r\n  // 在回调函数中，异步是不好控制的\r\n  arrIds.forEach(async item => {\r\n    const count = await getCount(item);\r\n    console.log(count);\r\n    result += count;\r\n  })\r\n  console.log('result', result);\r\n  console.log('end');\r\n}\r\nloop_forEach();\r\n\r\n// start\r\n// result 0\r\n// end\r\n// 11\r\n// 12\r\n// 13\r\n```\r\n### 在forEach中合理使用async\r\n> 将循环结果存储，使用promise.all进行解析。\r\n\r\n```\r\nconst arrIds = [1, 2, 3];\r\n\r\n// 写一个sleep方法模拟异步操作\r\nconst sleep = ms => {\r\n  return new Promise(resolve => setTimeout(resolve, ms));\r\n}\r\n\r\n// 假设根据id获取count的过程是异步的\r\nconst getCount = id => {\r\n  return sleep(2000).then(() => id + 10);\r\n}\r\n\r\nconst loop_forEach = async () => {\r\n  console.log('start');\r\n  const promise = [];\r\n  // 在回调函数中，异步是不好控制的\r\n  arrIds.forEach(item => {\r\n    const count = getCount(item);\r\n    promise.push(count);\r\n  });\r\n  const res = await Promise.all(promise);\r\n  console.log('res', res);\r\n  const result = res.reduce((sum, count) => sum + count);\r\n  console.log('result', result);\r\n  console.log('end');\r\n}\r\nloop_forEach();\r\n\r\n// start\r\n// res [11, 12, 13]\r\n// result 36\r\n// end\r\n```\r\n### [在forEach中不可以使用async的原因](https://www.cnblogs.com/xjnotxj/p/10629900.html)\r\n> 在forEach的实现中，调用传入的callback时是同步调用的，没有做任何异步(await)的处理。如果将callback的调用改为await将可以正常使用，不建议修改全局forEach的使用，所以建议使用for循环。\r\n\r\n```\r\n// 默认的处理逻辑\r\nArray.prototype.myForEach = function(callback, thisArg) {\r\n  if (!((typeof callback === 'Function' || typeof callback === 'function') && this)) {\r\n    throw new TypeError();\r\n  }\r\n  const arr = Object(this);  // this 就是调用当前方法的数组\r\n  const len = arr.length >>> 0;  // 转换为正整数\r\n  let i = 0;\r\n  while (i < len) {\r\n    if (i in arr) {\r\n      callback.call(thisArg, arr[i], i, arr);\r\n    }\r\n    i++;\r\n  }\r\n}\r\n\r\n// 如果将callback的调用改为await调用将没有这个问题\r\nArray.prototype.myForEach = function(callback, thisArg) {\r\n  // ...\r\n  await callback.call(thisArg, arr[i], i, arr);\r\n  // ...\r\n}\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## async函数的错误捕获\r\n### 使用try catch\r\n- 捕获异常后执行会中断。\r\n```\r\nconst getInfo = () => (\r\n  new Promise((resolve, reject) => {\r\n    setTimeout(() => {\r\n      reject('请求异常');\r\n    }, 1000)\r\n  })\r\n);\r\n\r\nconst test = async() => {\r\n  try {\r\n    const info = await getInfo();\r\n    // 执行中断\r\n    // ...\r\n  } catch(e) {\r\n    console.log(e)\r\n  }\r\n}\r\n\r\ntest();\r\n```\r\n### 直接catch\r\n- 捕获异常后执行不会中断，返回值为undefined，如果有串行操作时需要特殊判断。\r\n```\r\nconst getInfo = () => (\r\n  new Promise((resolve, reject) => {\r\n    setTimeout(() => {\r\n      reject('请求异常');\r\n    }, 1000)\r\n  })\r\n);\r\n\r\nconst test = async() => {\r\n  const info = await getInfo().catch(e => console.log(e))\r\n  // 执行不会中断\r\n  if (!info) return;\r\n  // ...\r\n}\r\n\r\ntest();\r\n```\r\n### 在catch中reject\r\n- 捕获异常后执行会中断，但是会在控制台暴露uncaught(in promise)的报错信息。\r\n```\r\nconst getInfo = () => (\r\n  new Promise((resolve, reject) => {\r\n    setTimeout(() => {\r\n      reject('请求异常');\r\n    }, 1000)\r\n  })\r\n);\r\n\r\nconst test = async() => {\r\n  const info = await getInfo().catch(e => {\r\n    console.log(e);\r\n    return Promise.reject(e);\r\n  })\r\n  // 执行中断\r\n  // ...\r\n}\r\n\r\ntest();\r\n```\r\n### 总结\r\n- 不需要在await处异常时中断时可以使用直接catch的形式。\r\n- 需要在await处异常时终端时使用try catch的形式。\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## beforeunload事件\r\n- 当浏览器窗口关闭或者刷新时，会触发beforeunload事件。\r\n- 当阻止beforeunload事件默认行为时当前页面不会直接关闭，可以点击确定按钮关闭或刷新，也可以取消关闭或刷新。\r\n### 显示确认对话框\r\n- 根据规范要显示确认对话框，事件处理程序需要在事件上调用preventDefault()。\r\n- 并非所有浏览器都支持上述方法，有些浏览器需要事件处理程序实现两个遗留方法中的一个作为代替：\r\n  1. 将字符串分配给事件的returnValue属性。\r\n  2. 从事件处理程序返回一个字符串。\r\n### 示例\r\n- JS\r\n```\r\nwindow.addEventListener(\"beforeunload\", (event) => {\r\n  console.log('beforeunload event triggered');\r\n  // Cancel the event as stated by the standard.\r\n  event.preventDefault();\r\n  // Chrome requires returnValue to be set.\r\n  event.returnValue = \"Are you sure you want to exit?\";\r\n});\r\n```\r\n- React\r\n```\r\nconst App = () => {\r\n  useEffect(() => {\r\n    const handleTabClose = (event: any) => {\r\n      console.log('beforeunload event triggered');\r\n      // Cancel the event as stated by the standard.\r\n      event.preventDefault();\r\n      // Chrome requires returnValue to be set.\r\n      event.returnValue = \"Are you sure you want to exit?\";\r\n    };\r\n\r\n    window.addEventListener('beforeunload', handleTabClose);\r\n    return () => {\r\n      window.removeEventListener('beforeunload', handleTabClose);\r\n    };\r\n  }, []);\r\n\r\n  return (\r\n    <div>hello world</div>\r\n  );\r\n};\r\n```\r\n### 浏览器窗口关闭或者刷新时发送接口请求\r\n> 常用的异步ajax请求在unload/beforeunload事件内是不可靠的，浏览器可能会无视异步请求从而导致后端收不到。\r\n\r\n#### sendBeacon\r\n- sendBeacon设计就是用来解决页面卸载时发送请求的问题。它能保证在页面unload完成前请求能够被发送，并且由于其是异步且非阻塞的，并不会影响浏览器其它页面的显示效率。\r\n- sendBeacon只能发送http post请求。\r\n- sendBeacon无法自定义header信息。\r\n```\r\nwindow.addEventListener('beforeunload', () => {\r\n  if (window.navigator?.sendBeacon) {\r\n    const blob = new Blob([JSON.stringify(data)], {\r\n      type: 'application/json; charset=UTF-8'\r\n    });\r\n    window.navigator.sendBeacon(url, blob);\r\n  }\r\n});\r\n```\r\n#### fetch + keepalive\r\n- keepalive字段一次只能承载最大64KB的请求内容，且该限制是所有并行请求共享的，即页面卸载阶段所有fetch+keepalive请求的内容体总和不能超过64KB。\r\n- 可以发送http get请求。\r\n- 可以自定义header信息。\r\n```\r\nwindow.addEventListener('beforeunload', () => {\r\n  fetch(url, {\r\n    method: 'POST',\r\n    headers: {\r\n      \"Content-Type\": \"application/json\"\r\n    }, \r\n    body: JSON.stringify(data),\r\n    // 必须有\r\n    keepalive: true,\r\n  });\r\n})\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## encodeURI和encodeURIComponent的异同\r\n### 相同点\r\n- encodeURI和encodeURIComponent作用对象都是URL，把URL上的特殊字符转换成特殊的code。\r\n### 差异点\r\n- encodeURI会对URL保留字符编码，不会对以下字符进行编码 ASCII字母 数字 ~!*()’@#$&=:/,;?+\r\n- encodeURIComponent不会对URL保留字符编码，也不会对以下字符进行编码 ASCII字母 数字 ~!*()’\r\n### encodeURIComponent比encodeURI的编码范围更大\r\n- encodeURIComponent会把http:// 编码成 http%3A%2F%2F 而encodeURI却不会。\r\n- encodeURI编码后的URL仍可以使用，如果还需要使用编码后的URL进行网络传输则可以使用encodeURI。例如URL出现了中文，中文在网络中无法直接传输，则URL需要编码。事实上我们在浏览器中输入一个含有中文参数的URL，在发出请求后，会自动使用encodeURI进行编码。\r\n- 对于URL上的参数进行编码使用encodeURIComponent更好，如果URL上的参数中包含:/?=&这些字符，如果不加处理，会解析错误。\r\n### 总结\r\n- 对完整URL进行编码使用encodeURI，对URL上的参数进行编码使用encodeURIComponent。\r\n### URL保留字符\r\n> 保留字符是在URL中具有特殊含义或用途的字符。它们在URL的结构和解析中扮演着重要的角色，用于指示URL的不同部分或执行特定操作。\r\n\r\n- 冒号（:）：在URL中用于分隔协议和主机名，例如 http://。\r\n- 正斜杠（/）：在URL中用于分隔不同的路径段，例如 /path/to/resource。\r\n- 问号（?）：在URL中用于分隔路径和查询参数，例如 /path?param=value。\r\n- 井号（#）：在URL中用于表示片段标识符，例如 example.com/#section1。\r\n- 等号（=）：在URL中用于分隔查询参数的键和值，例如 param=value。\r\n- 和号（&）：在URL中用于分隔不同的查询参数，例如 param1=value1&param2=value2。\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## esModule和CommonJS的区别\r\n- ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 属于运行时加载，都只能在运行时确定这些东西。\r\n- ES6 模块可以加载模块的部分内容，CommonJS需要加载模块整个对象。\r\n- ES6 模块输出的是值的引用，CommonJS输出的是值的拷贝(浅拷贝)。\r\n  1. CommonJS 模块输出的是值的拷贝，一旦输出一个值，模块内部的变化就影响不到这个值。由于是值的拷贝所以是深拷贝还是浅拷贝的效果存在差异。\r\n  ```\r\n  // lib.js\r\n  var counter = 3;\r\n  function incCounter() {\r\n    counter++;\r\n  }\r\n  module.exports = {\r\n    counter: counter,\r\n    incCounter: incCounter,\r\n  };\r\n  // main.js\r\n  var mod = require('./lib');\r\n\r\n  console.log(mod.counter);  // 3\r\n  mod.incCounter();\r\n  console.log(mod.counter); // 3\r\n  ```\r\n  2. ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。原始值变了，import加载的值也会跟着变。\r\n  ```\r\n  // lib.js\r\n  export let counter = 3;\r\n  export function incCounter() {\r\n    counter++;\r\n  }\r\n\r\n  // main.js\r\n  import { counter, incCounter } from './lib';\r\n  console.log(counter); // 3\r\n  incCounter();\r\n  console.log(counter); // 4\r\n\r\n  // m1.js\r\n  export var foo = 'bar';\r\n  setTimeout(() => foo = 'baz', 500);\r\n\r\n  // m2.js\r\n  import { foo } from './m1.js';\r\n  console.log(foo); // bar\r\n  setTimeout(() => console.log(foo), 500); // baz\r\n  ```\r\n- ES6模块属于编译时加载，无法像CommonJS一般，做到运行时加载。所以有一个提案，引入import()函数，完成运行时加载，或者叫动态加载。import()和require()相同点都是运行时加载；区别在于import()属于异步加载，require()属于同步加载。\r\n### 模块循环依赖不会死循环(入口文件引用了a模块，a模块引用了b模块，b模块却又引用了a模块)\r\n- CommonJS\r\n> 循环引用要解决两个问题，避免死循环以及确定输出的值。CommonJS通过模块缓存来解决，每一个模块都先加入缓存再执行，每次遇到require都先检查缓存，这样就不会出现死循环；借助缓存输出的值也很简单就能找到了。\r\n\r\n  1. 【入口模块】开始执行，把入口模块加入缓存。\r\n  2. var a = require('./a') 执行 将a模块加入缓存，进入a模块。\r\n  3. 【a模块】exports.a = '原始值-a模块内变量'执行，a模块的缓存中给变量a初始化，为原始值。\r\n  4. 执行var b = require('./b')，将b模块加入缓存，进入b模块。\r\n  5. 【b模块】exports.b ='原始值-b模块内变量'，b模块的缓存中给变量b初始化，为原始值。\r\n  6. var a = require('./a')，尝试导入a模块，发现已有a模块的缓存，所以不会进入执行，而是直接取a模块的缓存，此时打印{ a: '原始值-a模块内变量' }。\r\n  7. exports.b = '修改值-b模块内变量 执行，将b模块的缓存中变量b替换成修改值。\r\n  8. 【a模块】console.log('a模块引用b模块：',b) 执行，取缓存中的值，打印{ b: '修改值-b模块内变量' }。\r\n  9. exports.a = '修改值-a模块内变量' 执行，将a模块缓存中的变量a替换成修改值。\r\n  10. 【入口模块】console.log('入口模块引用a模块：',a) 执行，取缓存中的值，打印{ a: '修改值-a模块内变量' }。\r\n```\r\n//index.js\r\nvar a = require('./a')\r\nconsole.log('入口模块引用a模块', a)\r\n\r\n// a.js\r\nexports.a = '原始值-a模块内变量'\r\nvar b = require('./b')\r\nconsole.log('a模块引用b模块', b)\r\nexports.a = '修改值-a模块内变量'\r\n\r\n// b.js\r\nexports.b ='原始值-b模块内变量'\r\nvar a = require('./a')\r\nconsole.log('b模块引用a模块', a)\r\nexports.b = '修改值-b模块内变量'\r\n\r\n// 输出\r\nb模块引用a模块 {a: 原始值-a模块内变量}\r\na模块引用b模块 {b: 修改值-b模块内变量}\r\n入口模块引用a模块 {a: 修改值-a模块内变量}\r\n```\r\n- ES Module\r\n> 借助模块地图，已经进入过的模块标注为获取中，遇到import语句会去检查这个地图，已经标注为获取中的则不会进入，地图中的每一个节点是一个模块记录，上面有导出变量的内存地址，导入时会做一个连接——即指向同一块内存。\r\n\r\n  1. 【入口模块】首先进入入口模块，在模块地图中把入口模块的模块记录标记为“获取中”（Fetching），表示已经进入，但没执行完毕。\r\n  2. import * as a from './a.mjs' 执行，进入a模块，此时模块地图中a的模块记录标记为“获取中”。\r\n  3. 【a模块】import * as b from './b.mjs' 执行，进入b模块，此时模块地图中b的模块记录标记为“获取中”。\r\n  4. 【b模块】import * as a from './a.mjs' 执行，检查模块地图，模块a已经是Fetching态，不再进去。\r\n  5. let b = '原始值-b模块内变量' 模块记录中，存储b的内存块初始化。\r\n  6. console.log('b模块引用a模块：', a) 根据模块记录到指向的内存中取值，是{ a:}。\r\n  7. b = '修改值-b模块内变量' 模块记录中，存储b的内存块值修改。\r\n  8. 【a模块】let a = '原始值-a模块内变量' 模块记录中，存储a的内存块初始化。\r\n  9. console.log('a模块引用b模块：', b) 根据模块记录到指向的内存中取值，是{ b: '修改值-b模块内变量' }。\r\n  10. a = '修改值-a模块内变量' 模块记录中，存储a的内存块值修改。\r\n  11. 【入口模块】console.log('入口模块引用a模块：',a) 根据模块记录，到指向的内存中取值，是{ a: '修改值-a模块内变量' }。\r\n```\r\n//index.js\r\nvar a = require('./a')\r\nconsole.log('入口模块引用a模块', a)\r\n\r\n// a.js\r\nexports.a = '原始值-a模块内变量'\r\nvar b = require('./b')\r\nconsole.log('a模块引用b模块', b)\r\nexports.a = '修改值-a模块内变量'\r\n\r\n// b.js\r\nexports.b ='原始值-b模块内变量'\r\nvar a = require('./a')\r\nconsole.log('b模块引用a模块', a)\r\nexports.b = '修改值-b模块内变量'\r\n\r\n// 输出\r\nb模块引用a模块 uninitialized\r\na模块引用b模块 {b: 修改值-b模块内变量}\r\n入口模块引用a模块 {a: 修改值-a模块内变量}\r\n```\r\n### 多次引用(入口模块引用了a、b两个模块，a、b这两个模块又分别引用了c模块，此时并不存在循环引用，但是c模块被引用了两次。)\r\n- CommonJs\r\n> c模块只被执行了一次，当第二次引用c模块时，发现已经有缓存，则直接读取，而不会再去执行一次。\r\n\r\n```\r\n//index.js\r\nvar a = require('./a')\r\nvar b= require('./b')\r\n\r\n// a.js\r\nmodule.exports.a = '原始值-a模块内变量'\r\nconsole.log('a模块执行')\r\nvar c = require('./c')\r\n\r\n// b.js\r\nmodule.exports.b = '原始值-b模块内变量'\r\nconsole.log('b模块执行')\r\nvar c = require('./c')\r\n\r\n// c.js\r\nmodule.exports.c = '原始值-c模块内变量'\r\nconsole.log('c模块执行')\r\n\r\n// 输出\r\na模块执行\r\nc模块执行\r\nb模块执行\r\n```\r\n### tree shaking\r\n> tree shaking通常用于描述移除JavaScript上下文中的未引用代码（dead-code）。如果是使用模块化开发的话，就可以删除那些引入某个模块中用不到的函数。tree shaking的实现依赖于ESM的静态分析能力，会在编译过程中静态分析模块之间的导入导出，确定ESM模块中哪些导出值未曾其它模块使用，并将其删除，以此实现打包产物的优化。import和export可以实现tree shaking，但是直接export default整个对象或者使用CommonJS的语法是无法实现的。"},function(r,n,e){"use strict";e.r(n),n.default="## forEach的局限\r\n- 不支持处理异步函数\r\n> 因为forEach内部调用传入的callback时是同步调用的，没有做任何异步(await)的处理。\r\n\r\n- 除了抛出异常以外，没有办法中止或跳出forEach循环。\r\n- index不可被重置，在forEach中我们无法控制index的值，它只会无脑的自增直至大于数组的length跳出循环。\r\n- forEach性能比for循环低，for循环没有额外的函数调用栈和上下文，所以它的实现最为简单。"},function(r,n,e){"use strict";e.r(n),n.default="## hasOwnProperty与in的区别\r\n### 相同点\r\n- hasOwnProperty与in都可以检测一个对象上是否有某个属性。\r\n### 区别\r\n- in是判断对象本身和对象原型链上是否有这个属性。\r\n- hasOwnProperty是判断对象本身是否有这个属性，不会去原型链上查找。\r\n```\r\nconst Person = function(age) {\r\n  this.age = age;\r\n}\r\nPerson.prototype.name = 'dyx';\r\n\r\nconst p1 = new Person(26);\r\n\r\nconsole.log('age' in p1);  // true \r\nconsole.log('name' in p1); // true\r\nconsole.log('toString' in p1); // true\r\n\r\nconsole.log(p1.hasOwnProperty('age')); // true\r\nconsole.log(p1.hasOwnProperty('name')); // false，原型链上的name属性检测不到\r\nconsole.log(p1.hasOwnProperty('toString')); // false，原型链上的toString属性检测不到\r\n```\r\n### eslint报错Do not access Object.prototype method 'hasOwnProperty' from target object\r\n- eslint提示\r\n```\r\nobj.hasOwnProperty(key);\r\n```\r\n- eslint不提示\r\n```\r\nObject.prototype.hasOwnProperty.call(obj, key);\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## 事件流\r\n> 满足同时触发多个事件时(一次点击会触发多个不同DOM上的事件)的执行顺序：一个完整的事件流是从window开始，最后回到window的过程。并且被分为捕获阶段、目标阶段、冒泡阶段。\r\n\r\n- 捕获阶段：触发的事件从window发出，不断经过下级节点直到触发的目标节点。在到达目标节点之前的过程就是捕获阶段。\r\n- 目标阶段：触发的事件不断的传递直到目标节点的时候，最终在目标节点上触发这个事件，就是目标阶段。\r\n- 冒泡阶段：触发的事件由最精确的元素(事件发生所在的节点)然后逐级传播到较为不精确的节点的过程就是冒泡阶段。\r\n### 事件级别\r\n> DOM级别一共可以分为四个级别：DOM0级、DOM1级、DOM2级和DOM3级。而DOM事件分为3个级别：DOM0级事件处理、DOM2级事件处理和DOM3级事件处理。因为DOM1级标准没有定义事件相关的内容，所以没有所谓的1级DOM事件模型。\r\n\r\n### DOM0级事件处理\r\n> 将一个函数赋值给一个事件处理属性。\r\n\r\n```\r\n<body>\r\n\t<div></div>\r\n</body>\r\n\r\n<script type=\"text/javascript\">\r\n  const div = document.querySelector(\"div\");\r\n  div.onclick = function(){}\r\n<\/script>\r\n```\r\n### DOM2级处理事件\r\n> 定义了addEventListener和removeEventListener两个方法分别用来绑定和解绑事件。方法中包含三个参数分别是绑定的事件处理的属性名称、处理函数、是否在捕获时候执行事件处理函数。默认使用冒泡流，第三个参数设为true时使用捕获流。\r\n\r\n```\r\n<body>\r\n\t<div></div>\r\n</body>\r\n\r\n<script type=\"text/javascript\">\r\n  const div = document.querySelector(\"div\");\r\n  div.addEventListener('click', function(){}, false);\r\n<\/script>\r\n```\r\n### DOM3级处理事件\r\n> 在DOM2级事件的基础上添加了更多的事件类型，如滚动事件、触摸事件、过渡事件等。\r\n\r\n### 总结\r\n- 0级只能定义一个事件，多事件会相互覆盖。\r\n- 2级多了自定义事件，并且还有事件冒泡和捕获；可以给一个事件添加多个处理函数。\r\n- 3级添加了更多的事件类型。\r\n### 事件冒泡和事件捕获\r\n- 事件冒泡：事件按照从最精确的事件目标到最不精确的事件目标的顺序触发。\r\n```\r\n<div id='one'>\r\n  <div id='two'>\r\n    <div id='three'>\r\n      <div id='four'>\r\n        Event\r\n      </div>\r\n    </div>\r\n  </div>\r\n</div>\r\n\r\n<script type='text/javascript'>\r\n  const one=document.getElementById('one');\r\n  const two=document.getElementById('two');\r\n  const three=document.getElementById('three');\r\n  const four=document.getElementById('four');\r\n\r\n  one.addEventListener('click', function() {\r\n    alert('one');\r\n  }, false);\r\n\r\n  two.addEventListener('click', function() {\r\n    alert('two');\r\n  }, false);\r\n\r\n  three.addEventListener('click', function() {\r\n    alert('three');\r\n  }, false);\r\n\r\n  four.addEventListener('click', function() {\r\n    alert('four');\r\n  }, false);\r\n<\/script>\r\n// 点击之后弹框顺序是four、three、two、one。\r\n```\r\n- 事件捕获：事件按照从最不精确的事件目标到最精确的事件目标的顺序触发。\r\n```\r\n<div id='one'>\r\n  <div id='two'>\r\n    <div id='three'>\r\n      <div id='four'>\r\n        Event\r\n      </div>\r\n    </div>\r\n  </div>\r\n</div>\r\n\r\n<script type='text/javascript'>\r\n  const one=document.getElementById('one');\r\n  const two=document.getElementById('two');\r\n  const three=document.getElementById('three');\r\n  const four=document.getElementById('four');\r\n\r\n  one.addEventListener('click', function() {\r\n    alert('one');\r\n  }, true);\r\n\r\n  two.addEventListener('click', function() {\r\n    alert('two');\r\n  }, true);\r\n\r\n  three.addEventListener('click', function() {\r\n    alert('three');\r\n  }, true);\r\n\r\n  four.addEventListener('click', function() {\r\n    alert('four');\r\n  }, true);\r\n<\/script>\r\n// 点击之后弹框顺序是one、two、three、four。\r\n```\r\n### 事件对象\r\n> 在触发DOM上的某个事件时，会产生一个事件对象event，这个对象中包含着所有与事件有关的信息。只有在事件处理程序执行期间，event对象才会存在。一旦事件处理程序执行完成，event对象就会被销毁。\r\n\r\n- currentTarget、target\r\n> target指向事件流的目标阶段对象，currentTarget指向事件流在捕获、目标、冒泡阶段事件活动的对象。只有当事件流处在目标阶段的时候，两个的指向才是一样的，而当处于捕获和冒泡阶段的时候，target指向被触发的对象而currentTarget指向当前事件活动的对象。\r\n\r\n- event.type代表事件的类型如click\r\n- event.preventDefault()阻止事件的默认事件\r\n- stopPropagation()用于立即停止事件在DOM层次中的传播，即取消进一步的事件捕获或冒泡\r\n- e.persist() // 异步回调后事件对象的继续使用\r\n- eventPhase\r\n    - 用来确定事件当前正位于事件流的哪个阶段。捕获阶段：eventPhase = 1；处于目标对象上：eventPhase = 2；冒泡阶段：eventPhase = 3；\r\n    - 当eventPhase等于2时，this、target、currentTarget始终是相等的。\r\n```\r\n// 首先执行的事件是在捕获阶段触发的添加到document.body中的那一个，eventPhase为1。\r\n// 其次会触发在按钮上注册的事件处理程序(因为第三个参数设置为true，表示使用捕获流)，eventPhase为2。\r\n// 最后在冒泡阶段触发添加到document.body中的那一个，eventPhase为3。 \r\nbtn.onclick = function(event) {\r\n  alert(event.eventPhase); // 2\r\n}\r\ndocument.body.addEventListener(\"click\", function(event) {\r\n   alert(event.eventPhase); // 1\r\n}, true);\r\ndocument.body.onclick = function(event) {\r\n  alert(event.eventPhase); // 3\r\n}\r\n```\r\n### 自定义事件\r\n- 监听自定义prize事件\r\n```\r\ndocument.addEventListener('prize', () => {\r\n  // 监听prize事件\r\n})\r\n```\r\n- 触发自定义prize事件\r\n```\r\ndocument.dispatchEvent(new CustomEvent('prize'))\r\n```\r\n### 同一个元素既有click事件又有addEventListener事件，点击之后两个事件都会触发，且先执行addEventListener的事件后执行click的事件。\r\n### 阻止事件传播\r\n1. 阻止冒泡：stopPropagation()；IE下：cancelBubble = true。\r\n2. 默认事件阻止：preventDefault()；IE下：window.event.returnValue = false。\r\n### 获取元素绑定的事件getEventListeners\r\n- getEventListeners(window) 获取window上绑定的事件。"},function(r,n,e){"use strict";e.r(n),n.default='## js加载方式\r\n### 正常模式(同步加载)\r\n- 默认情况下浏览器是同步下载js脚本，浏览器会立即下载并执行相应的脚本，这种情况下js下载会阻塞dom渲染。\r\n- 如果脚本体积很大，下载和执行的时间就会很长，因此造成浏览器堵塞，用户会感觉到浏览器“卡死”了，没有任何响应。\r\n```\r\n<script src="index.js"><\/script>\r\n```\r\n### async模式(异步加载)\r\n- async模式下js下载是异步的，js下载结束会立即执行，js下载不会阻塞dom渲染。\r\n- async模式下js下载是无顺序的，当js下载结束会立即执行，渲染引擎就会中断渲染，执行完这个脚本以后，再继续渲染。\r\n- 若该js资源与dom元素没有依赖关系，也不会产生其他资源所需要的数据时，可以使用async模式，比如埋点统计。\r\n```\r\n<script async src="index.js"><\/script>\r\n```\r\n### defer模式(延迟加载)\r\n- defer模式下js下载也是异步的，会在文档完成解析后触发DOMContentLoaded事件前执行js资源，js下载不会阻塞dom渲染。\r\n- defer模式下js下载是有顺序的，如果有多个设置了defer的script标签存在，则会按照引入的前后顺序执行，即便是后面的script资源先返回。\r\n- 一般情况下都可以使用defer，特别是需要控制资源执行顺序时，比如element-ui.js和vue.js，因为element-ui.js依赖于vue，所以必须先引入vue.js再引入element-ui.js。\r\n```\r\n<script defer src="vue.js"><\/script>\r\n<script defer src="element-ui.js"><\/script>\r\n```\r\n### module模式\r\n- 在主流的现代浏览器中script标签的属性可以加上type="module"，浏览器会对其内部的import引用发起HTTP请求获取模块内容。\r\n- 这时script的行为会像defer模式一样，异步下载js并且会在文档完成解析后触发DOMContentLoaded事件前执行js资源。\r\n- vite就是利用浏览器支持原生的ES Module，开发时跳过打包的过程提升编译效率。\r\n```\r\n<script type="module">\r\n  import { a } from \'./a.js\';\r\n<\/script>\r\n```\r\n### async与defer\r\n- async和defer属性仅仅对外部脚本起作用。\r\n- async和defer属性都会异步下载js脚本，js脚本下载都不会阻塞页面的解析，但是js的执行一定是和UI线程是互斥的。\r\n- async是下载完就执行，defer是渲染完再执行。\r\n\r\n![js加载](./img/js加载.png)\r\n![js加载方式](./img/js加载方式.png)\r\n'},function(r,n,e){"use strict";e.r(n),n.default="## new操作符\r\n### new操作符的流程\r\n1. 创建一个新对象。\r\n2. 为第一步创建的对象添加原型属性(`__proto__`)属性值等于构造函数的原型对象。\r\n3. 将this指向这个新对象。\r\n4. 执行构造函数，属性和方法被添加到this指向的对象中。\r\n5. 如果构造函数返回非空对象，则返回该对象，否则返回刚创建的新对象。\r\n\r\n### 实现new操作符\r\n```\r\nfunction myNew(Con, ...args) {\r\n  // 创建空对象\r\n  let obj = {};\r\n  // 为对象添加原型属性\r\n  obj._proto_ = Con.prototype;\r\n  // 绑定 this 并执行构造函数(为对象设置属性)\r\n  const res = Con.apply(obj, args);\r\n  // 判断构造函数是否有返回值\r\n  if (res && typeof res === 'object' || typeof res === 'function') {\r\n    return res;\r\n  }\r\n  return obj;\r\n}\r\n\r\n// 构造函数\r\nfunction Test(name, age) {\r\n  this.name = name;\r\n  this.age = age;\r\n}\r\nTest.prototype.sayName = function() {\r\n  console.log(this.name);\r\n}\r\n\r\n// 实现一个 new 操作符\r\nconst a = myNew(Test, 'dyx', '26')\r\nconsole.log(a.age) // '26'\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## promise\r\n### Promise中的代码是同步执行的，then方法中是异步执行的\r\n```\r\n// 输出结果是 1 3 4 2\r\nnew Promise(resolve => {\r\n  console.log(1);\r\n  resolve(2);\r\n  console.log(3);\r\n}).then(res => console.log(res));\r\nconsole.log(4)\r\n```\r\n### Promise一旦状态改变，就不会再变,后序的操作会执行(可以使用return语句停止后面语句的执行)但是不影响Promise的状态,并且不会影响返回的结果\r\n```\r\n// 输出结果1\r\nnew Promise((resolve, reject) => {\r\n  resolve(1);\r\n  reject(2);\r\n  resolve(3)\r\n}).then(\r\n  res => console.log(res)\r\n).catch(\r\n  err => console.log(err)\r\n)\r\n```\r\n### then方法\r\n- then方法的第一个参数是resolved状态的回调函数，第二个参数（可选）是rejected状态的回调函数。\r\n```\r\nnew Promise((resolve, reject) => {\r\n  resolve(1);\r\n}).then(\r\n  res => console.log(res), // 1\r\n  err => console.log(err)\r\n)\r\n\r\nnew Promise((resolve, reject) => {\r\n  reject(1);\r\n}).then(\r\n  res => console.log(res),\r\n  err => console.log(err) // 1\r\n)\r\n```\r\n- then方法返回一个Promise对象，所以then方法可以链式调用。\r\n```\r\n// 输出 1 2\r\nnew Promise(resolve => {\r\n  resolve(1);\r\n}).then(\r\n  res => {\r\n    console.log(res);\r\n    return 2;\r\n  }\r\n).then(res => console.log(res))\r\n```\r\n### catch方法\r\n> 用于获取Promise中抛出的错误或者rejected状态返回的结果，效果等同于then方法中第二个参数的作用，then方法使用两个参数时，catch方法不生效。抛出错误不能return Error对象，需要throw Error对象或者使用reject。\r\n\r\n```\r\nnew Promise((resolve, reject) => {\r\n  // throw new Error('error');\r\n  reject('123')\r\n}).then(\r\n  res => {\r\n    console.log(res);\r\n    return 2;\r\n  },\r\n  err => console.log(err) // 输出结果\r\n).catch(\r\n  err => console.log(err) // 不执行\r\n)\r\n\r\n// catch 可以捕获then方法中抛出的错误, then方法的第二个参数不能捕获第一个参数中抛出的错误，只能捕获前面Promise实例抛出的错误\r\nPromise.resolve(123).then(\r\n  res => {\r\n    throw new Error('err')\r\n  },\r\n  err => console.log(err)\r\n).catch(\r\n  err => console.log(err) // 捕获错误信息\r\n)\r\n\r\n// 可以使用链式调用then方法的形式捕获上一个then方法抛出的错误\r\nPromise.resolve(123).then(\r\n  res => {\r\n    throw new Error('err')\r\n  },\r\n  err => console.log(err)\r\n).then(\r\n  res => console.log(res),\r\n  err => console.log(err) // 捕获错误信息\r\n)\r\n```\r\n### finally方法\r\n> 不管 Promise 对象最后状态如何，都会执行的操作\r\n\r\n```\r\nnew Promise((resolve, reject) => {\r\n  reject(1);\r\n}).then(\r\n  res => console.log(res)\r\n).catch(\r\n  err => console.log(err) // 1\r\n).finally(res => console.log('dyx')) // 'dyx'\r\n```\r\n### then 或者 catch 可以被调用多次，但 Promise 构造函数只执行一次。后续每次调用 then 或者 catch 都会直接拿到第一次执行的结果。\r\n- then 或 catch 返回的值不能是 当前Promise 本身，否则会造成死循环\r\n- then 或者 catch 的参数期望是函数，如果传入非函数会将最前面的Promsie的值传递过去\r\n```\r\n// 最后console的res是'123',前面的then方法中的console.log(1)依然会执行\r\nnew Promise((resolve, reject) => {\r\n  resolve('123')\r\n}).then('dyx').then(console.log(1)).then(res => console.log(res))\r\n```\r\n- 如果传入函数后面的then方法接收到的值为前面then方法中返回的值\r\n```\r\n// 最后console的res是undefined,因为前面的then方法中的函数没有return任何值\r\nnew Promise((resolve, reject) => {\r\n  resolve('123')\r\n}).then(() => 'dyx').then(() => console.log(1)).then(res => console.log(res))\r\n```\r\n### Promise.all\r\n> 接受一个数组作为参数，数组中的每一个参数都是一个promise实例。适用于对同一接口调用多次只是调用参数不同的情况。所有的Promise实例都为resolved才会返回Promise.all的结果，有Promise实例rejected时会立即返回当前rejected的结果，后序的Promise实例依然会执行，只是不影响整体的返回结果。当rejected的实例自定义了catch方法会将此实例的结果看为resolved，值为定义的catch方法的返回值。\r\n\r\n- 所有的Promise实例的结果为resolved的时候，Promise.all会返回一个数组的结果，数组内容为每一个Promise实例的返回结果\r\n```\r\n// 输出顺序是 1 2 [1,2]\r\nvar p1 = new Promise(resolve => {\r\n  setTimeout(() => {\r\n    console.log(1);\r\n    resolve(1)\r\n  }, 500);\r\n});\r\nvar p2 = new Promise(resolve => {\r\n  setTimeout(() => {\r\n    console.log(2);\r\n    resolve(2)\r\n  }, 600);\r\n});\r\nPromise.all([p1, p2]).then(res => {\r\n  console.log(res);  // [1,2]\r\n});\r\n```\r\n- 所有的Promise实例中有一个被rejected，Promise.all的状态就变成rejected，此时第一个被reject的实例的返回值会作为Promise.all的返回值，后序的Promsie实例依然会执行，只是不影响最终的结果\r\n```\r\n// 输出顺序是1 err 2\r\nvar p1 = new Promise((resolve, reject) => {\r\n  setTimeout(() => {\r\n    console.log(1);\r\n    reject('err')\r\n  }, 500);\r\n})\r\nvar p2 = new Promise(resolve => {\r\n  setTimeout(() => {\r\n    console.log(2);\r\n    resolve(2)\r\n  }, 600);\r\n});\r\nPromise.all([p1, p2]).then(\r\n  res => console.log(res),\r\n  err => console.log(err) // err\r\n)\r\n```\r\n- 如果作为参数的Promise 实例，自己定义了catch方法，那么一旦被rejected，并不会触发Promise.all()的catch方法,只会触发这个实例的catch方法\r\n```\r\n// 输出顺序是1 'err' 2 ['err', 2]\r\nvar p1 = new Promise((resolve, reject) => {\r\n  setTimeout(() => {\r\n    console.log(1);\r\n    reject('err')\r\n  }, 500);\r\n}).catch(err => {\r\n  console.log(err) // err\r\n  return err;\r\n}) \r\nvar p2 = new Promise(resolve => {\r\n  setTimeout(() => {\r\n    console.log(2);\r\n    resolve(2)\r\n  }, 600);\r\n});\r\nPromise.all([p1, p2]).then(\r\n  res => console.log(res) // ['err', 2]\r\n).catch(err => console.log(err))\r\n```\r\n### Promise.race\r\n> Promise.race同样接受一个数组作为参数，数组中的每一个参数都是一个promise实例。适用于多个接口调用有其中一个成功即可的场景。只要有一个Promise实例都为resolved就会返回Promise.race的结果，有Promise实例rejected时会立即返回当前rejected的结果，后序的Promise实例依然会执行，只是不影响整体的返回结果。当rejected的实例自定义了catch方法会将此实例的结果看为resolved，值为定义的catch方法的返回值。\r\n\r\n- Promise.race根据传入的实例，一旦有Promsie实例为resolved，则将该实例的结果作为Promise.race的结果返回，后序的Promise实例的依然会执行只是运行结果不会影响最终结果。\r\n```\r\n// 输出结果为 1 1 2\r\nvar p1 = new Promise(resolve => {\r\n  setTimeout(() => {\r\n    console.log(1);\r\n    resolve(1)\r\n  }, 500);\r\n});\r\nvar p2 = new Promise(resolve => {\r\n  setTimeout(() => {\r\n    console.log(2);\r\n    resolve(2)\r\n  }, 600);\r\n});\r\nPromise.race([p1, p2]).then(res => {\r\n  console.log(res);  // 1\r\n});\r\n```\r\n- 一旦有Promise实例为rejected，也将作为结果返回，后序的Promsie实例依然会执行，只是不影响最终的结果。\r\n```\r\n// 输出结果为 1 err 2\r\nvar p1 = new Promise((resolve, reject) => {\r\n  setTimeout(() => {\r\n    console.log(1);\r\n    reject('err')\r\n  }, 500);\r\n});\r\nvar p2 = new Promise(resolve => {\r\n  setTimeout(() => {\r\n    console.log(2);\r\n    resolve(2)\r\n  }, 600);\r\n});\r\nPromise.race([p1, p2]).then(res => {\r\n  console.log(res);  \r\n}).catch(err => console.log(err)); // err\r\n```\r\n- 如果作为参数的Promise 实例，自己定义了catch方法，那么一旦被rejected，并不会触发Promise.race()的catch方法,只会触发这个实例的catch方法\r\n```\r\n// 输出顺序是1 'err' 'err' 2\r\nvar p1 = new Promise((resolve, reject) => {\r\n  setTimeout(() => {\r\n    console.log(1);\r\n    reject('err')\r\n  }, 500);\r\n}).catch(err => {\r\n  console.log(err) // err\r\n  return err;\r\n})\r\nvar p2 = new Promise(resolve => {\r\n  setTimeout(() => {\r\n    console.log(2);\r\n    resolve(2)\r\n  }, 600);\r\n});\r\nPromise.race([p1, p2]).then(\r\n  res => console.log(res) // 'err'\r\n).catch(err => console.log(err))\r\n```\r\n### Promise.any\r\n> Promise.any同样接受一个数组作为参数，数组中的每一个参数都是一个promise实例。和Promise.race相似，只是不会因为某个 Promise 变成rejected状态而结束。只要有Promise实例为resolved就会返回Promise.any的结果，当所有Promise实例rejected时会返回一个error信息。当rejected的实例自定义了catch方法会将此实例的结果看为resolved，值为定义的catch方法的返回值。\r\n\r\n- Promise.any根据传入的实例，一旦有Promsie实例为resolved，则将该实例的结果作为Promise.any的结果返回，后序的Promise实例的依然会执行只是运行结果不会影响最终结果。\r\n```\r\n// 输出结果为 1 1 2\r\nvar p1 = new Promise(resolve => {\r\n  setTimeout(() => {\r\n    console.log(1);\r\n    resolve(1)\r\n  }, 500);\r\n});\r\nvar p2 = new Promise(resolve => {\r\n  setTimeout(() => {\r\n    console.log(2);\r\n    resolve(2)\r\n  }, 600);\r\n});\r\nPromise.any([p1, p2]).then(res => {\r\n  console.log(res);  // 1\r\n});\r\n```\r\n- 有Promise实例为rejected，不会将reject结果返回，而是会返回后续执行中实例为resolve的结果，后序的Promsie实例依然会执行，只是不影响最终的结果。\r\n```\r\n// 输出结果为 1 2 2\r\nvar p1 = new Promise((resolve, reject) => {\r\n  setTimeout(() => {\r\n    console.log(1);\r\n    reject('err')\r\n  }, 500);\r\n});\r\nvar p2 = new Promise(resolve => {\r\n  setTimeout(() => {\r\n    console.log(2);\r\n    resolve(2)\r\n  }, 600);\r\n});\r\nPromise.any([p1, p2]).then(res => {\r\n  console.log(res);  // 2\r\n}).catch(err => console.log(err)); \r\n```\r\n- 当所有的实例都reject时，会返回一个error信息，表示所有的Promise实例都rejected\r\n```\r\n// 输出结果为 1 2 All promises were rejected\r\nvar p1 = new Promise((resolve, reject) => {\r\n  setTimeout(() => {\r\n    console.log(1);\r\n    reject('err')\r\n  }, 500);\r\n});\r\nvar p2 = new Promise((resolve, reject) => {\r\n  setTimeout(() => {\r\n    console.log(2);\r\n    reject(2)\r\n  }, 600);\r\n});\r\n\r\nPromise.any([p1, p2]).then(res => {\r\n  console.log(res); \r\n}).catch(err => console.log(err)); // All promises were rejected\r\n```\r\n- 如果作为参数的Promise 实例，自己定义了catch方法，那么一旦被rejected，并不会触发Promise.any()的catch方法,只会触发这个实例的catch方法\r\n```\r\n// 输出结果为 1 'err' 'err' 2\r\nvar p1 = new Promise((resolve, reject) => {\r\n  setTimeout(() => {\r\n    console.log(1);\r\n    reject('err')\r\n  }, 500);\r\n}).catch(err => {\r\n  console.log(err) // 'err'\r\n  return err\r\n});\r\nvar p2 = new Promise((resolve, reject) => {\r\n  setTimeout(() => {\r\n    console.log(2);\r\n    reject(2)\r\n  }, 600);\r\n});\r\n\r\nPromise.any([p1, p2]).then(res => {\r\n  console.log(res); // 'err'\r\n}).catch(err => console.log(err));\r\n```\r\n### Promise.allSettled\r\n> Promise.allSettled同样接受一个数组作为参数，数组中的每一个参数都是一个promise实例。只有等到所有这些参数实例都返回结果，不管是fulfilled还是rejected，allSettled才会结束。当rejected的实例自定义了catch方法会将此实例的结果看为resolved，值为定义的catch方法的返回值。\r\n\r\n- 当所有的实例都为resolve时\r\n```\r\n// 输出结果为 1 2 [{status: \"fulfilled\", value: 1}, {status: \"fulfilled\", value: 2}]\r\nvar p1 = new Promise(resolve => {\r\n  setTimeout(() => {\r\n    console.log(1);\r\n    resolve(1)\r\n  }, 500);\r\n});\r\nvar p2 = new Promise(resolve => {\r\n  setTimeout(() => {\r\n    console.log(2);\r\n    resolve(2)\r\n  }, 600);\r\n});\r\nPromise.allSettled([p1, p2]).then(res => {\r\n  console.log(res);  // [{status: \"fulfilled\", value: 1}, {status: \"fulfilled\", value: 2}]\r\n});\r\n```\r\n- 当所有的实例都为reject时\r\n```\r\n// 输出结果为 1 2 [{status: \"rejected\", reason: 1}, {status: \"rejected\", reason: 2}]\r\nvar p1 = new Promise((resolve, reject) => {\r\n  setTimeout(() => {\r\n    console.log(1);\r\n    reject(1)\r\n  }, 500);\r\n});\r\nvar p2 = new Promise((resolve, reject) => {\r\n  setTimeout(() => {\r\n    console.log(2);\r\n    reject(2)\r\n  }, 600);\r\n});\r\nPromise.allSettled([p1, p2]).then(res => {\r\n  console.log(res);  // [{status: \"rejected\", reason: 1}, {status: \"rejected\", reason: 2}]\r\n}).catch(err => console.log(err));\r\n```\r\n- 有的实例resolve，有的reject时\r\n```\r\n// 输出结果为 1 2 [{status: \"fulfilled\", value: 1}, {status: \"rejected\", reason: 2}]\r\nvar p1 = new Promise((resolve, reject) => {\r\n  setTimeout(() => {\r\n    console.log(1);\r\n    resolve(1)\r\n  }, 500);\r\n});\r\nvar p2 = new Promise((resolve, reject) => {\r\n  setTimeout(() => {\r\n    console.log(2);\r\n    reject(2)\r\n  }, 600);\r\n});\r\nPromise.allSettled([p1, p2]).then(res => {\r\n  console.log(res);  // [{status: \"fulfilled\", value: 1}, {status: \"rejected\", reason: 2}]\r\n}).catch(err => console.log(err));\r\n```\r\n- 其中一个promise没有结果，则什么都结果都拿不到\r\n```\r\n// 输出结果为 1 \r\nvar p1 = new Promise((resolve, reject) => {\r\n  setTimeout(() => {\r\n    console.log(1);\r\n    resolve(1)\r\n  }, 500);\r\n});\r\nvar p2 = new Promise((resolve, reject) => {});\r\nPromise.allSettled([p1, p2]).then(res => {\r\n  console.log(res);  // 不会返回任何结果\r\n}).catch(err => console.log(err));\r\n```\r\n- 当reject的实例自定义catch时\r\n```\r\n// 输出结果为 1 2 2 [{status: \"fulfilled\", value: 1}, {status: \"fulfilled\", reason: 2}]\r\nvar p1 = new Promise((resolve, reject) => {\r\n  setTimeout(() => {\r\n    console.log(1);\r\n    resolve(1)\r\n  }, 500);\r\n});\r\nvar p2 = new Promise((resolve, reject) => {\r\n  setTimeout(() => {\r\n    console.log(2);\r\n    reject(2)\r\n  }, 600);\r\n}).catch(err => {\r\n  console.log(err)\r\n  return err;\r\n});\r\nPromise.allSettled([p1, p2]).then(res => {\r\n  console.log(res);  // [{status: \"fulfilled\", value: 1}, {status: \"fulfilled\", reason: 2}]\r\n}).catch(err => console.log(err));\r\n```\r\n### Promsie实现简单的延时效果\r\n```\r\nconst delay = time => new Promise(resolve => {\r\n  setTimeout(resolve, time)\r\n})\r\ndelay(3000).then(() => {\r\n  console.log(\"三秒以后执行\")\r\n})\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## promiseAll控制并发\r\n> 比如有几百个存储操作，不能要一次性去全部执行，而是要控制一次性只能执行10个操作，10个中有一个执行完了，就拿还没执行的操作补上去，就这样一直到这几百个操作全部执行完为止。减少服务器的并发压力\r\n\r\n- 从第1个异步操作开始，初始化promise对象，同时用一个executing数组保存正在执行的promise。\r\n- 不断初始化promise，直到达到poolLimt。\r\n- 使用Promise.race，获得executing中promise的执行情况，当有一个promise执行完毕，继续初始化promise并放入executing中。\r\n- 所有异步操作都执行了，调用Promise.all返回。\r\n```\r\nfunction asyncPool(poolLimit, array, iteratorFn) {\r\n  let i = 0;\r\n  const ret = [];\r\n  const executing = [];\r\n  const enqueue = function () {\r\n    // 当所有的异步都处理之后返回一个resolve状态的promise\r\n    if (i === array.length) {\r\n      return Promise.resolve();\r\n    }\r\n    // 每调一次enqueue，初始化一个promise\r\n    const item = array[i++];\r\n    const p = new Promise(resolve => resolve(iteratorFn(item)))\r\n    // 将当前的promise放入最终结果的数组中\r\n    ret.push(p);\r\n    // promise执行完毕，从executing数组中删除\r\n    const e = p.then(() => executing.splice(executing.indexOf(e), 1));\r\n    // 正在执行的promise插入executing数组，用于表示正在执行的数据\r\n    executing.push(e);\r\n    let r = Promise.resolve();\r\n    // 默认Promise状态为resolve，每当executing数组中promise数量大于等于poolLimit，使用Promise.race判断进行中的promise是否有完成的实例从而判断是否要实例化新的promise并执行\r\n    if (executing.length >= poolLimit) {\r\n      r = Promise.race(executing);\r\n    }\r\n    // 递归，直到遍历完array\r\n    return r.then(() => enqueue());\r\n  };\r\n\r\n  // 当所有的异步操作都处理之后才执行Promise.all\r\n  return enqueue().then(() => Promise.all(ret));\r\n}\r\n\r\n// 使用\r\nconst timeout = i => new Promise(resolve => setTimeout(() => resolve(i), i));\r\nasyncPool(2, [1000, 5000, 3000, 2000], timeout).then(results => {\r\n  console.log(results);\r\n});\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## [requestIdleCallback](https://juejin.cn/post/7221793823705268284)\r\n- requestIdleCallback()方法传入一个函数，这个函数将在浏览器空闲时期被调用。这使开发者能够在主事件循环上执行后台和低优先级工作，而不会影响延迟关键事件如动画和输入响应。\r\n- 传如函数一般会按先进先调用的顺序执行，如果回调函数指定了执行超时时间timeout，则有可能为了在超时前执行函数而打乱执行顺序。如果指定了超时时间，会在超时后的下一帧强制执行。\r\n- 建议为必要的工作设置timeout选项，否则在回调触发之前可能已经过去了很多秒。\r\n- 可以在空闲回调函数中调用requestIdleCallback()，以便在下一次通过事件循环之前调度另一个回调。\r\n- 对于长时间任务的优化首先考虑的是Web Worker使其不占用主线程，如果需要操作DOM可以使用requestIdleCallback将长时间任务进行拆分，保证这些任务只在空闲时间执行。每次执行下一个任务的时候，先检查一下当前页面是否该渲染下一帧了，这时会把主线程让出来让页面进行渲染。\r\n```\r\nconst id = window.requestIdleCallback((deadline) => {\r\n  // 当前帧剩余时间大于0，或任务已超时\r\n  if (deadline.timeRemaining() > 0 || deadline.didTimeout) {\r\n    // do something\r\n    console.log(1)\r\n  }\r\n}, { timeout: 2000 }) // 指定超时时间\r\n```\r\n### requestIdleCallback在Event Loop的执行流程\r\n![requestIdleCallback执行](./img/requestIdleCallback%E6%89%A7%E8%A1%8C.png)\r\n![requestIdleCallback渲染](./img/requestIdleCallback%E6%B8%B2%E6%9F%93.png)\r\n### 模拟requestIdleCallback\r\n- requestIdleCallback兼容性不够好，Safari完全不支持。\r\n- 可以使用requestAnimationFrame和MessageChannel来模拟实现一个requestIdleCallback。\r\n- requestAnimationFrame在每一帧开始渲染前执行，当帧开始渲染前标记开始时间(start)，并使用MessageChannel创建一个宏任务，根据上面的Event Loop执行流程，渲染完毕后会执行刚才创建出的宏任务，这时在宏任务中判断当前帧渲染耗费的时间(current - start)，判断渲染耗时是否小于16.7ms(current - start < 16.7)，来判断当前是否是空闲时间。\r\n- setTimeout即使指定时间为0浏览器实际也会延时几毫秒后才执行(chrome大概为4ms)，因此使用MessageChannel而不是setTimeout来创建宏任务。\r\n![requestAnimationFrame执行](./img/requestAnimationFrame%E6%89%A7%E8%A1%8C.png)\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## setTimeout和setInterval\r\n### setTimeout\r\n> 在指定的毫秒数后执行指定代码(只执行一次)。\r\n\r\n```\r\n// 使用setTimeout模拟setInterval\r\nfunction tick() {\r\n  doStuff();\r\n  setTimeout(tick, 100);\r\n} \r\ntick();\r\n```\r\n### setInterval\r\n> 间隔指定的毫秒数不停地执行指定的代码（一直执行）。\r\n\r\n```\r\nfunction doStuff(){ \r\n  // 此处为需要执行一段时间T的代码\r\n} \r\nsetInterVal(doStuff, 100);\r\n```\r\n### setInterval和setTimeout实现的setInterval区别\r\n![setTimeout和setInterval](./img/setTimeout和setInterval.png)\r\n> setInterval每个定时器之间的间隔是100ms，而setTimeout每隔100ms执行一次doStuff，所以每个定时器之间的间隔是100 + T(doStuff执行时间为T)；T的时间不同导致的区别也不同。\r\n\r\n- 如果T可以忽略的话，两者的效果是基本相同的。\r\n- T <= 100时， setTimeout定时器间隔100+T，setInterval定时器间隔100。\r\n- T > 100时，setTimeout定时器间隔100+T，setInterval在第一次执行后定时器间隔为执行函数的时间。假设T为140ms。在0ms时，定时器1开始进入宏任务队列；100ms时，定时器1开始执行doStuff1，队列为空，定时器2进入队列；200ms时，因为定时器2(doStuff1还没执行完)在队列中，所以定时器3被跳过。**浏览器不会同时创建两个相同的间隔计时器**。300ms时，定时器2已经开始执行，队列为空，定时器4进入队列。以此类推。\r\n\r\n### setInterval效果总结\r\n- setInterval是在特定时间点将代码推入队列，如果已有定时器在队列中，则会跳过。**浏览器不会同时创建两个相同的间隔计时器**。\r\n- setInterval设置定时时间小于函数体内的执行时间时候，在第一次执行后定时器间隔为执行函数的时间。\r\n- setInterval中的异步代码不会阻塞创建新的定时器。定时器中的同步代码会直接进入队列，异步代码注册事件，当异步代码注册事件后，这个定时器就执行完了，并不是等异步代码回来后这个定时器才算结束。\r\n\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## this\r\n> this在javascript中十分常用且重要。\r\n\r\n### this的作用\r\n> 提供了一个便捷的方式传递一个隐式的引用让代码变得更加简洁同时也会让代码更好的复用。\r\n\r\n### this的指向\r\n#### 普通函数的this指向\r\n> 谁调用函数，this指向谁。\r\n\r\n- 全局调用\r\n```\r\nfunction test() {\r\n const name = \"dyx\";\r\n console.log(this.name);\r\n console.log(this);\r\n}\r\ntest(); // undefined，window。this指向调用它的那个对象，在这里相当于window.test()；所以this指向window。\r\n```\r\n- 对象的方法形式调用\r\n```\r\nconst obj = {\r\n  name: \"dyx\",\r\n  test: function() {\r\n    console.log(this.name);\r\n    console.log(this);\r\n  }\r\n}\r\nobj.test(); // dyx，obj。此时this指向的是调用函数的对象obj。\r\nconst fn = obj.test;\r\nfn(); // undefined，window。此时test的调用相当于全局调用所以this指向window。\r\n```\r\n- 深层次对象的方法调用\r\n```\r\nconst obj = {\r\n  name: \"dyx\",\r\n  innerObj: {\r\n    test: function() {\r\n      console.log(this.name);\r\n    }\r\n  },\r\n  test1: function() {\r\n    console.log(this.name);\r\n  }\r\n}\r\nobj.test1(); // dyx\r\nobj.innerObj.test(); // undefined，调用函数的对象为innerObj，在该作用域中找不到声明的name变量。\r\n```\r\n- 特殊形式\r\n```\r\nlet len = 10;\r\nfunction fn() {\r\n  console.log(this.len);\r\n}\r\nfn(); // undefined，let不会在window上添加属性。\r\n\r\nlet person = {\r\n  len: 5,\r\n  say: function() {\r\n    fn();\r\n  }\r\n}\r\nperson.say(); // undefined，调用fn的this还是指向window。\r\n```\r\n#### 构造函数的this指向\r\n> 构造函数有return的内容this指向return的内容。没有return指向new出来的新对象。\r\n\r\n- 构造函数有return的形式\r\n```\r\nfunction Test() { \r\n  this.name = 'dyx';\r\n  return {}; \r\n}\r\nvar obj = new Test(); // {}\r\nconsole.log(obj.name); // undefined，这里的this指向的是return返回的对象，是一个空对象，并没有name变量。\r\n```\r\n- 构造函数没有return的形式\r\n```\r\nfunction Test() { \r\n  this.name = 'dyx';\r\n}\r\nvar obj = new Test(); // { name: 'dyx' }\r\nconsole.log(obj.name); // dyx，这里的this指向的是new出来的新对象。\r\n```\r\n#### DOM事件绑定\r\n> onclick和addEventerListener中this默认指向绑定事件的元素。IE比较奇怪使用attachEvent里面的this默认指向window。\r\n\r\n#### 箭头函数this的指向\r\n> 箭头函数没有自己的this，如果箭头函数外层有函数，外层函数的this就是内部箭头函数的this，否则this就是window。箭头函数的this指向该函数定义时的作用域，而非指向调用函数的对象。\r\n\r\n```\r\n// 当我们创建对象的时候，是在全局作用域下创建的，而对象中的方法也是这时候创建的，所以这时候的this是指向全局的，而我们在fn2里面创建的对象，这个对象的方法的this就指向他被创建时的词法作用域obj了。\r\nvar str = 'window';   \r\nconst obj = {    \r\n  str: 'obj',    \r\n  fn: () => console.log(this.str),   \r\n  fn2: function() {\t\r\n    console.log(this.str);\r\n    return { \r\n      str: 'newObj',\t    \r\n      fn: () => console.log(this.str)\r\n    }\r\n  },  \r\n}\r\n \r\nobj.fn(); // window\r\n \r\nvar newObj = obj.fn2(); // obj\r\nnewObj.fn(); // obj\r\n```\r\n### 改变函数this的指向\r\n> call、apply、bind方法都可以改变this指向, this指向传入的第一个参数。bind方法改变后的函数想什么时候调用就什么时候调用，执行bind之后返回的是一个函数，bind方法也可以接收多个参数，并且参数可以执行的时候再次添加，但是要注意的是，参数是按照形参的顺序进行的，call和apply都是改变指向后立即调用此方法。apply的使用同call不同的是传入的参数需要是数组形式或者类数组形式。\r\n\r\n- bind\r\n> 改变之后可以自定义函数何时调用，bind方法会创建一个函数实例，this会指向传给bind方法的第一个参数。\r\n\r\n```\r\nvar obj = {\r\n name: \"dyx\",\r\n test: function(num1, num2, num3) {\r\n   console.log(this); // obj1\r\n   console.log(this.name); // douyaxing\r\n   console.log(num1, num2, num3); // 10 1 2\r\n }\r\n}\r\nvar obj1 = {\r\n  name: 'douyaxing'\r\n}\r\nvar fn = obj.test.bind(obj1, 10); // this将会指向obj1\r\nfn(1, 2);\r\n```\r\n- call\r\n> 方法立即执行，参数一个一个传入。\r\n\r\n```\r\nvar obj = {\r\n  name: \"dyx\",\r\n  test: function(c, d) {\r\n    console.log(this); // obj1\r\n    console.log(this.name); // douyaxing\r\n    console.log(c + d); // 3\r\n  }\r\n}\r\nvar obj1 = {\r\n  name: 'douyaxing'\r\n}\r\nvar fn = obj.test;\r\nfn.call(obj1, 1, 2); // 参数一个一个传入\r\n```\r\n- apply\r\n> 方法立即执行，传入一个数组或者类数组作为参数，可以直接使用函数的arguments对象作为参数传递。\r\n\r\n```\r\nvar obj = {\r\n  name: \"dyx\",\r\n  test: function(c, d) {\r\n    console.log(this); // obj1\r\n    console.log(this.name); // douyaxing\r\n    console.log(c + d); // 3\r\n  }\r\n}\r\nvar obj1 = {\r\n  name: 'douyaxing'\r\n}\r\nvar fn = obj.test;\r\nfn.apply(obj1, [1, 2]); // 参数以数组形式传入\r\n```\r\n### 示例\r\n- 加括号的形式\r\n```\r\nvar x = 10;\r\nvar foo = {\r\n  x: 20,\r\n  bar: function () {\r\n    var x = 30;\r\n    return this.x;\r\n  }\r\n};\r\n\r\nconsole.log(foo.bar());   // 20\r\nconsole.log((foo.bar)());  // 20\r\nconsole.log((foo.bar = foo.bar)()); // 10\r\nconsole.log((foo.bar, foo.bar)()); // 10\r\nconsole.log(foo.bar.call(window)); // 10\r\nconsole.log(foo.bar.call(foo)); // 20\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## var let const差异\r\n### var声明的变量会挂载在window上，而let和const声明的变量不会。\r\n```\r\nvar name = 'dyx';\r\nlet name1 = 'dyx1';\r\nconst name2 = 'dyx2';\r\nconsole.log(window.name);  // dyx\r\nconsole.log(window.name1); // undefined\r\nconsole.log(window.name2); // undefined\r\n```\r\n### var声明变量存在变量提升，let和const不存在变量提升。\r\n```\r\nconsole.log(name); // undefined \r\nvar name = 'dyx';\r\n\r\nconsole.log(name1); //  Cannot access 'name1' before initialization\r\nlet name1 = 'dyx1';\r\n\r\nconsole.log(name2); //  Cannot access 'name2' before initialization\r\nconst name2 = 'dyx2';\r\n```\r\n### let和const声明形成块级作用域。\r\n```\r\nif (true) {\r\n  var name = 'dyx';\r\n  let name1 = 'dyx1';\r\n  const name2 = 'dyx2';\r\n}\r\nconsole.log(name); // dyx \r\nconsole.log(name1); // name1 is not defined\r\nconsole.log(name2); // name2 is not defined \r\n```\r\n### 同一作用域下let和const不能声明同名变量，而var可以。\r\n```\r\nvar name = 'dyx';\r\nvar name = 'dyx1';\r\nlet name1 = 'dyx2';\r\nlet name1 = 'dyx3'; // name1 has already been declared\r\nconst name2 = 'dyx4';\r\nconst name2 = 'dyx5'; // name2 has already been declared\r\n```\r\n### 暂时性死区。\r\n```\r\nvar name = 'dyx';\r\n\r\nif (true) {\r\n  // let创建的name变量创建过程被提升了，但是初始化没有提升。变量未初始化或赋值前不允许访问。\r\n  name = 'douyaxing'; // Cannot access 'name' before initialization\r\n  let name = 'dyxweb';\r\n}\r\n```\r\n### const一旦声明必须赋值，声明后不能再修改，如果声明的是复合类型数据，可以修改其属性。\r\n```\r\nconst name = 'dyx';\r\nname = 'dyx1'; // Assignment to constant variable\r\n\r\nconst info = {\r\n  name: 'dyx',\r\n}\r\ninfo.name = 'douyaxing';\r\nconsole.log(info); // { name: 'douyaxing' }\r\n```\r\n### 暂时性死区的原因\r\n- 变量的赋值可以分为三个阶段：\r\n   1. 创建变量，在内存中开辟空间。\r\n   2. 初始化变量，将变量初始化为undefined。\r\n   3. 真正赋值。\r\n- let 的「创建」过程被提升了，但是初始化没有提升。存在暂时死区，在变量未初始化或赋值前不允许访问。\r\n- var 的「创建」和「初始化」都被提升了。\r\n- function 的「创建」「初始化」和「赋值」都被提升了。\r\n### let关键字\r\n- 块级作用域\r\n> 使用let声明的变量具有块级作用域，即它们只在声明该变量的花括号{}内部可见和访问。这与使用var声明的变量具有函数作用域(Function Scope)的行为不同。\r\n\r\n- 暂时性死区\r\n> 在变量声明之前使用let声明的变量会进入暂时性死区，此时访问该变量会抛出ReferenceError。这与使用var声明的变量在未初始化前默认值为undefined的行为不同。\r\n\r\n- 无变量提升\r\n> let声明的变量不会像var一样被提升到作用域顶部，意味着在声明之前无法访问let声明的变量。\r\n\r\n- 不允许重复声明\r\n> 在同一作用域内，使用let声明的变量不允许被重复声明，而var则可以在同一作用域内重复声明同名变量而不会报错。\r\n\r\n### const关键字\r\n> let关键字的特性const关键字都有，唯一的区别就是const被赋初值以后无法修改。\r\n\r\n### let和const对比var的优势\r\n> ES6中的let和const相比var提供了更加清晰和严格的变量管理机制，有助于编写更加健壮和可维护的JavaScript代码。这些改进使得JavaScript的变量声明和作用域行为更加符合开发者的预期，减少了一些常见的错误。\r\n\r\n1. 作用域管理更加清晰和直观\r\n    - var声明的变量具有函数作用域或全局作用域，这可能会导致意料之外的变量污染和泄露。\r\n    - let和const声明的变量具有块级作用域，限定在它们所在的花括号{}内部，使得变量的作用域更加明确和可控。\r\n2. 避免变量提升问题\r\n    - var声明的变量会被提升到作用域顶部，这可能会导致意料之外的行为。\r\n    - let和const声明的变量不会被提升，必须在声明之后才能访问，避免了这种问题。\r\n3. 引入暂时性死区\r\n    - let和const声明的变量在声明之前会进入暂时性死区，访问会抛出ReferenceError，这有助于避免一些隐藏的bug。\r\n    - var声明的变量在未初始化前默认值为undefined,可能会导致一些隐藏的错误。\r\n4. 支持常量声明\r\n    - const关键字允许声明不可变的常量变量，有助于增强代码的可读性和稳定性。\r\n    - var无法直接声明常量。\r\n5. 不允许重复声明\r\n    - let和const不允许在同一作用域内重复声明同名变量，有利于避免一些错误。\r\n    - var则可以在同一作用域内重复声明同名变量而不会报错。\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## 事件委托\r\n> 事件委托是利用了浏览器事件冒泡的机制。因为事件在冒泡过程中会上传到父节点，并且父节点可以通过事件对象获取到目标节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件，这种方式称为事件代理。\r\n\r\n```\r\n<ul id=\"parent\">\r\n  <li>1</li>\r\n  <li>2</li>\r\n  <li>3</li>\r\n  ...\r\n  <li>999</li>\r\n  <li>1000</li>\r\n</ul>\r\n\r\n<script>\r\n  let parent = document.getElementById('parent');\r\n  parent.addEventListener('click', (e) => {\r\n    // 根据e.target进行处理\r\n  })\r\n<\/script>\r\n```\r\n### 优点\r\n- 不必要为每一个子元素都绑定一个监听事件，这样减少了内存上的消耗。\r\n- 可以实现事件的动态绑定，比如说新增了一个子节点，不需要单独地为它添加一个监听事件，它所发生的事件会交给父元素中的监听函数来处理。"},function(r,n,e){"use strict";e.r(n),n.default="## [事件循环(eventLoop)](https://juejin.cn/post/6969028296893792286)\r\n- 事件循环是目前浏览器和NodeJS处理JS代码的一种机制。\r\n### JS引擎是单线程的\r\n- JS是单线程的，执行顺序是从上到下执行。JS的顺序执行会存在一些问题，比如当一个语句需要执行很长时间的话，如请求数据、定时器、读取文件等，后面的语句就得一直等着前面的语句执行结束后才会开始执行。\r\n- JS将所有执行任务分为了同步任务和异步任务。每个任务都是在做两件事情，就是发起调用和得到结果。\r\n- 假设JS同时有两个线程，一个是操作A节点，一个是删除A节点，这时候浏览器就不知道要以哪个线程为准了。因此为了避免这类型的问题，JS从一开始就是单线程的语言。\r\n### 调用栈(执行栈)\r\n- 在JS运行的时候会形成一个栈，这个栈被称为调用栈或者执行栈，具有后进先出的特性。\r\n- 调用栈内存放的是代码执行期间的所有执行上下文(浏览器报错的调用栈是从下向上执行的)。\r\n- 每调用一个函数，解释器就会把该函数的执行上下文添加到调用栈并开始执行。\r\n- 正在调用栈中执行的函数，如果还调用了其他函数，那么新函数也会被添加到调用栈，并立即执行。\r\n- 当前函数执行完毕后，解释器会将其执行上下文清除调用栈，继续执行剩余执行上下文中的剩余代码。\r\n- 当分配的调用栈空间被占满，会引发“堆栈溢出”的报错。\r\n### 同步任务\r\n- 同步任务发起调用后，很快就可以得到结果。\r\n- 同步任务的执行会按照代码顺序调用，进入调用栈中并执行，执行结束后从调用栈移除。\r\n### 异步任务\r\n- 异步任务是无法立即得到结果，比如请求接口、定时器。\r\n- 异步任务的执行，首先它依旧会进入调用栈中，然后发起调用，然后解释器会将其回调方法放入一个任务队列，紧接着调用栈会将这个任务移除。\r\n- 当调用栈清空后，即所有同步任务结束后(也就是setTimeout时间有延误的原因，当同步任务十分耗时的时候，setTimeout并不能及时执行)，解释器会读取任务队列，并依次将已完成的异步任务加入调用栈中并执行。\r\n### 异步任务回调进入任务队列\r\n> 异步任务回调进入任务队列，其实会利用到浏览器的其它线程。虽然说JS是单线程语言，但是浏览器不是单线程的。而不同的线程就会对不同的事件进行处理，当对应事件可以执行的时候，对应线程就会将其放入任务队列。\r\n\r\n- JS引擎线程：用于解释执行JS代码、用户输入、网络请求等。\r\n- GUI渲染线程：绘制用户界面，与JS引擎线程互斥(因为JS可以操作DOM，进而会影响到GUI的渲染结果)。\r\n- http异步网络请求线程：处理用户的http请求，等返回结果后将回调函数推入到任务队列。\r\n- 定时触发器线程：setInterval、setTimeout等待时间结束后，会把执行函数推入任务队列中。\r\n- 浏览器事件处理线程：将click、mouse等UI交互事件发生后，将要执行的回调函数放入到任务队列中。\r\n```\r\n// 后者的定时器会先被推进宏任务队列，而前者会在之后再被推入宏任务队列\r\nsetTimeout(() => {\r\n  console.log('a');\r\n}, 10000);\r\n\r\nsetTimeout(() => {\r\n  console.log('b');\r\n}, 100);\r\n```\r\n![同步异步执行](./img/%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E6%89%A7%E8%A1%8C.png)\r\n### 定时器\r\n- 当使用setTimeout或setInterval时，需要定时触发器线程计时，计时完成后会将回调函数推入事件队列中，等待调用栈执行。\r\n- JS引擎会对setInterval进行优化，如果当前事件队列中有setInterval的回调，不会重复添加。\r\n- 使用setTimeout模拟setInterval效果更好，setTimeout可以等待事件执行完之后再开启下次定时器，定时效果更加合理。\r\n### 宏任务和微任务\r\n> 在任务队列中，其实还分为宏任务队列和微任务队列，对应的里面存放的就是宏任务和微任务。\r\n\r\n- macro-task(宏任务)：包括整体JS代码script，setTimeout，setInterval，setImmediate，MessageChannel，I/O操作，UI渲染。\r\n- micro-task(微任务)：Promise的then方法，process.nextTick(优先级高于Promise的then方法)，MutationObserver。\r\n- 浏览器会在一个宏任务执行结束后下一个宏任务执行开始前，对页面进行重新渲染。\r\n- 微任务是在当前宏任务执行结束后立即执行的任务，在当前宏任务后下一个宏任务之前，在渲染之前执行，\r\n- 在某一个宏任务执行完后在渲染之前，就会将在它执行期间产生的所有微任务都执行完毕(包括执行微任务时又产生的微任务)。\r\n- 微任务的响应速度相比setTimeout会更快，因为无需等渲染。\r\n### script(整体代码块)是宏任务\r\n- 如果同时存在两个script代码块，会首先执行第一个script代码块中的同步代码，如果这个过程中创建了微任务并进入了微任务队列，第一个script同步代码执行完之后，会首先去清空微任务队列，再去开启第二个script代码块的执行。所以就可以理解script(整体代码块)是宏任务。\r\n### [Promise.then微任务的注册和执行过程](https://juejin.cn/post/6844903987183894535)\r\n1. .then的执行顺序是先注册的先执行, .then的注册微任务队列和执行是分离的, .then对应的同步代码执行完之后则开始注册.then。\r\n2. .then的链式调用的注册时机是依赖前一个.then的执行完成的, 而非链式的调用的注册时机则是同步注册。\r\n### 事件循环流程\r\n1. 从宏任务队列中，按照入队顺序，找到第一个执行的宏任务，放入调用栈，开始执行。\r\n2. 执行完该宏任务下所有同步任务后，即调用栈清空后，该宏任务被推出宏任务队列，然后微任务队列开始按照入队顺序，依次执行其中的微任务，直至微任务队列清空为止。\r\n3. 当微任务队列清空后，一次事件循环结束，开始检查渲染然后GUI线程接管渲染。\r\n4. 接着从宏任务队列中，找到下一个执行的宏任务，开始第二次事件循环，直至宏任务队列清空为止。\r\n### 事件循环注意点\r\n- 第一次执行的时候，解释器会将整体代码script放入宏任务队列中，因此事件循环是从script这个宏任务开始的。\r\n- 一次事件循环中，宏任务永远在微任务之前执行。完成一个宏任务后，执行余下的所有微任务。一次事件循环只执行一个宏任务。\r\n- 微任务按放入队列的顺序执行，先放入的先执行，如果在执行微任务的过程中，产生新的微任务添加到微任务队列中，也需要一起清空；微任务队列没清空之前，是不会执行下一个宏任务的。\r\n- 一次事件循环结束后浏览器会更新渲染。\r\n\r\n![事件循环](./img/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF.png)\r\n### 页面渲染响应\r\n- 当一次事件循环结束后，即一个宏任务执行完成后以及微任务队列被清空后，浏览器就会进行一次页面更新渲染。\r\n```\r\n<body>\r\n  <div id=\"demo\"></div>\r\n</body>\r\n<script>\r\n  // innerText时并不会直接更新渲染当promise的then执行完alert('开始渲染！')，一次事件循环结束才会更新渲染。\r\n  const demoEl = document.getElementById('demo');\r\n  console.log('a');\r\n  setTimeout(() => {\r\n    alert('渲染完成！')\r\n    console.log('b');\r\n  }, 0)\r\n  new Promise(resolve => {\r\n    console.log('c');\r\n    resolve()\r\n  }).then(() => {\r\n    console.log('d');\r\n    alert('开始渲染！')\r\n  })\r\n  console.log('e');\r\n  demoEl.innerText = 'Hello World!';\r\n<\/script>\r\n```\r\n- 页面不再响应\r\n```\r\n// 一直在执行微任务\r\nfunction foo() {\r\n return Promise.resolve().then(foo);\r\n};\r\n```\r\n### promise.then + setTimeout\r\n- 第一轮事件循环执行script宏任务。\r\n  - setTimeout会作为第二轮的宏任务执行。\r\n  - 打印promise，promise的then方法会作为第一轮的微任务执行。\r\n  - 打印console。\r\n  - 执行第一轮的微任务打印then。\r\n- 执行第二轮的宏任务打印setTimeout。\r\n```\r\nsetTimeout(() => {\r\n  console.log('setTimeout');\r\n}, 0);\r\nnew Promise(resolve => {\r\n  console.log('promise');\r\n  resolve('dyx');\r\n}).then(res => {\r\n  console.log('then');\r\n})\r\n\r\nconsole.log('console');\r\n\r\n// 执行结果\r\n- promise\r\n- console\r\n- then\r\n- setTimeout\r\n```\r\n- 第一轮事件循环执行script宏任务。\r\n  - promise的then方法作为第一轮的微任务执行。\r\n  - setTimeout1会作为第二轮事件循环的宏任务。\r\n  - 然后执行第一轮的微任务打印promise1，然后将setTimeout2作为第三轮事件循环的宏任务（每一次事件循环只能执行一个宏任务）。\r\n- 执行第二轮的宏任务，打印setTimeout1。\r\n  - 此时将promise2作为第二轮的微任务执行，所以打印promise2。\r\n- 然后执行第三轮宏任务打印setTimeout2。\r\n\r\n```\r\nPromise.resolve().then(() => {\r\n  console.log('promise1');\r\n  setTimeout(() => {\r\n    console.log('setTimeout2');\r\n  }, 0);\r\n})\r\nsetTimeout(() => {\r\n  console.log('setTimeout1');\r\n  Promise.resolve().then(() => {\r\n    console.log('promise2');\r\n  });\r\n}, 0);\r\n\r\n// 执行结果\r\n- promise1\r\n- setTimeout1\r\n- promise2\r\n- setTimeout2\r\n```\r\n- 第一次事件循环\r\n  - 1\r\n  - 6\r\n  - 8\r\n  - 10\r\n  - 7 // 微任务\r\n- 第二次事件循环\r\n  - 2\r\n  - 3\r\n  - 5\r\n  - 4 // 微任务\r\n- 第三次事件循环\r\n  - 9\r\n```\r\nconsole.log(1);\r\n\r\nsetTimeout(() => {\r\n  console.log(2);\r\n  new Promise(resolve => {\r\n    console.log(3);\r\n    resolve(4);\r\n    console.log(5);\r\n  }).then(res => {\r\n    console.log(res);\r\n  });\r\n}, 0);\r\n\r\nnew Promise(resolve => {\r\n  console.log(6);\r\n  resolve(7);\r\n  console.log(8);\r\n}).then(res => {\r\n  console.log(res);\r\n});\r\n\r\nsetTimeout(() => {\r\n  console.log(9);\r\n}, 0);\r\nconsole.log(10);\r\n```\r\n### [async函数执行](https://juejin.cn/post/7194744938276323384)\r\n#### async函数返回值\r\n- async函数在抛出返回值时，会根据返回值类型开启不同数目的微任务。\r\n  - return结果值：非thenable、非promise（不等待）。\r\n  - return结果值：thenable（等待 1个then的时间）。\r\n  - return结果值：promise（等待 2个then的时间）。\r\n- await右值类型区别\r\n  - 接非thenable类型，会立即向微任务队列添加一个微任务then，但不需等待。\r\n  - 接thenable类型，需要等待一个then的时间之后执行。\r\n  - 接Promise类型(有确定的返回值)，会立即向微任务队列添加一个微任务then，但不需等待。（TC39对await后面是promise的情况如何处理进行了一次修改，移除了额外的两个微任务，在早期版本，依然会等待两个then的时间）。\r\n#### 例子\r\n- 类型1\r\n```\r\nconst test = () => {\r\n console.log(\"test\");\r\n return \"testFunReturn\";\r\n}\r\nconst testAsync = async() => {\r\n console.log(\"testAsync\");\r\n return Promise.resolve(\"testAsyncFunReturn\");\r\n}\r\n\r\nconst run = async() => {\r\n console.log(\"run\");\r\n const result1 = await test();\r\n console.log(result1);\r\n const result2 = await testAsync();\r\n console.log(result2);\r\n console.log(result1, result2);\r\n}\r\nrun();\r\nconst promise = new Promise(resolve => {\r\n  console.log(\"promise\");\r\n  resolve(\"promise end\");\r\n})\r\npromise.then(res => console.log(res));\r\nconsole.log(\"end\")\r\n\r\n// 执行结果\r\n- run\r\n- test\r\n- promise\r\n- end\r\n- testFunReturn\r\n- testAsync\r\n- promise end\r\n- testAsyncFunReturn\r\n- testFunReturn, testAsyncFunReturn\r\n```\r\n- 类型2\r\n```\r\n// 将test方法加async\r\nconst test = async() => {\r\n console.log(\"test\");\r\n return \"testFunReturn\";\r\n}\r\nconst testAsync = async() => {\r\n console.log(\"testAsync\");\r\n return Promise.resolve(\"testAsyncFunReturn\");\r\n}\r\n\r\nconst run = async() => {\r\n console.log(\"run\");\r\n const result1 = await test();\r\n console.log(result1);\r\n const result2 = await testAsync();\r\n console.log(result2);\r\n console.log(result1, result2);\r\n}\r\nrun();\r\nconst promise = new Promise(resolve => {\r\n  console.log(\"promise\");\r\n  resolve(\"promise end\");\r\n})\r\npromise.then(res=> console.log(res));\r\nconsole.log(\"end\")\r\n\r\n// 执行结果\r\n- run\r\n- test\r\n- promise\r\n- end\r\n- promise end\r\n- testFunReturn\r\n- testAsync\r\n- testAsyncFunReturn\r\n- testFunReturn, testAsyncFunReturn\r\n```\r\n- 类型3\r\n```\r\nconst asyncTestOne = async() => {\r\n  console.log('asyncOne start')\r\n  await asyncTestTwo()\r\n  console.log('asyncOne end')\r\n}\r\n\r\nconst asyncTestTwo = async() => {\r\n  console.log('asyncTwo start')\r\n}\r\n\r\nconsole.log('start');\r\n\r\nsetTimeout(() => {\r\n  console.log('setTimeout') \r\n}, 0)\r\n\r\nasyncTestOne();\r\n\r\nnew Promise(resolve => {\r\n  console.log('promise')\r\n  resolve('promiseResult');\r\n}).then((res) => {\r\n  console.log(res)\r\n})\r\n\r\nconsole.log('end')\r\n\r\n// 执行结果\r\n- start\r\n- asyncOne start\r\n- asyncTwo start\r\n- promise\r\n- end\r\n- promiseResult\r\n- asyncOne end\r\n- setTimeout\r\n```\r\n### node和浏览器的事件循环差异\r\n- 浏览器环境下，微任务会在宏任务之后执行。而在NodeJS中，微任务会在事件循环的各个阶段之间执行，也就是一个阶段执行完毕，就会去执行微任务队列的任务。\r\n- node端的setTimeout/setInterval的宏任务有多个时会一次执行完所有的宏任务，然后再去执行微任务，并不会一次事件循环只执行一个宏任务。\r\n```\r\nconsole.log('start');\r\n\r\nsetTimeout(() => {\r\n  console.log('timer1');\r\n  Promise.resolve().then(function() {\r\n    console.log('promise1');\r\n  })\r\n}, 0);\r\n\r\nsetTimeout(() => {\r\n  console.log('timer2');\r\n  Promise.resolve().then(function() {\r\n    console.log('promise2');\r\n  })\r\n}, 0);\r\n\r\nPromise.resolve().then(function() {\r\n  console.log('promise3');\r\n})\r\nconsole.log('end');\r\n\r\n// node端执行结果\r\n1. start\r\n2. end\r\n3. promise3\r\n4. timer1\r\n5. timer2\r\n6. promise1\r\n7. promise2\r\n\r\n// 浏览器端执行结果\r\n1. start\r\n2. end\r\n3. promise3\r\n4. timer1\r\n5. promise1\r\n6. timer2\r\n7. promise2\r\n```\r\n\r\n\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## 作用域\r\n> 作用域决定了代码区块中变量和其他资源的可被访问性，作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。ES6 之前 JavaScript 没有块级作用域,只有全局作用域和函数作用域。\r\n\r\n```\r\nconsole.log(total); // undefined\r\nvar total = 0;\r\nfunction func(num1, num2) {\r\n  console.log(total); // undefined\r\n  var total = num1 + num2;\r\n  console.log(total); // 300\r\n}\r\nfunc(100 , 200);\r\nconsole.log(total); // 0\r\n// 局部的与全局的同名变量互不干扰，如果不使用var会去全局中查找该变量，如果存在即使用全局的该变量，若不存在相当于给window增加了一个属性名total，属性值是100,不会有预解析。\r\n```\r\n### 全局作用域\r\n> 块语句（大括号“｛｝”中间的语句），如 if 和 switch 条件语句或 for 和 while 循环语句，不像函数，它们不会创建一个新的作用域。\r\n\r\n- 最外层函数 和在最外层函数外面定义的变量拥有全局作用域。\r\n- 所有末定义直接赋值的变量自动声明为拥有全局作用域。\r\n- 所有window对象的属性拥有全局作用域\r\n\r\n### 函数作用域\r\n> 函数作用域,是指声明在函数内部的变量和函数的形参，和全局作用域相反，局部作用域一般只在固定的代码片段内可访问到，一般为函数内部。\r\n\r\n### 块级作用域\r\n> 使用let或const声明\r\n\r\n- 在一个函数内部\r\n- 在一个代码块（由一对花括号包裹）内部\r\n\r\n### 作用域链\r\n> 在函数作用域中，代码执行的时候，遇到了一个变量，首先需要确定它是否为私有变量，如果是私有变量，那么和外面的任何东西都没有关系，如果不是私有的，则往当前作用域的父级作用域（创建该函数的那个父级作用域）进行查找，如果父级作用域也没有则继续查找，一直查找到window为止，如果没有找到即报错 not defined，这就是作用域链。\r\n\r\n### 作用域现象\r\n```\r\n// 使用var定义的变量 i 虽然是在 for 循环代码块中被定义，但在代码块外仍可以访问 i, 属于全局作用域。定时器中的匿名函数也是执行在全局作用域中，所以每次都输出11了。\r\nfor (var i = 1; i <= 10; i++) {\r\n  setTimeout(() => {\r\n    console.log(i);\r\n  }, 1000);\r\n} // 输出10次11，因为setTimeout中的匿名函数执行的时候，for循环都已经结束了，此时i为11。\r\n\r\n// 让i在每次迭代的时候，都产生一个私有的作用域，在这个私有的作用域中保存当前i的值。\r\nfor (var i = 1; i <= 10; i++) {\r\n  (function () {\r\n    const j = i;\r\n    setTimeout(function () {\r\n      console.log(j);\r\n    }, 1000);\r\n  })();\r\n}\r\n\r\nfor (var i = 1; i <= 10; i++) {\r\n  (function (j) {\r\n    setTimeout(function () {\r\n      console.log(j);\r\n    }, 1000);\r\n  })(i);\r\n}\r\n\r\n// 使用es6的let const形成块级作用域。\r\nfor (let i = 1; i <= 10; i++) {\r\n  setTimeout(() => {\r\n    console.log(i);\r\n  }, 1000);\r\n}\r\n```\r\n### 易错现象\r\n```\r\n// 输出10个10，因为在createFun函数中返回的result的数组中是一些函数，这些函数并没有立即调用，而是在循环结束之后才调用的所以结果是10个10;\r\nfunction createFun() {\r\n var result = new Array();\r\n for (var i = 0; i < 10; i++) {\r\n   result[i] = function(){\r\n     return i;\r\n   };\r\n }\r\n return result;\r\n}\r\nvar fun = createFun();\r\nfor (var i = 0; i < fun.length; i++){\r\n console.log(fun[i]());\r\n}\r\n```\r\n\r\n```\r\n// test函数与a变量都属于全局作用域下，test2中声明的a变量属于函数作用域。\r\nvar a = 'dyx';\r\nvar test = function() {\r\n  console.log(a) // dyx\r\n}\r\nfunction test2(){\r\n  var a = null;\r\n  test();\r\n}\r\ntest2();\r\n```\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## 前端获取网络信息\r\n### 网络变化\r\n- 直接关闭wifi和开启wifi不会触发offline和online事件。\r\n- 浏览器的network面板修改网络状态会触发offline和online事件。\r\n```\r\nwindow.addEventListener('offline', () => {\r\n  console.log('offline');\r\n});\r\n\r\nwindow.addEventListener('online', () => {\r\n  console.log('online');\r\n});\r\n```\r\n### 网络状态 \r\n```\r\nconst online = window.navigator.onLine; // true or false\r\n```\r\n### 网络连接状态(兼容性较低)\r\n```\r\nconst connection = navigator.connection || navigator.webkitConnection || navigator.mozConnection;\r\n```\r\n### 监听网络类型切换(2G/3G/4G)\r\n```\r\nnavigator.connection.addEventListener('change', () => {\r\n  \r\n});\r\n```\r\n"},function(r,n,e){"use strict";e.r(n),n.default='## 图像懒加载和预加载\r\n### 懒加载\r\n> 将img标签中设置一个data-src属性，它指向的是实际上我们需要加载的图像，而img的src指向一张默认的图片，如果为空的话也会向服务器发送请求。当用户访问可视区域的img元素时，将src得值替换为data-src指向的实际资源加载的图像。\r\n\r\n- 优点\r\n  - 用户可以更快地加载到内容，因为用户第一次打开网站时只需要加载一部分内容。\r\n  - 较低的资源成本，因为内容只在用户需要时才加载，而不是一次完成。\r\n- IntersectionObserver实现\r\n> 一种可以异步监听目标元素与其祖先或视窗(viewport)是否处于交叉状态的方式。\r\n\r\n```\r\n// 加载img\r\nfunction preloadImage(img) {\r\n  const src = img.dataset.src;\r\n  if (!src) {\r\n    return;\r\n  }\r\n  img.src = src;\r\n}\r\n\r\nconst config = {\r\n\trootMargin: \'0px\',\r\n\tthreshold: 0\r\n};\r\nconst observer = new IntersectionObserver((entries, self) => {\r\n  entries.forEach(entry => {\r\n    if (entry.isIntersecting) {\r\n\t\t\t// 加载图像\r\n\t\t\tpreloadImage(entry.target);\r\n\t\t\t// 解除观察\r\n\t\t\tself.unobserve(entry.target);\r\n    }\r\n  })\r\n}, config);\r\n\r\n// 监听所有img元素\r\nconst images = document.querySelectorAll(\'[data-src]\');\r\nimages.forEach(image => {\r\n  observer.observe(image);\r\n});\r\n```\r\n### 预加载\r\n> 将所有所需的资源提前请求加载到本地，这样后面在需要用到时就直接从缓存取资源。\r\n\r\n- 优点\r\n  - 减少用户等待时间，提升体验。\r\n- 使用HTML标签\r\n```\r\n<img src="http://pic26.nipic.com/20121213/61681830044449030002.jpg" style="display:none" />\r\n```\r\n- 使用Image对象\r\n```\r\nvar image= new Image();\r\nimage.src = "http://pic26.nipic.com/20121213/61681830044449030002.jpg";\r\n```\r\n- 使用ajax请求图片资源'},function(r,n,e){"use strict";e.r(n),n.default="## 实现准时的setTimeout\r\n- setTimeout是不准的，因为setTimeout是一个宏任务，它的指定时间指的是进入主线程的时间。\r\n- 什么时候可以执行callback，需要看主线程前面还有多少任务待执行。\r\n```\r\nsetTimeout(callback, 进入主线程的时间)\r\n```\r\n### setTimeout不准时的案例\r\n- 如果在setTimeout还未执行期间加入一些额外的代码逻辑会加剧时间误差。\r\n```\r\nfunction timer() { \r\n  var speed = 50, // 设定间隔 \r\n  counter = 1,  // 设定间隔  \r\n  start = new Date().getTime(); \r\n  \r\n  function instance() { \r\n    var ideal = counter * speed, // 定时器理想正常的时间间隔\r\n    real = new Date().getTime() - start; // 定时器实际运行的时间间隔\r\n    counter++; \r\n    var diff = real - ideal; \r\n    window.setTimeout(function() { instance(); }, speed); \r\n  }; \r\n  \r\n  window.setTimeout(function() { instance(); }, speed); \r\n} \r\ntimer(); \r\n```\r\n### requestAnimationFrame模拟setTimeout\r\n- requestAnimationFrame方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行，回调函数执行次数通常是每秒60次，也就是每16.7ms执行一次，但是并不一定保证为16.7ms。\r\n- 由于16.7ms间隔执行，在使用间隔很小的定时器，很容易导致时间的不准确。\r\n```\r\nfunction setTimeout2 (cb, delay) { \r\n  let startTime = Date.now() \r\n  loop() \r\n  \r\n  function loop () { \r\n    const now = Date.now() \r\n    if (now - startTime >= delay) { \r\n      cb(); \r\n      return; \r\n    } \r\n    requestAnimationFrame(loop) \r\n  } \r\n} \r\n```\r\n### while模拟setTimeout\r\n- 主动去触发获取到最开始的时间，以及不断去轮询当前时间，如果差值是预期的时间，那么这个定时器肯定是准确的，使用while可以实现这个功能。\r\n- js是单线程运行，使用这样的方式强行霸占线程会使得页面进入卡死状态，这样的结果显然是不合适的。\r\n```\r\nfunction timer(time) { \r\n  const startTime = Date.now(); \r\n  while(true) {\r\n    const now = Date.now(); \r\n    if (now - startTime >= time) {\r\n      console.log('误差', now - startTime - time); \r\n      return; \r\n    } \r\n  } \r\n}\r\ntimer(5000); \r\n```\r\n### setTimeout系统时间补偿\r\n- 当每一次定时器执行时后，都去获取系统的时间来进行修正，虽然每次运行可能会有误差，但是通过系统时间对每次运行的修复，能够让后面每一次时间都得到一个补偿。\r\n```\r\nfunction timer() { \r\n  var speed = 500, // 设定间隔 \r\n  counter = 1,  // 设定间隔 \r\n  start = new Date().getTime(); \r\n  \r\n  function instance() { \r\n    var ideal = counter * speed, // 定时器理想正常的时间间隔\r\n    real = new Date().getTime() - start; // 定时器实际运行的时间间隔\r\n    counter++; \r\n    var diff = real - ideal; \r\n    window.setTimeout(function() { instance(); }, (speed - diff)); // 通过系统时间进行修复 \r\n  }; \r\n  \r\n  window.setTimeout(function() { instance(); }, speed); \r\n} \r\n```"},function(r,n,e){"use strict";e.r(n),n.default='## 创建对象\r\n### 工厂模式\r\n- 优点：解决了创建多个相似对象时，代码的复用问题。\r\n- 缺点：使用工厂模式创建的对象，没有解决对象识别的问题（就是怎样知道一个对象的类型是什么）。\r\n```\r\nfunction createPerson(name, age) {\r\n  const o = new Object();\r\n  o.name = name;\r\n  o.age = age;\r\n  o.sayName = function() {\r\n    alert(this.name);\r\n  };\r\n  return o;\r\n}\r\n\r\nconst person1 = createPerson("dyx", 24);\r\nconst person2 = createPerson("douyaxing", 25);\r\n```\r\n### 构造函数\r\n- 优点：解决了工厂模式中对象类型无法识别的问题（实例对象中我们可以通过原型链来访问到constructor属性，从而判断对象的类型），并且创建自定义的构造函数意味着将来可以将它的实例标识为一种特定的类型。\r\n- 缺点：在使用构造函数创建对象时，每个方法都会在实例对象中重新创建一遍。这意味着每创建一个对象，我们就会创建一个sayName函数的实例，因此这样便会造成内存的浪费。\r\n```\r\nfunction CreatePerson(name, age) {\r\n  this.name = name;\r\n  this.age = age;\r\n  this.sayName = function() {\r\n    alert(this.name);\r\n  };\r\n  return o;\r\n}\r\n\r\nconst person1 = new CreatePerson("dyx", 24);\r\nconst person2 = new CreatePerson("douyaxing", 25);\r\n```\r\n### 原型模式\r\n- 优点：解决了构造函数模式中多次创建相同函数对象的问题，所有的实例可以共享同一组属性和函数。\r\n- 缺点：原型模式省略了构造函数模式传递初始化参数的过程，所有的实例在默认情况下都会取得默认的属性值，会在一定程度上造成不方便。我们创建的实例一般都是要有属于自己的全部属性的，因此单独使用原型模式的情况是很少存在的。\r\n```\r\nfunction Person() {\r\n}\r\n\r\nPerson.prototype.name = "dyx";\r\nPerson.prototype.age = 24;\r\nPerson.prototype.sayName = function() {\r\n  alert(this.name);\r\n}\r\n\r\nconst person1 = new Person();\r\nperson1.sayName(); // "dyx"\r\n\r\nconst person2 = new Person();\r\nperson2.sayName(); // "dyx"\r\n\r\nconsole.log(person1.sayName === person2.sayName) // true\r\n```\r\n### 组合模式(构造函数与原型模式组合)\r\n- 优点：采用了构造函数模式和原型模式的优点，可以传递属于自己的参数，也可以共享。\r\n- 缺点：由于使用了两种模式，因此对于代码的封装性来说不是很好。\r\n```\r\nfunction Person(name, age) {\r\n  this.name = name;\r\n  this.age = age;\r\n}\r\n\r\nPerson.prototype = {\r\n  constructor: Person,\r\n  sayName: function() {\r\n    alert(this.name);\r\n  }\r\n}\r\n\r\nconst person1 = new createPerson("dyx", 24);\r\nconst person2 = new createPerson("douyaxing", 25);\r\n\r\nconsole.log(person1.name); // "dyx"\r\nconsole.log(person2.name); // "douyaxing"\r\nconsole.log(person1.sayName === person2.sayName); // true\r\n```\r\n### 动态原型模式\r\n> 这个方法把所有信息都封装到了构造函数中，而在构造函数中通过判断只初始化一次原型。if语句中检查的可以是初始化后应该存在的任何属性或方法，不必要检查每一个方法和属性，只需要检查一个就行。\r\n\r\n- 优点：解决了组合模式中封装性的问题。\r\n```\r\nfunction Person(name, age) {\r\n  this.name = name;\r\n  this.age = age;\r\n  if (typeof this.sayName !== "function") {\r\n    Person.prototype.sayName: function() {\r\n      alert(this.name);\r\n    } \r\n  } \r\n}\r\n\r\nconst person1 = new Person("dyx", 24);\r\nperson1.sayName(); // "dyx"\r\n```\r\n### 寄生构造函数模式\r\n> 和工厂模式基本上是一摸一样的，只不过我们是采用 new 操作符最后来创建对象。\r\n\r\n- 优点：基于一个已有的类型，在实例化时对实例化的对象进行扩展。这样既不用修改原来的构造函数，也达到了扩展对象的目的。\r\n- 缺点：和工厂模式一样的问题，不能依赖 instanceof 操作符来确定对象的类型。\r\n```\r\nfunction CreatePerson(name, age) {\r\n  const o = new Object();\r\n  o.name = name;\r\n  o.age = age;\r\n  o.sayName = function() {\r\n    alert(this.name);\r\n  };\r\n  return o;\r\n}\r\n\r\nconst person1 = new CreatePerson("dyx", 24);\r\nconst person2 = new CreatePerson("douyaxing", 25);\r\n```\r\n### 稳妥构造函数模式\r\n> 稳妥对象最适合在一些安全的环境中（这些环境中会禁止使用 this 和 new）。\r\n\r\n- 优点：除了sayName方法外，没有别的方法可以访问数据成员，这就是稳妥构造函数提供的安全性。\r\n- 缺点：和寄生构造函数一样，没有办法使用 instanceof 操作符来判断对象的类型\r\n```\r\nfunction Person(name, age) {\r\n  // 创建要返回的对象\r\n  const o = new Object();\r\n\r\n  // 可以在这里定义私有变量和函数\r\n\r\n  // 添加方法\r\n  o.sayName = function() {\r\n    console.log(this.name);\r\n  }\r\n\r\n  //返回对象\r\n  return o;\r\n} \r\n\r\nconst person1 = Person("dyx", 25);\r\nperson1.sayName(); // "dyx"\r\n```\r\n'},function(r,n,e){"use strict";e.r(n),n.default="## 异步处理方案\r\n### callback回调函数\r\n- 优点：简单，容易理解。\r\n- 缺点：代码可读性差，不易维护，耦合度高，层层嵌套造成回调地狱。\r\n```\r\nconst funcOne = (num, callback) => {\r\n  const newNum = num + 5;\r\n  // 异步操作，使用setTimeout模拟\r\n  setTimeout(() => callback(newNum), 1000)\r\n}\r\nconst funcTwo = (num, callback) => {\r\n  const newNum = num + 10;\r\n  // 异步操作，使用setTimeout模拟\r\n  setTimeout(() => callback(newNum), 2000)\r\n}\r\nconst funcThree = (num, callback) => {\r\n  const newNum = num + 20;\r\n  // 异步操作，使用setTimeout模拟\r\n  setTimeout(() => callback(newNum), 3000)\r\n}\r\n\r\nconst start = () => {\r\n  const num = 5;\r\n  console.log(num);\r\n  funcOne(num, function(funcOneReturnvalue) {\r\n    console.log(funcOneReturnvalue);\r\n    funcTwo(funcOneReturnvalue, function(funcTwoReturnvalue) {\r\n      console.log(funcTwoReturnvalue);\r\n      funcThree(funcTwoReturnvalue, function(funcThreeReturnvalue) {\r\n        console.log(funcThreeReturnvalue);\r\n      });\r\n    });\r\n  });\r\n}\r\n\r\nstart();\r\n```\r\n### 事件监听（发布订阅模式）\r\n- 优点：更符合模块化思想，编写自己的监听器的时候可以做很多优化，从而更好的监听程序的运行。\r\n- 缺点：整个程序变成了事件驱动，或多或少影响了流程，而且每次使用都要注册事件监听器然后触发，比较麻烦。\r\n```\r\ndocument.body.addEventListener('click', function () {\r\n  console.log('click');\r\n});\r\n\r\n// 实现发布订阅\r\ntype EventHandler = (data?: any) => void;\r\n\r\nclass EventEmitter {\r\n  handlersMapping: {\r\n    [key: string]: Array<EventHandler>;\r\n  } = {};\r\n\r\n  // 注册事件和处理函数\r\n  on(type: string, handler: EventHandler) {\r\n    let handlers = this.handlersMapping[type];\r\n    if (!handlers) {\r\n      handlers = this.handlersMapping[type] = [];\r\n    }\r\n    handlers.push(handler);\r\n  }\r\n\r\n  // 销毁事件和处理函数\r\n  off(type: string, handler: EventHandler) {\r\n    let handlers = this.handlersMapping[type] || [];\r\n    if (!handler) {\r\n      // 没有传入要销毁的方法时，清空时间对应所有方法\r\n      this.handlersMapping[type] = [];\r\n    } else {\r\n      const targetIndex = handlers.findIndex((handlerItem: EventHandler) => handlerItem === handler);\r\n      if (targetIndex !== -1) {\r\n        handlers.splice(targetIndex, 1);\r\n      }\r\n    }\r\n  }\r\n\r\n  // 触发某事件所有回调并带参数\r\n  emit(type: string, payload?: any) {\r\n    let handlers = this.handlersMapping[type] || [];\r\n    handlers.forEach(handler => handler(payload));\r\n  }\r\n}\r\n\r\nexport default new EventEmitter();\r\n\r\n// 内部组件进行监听某个事件执行在内部组件中注册处理函数，在全局组件中满足条件时触发内部组件所监听的方法\r\nconst dyxtest = () => {}\r\nuseEffect(() => {\r\n  eventBus.on(\"dyxtest\", dyxtest);\r\n  return () => {\r\n    eventBus.off(\"dyxtest\", dyxtest);\r\n  };\r\n}, []);\r\n\r\n// 全局组件触发\r\neventBus.emit(\"dyxtest\");\r\n```\r\n### Promise\r\n- 优点：避免了回调函数层层嵌套，可读性更强。链式操作，可以在then中继续写Promise对象并return，然后继续调用then进行回调操作。\r\n- 缺点：Promise对象一旦创建就会立即执行，不能中途取消。\r\n```\r\nconst funcOne = num => {\r\n  return new Promise((resolve, reject) => {\r\n    const newNum = num + 5;\r\n    setTimeout(() => resolve(newNum), 1000)\r\n  })\r\n}\r\n\r\nconst funcTwo = num => {\r\n  return new Promise((resolve, reject) => {\r\n    const newNum = num + 10;\r\n    setTimeout(() => resolve(newNum), 2000)\r\n  })\r\n}\r\n\r\nconst funcThree = num => {\r\n  return new Promise((resolve, reject) => {\r\n    const newNum = num + 20;\r\n    setTimeout(() => resolve(newNum), 3000)\r\n  })\r\n}\r\n\r\nconst start = () => {\r\n  const num = 5;\r\n  console.log(num);\r\n  funcOne(num).then(resOne => {\r\n    console.log(resOne);\r\n    return funcTwo(resOne);\r\n  }).then(resTwo => {\r\n    console.log(resTwo);\r\n    return funcThree(resTwo);\r\n  }).then(resThree => {\r\n    console.log(resThree);\r\n  });\r\n}\r\n\r\nstart();\r\n```\r\n### Generator函数\r\n- 优点：优雅的流程控制方法，允许函数被中断地执行。\r\n- 缺点：Generator函数的执行必须依赖执行器，对于只做异步处理还是不太方便。\r\n```\r\nconst funcOne = () => {\r\n  return new Promise(resolve => {\r\n    setTimeout(() => console.log(1), 1000);\r\n  })\r\n}\r\n\r\nconst funcTwo = () => {\r\n  return new Promise(resolve => {\r\n    setTimeout(() => console.log(2), 2000);\r\n  })\r\n}\r\n\r\nconst funcThree = () => {\r\n  return new Promise(resolve => {\r\n    setTimeout(() => console.log(3), 3000);\r\n  })\r\n}\r\n\r\nfunction* start() {\r\n  console.log('start');\r\n  yield funcOne();\r\n  yield funcTwo();\r\n  yield funcThree();\r\n  return 'dyx';\r\n}\r\n\r\nconst startFun = start();  // 仅生成指针对象，并不执行\r\nstartFun.next() // start 1\r\nstartFun.next() // 2\r\nstartFun.next() // 3\r\n```\r\n### async函数\r\n- 优点：内置执行器，语义更好，适用性更广。\r\n- 缺点：误用await可能会导致性能问题，因为await会阻塞代码。\r\n```\r\nconst funcOne = num => {\r\n  return new Promise((resolve, reject) => {\r\n    const newNum = num + 5;\r\n    setTimeout(() => resolve(newNum), 1000)\r\n  })\r\n}\r\n\r\nconst funcTwo = num => {\r\n  return new Promise((resolve, reject) => {\r\n    const newNum = num + 10;\r\n    setTimeout(() => resolve(newNum), 2000)\r\n  })\r\n}\r\n\r\nconst funcThree = num => {\r\n  return new Promise((resolve, reject) => {\r\n    const newNum = num + 20;\r\n    setTimeout(() => resolve(newNum), 3000)\r\n  })\r\n}\r\n\r\nconst start = async () => {\r\n  const num = 5;\r\n  console.log(num);\r\n  const firstAddNum = await funcOne(num);\r\n  console.log(firstAddNum);\r\n  const secondAddNum = await funcTwo(firstAddNum);\r\n  console.log(secondAddNum);\r\n  const thirdAddNum = await funcThree(secondAddNum);\r\n  console.log(thirdAddNum);\r\n}\r\n\r\nstart();\r\n```\r\n### async/await对比promise的优缺点\r\n- 优点\r\n  1. 真正的串行的同步写法，代码阅读相对容易。\r\n  2. 对于条件语句和其他流程语句比较友好，可以直接写到判断条件里面。\r\n- 缺点\r\n  1. 无法处理promise返回的reject对象，要借助try catch。\r\n### async/await与Generator的差异\r\n- async/await自带执行器，不需要手动调用next()就能自动执行下一步。\r\n- async函数返回值是Promise对象，而Generator返回的是生成器对象。\r\n- await能够返回Promise的resolve/reject的值。\r\n### 利用Generator实现async函数\r\n> async/await实际上是对Generator（生成器）的封装，是一个语法糖。通过step函数实现Generator函数的自执行，当Generator函数的.next()执行返回done: true时表示执行完毕.\r\n\r\n```\r\nfunction asyncToGenerator(generatorFunc) {\r\n  return function() {\r\n    const gen = generatorFunc.apply(this, arguments);\r\n    return new Promise((resolve, reject) => {\r\n      function step(key, arg) {\r\n        let generatorResult;\r\n        try {\r\n          generatorResult = gen[key](arg);\r\n        } catch (error) {\r\n          return reject(error);\r\n        }\r\n        const { value, done } = generatorResult;\r\n        if (done) {\r\n          return resolve(value);\r\n        } else {\r\n          return Promise.resolve(value).then(val => step('next', val), err => step('throw', err));\r\n        }\r\n      }\r\n      step(\"next\");\r\n    })\r\n  }\r\n}\r\n```\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## javascript数据类型及判断方法\r\n> 基本数据类型在JavaScript中是按值传递的，而引用数据类型则是按引用传递的。\r\n\r\n### 基本数据类型\r\n> 存储在栈内存中，占据空间小、大小固定、读写速度快。基本数据类型变量存储的是值本身。\r\n\r\n1. undefined\r\n2. null\r\n3. Boolean\r\n4. Number\r\n5. String\r\n6. Symbol（es6新增）表示独一无二的值且不可变，一般用于对象的属性名。对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的Symbol类型。\r\n7. BigInt（es2020新增）BigInt是一种新的数据类型，当整数值大于Number数据类型支持的范围时使用。这种数据类型允许我们安全地对大整数执行算术操作。JS中的Number无法精确表示非常大的整数，它会将非常大的整数四舍五入，JS中的Number类型只能安全地表示-9007199254740991(-(2^53 - 1))和9007199254740991(2^53 - 1)，任何超出此范围的整数值都可能失去精度。\r\n### 引用数据类型\r\n> 存放在堆内存中，占据空间大、大小不固定、读写速度慢。引用数据类型变量存储的是一个指针(栈内存)，该指针指向数据实体在堆中的地址。\r\n\r\n1. Object (Array、Function、Object等)\r\n### 基础数据类型赋值\r\n> 当把变量a赋值给变量b时，会直接把变量a的值复制一份，然后赋值给变量b，这时改变变量a或者变量b的值，不会改变另外一个变量的值。\r\n\r\n```\r\nlet a = 18;\r\nlet b = a;\r\na = 20;\r\nconsole.log(a); // 20\r\nconsole.log(b); // 18\r\n```\r\n### 引用数据类型赋值\r\n> 当把变量a赋值给变量b时，是把变量a的内存地址复制一份赋值给变量b。\r\n\r\n- 改变变量a所指向的堆内存中的数据时会让另一个变量b的值改变。\r\n```\r\nlet a = {\r\n  name: 'dyx'\r\n};\r\nlet b = a;\r\na.name = 'douyaxing';\r\nconsole.log(a); // { name: 'douyaxing' }\r\nconsole.log(b); // { name: 'douyaxing' }\r\n```\r\n- 直接改变变量a的指针指向时不会让另一个变量b的值改变。\r\n```\r\nlet a = {\r\n  name: 'dyx'\r\n};\r\nlet b = a;\r\na = {\r\n  name: 'douyaxing'\r\n};\r\nconsole.log(a); // { name: 'douyaxing' }\r\nconsole.log(b); // { name: 'dyx' }\r\n```\r\n### 数据类型判断\r\n#### typeof\r\n- typeof返回一个表示数据类型的字符串，返回结果包括string、number、boolean、symbol、undefined、object、function等7种数据类型。\r\n- typeof对于基本数据类型除了null都可以显示正确的类型，typeof对于引用数据类型除了函数会显示function其它都会显示object。\r\n```\r\ntypeof '123';              // string 有效\r\ntypeof 1;                  // number 有效\r\ntypeof true;               // boolean 有效\r\ntypeof Symbol('1');        // symbol 有效\r\ntypeof undefined;          // undefined 有效\r\ntypeof null;               // object 无效\r\ntypeof {};                 // object 有效\r\ntypeof function() {};      // function 有效\r\ntypeof [];                 // object 无效\r\ntypeof new Date();         // object 无效\r\ntypeof new RegExp();       // object 无效\r\n```\r\n#### instanceof\r\n- instanceof用来判断A是否为B的实例，内部机制是检测构造函数的prototype属性是否出现在某个实例对象的原型链上。\r\n- 不能获取具体的数据类型。\r\n- instanceof可以正确的判断引用数据的类型，无法正确判断基本数据的类型。\r\n```\r\n'123' instanceof String;                // false 无效\r\n1 instanceof Number;                    // false 无效\r\ntrue instanceof Boolean;                // false 无效\r\nSymbol('1') instanceof Symbol;          // false 无效\r\n{} instanceof Object;                   // true 有效\r\nfunction() {} instanceof Function;      // true 有效\r\n[] instanceof Array;                    // true 有效\r\nnew Date() instanceof Date;             // true 有效\r\nnew RegExp() instanceof RegExp;         // true 有效\r\n```\r\n#### constructor\r\n- 当一个构造函数被定义时，构造函数会有原型对象prototype，原型对象上constructor属性指向构造函数。使用构造函数创建对象时，创建的对象继承了构造函数原型对象prototype。新创建的对象的constructor属性指向构造函数。\r\n- 不能获取具体的数据类型。\r\n- 除undefined、null两种数据类型外都可以判断正确的类型，undefined、null没有原生构造函数。\r\n- 当修改了构造函数原型对象的constructor属性值时，使用constructor判断数据类型就变得不可靠了。\r\n```\r\n('123').constructor === String;           // true\r\n(1).constructor === Number;               // true\r\n(true).constructor === Boolean;           // true\r\n(Symbol('1')).constructor === Symbol;     // true            \r\n({}).constructor === Object;              // true \r\n(function() {}).constructor === Function; // true \r\n([]).constructor === Array;               // true \r\n(new Date()).constructor === Date;        // true \r\n(new RegExp()).constructor === RegExp;    // true \r\n```\r\n#### Object.prototype.toString.call()\r\n- 使用Object原型对象上的toString方法，toString方法返回运行时this指向的对象类型，返回的类型格式为`[object,xxx]`，xxx是具体的数据类型。\r\n- 最准确的类型判断方法。适用所有的数据类型。\r\n```\r\nObject.prototype.toString.call('123');         // [object, String]\r\nObject.prototype.toString.call(1);             // [object, Number]\r\nObject.prototype.toString.call(true);          // [object, Boolean]\r\nObject.prototype.toString.call(Symbol('1'));   // [object, Symbol]\r\nObject.prototype.toString.call(undefined);     // [object, Undefined]\r\nObject.prototype.toString.call(null);          // [object, Null]\r\nObject.prototype.toString.call({});            // [object, Object]\r\nObject.prototype.toString.call(function() {}); // [object, Function]\r\nObject.prototype.toString.call([]);            // [object, Array]\r\nObject.prototype.toString.call(new Date());    // [object, Date]\r\nObject.prototype.toString.call(new RegExp());  // [object, RegExp]\r\n\r\n// 通用的判断方法\r\nconst checkType = data => {\r\n  const type = Object.prototype.toString.call(data); // 返回字符串类型的值\r\n  // 截取代表真正数据类型部分\r\n  return type.slice(8, -1);\r\n}\r\n```\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## [浏览器页面不可见时定时器是否准时](http://www.codebaoku.com/it-js/it-js-255148.html)\r\n### 浏览器可见和不可见状态\r\n> 浏览器的可见和不可见状态(浏览器切换到其他标签页或最小化)的切换会触发visibilitychange事件，可以通过监听这个事件来判别浏览器的可见状态。\r\n\r\n- hidden：页面彻底不可见，也可以使用document.hidden返回一个布尔值，为true说明当前浏览器是不可见状态。\r\n- visible：页面至少一部分可见。\r\n- prerender：页面即将或正在渲染，处于不可见状态。 \r\n```\r\ndocument.addEventListener(\"visibilitychange\", function() {\r\n  console.log(document.visibilityState);\r\n});\r\n```\r\n### setInterval\r\n- 谷歌浏览器中当页面处于不可见状态时，setInterval的最小间隔时间会被限制为1s。\r\n- 火狐浏览器和谷歌浏览器特性一致。\r\n- IE浏览器没有对不可见状态时的setInterval进行性能优化，不可见状态前后间隔时间不变。\r\n### setTimeout\r\n- 谷歌浏览器中当页面处于不可见状态时，setTimeout的间隔低于1s的会变为1s，大于等于1s的会变成N+1s的间隔值(n为设置的时间间隔，页面恢复可见后时间间隔恢复正常)。\r\n- 火狐浏览器中当页面处于不可见状态时，setTimeout的间隔低于1s的会变为1s，大于等于1s的间隔不变。\r\n- IE浏览器在不可见状态前后间隔时间不变。\r\n### requestAnimationFrame\r\n- 谷歌浏览器中当页面处于不可见状态时，requestAnimationFrame方法停止执行。\r\n- 火狐浏览器中当页面处于不可见状态时，间隔是1s,2s,4s,8s,16s,32s...这样的顺序去执行requestAnimationFrame方法。\r\n- IE浏览器中当页面处于不可见状态时，requestAnimationFrame方法停止执行。\r\n### 解决方法\r\n- 在一些定时器小于1s的倒计时页面中，如果用户切换到了其他标签页。再切回去的时候，页面上显示的倒计时时间其实是错误的。\r\n- 使用webWorkers解决上述问题，而且webWorkers还可以解决一个页面存在多个定时器间隔时间误差较大的问题。\r\n```\r\ndocument.getElementById('btn').addEventListener('click', function() {\r\n  const w = new Worker('demo_workers.js');\r\n  w.onmessage = function(event) {\r\n    console.log(event.data);\r\n  };\r\n});\r\n\r\n// 浏览器切换事件\r\ndocument.addEventListener('visibilitychange', function() { \r\n  if (document.hidden) {\r\n    console.log('页面不可见');\r\n  }\r\n});\r\n\r\n\r\n// demo_workers.js\r\nsetInterval(function() {\r\n  const myDate = new Date();\r\n  const currentDate = myDate.getMinutes() + '分'+ myDate.getSeconds() + '秒' + myDate.getMilliseconds() + '豪秒';\r\n  postMessage(currentDate);\r\n}, 500);\r\n```\r\n### 电脑休眠状态下定时器的运行状况\r\n- setTimeout在电脑休眠后会暂停运行，电脑重新唤醒之后会立即执行一次。\r\n- node-schedule在电脑休眠后会暂停运行，电脑重新唤醒之后会立即执行之前暂停时间段所有没有执行的任务。\r\n\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## 浮点数精度丢失\r\n### 0.1 + 0.2 ≠ 0.3的现象\r\n> 计算机存储双精度浮点数，需要先把十进制转换为二进制的科学计数法形式，然后计算机以一定的规则存储，因为存储时有位数限制（双精度 8 字节，64 位），末位就需要取近似值（0舍1入），再转换为十进制时，就造成了误差。\r\n\r\n### 解决办法\r\n- 处理大数的bignumber.js。\r\n- 处理小数的number-precision和decimal.js。\r\n### 二进制转化\r\n#### 正整数的转换\r\n> 除二取余，然后倒序排列，高位补零。\r\n\r\n1. 65转二进制为1000001\r\n2. 高位0后为01000001。\r\n\r\n#### 负整数的转换\r\n> 将对应的正整数转换成二进制后，对二进制取反，然后对结果再加一。\r\n\r\n1. -65转二进制\r\n2. 先把65转换成二进制01000001\r\n3. 逐位取反：10111110\r\n4. 再加1：10111111\r\n#### 小数的转换\r\n> 对小数点以后的数乘以2，取整数部分，再取小数部分乘2，以此类推……，直到小数部分为0或位数足够。取整部分按先后顺序排列即可。进制小数转二进制后大概率出现无限位数。\r\n\r\n1. 123.4转二进制\r\n2. `0.4*2=0.8` ——————-> 取0\r\n3. `0.8*2=1.6` ——————-> 取1\r\n4. `0.6*2=1.2` ——————-> 取1\r\n5. `0.2*2=0.4` ——————-> 取0\r\n6. `0.4*2=0.8` ——————-> 取0\r\n7. 以此类推循环\r\n8. 按顺序写出：0.4 = 0.01100110……（0110循环）\r\n9. 整数部分123的二进制是1111011\r\n10. 则123.4的二进制表示为：1111011.011001100110……"},function(r,n,e){"use strict";e.r(n),n.default="## 浅拷贝深拷贝\r\n### 引用数据类型直接赋值\r\n- 改变变量a所指向的内存中的数据时会让另一个变量b的值改变。\r\n```\r\nlet a = {\r\n  name: 'dyx'\r\n};\r\nlet b = a;\r\na.name = 'douyaxing';\r\nconsole.log(a); // { name: 'douyaxing' }\r\nconsole.log(b); // { name: 'douyaxing' }\r\n```\r\n- 直接改变变量a的指针指向时不会让另一个变量b的值改变。\r\n```\r\nlet a = {\r\n  name: 'dyx'\r\n};\r\nlet b = a;\r\na = {\r\n  name: 'douyaxing'\r\n};\r\nconsole.log(a); // { name: 'douyaxing' }\r\nconsole.log(b); // { name: 'dyx' }\r\n```\r\n- 改变形参arr所指向的内存中的数据时也会修改变量a。\r\n```\r\nconst a = [1, 2, 3];\r\nfunction test(arr) {\r\n  arr[0] = 4; // arr形参的修改也会修改变量a，因为两个变量的值(数组)指向同一内存内容。\r\n}\r\ntest(a);\r\nconsole.log(a) // [4, 2, 3]\r\n```\r\n- 改变形参arr的指针指向时不会修改变量a。\r\n```\r\nconst a = [1, 2, 3];\r\nfunction test(arr) {\r\n  arr = [1, 2]; // 修改的是arr变量的指向，并不会影响a变量指向内存的内容\r\n}\r\ntest(a);\r\nconsole.log(a) // [1, 2, 3]\r\n```\r\n### 浅拷贝\r\n> 第二层及以下的都是浅拷贝，修改第二层及以下层级内容，另一个变量还是会跟着改变。\r\n\r\n- 扩展运算符\r\n```\r\nconst obj = {\r\n  a: 1,\r\n  b: 2,\r\n  c: [1, { name: 'dyx' }]\r\n};\r\nconst shallowCopy = {...obj};\r\n```\r\n- Object.assign\r\n```\r\nconst obj = {\r\n  a: 1,\r\n  b: 2,\r\n  c: [1, { name: 'dyx' }]\r\n};\r\nconst shallowCopy = Object.assign({}, obj);\r\n```\r\n- 自己实现\r\n```\r\nconst obj = {\r\n  a: 1,\r\n  b: 2,\r\n  c: [1, { name: 'dyx' }]\r\n};\r\n\r\nfunction shallowClone(obj) {\r\n  const newObj = Object.prototype.toString.call(obj) === '[object Array]' ? [] : {};\r\n  if (typeof obj !== 'object') {\r\n    return;\r\n  } else {\r\n    for(const name in obj) {\r\n      if(obj.hasOwnProperty(name)) {\r\n        newObj[name] = obj[name];\r\n      }\r\n    }\r\n    return newObj;\r\n  }\r\n}\r\n\r\nconst shallowCopy = shallowClone(obj);\r\n```\r\n### 深拷贝\r\n> 所有层级都可以修改，不会影响另一个变量。\r\n\r\n- JSON.parse(JSON.stringify(x))\r\n  1. 性能很好。\r\n  2. 只能拷贝基本对象、数组，日期对象会被转换为字符串，集合会被简转换为{}。\r\n  3. 遇到循环引用时会抛出错误。\r\n```\r\nconst obj = {\r\n  a: 1,\r\n  b: 2,\r\n  c: [1, { name: 'dyx' }]\r\n};\r\nconst deepCopy = JSON.parse(JSON.stringify(obj));\r\n```\r\n- _.cloneDeep，使用lodash的cloneDeep方法\r\n  1. 拷贝效果好，常用方法。\r\n  2. 增加三方依赖包体积。\r\n```\r\nimport { cloneDeep } from 'lodash';\r\n\r\nconst obj = {\r\n  a: 1,\r\n  b: 2,\r\n  c: [1, { name: 'dyx' }]\r\n};\r\nconst deepCopy = _.cloneDeep(obj);\r\n```\r\n- structuredClone方法\r\n  1. 支持拷贝无限嵌套的对象和数组。\r\n  2. 支持拷贝循环引用对象。\r\n  3. 支持拷贝多种JavaScript类型，如Date、Set、Map、Error、RegExp等。\r\n  4. 函数、DOM节点不支持拷贝。\r\n  5. 存在兼容性问题。\r\n```\r\nconst obj = {\r\n  a: 1,\r\n  b: 2,\r\n  c: [1, { name: 'dyx' }]\r\n};\r\nconst deepCopy = structuredClone(obj);\r\n```\r\n- 使用递归自己实现，当value仍是对象数据格式时递归调用deepClone方法。\r\n```\r\nconst obj = {\r\n  a: 1,\r\n  b: 2,\r\n  c: [1, { name: 'dyx' }]\r\n};\r\nfunction deepClone(obj) {\r\n  const newObj = Object.prototype.toString.call(obj) === '[object Array]' ? [] : {};\r\n  if (typeof obj !== 'object') {\r\n    return;\r\n  } else {\r\n    for (const name in obj) {\r\n      if (obj.hasOwnProperty(name)) {\r\n        newObj[name] = typeof obj[name] === 'object' ? deepClone(obj[name]) : obj[name];\r\n      }\r\n    }\r\n  }\r\n  return newObj;\r\n}\r\n\r\nconst deepCopy = deepClone(obj);\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## 渲染大量数据\r\n> 对于大量数据的渲染，JS运算并不是性能的瓶颈，性能的瓶颈主要在于渲染阶段。JS执行要比DOM渲染快的多。\r\n\r\n### 滚动加载更多\r\n### 分页实现\r\n### 虚拟列表\r\n> 虚拟列表其实是按需显示的一种实现，只对可见区域进行渲染，对非可见区域中的数据不渲染或部分渲染的技术，从而达到极高的渲染性能。假设有1万条记录需要同时渲染，我们屏幕的可见区域的高度为500px,而列表项的高度为50px，则此时我们在屏幕中最多只能看到10个列表项，那么在首次渲染的时候，我们只需加载10条即可。当滚动发生时，可以通过计算当前滚动值得知此时在屏幕可见区域应该显示的列表项。假设滚动条距顶部的位置为150px，则我们可得知在可见区域内的列表项为第4项至第13项。\r\n\r\n- 计算当前可视区域起始数据索引。\r\n- 计算当前可视区域结束数据索引。\r\n- 计算当前可视区域的数据，并渲染到页面中。\r\n- 计算startIndex对应的数据在整个列表中的偏移位置并设置到列表上。\r\n- 监听滚动列表的scroll事件，获取滚动位置scrollTop，从而重新计算可视区域的起始数据索引、结束数据索引、可视区域的数据、以及整个列表的偏移位置。\r\n### 时间分片\r\n#### setTimeout的问题\r\n- 当使用setTimeout来拆分大量的DOM插入操作时，即使我们将延迟时间设置为0ms，但实际上由于JavaScript是单线程的，任务执行时会被放入到事件队列中，而事件队列中的任务需要等待当前任务执行完成后才能执行。所以即使设置了0ms延迟，setTimeout的回调函数也不一定会立即执行，可能会受到其他任务的阻塞。\r\n- 当setTimeout的回调函数执行的间隔超过了浏览器每帧更新的时间间隔(一般是16.7ms)，就会出现丢帧现象。丢帧指的是浏览器在更新页面时，没有足够的时间执行全部的任务，导致部分任务被跳过，从而导致页面渲染不连续，出现闪烁的情况。\r\n- 使用setTimeout实现动画在页面隐藏或最小化时，仍会在后台执行动画任务浪费cpu资源。而requestAnimationFrame不同，在页面处于未激活状态下，该页面的屏幕绘制会暂停，当页面被激活时动画从上次停留位置开始执行。\r\n#### requestAnimationFrame\r\n> requestAnimationFrame最大的优势是由系统来决定回调函数的执行时机。如果屏幕刷新率是60Hz，那么回调函数就每16.7ms被执行一次，如果刷新率是75Hz，那么这个时间间隔就变成了1000/75=13.3ms，requestAnimationFrame的步伐跟着系统的刷新步伐走。它能保证回调函数在屏幕每一次的刷新间隔中只被执行一次，这样就不会引起丢帧现象。\r\n\r\n```\r\n// 需要插入的容器\r\nconst ul = document.getElementById('container');\r\n// 插入十万条数据\r\nconst total = 100000;\r\n// 一次插入 20 条\r\nconst once = 20;\r\n// 每条记录的索引\r\nconst index = 0;\r\n// 循环加载数据\r\nfunction loop(curTotal, curIndex) {\r\n  if (curTotal <= 0) {\r\n    return false;\r\n  }\r\n  // 每页多少条\r\n  const pageCount = Math.min(curTotal, once);\r\n  window.requestAnimationFrame(function() {\r\n    for (let i = 0; i < pageCount; i++) {\r\n      const li = document.createElement('li');\r\n      li.innerText = curIndex + i;\r\n      ul.appendChild(li);\r\n    }\r\n    loop(curTotal - pageCount, curIndex + pageCount);\r\n  })\r\n}\r\nloop(total, index);\r\n```\r\n#### 使用DocumentFragment优化\r\n> 被作为一个轻量版的Document使用，用于存储已排好版的或尚未打理好格式的html片段。DocumentFragment不是真实DOM树的一部分，它的变化不会触发DOM树的重新渲染，且不会导致性能等问题。DocumentFragment是DOM节点，但并不是DOM树的一部分，可以认为是存在内存中的，所以将子元素插入到文档片段时不会引起页面回流。\r\n\r\n```\r\n// 需要插入的容器\r\nconst ul = document.getElementById('container');\r\n// 插入十万条数据\r\nconst total = 100000;\r\n// 一次插入 20 条\r\nconst once = 20;\r\n// 每条记录的索引\r\nconst index = 0;\r\n// 循环加载数据\r\nfunction loop(curTotal, curIndex) {\r\n  if (curTotal <= 0) {\r\n    return false;\r\n  }\r\n  // 每页多少条\r\n  const pageCount = Math.min(curTotal , once);\r\n  window.requestAnimationFrame(function() {\r\n    const fragment = document.createDocumentFragment();\r\n    for (let i = 0; i < pageCount; i++) {\r\n      const li = document.createElement('li');\r\n      li.innerText = curIndex + i;\r\n      fragment.appendChild(li);\r\n    }\r\n    ul.appendChild(fragment);\r\n    loop(curTotal - pageCount, curIndex + pageCount);\r\n  })\r\n}\r\nloop(total, index);\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## 箭头函数与普通函数的区别\r\n- 箭头函数语法更加简洁、清晰。\r\n- 箭头函数会使用其所在上下文的this作为自己的this值，定义的时候就确定了。\r\n- call、apply、bind不会影响箭头函数this的指向。箭头函数中的this不会指向传入的第一个参数，第一个参数被忽略，而是指向了window对象。\r\n- 箭头函数不能作为构造函数使用，也不能使用new关键字(因为箭头函数没有自己的this，它的this是继承了其所在上下文中的this，且this指向永远不会改变，构造函数的this要是指向创建的新对象)。\r\n- 不可以使用arguments对象，该对象在箭头函数体内不存在。如果要用可以用rest参数代替。\r\n- 箭头函数没有原型prototype。\r\n- 箭头函数不能用作Generator函数，不能使用yield关键字。\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## 类和原型实现相同功能\r\n### 基础功能\r\n- 类\r\n```\r\nclass Student {\r\n  constructor(name, age, grade) {\r\n    this.name = name;\r\n    this.age = age;\r\n    this.grade = grade;\r\n  } \r\n   \r\n  displayInfo() {\r\n    console.log(`Name: ${this.name}, Age: ${this.age}, Grade: ${this.grade}`);\r\n  }\r\n\r\n  // 静态方法适用于与实例无关的功能\r\n  static compareAge(student1, student2) {\r\n    if (student1.age > student2.age) {\r\n      console.log(`${student1.name} is older than ${student2.name}.`);\r\n    } else if (student1.age < student2.age) {\r\n      console.log(`${student1.name} is younger than ${student2.name}.`);\r\n    } else {\r\n      console.log(`${student1.name} and ${student2.name} are of the same age.`);\r\n    }\r\n  }\r\n}\r\n```\r\n- 原型\r\n  1. class类构造函数中声明的属性，是在Student实例中的，function实现时也需在实例上。\r\n  2. 类中的实例函数displayInfo是定义在类的原型上，并且是不可枚举的，function实现时也需要在原型上。\r\n  3. 类中的静态方法compareAge是定义在类本身上的方法，而不是在类实例上的，function实现时应在函数本身上，并且类中静态函数也是不可枚举的。\r\n```\r\nfunction Student(name, age, grade) {\r\n  // 实例属性\r\n  this.name = name;\r\n  this.age = age;\r\n  this.grade = grade;\r\n}\r\n\r\nObject.defineProperty(Student.prototype, 'displayInfo', {\r\n  value: function() {\r\n    console.log(`Name: ${this.name}, Age: ${this.age}, Grade: ${this.grade}`);\r\n  },\r\n  enumerable: false, // 类中的函数是不可枚举的\r\n})\r\n\r\nObject.defineProperty(Student,\r\n  'compareAge', function(student1, student2) {\r\n    if (student1.age > student2.age) {\r\n      console.log(`${student1.name} is older than ${student2.name}.`);\r\n    } else if (student1.age < student2.age) {\r\n      console.log(`${student1.name} is younger than ${student2.name}.`);\r\n    } else {\r\n      console.log(`${student1.name} and ${student2.name} are of the same age.`);\r\n    }\r\n  }\r\n)\r\n```\r\n- 如果在function上增加一个非函数属性, 在类中是没有对应实现的，即使写在构造函数中的实例属性也不是等价的。因为在原型链模式下，原型上的属性是所有实例共享的，而将属性写在类的构造函数中会使每个实例拥有自己的属性副本，这改变了属性的共享方式。类中实现不了，但是可以给类的原型链增加非函数属性手动修改class的原型。\r\n```\r\n// function\r\nfunction Student() {}\r\nStudent.prototype.name = '123';\r\n\r\n// class\r\nclass Student {}\r\nStudent.prototype.name = '123'; // 所有实例共享\r\n```\r\n### 进阶功能(继承)\r\n- 类\r\n```\r\nclass Person {\r\n  constructor(sex) {\r\n    this.sex = sex;\r\n  }\r\n\r\n  getSex() {\r\n    console.log('获取性别',this.sex);\r\n    return this.sex;\r\n  }\r\n}\r\n\r\nclass Student extends Person {\r\n  constructor(name, age, grade, sex) {\r\n    super(sex); // 调用父类的constructor\r\n    this.name = name;\r\n    this.age = age;\r\n    this.grade = grade;\r\n  } \r\n   \r\n  displayInfo(){\r\n    console.log(`Name: ${this.name}, Age: ${this.age}, Grade: ${this.grade}`);\r\n  }\r\n\r\n  // 静态方法适用于与实例无关的功能\r\n  static compareAge(student1, student2) {\r\n    if (student1.age > student2.age) {\r\n      console.log(`${student1.name} is older than ${student2.name}.`);\r\n    } else if (student1.age < student2.age) {\r\n      console.log(`${student1.name} is younger than ${student2.name}.`);\r\n    } else {\r\n      console.log(`${student1.name} and ${student2.name} are of the same age.`);\r\n    }\r\n  }\r\n}\r\n```\r\n- 原型\r\n  1. 构造函数定义：Person和Student都作为构造函数定义，其中Student构造函数内部首先调用Person.call(this, sex)来确保父类的构造函数被正确执行，并设置了sex属性。\r\n  2. 设置原型和构造器：通过Object.create(Person.prototype)创建一个新对象，这个对象的原型指向Person.prototype，然后将这个对象赋值给Student.prototype以建立原型链继承。然后将Student.prototype.constructor设置为Student，以保证实例的constructor属性正确指向Student。\r\n```\r\n// 定义Person构造函数\r\nfunction Person(sex) {\r\n  this.sex = sex;\r\n}\r\n\r\n// 定义Person的getSex实例方法\r\nObject.defineProperty(Person.prototype, 'getSex', {\r\n  value: function() {\r\n    console.log('获取性别', this.sex);\r\n    return this.sex;\r\n  },\r\n  enumerable: false\r\n})\r\n\r\n// 定义Student构造函数\r\nfunction Student(name, age, grade, sex) {\r\n  // 显式调用父类的构造函数\r\n  Person.call(this,sex);\r\n  this.name = name;\r\n  this.age = age;\r\n  this.grade = grade;\r\n}\r\n\r\n// 建立继承关系，设置Student的原型为Person的prototype\r\nStudent.prototype = Object.create(Person.prototype);\r\n// 设置构造器指向，确保intanceof运算符能正确识别实例\r\nStudent.prototype.constructor = Student;\r\n\r\nObject.defineProperty(Student.prototype, 'displayInfo', {\r\n  value: function() {\r\n    console.log(`Name: ${this.name}, Age: ${this.age}, Grade: ${this.grade}`);\r\n  },\r\n  enumerable: false, // 类中的函数是不可枚举的\r\n})\r\n\r\nObject.defineProperty(Student,\r\n  'compareAge', function(student1,student2) {\r\n    if (student1.age > student2.age) {\r\n      console.log(`${student1.name} is older than ${student2.name}.`);\r\n    } else if (student1.age < student2.age) {\r\n      console.log(`${student1.name} is younger than ${student2.name}.`);\r\n    } else {\r\n      console.log(`${student1.name} and ${student2.name} are of the same age.`);\r\n    }\r\n  }\r\n)\r\n```"},function(r,n,e){"use strict";e.r(n),n.default='## js数据类型转换\r\n### 转成boolean\r\n- js在预期为布尔值的地方比如if()的语句中会自动将非布尔值参数转为布尔值;只有空字符串("")、null、undefined、+0、-0、false和 NaN 在if中转为布尔型是 false，其他的都是 true([]、{})。\r\n```\r\nif (\'abc\') {\r\n console.log(\'hello\')\r\n} // "hello"\r\n```\r\n- !非运算符会自动将非布尔值转为布尔值,利用该规则对一非布尔值去两次反会转为布尔类型\r\n- Boolean(\'abc\')可以转成布尔值，只有\'\'(空字符串)、null、undefined、0、NaN、false为false，空数组、空对象 new Boolean(false)都为true\r\n```\r\nBoolean(function(){}) // true\r\n!!() => {} // true\r\nBoolean(\'0\') // true\r\nBoolean(0) // false\r\nnew Boolean(false) // true\r\n```\r\n### 其他的数据类型转换为String\r\n- toString()方法\r\n> 调用被转换数据类型的toString()方法,该方法不会影响到原变量，它会将转换的结果返回，但是注意：null和undefined这两个值没有toString，如果调用他们的方法，会报错。采用 Number 类型的 toString() 方法的基模式，可以用不同的基输出数字，例如二进制的基是 2，八进制的基是 8，十六进制的基是 16。\r\n\r\n```\r\nvar iNum = 10;\r\nalert(iNum.toString(2)); //输出 "1010"\r\nalert(iNum.toString(8)); //输出 "12"\r\nalert(iNum.toString(16)); //输出 "A"\r\n```\r\n- String()函数\r\n> 使用String()函数做强制类型转换时，对于Number和Boolean实际上就是调用的toString()方法,但是对于null和undefined，就不会调用toString()方法,它会将null直接转换为"null",将undefined 直接转换为"undefined",String方法的参数如果是对象，返回一个类型字符串；如果是数组，返回该数组的字符串形式。\r\n\r\n```\r\nvar a = null\r\nString(a) // "null"\r\nvar b = undefined\r\nString(b) // "undefined"\r\nString({ a: 1 }) // "[object Object]"\r\nString([1, 2, 3]) // "1,2,3"\r\n```\r\n- 字符串的自动转换，主要发生在字符串的加法运算时。当一个值为字符串，另一个值为非字符串，则后者转为字符串。\r\n```\r\n5 + \'1\' // \'51\'\r\n\'5\' + true // "5true"\r\n\'5\' + false // "5false"\r\n\'5\' + {} // "5[object Object]"\r\n\'5\' + [] // "5"\r\n\'5\' + function (){} // "5function (){}"\r\n\'5\' + undefined // "5undefined"\r\n\'5\' + null // "5null"\r\n```\r\n### 其他的数据类型转换为Number\r\n- 纯数字的字符串可以直接在前面加+号转为数值型\r\n- 使用Number()函数\r\n  1. 字符串转数字\r\n  > 如果是纯数字的字符串，则直接将其转换为数字;如果字符串中有非数字的内容，则转换为NaN;如果字符串是一个空串或者是一个全是空格的字符串，则转换为0\r\n\r\n  2. 布尔值转数字:true转成1,false转成0\r\n  3. undefined转数字:转成NaN  undefined+5=NaN\r\n  4. null转数字：转成0  null+5=5\r\n  5. Number() 接受数值作为参数，此时它既能识别负的十六进制，也能识别0开头的八进制，返回值永远是十进制值\r\n  ```\r\n  Number(3.15); // 3.15\r\n  Number(023); // 19\r\n  Number(0x12); // 18\r\n  Number(-0x12); // -18\r\n  ```\r\n  6. 对象转数字\r\n  > Number方法的参数是对象时，将返回NaN，除非是包含单个数值的数组\r\n\r\n  ```\r\n  Number({ a: 1 }) // NaN\r\n  Number([1, 2, 3]) // NaN\r\n  Number([5]) // 5\r\n  ```\r\n- parseInt() & parseFloat()\r\n> 这种方式专门用来对付字符串，parseInt()一个字符串转换为一个整数,可以将一个字符串中的有效的整数内容取出来，然后转换为Number。parseFloat()把一个字符串转换为一个浮点数。parseFloat()作用和parseInt()类似，不同的是它可以获得有效的小数。\r\n\r\n```\r\n// 当可以抽取出来的数值的前面有不符合的内容时会返回NaN \r\nconsole.log(parseInt("a10")); // NaN\r\nconsole.log(parseInt(\'.21\')); // NaN\r\nconsole.log(parseInt("10.3")); // 10\r\nconsole.log(parseFloat(\'.21\')); // 0.21\r\nconsole.log(parseFloat(\'.d1\')); // NaN\r\nconsole.log(parseFloat("10.11.33")); // 10.11\r\nconsole.log(parseFloat("4.3years")); // 4.3\r\nconsole.log(parseFloat("He40.3")); // NaN\r\n```\r\n> parseInt()在没有第二个参数时默认以十进制转换数值，有第二个参数时，以第二个参数为基数转换数值，如果基数有误返回NaN\r\n\r\n```\r\nconsole.log(parseInt("13")); // 13\r\nconsole.log(parseInt("11", 2)); // 3\r\nconsole.log(parseInt("17", 8)); // 15\r\nconsole.log(parseInt("1f", 16)); // 31\r\n```\r\n- 算数运算符(+ - * /)跟非Number类型的值进行运算时，会将这些值转换为Number，然后在运算，除了字符串的加法运算\r\n```\r\ntrue + 1 // 2\r\n2 + null // 2\r\nundefined + 1 // NaN\r\n2 + NaN // NaN 任何值和NaN做运算都得NaN\r\n\'5\' - \'2\' // 3\r\n\'5\' * \'2\' // 10\r\ntrue - 1 // 0\r\n\'1\' - 1 // 0\r\n\'5\' * [] // 0\r\nfalse / \'5\' // 0\r\n\'abc\' - 1 // NaN\r\n```\r\n- Number函数将字符串转为数值，要比parseInt函数严格很多。基本上，只要有一个字符无法转成数值，整个字符串就会被转为NaN。对空字符串的处理也不一样\r\n```\r\nparseInt(\'42 cats\') // 42\r\nNumber(\'42 cats\') // NaN\r\nNumber(" "); // 0 \r\nparseInt(" "); // NaN\r\n```'},function(r,n,e){"use strict";e.r(n),n.default="## 继承\r\n> 继承是面向对象编程的三大特征之一（封装、继承、多态）。多个类中存在相同的属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只需要继承那个类即可。多个类可以称为子类，单独这个类称为父类或者超类，基类等。子类可以直接访问父类中的非私有的属性和行为。\r\n\r\n### js的继承\r\n> 在其他面向类语言中，继承意味着复制操作，子类是实实在在地将父类的属性和方法复制了过来，但javascript中的继承不是这样的。根据原型的特性，js中继承的本质是一种委托机制，对象可以将需要的属性和方法委托给原型，需要用的时候就去原型上拿，这样多个对象就可以共享一个原型上的属性和方法，这个过程中是没有复制操作的。\r\n\r\n### 原型链继承\r\n> 直接利用原型链特征实现的继承，让构造函数的prototype指向另一个构造函数的实例。当查找dyx实例的head和hand属性时，由于dyx本身并没有这两个属性，引擎就会去查找dyx的原型，还是没有，继续查找dyx原型的原型，也就是Person原型对象，结果就找到了。因此YellowPerson和Person之间通过原型链实现了继承关系。\r\n\r\n```\r\nfunction Person() {\r\n  this.head = 1;\r\n  this.hand = 2;\r\n}\r\n\r\nfunction YellowPerson() {};\r\nYellowPerson.prototype = new Person();\r\n\r\nconst dyx = new YellowPerson();\r\nconsole.log(dyx.head); // 1\r\nconsole.log(dyx.hand); // 2\r\n```\r\n![原型链继承](./img/原型链继承.png)\r\n#### 原型链继承的问题\r\n1. 创建dyx实例时不能传参，也就是YellowPerson构造函数本身不接受参数。\r\n2. 当原型上的属性是引用数据类型时，所有实例都会共享这个属性，即某个实例对这个属性重写会影响其他实例。\r\n```\r\nfunction Person() {\r\n  this.colors = ['white', 'yellow', 'black'];\r\n}\r\n\r\nfunction YellowPerson() {};\r\nYellowPerson.prototype = new Person();\r\n\r\nconst dyx = new YellowPerson();\r\ndyx.colors.push('green');\r\nconsole.log(dyx.colors); // ['white', 'yellow', 'black', 'green']\r\n\r\nconst douyaxing = new YellowPerson();\r\nconsole.log(douyaxing.colors); // ['white', 'yellow', 'black', 'green']\r\n```\r\n### 盗用构造函数继承\r\n> 盗用构造函数也叫作“对象伪装”或者“经典继承”，原理就是通过在子类中调用父类构造函数实现上下文的绑定。YellowPerson在内部使用call调用构造函数，这样在创建YellowPerson的实例时，Person就会在YellowPerson实例的上下文中执行，于是每个YellowPerson实例都会拥有自己的colors属性，而且这个过程是可以传递参数的，Person.call()接受的参数最终会赋给YellowPerson的实例。\r\n\r\n```\r\nfunction Person(eyes) {\r\n  this.eyes = eyes;\r\n  this.colors = ['white', 'yellow', 'black'];\r\n}\r\n\r\nfunction YellowPerson() {\r\n  Person.call(this, 'black'); // 调用构造函数并传参\r\n}\r\n\r\nconst dyx = new YellowPerson();\r\ndyx.colors.push('green');\r\nconsole.log(dyx.colors); // ['white', 'yellow', 'black', 'green']\r\nconsole.log(dyx.eyes); // black\r\n\r\nconst douyaxing = new YellowPerson();\r\nconsole.log(douyaxing.colors); // ['white', 'yellow', 'black']\r\nconsole.log(douyaxing.eyes); // black\r\n```\r\n![盗用构造函数继承](./img/盗用构造函数继承.png)\r\n#### 盗用构造函数继承的问题\r\n1. 必须在构造函数中定义方法，通过盗用构造函数继承的方法本质上都变成了实例自己的方法，不是公共的方法，因此失去了复用性。\r\n2. 子类不能访问父类原型上定义的方法，因此所有类型只能使用构造函数模式，原因是YellowPerson构造函数、dyx和douyaxing实例都没有和Person的原型对象产生联系。\r\n```\r\nfunction Person(eyes) {\r\n  this.eyes = eyes;\r\n  this.getEyes = function () {\r\n    return this.eyes;\r\n  }\r\n}\r\nPerson.prototype.ReturnEyes = function() {\r\n  return this.eyes;\r\n}\r\n\r\nfunction YellowPerson() {\r\n  Person.call(this, 'black');\r\n}\r\n\r\nconst dyx = new YellowPerson();\r\nconsole.log(dyx.getEyes()); // black\r\n// dyx实例能继承Person构造函数内部的方法getEyes()，对于Person原型对象上的方法，dyx实例是访问不到的\r\nconsole.log(dyx.ReturnEyes()) // TypeError: hjy.ReturnEyes is not a function\r\n```\r\n### 组合继承\r\n> 组合继承的原理就是先通过盗用构造函数实现上下文绑定和传参，然后再使用原型链继承的手段将子构造函数的prototype指向父构造函数的实例。相较于盗用构造函数继承，组合继承额外的将YellowPerson的原型对象（同时也是dyx和douyaxing实例的原型）指向了Person的原型对象，这样就集合了原型链继承和盗用构造函数继承的优点。\r\n\r\n```\r\nfunction Person(eyes) {\r\n  this.eyes = eyes;\r\n  this.colors = ['white', 'yellow', 'black'];\r\n}\r\nPerson.prototype.getEyes = function() {\r\n  return this.eyes;\r\n}\r\n\r\nfunction YellowPerson() {\r\n  Person.call(this, 'black'); // 调用构造函数并传参\r\n}\r\nYellowPerson.prototype = new Person(); // 再次调用构造函数\r\n\r\nconst dyx = new YellowPerson();\r\ndyx.colors.push('green');\r\nconst douyaxing = new YellowPerson();\r\n\r\nconsole.log(dyx.colors); // ['white', 'yellow', 'black', 'green']\r\nconsole.log(dyx.getEyes()); // black\r\nconsole.log(douyaxing.colors); // ['white', 'yellow', 'black']\r\n```\r\n![组合继承](./img/组合继承.png)\r\n#### 组合继承的缺点\r\n1. 实现的过程中调用了两次Person构造函数，有一定程度上的性能浪费。\r\n### 原型式继承\r\n> object.create()通过第二个参数新增的属性是直接挂载到新建对象本身，而不是挂载在它的原型上。原型式继承非常适合不需要单独创建构造函数，但仍然需要在对象间共享信息的场合。原型式继承和原型链继承中原型与实例之间的关系基本是一致的，不过构造函数是一个中间函数，在object.create()执行完后它就随着函数作用域一起被回收了。\r\n\r\n```\r\nconst dyx = {\r\n  eyes: 'black',\r\n  colors: ['white', 'yellow', 'black']\r\n}\r\n\r\nconst douyaxing = Object.create(dyx, {\r\n  name: {\r\n    value: 'douyaxing',\r\n    writable: false,\r\n    enumerable: true,\r\n    configurable: true\r\n  },\r\n  age: {\r\n    value: '26',\r\n    writable: true,\r\n    enumerable: true,\r\n    configurable: false\r\n  }\r\n});\r\nconsole.log(douyaxing.eyes) // black\r\nconsole.log(douyaxing.colors) // ['white', 'yellow', 'black']\r\nconsole.log(douyaxing.name) // douyaxing\r\nconsole.log(douyaxing.age) // 26\r\n```\r\n![原型式继承](./img/原型式继承.png)\r\n#### 原型式继承的缺点\r\n> 原型式继承和原型链继承的本质基本一致，那么原型式继承也有一样的缺点。\r\n\r\n- 不能传参，使用手写的object()不能传参数，但使用Object.create()是可以传参的。\r\n- 原对象中的引用类型的属性会被新对象共享。\r\n### 寄生式继承\r\n> 寄生式继承与原型式继承很接近，它的思想就是在原型式继承的基础上以某种方式增强对象，然后返回这个对象。\r\n\r\n```\r\nfunction inherit(obj) {\r\n  let clone = Object.create(obj);\r\n  clone.sayHi = function () { // 增强对象\r\n    console.log('Hi');\r\n  }\r\n  return clone;\r\n}\r\n\r\nconst dyx = {\r\n  eyes: 'black',\r\n  colors: ['white', 'yellow', 'black']\r\n}\r\nconst douyaxing = inherit(dyx)\r\n\r\nconsole.log(douyaxing.eyes); // black\r\nconsole.log(douyaxing.colors); // ['white', 'yellow', 'black']\r\ndouyaxing.sayHi(); // Hi\r\n```\r\n### 寄生式组合继承\r\n> 寄生式组合继承只调用了一次Person造函数，避免了在Person.prototype上面创建不必要、多余的属性。于此同时，原型链依然保持不变，效率非常之高效。\r\n\r\n```\r\nfunction inherit(Father, Son) {\r\n  const prototype = Object.create(Father.prototype); // 获取父类原型对象副本\r\n  prototype.constructor = Son; // 将获取的副本的constructor指向子类，以此增强副本原型对象\r\n  Son.prototype = prototype; // 将子类的原型对象指向副本原型对象\r\n}\r\n\r\nfunction Person(eyes) {\r\n  this.eyes = eyes;\r\n  this.colors = ['white', 'yellow', 'black'];\r\n}\r\nPerson.prototype.getEyes = function() {\r\n  return this.eyes;\r\n}\r\n\r\nfunction YellowPerson() {\r\n  Person.call(this, 'black'); // 调用构造函数并传参\r\n}\r\n\r\ninherit(Person, YellowPerson) // 寄生式继承，不用第二次调用构造函数\r\n\r\nconst dyx = new YellowPerson();\r\ndyx.colors.push('green');\r\nconst douyaxing = new YellowPerson();\r\n\r\nconsole.log(dyx.colors); // ['white', 'yellow', 'black']\r\nconsole.log(dyx.getEyes()); // 'black'\r\nconsole.log(douyaxing.colors); // ['white', 'yellow', 'black', 'green']\r\n```\r\n![寄生式组合继承](./img/寄生式组合继承.png)\r\n### es6 class继承\r\n> 使用关键字extends，并使用super关键字将子类的数据传参给父类,super等于调用父类的constructor，但是this指向子类。\r\n\r\n```\r\nclass Person {\t\r\n  constructor(name, age) {\r\n  \tthis.name = name;\r\n  \tthis.age = age;\t\r\n    this.nickName = 'douyaxing';\t\r\n  }\r\n  getInfo() {\r\n    console.log(this.name, this.age, nickName);\r\n  } \r\n}  \r\n\r\n\r\nclass Man extends Person {\t\r\n  constructor(name, age, sex) {\r\n    super(name, age);\r\n  \tthis.sex = sex;\t\t\r\n  }\r\n  print() {\r\n    console.log(this.sex);\r\n  } \r\n} \r\nconst dyx = new Man(\"dyx\", 25, \"男\")\r\ndyx.getInfo() // dyx 25, douyaxing  父类的nickName属性也会继承\r\ndyx.print() // 男\r\n```\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## 节流与防抖\r\n> 节流和防抖是为了限制函数触发频率而产生的，主要运用了函数的闭包，多使用三方库如lodash中的方法实现所需效果。\r\n\r\n### 节流\r\n> 指定时间段内触发多次函数，只有一次生效。固定时间内函数只执行一次，不会导致函数延迟执行。\r\n\r\n- 监听缩放、滚动等场景建议使用。\r\n```\r\n// 使用时间间隔来判断\r\nconst throttle = (fn, delay) => {\r\n  let preT = 0;\r\n  return (...rest) => {\r\n    const currT = new Date();\r\n    if(currT - preT > delay) {\r\n      fn.apply(this, rest);\r\n      preT = currT;\r\n    }\r\n  }\r\n}\r\n```\r\n### 防抖\r\n> 在函数被触发n秒后再执行，如果在这n秒内又被触发，则重新计时。会导致函数被延迟执行。使用高阶函数，返回一个被定时器包裹的新函数，此函数在指定时间内若触发多次会导致上一次的函数不执行。\r\n\r\n- input框根据输入内容变化实时搜索的时候使用较多，用户停止输入后指定时间不再输入才会调用函数，节约请求资源。\r\n```\r\nconst debounce = (fn, delay) => {\r\n  let handle = null;\r\n  return (...rest) => {\r\n    if (handle) {\r\n      // 取消之前的延时调用\r\n      clearTimeout(handle);\r\n    }\r\n    handle = setTimeout(() => {\r\n      fn.apply(this, rest);\r\n    }, delay);\r\n  }\r\n}\r\n```\r\n### 返回一个promise的防抖\r\n- 可用于antd form的自定义校验validator场景。\r\n```\r\n// 返回一个promise函数的debounce\r\nconst promiseDebounce = (fn, delay) => {\r\n  let handle = null;\r\n  return (...rest) => {\r\n    if (handle) {\r\n      // 取消之前的延时调用\r\n      clearTimeout(handle);\r\n    }\r\n    return new Promise((resolve) => {\r\n      handle = setTimeout(() => {\r\n        resolve(fn.apply(null, rest));\r\n      }, delay);\r\n    });\r\n  };\r\n}\r\n```\r\n\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## 运算符\r\n### 可选链操作符 ?.\r\n- 当不确定一个对象是否存在时，调用对象属性可以使用该操作符。\r\n```\r\nconst obj = {\r\n  name: 'dyx'\r\n}\r\n\r\nconsole.log(obj.name); // 'dyx'\r\nconsole.log(obj.hobby?.name); // undefined，不会报错\r\nconsole.log(obj.hobby.name); // 会报错\r\n```\r\n### 空值合并操作符 ??\r\n- 当左侧的操作值为null或undefined时，返回其右侧操作值，否则返回左侧操作值。\r\n- ?? 与 ||的区别在于 ?? 对 0、''、false会判断为真。\r\n```\r\nconsole.log(null ?? 1); // 1\r\nconsole.log(null || 1); // 1\r\n\r\nconsole.log(undefined ?? 2); // 2\r\nconsole.log(undefined || 2); // 2\r\n\r\nconsole.log(false ?? 3); // false\r\nconsole.log(false || 3); // 3\r\n\r\nconsole.log('' ?? 4); // ''\r\nconsole.log('' || 4); // 4\r\n\r\nconsole.log(0 ?? 0); // 0\r\nconsole.log(0 || 5); // 5\r\n```\r\n### 逻辑空赋值 ??=\r\n- 逻辑空赋值运算符仅在值是null或undefined时对其赋值。\r\n```\r\nlet a = null;\r\nconsole.log(a ??= 1); // 1\r\n\r\nlet b = undefined;\r\nconsole.log(b ??= 1); // 1\r\n\r\nlet c = false;\r\nconsole.log(c ??= 1); // false\r\n\r\nlet d = '';\r\nconsole.log(d ??= 1); // ''\r\n\r\nlet e = 0;\r\nconsole.log(e ??= 1); // 0\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## 闭包\r\n> 内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，就把返回的函数和这些变量的集合称为闭包。闭包中的数据会组成一个对象，然后保存在堆空间中。\r\n\r\n```\r\n// 当fn1函数执行完毕之后，其作用域是会被销毁的，然后垃圾回收器会释放那段内存空间。而闭包却很神奇的将fn1的作用域存活了下来，fn2依然持有该作用域的引用，这个引用就是闭包。由于返回的函数在其中引用了name的值，于是name的引用计数被+1。当返回函数不被垃圾回收时，则name也会一直存在。\r\nfunction fn1() {\r\n  const name = 'dyx';\r\n  function fn2() {\r\n    console.log(name);\r\n  }\r\n  return fn2;\r\n}\r\nconst fn3 = fn1();\r\nfn3();\r\n\r\n// 通过回调函数来进行函数值得传递\r\nfunction fn1() {\r\n  const name = 'dyx';\r\n  function fn2() {\r\n    console.log(name);\r\n  }\r\n  fn3(fn2);\r\n}\r\nfunction fn3(fn) {\r\n  fn();\r\n}\r\nfn1();\r\n```\r\n### 闭包的应用\r\n- debounce的闭包应用\r\n> handle变量在函数执行完之后并没有销毁，就是使用了闭包的原理。\r\n\r\n```\r\nconst debounce = (fn, delay) => {\r\n  let handle = null;\r\n  return (...rest) => {\r\n    if (handle) {\r\n      // 取消之前的延时调用\r\n      clearTimeout(handle);\r\n    }\r\n    handle = setTimeout(() => {\r\n      fn.apply(this, rest);\r\n    }, delay);\r\n  }\r\n}\r\n```\r\n- 模拟私有属性\r\n> 在JavaScript中是没有私有属性特性的，利用闭包来隐藏变量就可以模拟出私有属性的效果。\r\n\r\n```\r\nvar counter = (function() {\r\n  var count = 0;\r\n\r\n  return {\r\n    increment: function() {\r\n      count++;\r\n      return count;\r\n    },\r\n    zero: function() {\r\n      count = 0;\r\n      return count;\r\n    },\r\n    get value() {\r\n      return count;\r\n    },\r\n  };\r\n})();\r\n\r\ncounter.increment();\r\nconsole.log(counter.value); // 输出：1\r\ncounter.increment();\r\nconsole.log(counter.value); // 输出：2\r\n\r\nconsole.log(counter.count); // 输出：undefined\r\n```\r\n### 闭包的缺点\r\n> 由于闭包会引用外部函数的变量，但是这些变量在外部函数执行完毕后没有被释放，那么这些变量会一直存在于内存中。一旦形成闭包只有在页面关闭后闭包占用的内存才会被回收，这就造成了所谓的内存泄漏。\r\n\r\n- 及时释放闭包：手动调用闭包函数，并将其返回值赋值为null，这样可以让闭包中的变量及时被垃圾回收器回收。\r\n- 使用立即执行函数：在创建闭包时，将需要保留的变量传递给一个立即执行函数，并将这些变量作为参数传递给闭包函数，这样可以保留所需的变量，而不会导致其他变量的内存泄漏。\r\n\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## [预解析](https://www.jianshu.com/p/c3276ff58c93)\r\n> 在当前作用域中，在代码执行之前，浏览器首先会默认的把所有带var和function声明的变量进行提前的声明。var声明的变量在预解析的时候只是提前的声明并没有定义，function声明的函数在预解析的时候会提前声明并且会同时定义。程序最开始的时候，只对window下的变量和函数进行预解析，只有函数执行的时候才会对函数中的变量和函数进行预解析。\r\n\r\n### 在全局作用域中声明变量带var可以进行预解析；声明变量的时候不带var的时候，不能进行预解析\r\n- num2 = 12; 相当于给window增加了一个num2的属性名，属性值是12；\r\n- var num1 = 12; 相当于给全局作用域增加了一个全局变量num1，但是不仅如此，它也相当于给window增加了一个属性名num1，属性值是12；\r\n- 同一作用域重复声明不会报错，因为遇见var a = 2；会询问作用域是否已有a，如果有会忽略var，只解释a=2，会发生值的覆盖，如果没有var，则在当前作用域生成一个a变量。\r\n### 预解析的奇葩现象\r\n- 不管条件是否成立，都要把带var的进行提前的声明，因为在ES6之前并没有块级作用域的概念所以在{}之中的变量声明相当于全局的声明\r\n```\r\nif (false) { \r\n  var num = 12;\r\n}\r\nconsole.log(num); // undefined\r\n```\r\n- 只预解析“=”左边的，右边的是指针，不参与预解析,所以函数表达式的形式不会有函数提升的现象\r\n```\r\nfn();  // Uncaught TypeError: fn is not a function\r\nvar fn = function () {\r\n  console.log('ok');\r\n}\r\nfn(); // 'ok'\r\n\r\nfn1(); // 'ok1'\r\nfunction fn1() {\r\n  console.log('ok1');\r\n}\r\n```\r\n- 自执行函数定义的那个function在全局作用域下不进行预解析，当代码执行到这个位置的时候，定义和执行一起完成了。\r\n- 函数体中return下面的代码，虽然不再执行了，但是需要进行预解析，return中的代码，都是我们的返回值，所以不进行预解析。\r\n```\r\nfunction fn() {                             \r\n  console.log(num); // undefined\r\n  return function () {                                              \r\n  };                               \r\n  var num = 100;                   \r\n}                                  \r\nfn();\r\n```\r\n- 名字已经声明过了，不需要重新的声明，但是需要重新的赋值,当方法名称和变量名称一样时，变量被覆盖，同名的变量和函数预解析只会留下一个。\r\n```\r\n// 同一名称预解析只会留下一个，然后逐行解析，找关于预解析的表达式，找到就修改预解析的值。\r\nconsole.log(a)  // function a(){console.log(2)}  函数会覆盖变量\r\nvar a=1;\r\nconsole.log(a)  // 1\r\nfunction a(){console.log(2)}\r\nconsole.log(a) // 1\r\nvar a=3;\r\nconsole.log(a) // 3\r\na() // a is not a function\r\n```\r\n### 示例\r\n```\r\nfunction a(){\r\n  var a=1;\r\n  a=2;\r\n  var b=g();\r\n  a=3;\r\n  return b;\r\n  function g(){\r\n    return a;\r\n  }\r\n}\r\nconsole.log(a()) // 2\r\n\r\n// 变量将从作用域链中去寻找，但是 依据的是函数定义时的作用域链，而不是函数执行时\r\nfunction F1() {\r\n  var a = 100\r\n  return function () {\r\n    console.log(a)\r\n  }\r\n}\r\n\r\nfunction F2(f1) {\r\n  var a = 200\r\n  console.log(f1())\r\n}\r\nvar f1 = F1()\r\nF2(f1) // 100\r\n\r\n// 即使有if在但是声明变量依然提升了，进行了变量声明\r\nfunction a(bool) {\r\n  if(bool) {\r\n    var x=10;\r\n  }\r\n  return x;\r\n}\r\nconsole.log(a(true)) // 10\r\nconsole.log(a(false)) // undefined\r\n```"},function(r,n,e){"use strict";e.r(n),n.default='## 高级函数用法\r\n### compose组合函数\r\n> 把逻辑解耦在各个函数中，通过compose的方式组合函数，将外部数据依次通过各个函数的加工，生成结果。先执行后传入的函数。\r\n\r\n#### redux源码中的中间件的处理使用的函数\r\n```\r\nfunction compose(...funcs) {\r\n  if (funcs.length === 0) {\r\n    return arg => arg;\r\n  }\r\n\r\n  if (funcs.length === 1) {\r\n    return funcs[0];\r\n  }\r\n\r\n  return funcs.reduce((a, b) => (...args) => a(b(...args)));\r\n} \r\n```\r\n#### compose组合函数使用示例\r\n```\r\nlet a = x => x + "。";\r\nlet b = x => x + "!";\r\nlet c = x => x + "?";\r\nlet combineFun = compose(a, b, c)\r\ncombineFun(\'dyx\') // dyx?!。\r\n```\r\n#### 洋葱圈模型\r\n> 通过以上的组合函数使传入的中间件函数变成(...arg) => mid1(mid2(mid3(...arg)))，最后执行的中间件mid3最先执行完，最先执行的mid1最后执行完，是符合洋葱圈模型的。\r\n\r\n### 柯里化函数\r\n> 函数使用更加灵活，可以一次传入所有参数调用也可以只传入一部分参数调用，让它返回一个函数去处理剩余的参数。\r\n\r\n```\r\nfunction curry(fn) {\r\n  let judge = (...args) => {\r\n    // 一次传递了所有参数 则直接调用\r\n    if (args.length >= fn.length) {\r\n      return fn(...args);\r\n    } \r\n    return (...arg) => judge(...args, ...arg);\r\n  }\r\n  return judge;\r\n}\r\n\r\nfunction add(a, b, c) {\r\n  return a + b + c;\r\n}\r\nadd(1, 2, 3) // 6\r\n\r\nconst addCurry = curry(add);\r\nconsole.log(addCurry(1, 2, 3)); // 6\r\nconsole.log(addCurry(1)(2)(3)); // 6\r\nconsole.log(addCurry(1, 2)(3)); // 6\r\nconsole.log(addCurry(1)(2, 3)); // 6\r\n```\r\n### 高阶函数\r\n> 高阶函数是一个接收函数作为参数或将函数作为输出返回的函数。Array.prototype.map，Array.prototype.filter 和 Array.prototype.reduce 是语言中内置的一些高阶函数。\r\n\r\n### 纯函数\r\n> 一个函数的返回结果只依赖于它的参数，并且在执行过程里面没有副作用，我们就把这个函数叫做纯函数。'},function(r,n,e){"use strict";e.r(n),n.default="## 优化内存使用\r\n### 尽量减少全局变量使用\r\n- 将变量限制在局部作用域中。\r\n### 按需加载资源\r\n- 使用懒加载技术，按需加载图片、脚本和其他资源。\r\n- 对于大型数据集，可以使用分页或虚拟滚动技术。\r\n### 及时清理无用数据\r\n- 当数据不再需要时，手动清理引用。\r\n- 对于大型对象或数组，置为null或重新赋值。\r\n### 优化DOM操作\r\n- 减少不必要的DOM操作，尽量批量更新DOM。\r\n- 使用虚拟DOM或框架如React、Vue来优化渲染过程。\r\n### 避免过度使用闭包\r\n- 闭包是强大的工具，但滥用可能导致内存问题。确保闭包引用的变量是必要的，及时清理不需要的闭包。\r\n### 移除事件监听器\r\n- 在组件销毁或元素移除时，手动移除事件监听器。\r\n### 移除定时器\r\n- 在不需要使用时清理定时器。\r\n### 使用弱引用\r\n- 对于不需要长期强引用的对象，可以使用WeakMap或WeakSet，它们不会阻止垃圾回收。"},function(r,n,e){"use strict";e.r(n),n.default='## 内存泄漏场景\r\n### 全局变量\r\n- 全局变量会一直存在于内存中，直到页面关闭。\r\n```\r\nfunction createLeak() {\r\n  leakedVar = "I am a global variable"; // 没有使用 `var`、`let` 或 `const`\r\n}\r\n```\r\n- 解决方法：始终使用let、const或var声明变量。\r\n### 闭包未正确释放\r\n- 闭包会保留对外部作用域的引用，如果没有正确清理，可能导致内存泄漏。\r\n```\r\nfunction createClosure() {\r\n  let largeData = new Array(1000000); // 占用大量内存\r\n  return function () {\r\n    console.log(largeData);\r\n  };\r\n}\r\nlet closure = createClosure();\r\n```\r\n- 解决方法：当闭包不再需要时，手动清理引用。\r\n```\r\nclosure = null; // 解除引用\r\n```\r\n### DOM引用未清理\r\n- 如果JavaScript对DOM元素的引用未及时清理，即使DOM已被移除，内存仍然会被占用。\r\n```\r\nlet element = document.getElementById("myElement");\r\ndocument.body.removeChild(element); // 但element变量仍然引用该DOM\r\n```\r\n- 解决方法：手动清理引用。\r\n```\r\nelement = null;\r\n```\r\n### 事件监听器未移除\r\n- 事件监听器会保留对目标元素的引用，导致内存泄漏。\r\n```\r\nlet button = document.getElementById("myButton");\r\nbutton.addEventListener("click", () => {\r\n  console.log("clicked");\r\n});\r\ndocument.body.removeChild(button); // 监听器仍然存在\r\n```\r\n- 解决方法：移除事件监听器。\r\n```\r\nbutton.removeEventListener("click", handler);\r\n```\r\n### 定时器未清理\r\n- 使用setInterval或setTimeout创建的定时器，如果未清理可能导致内存泄漏。\r\n```\r\nsetInterval(() => {\r\n  console.log("Running...");\r\n}, 1000);\r\n```\r\n- 解决方法：在不需要时清理定时器。\r\n```\r\nlet intervalId = setInterval(() => {\r\n  console.log("Running...");\r\n}, 1000);\r\nclearInterval(intervalId);\r\n```\r\n### 内存泄漏\r\n> 程序的运行需要内存，只要程序提出要求，操作系统或者运行时（runtime）就必须供给内存。对于持续运行的服务进程，必须及时释放不再用到的内存。否则内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。不再用到的内存没有及时释放，就叫做内存泄漏（memory leak）。\r\n'},function(r,n,e){"use strict";e.r(n),n.default="## 内存管理机制\r\n### 内存生命周期\r\n> JavaScript是一种高级的解释执行的编程语言，是一种属于网络的高级脚本语言。所有语言第二部分都是明确的，第一和第三部分在底层语言中是明确的。但在像 JavaScript这些高级语言中，大部分都是隐含的。\r\n\r\n1. 分配你所需要的内存\r\n2. 使用分配到的内存（读、写）\r\n3. 不需要时将其释放\\归还\r\n### JavaScript内存管理主要依赖以下两个过程\r\n> 虽然垃圾回收是自动的，但开发者仍需避免不必要的内存占用和泄漏。\r\n\r\n1. 内存分配：当创建变量、对象、函数时，JavaScript会自动分配内存。\r\n2. 垃圾回收：JavaScript引擎（如V8引擎）会自动回收不再使用的内存（通常基于引用计数或标记清除算法）。\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## 垃圾回收\r\n> JavaScript在创建变量（对象，字符串等）时自动进行了内存分配，并且在不使用它们时“自动”释放，释放的过程称为垃圾回收。垃圾回收机制会定期（周期性）找出那些不再用到的内存（变量）然后释放其内存，JavaScript的运行环境极大地依赖于垃圾回收机制。\r\n\r\n### 内存空间\r\n> JavaScript的内存空间分为栈（Stack）和堆（Heap）两部分。栈用于存储原始类型（如Number，String，Boolean，Null，Undefined，Symbol）和引用对象的内存地址，而堆用于存储引用类型的对象。\r\n\r\n### 栈回收\r\n> 函数调用的参数、返回地址和局部变量都存储在调用栈中。每当一个函数被调用时，都会创建一个新的栈帧，其中包含这些信息。而栈帧的回收则非常直接：一旦函数调用结束，其栈帧就会被立即移除。这种机制依赖于ESP（Extended Stack Pointer）指针，该指针始终指向栈的顶部，用于追踪哪些栈帧是活动的，哪些可以被安全回收。\r\n\r\n```\r\nfunction getName() {\r\n  let a = 1\r\n  let b = {\r\n    name: 'Hello World'\r\n  }\r\n  function foo() {\r\n    let c = 2\r\n    let d = {\r\n      name: 'Hello Javascript'\r\n    }\r\n  }\r\n  foo()\r\n}\r\ngetName()\r\n```\r\n### 堆回收\r\n> 与栈回收机制相比，堆回收要复杂得多。所有的对象实例都存储在堆中。这些对象的生命周期不像栈帧那样简单明了，因此需要更复杂的机制来确定何时可以安全回收这些对象的内存。主要采用标记清除算法进行垃圾回收。该算法分为两个步骤：标记阶段，V8引擎会遍历所有的对象，标记活动对象和非活动对象；清除阶段，非活动对象所占用的内存将被回收。\r\n\r\n```\r\nfunction createObject() {\r\n  let obj = new Object();\r\n  obj.value = 'Hello, World!';\r\n  return obj;\r\n}\r\n\r\nlet myObject = createObject();  // 创建对象，分配内存\r\nmyObject = null;  // 丢弃对象，垃圾回收器现在可以回收这个对象的内存\r\n```\r\n### 标记清除（常用的方法）\r\n> 垃圾回收机制在运行的时候会给存储在内存中的所有变量都加上标记（可以是任何标记方式），然后它会去掉处在环境中的变量及被环境中的变量引用的变量的标记（闭包）。而在此之后剩下的带有标记的变量被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后垃圾回收机制到下一个周期运行时，将释放这些变量的内存，回收它们所占用的空间。\r\n\r\n### 引用计数\r\n> 语言引擎有一张\"引用表\"，保存了内存里面所有资源（通常是各种值）的引用次数。如果一个值的引用次数是0，就表示这个值不再用到了，因此可以将这块内存释放。循环使用会有内存无法释放的情况。"},function(r,n,e){"use strict";e.r(n),n.default='## lerna + Yarn Workspace\r\n- lerna初始化\r\n```\r\n// npm install lerna -g\r\nlerna init\r\n\r\nmonorepo\r\n├── packages\r\n├── lerna.json\r\n├── package.json\r\n```\r\n- 修改lerna.json\r\n```\r\n{\r\n  "$schema": "node_modules/lerna/schemas/lerna-schema.json",\r\n  "useWorkspaces": true,\r\n  "npmClient": "yarn",\r\n  "version": "0.0.0"\r\n}\r\n```\r\n- 修改package.json\r\n```\r\n{\r\n  "name": "root",\r\n  "private": true,\r\n  "workspaces": [\r\n    "packages/*"\r\n  ],\r\n  "devDependencies": {\r\n    "lerna": "^6.4.1"\r\n  }\r\n}\r\n```\r\n- packages目录下新建子项目utils、pc\r\n```\r\nmonorepo\r\n├── packages\r\n    ├── pc\r\n    ├── utils\r\n├── lerna.json\r\n├── package.json\r\n```\r\n- pc项目依赖utils项目，在pc项目的package.json的dependencies下手动添加一行依赖。名称和版本来自utils项目的package.json的数据。\r\n```\r\n"utils": "1.0.0"\r\n```\r\n- 使用TypeScript时如果某一个包依赖于另一个包，必须明确让TypeScript知道这种依赖关系。例如pc项目依赖utils项目，需要在pc项目的tsconfig文件中添加references配置。\r\n```\r\n{\r\n  "references": [{ "path": "../utils/tsconfig.json" }],\r\n  "compilerOptions": {\r\n    "target": "es5",\r\n    "lib": [\r\n      "dom",\r\n      "dom.iterable",\r\n      "esnext"\r\n    ],\r\n    "paths": {\r\n      "@/*": ["src/*"],\r\n    },\r\n    "allowJs": true,\r\n    "skipLibCheck": true,\r\n    "esModuleInterop": true,\r\n    "allowSyntheticDefaultImports": true,\r\n    "strict": true,\r\n    "forceConsistentCasingInFileNames": true,\r\n    "noFallthroughCasesInSwitch": true,\r\n    "module": "esnext",\r\n    "moduleResolution": "node",\r\n    "resolveJsonModule": true,\r\n    "isolatedModules": true,\r\n    "noEmit": true,\r\n    "jsx": "react-jsx"\r\n  },\r\n  "include": [\r\n    "src",\r\n    "global.d.ts"\r\n  ]\r\n}\r\n```\r\n- pc项目安装依赖，启动项目。pc项目之所以可以引用utils项目内容依赖于yarn的workspaces功能会自动管理/package.json里workspaces字段指定包下的所有依赖。\r\n```\r\nyarn\r\nyarn start\r\n```\r\n- utils项目使用tsc --watch实时编译，pc项目中直接引用tsc编译后的文件\r\n```\r\n"scripts": {\r\n  "build": "tsc --watch"\r\n},\r\n```\r\n'},function(r,n,e){"use strict";e.r(n),n.default="## pnpm-monorepo\r\n1. 在根目录pnpm初始化生成package.json。\r\n```\r\npnpm init\r\n```\r\n2. 配置工作空间，根目录新建pnpm-workspace.yaml文件。\r\n```\r\npackages:\r\n  # web应用程序目录\r\n  - 'applications/**'\r\n  # 通用程序目录\r\n  - 'packages/**'\r\n```\r\n3. 安装项目依赖，在根目录运行如下命令，一键为所有项目安装依赖。\r\n```\r\npnpm i\r\n```\r\n### pnpm命令\r\n- 执行admin-user项目命令\r\n```\r\npnpm -F admin-user start\r\npnpm -F admin-user build\r\n```\r\n- 安装外部模块依赖\r\n```\r\npnpm -F utils add -S lodash\r\npnpm -F utils add -D webpack\r\n```\r\n- 安装其它模块依赖\r\n```\r\npnpm -F admin-user add utils --workspace\r\n```\r\n- 删除模块依赖\r\n```\r\npnpm -F utils remove lodash\r\npnpm -F utils remove webpack\r\n```"},function(r,n,e){"use strict";e.r(n),n.default='## 项目依赖管理\r\n- 使用Yarn会将子模块的依赖项向最外层扁平化展开，这就会造成幽灵依赖现象，导致项目的依赖关系不够清晰，给开发者带来一定困惑。\r\n- 使用Pnpm的依赖树结构更符合常规认知，整个依赖关系更加透明和可控。\r\n### Yarn Workspace\r\n- package.json\r\n```\r\n{\r\n  "workspaces": ["packages/*"]\r\n}\r\n```\r\n- 子模块间依赖配置\r\n```\r\n// modulea\r\n\r\n{\r\n  "name": "@xx/modulea",\r\n  "version": "1.0.0",\r\n  "dependencies": {\r\n    "@xx/moduleb": "1.0.0",\r\n    "@xx/modulec": "1.0.0"\r\n  }\r\n}\r\n```\r\n- 根目录执行yarn install命令进行依赖安装，会自动关联子模块之间的模块依赖。其依赖树结构如下\r\n```\r\n.\r\n├── node_modules\r\n│   ├── @babel\r\n│   └── @xx # 幽灵依赖，来自子模块\r\n│       ├── modulea -> ../../packages/moduleA\r\n│       ├── moduleb -> ../../packages/moduleB\r\n│       └── modulec -> ../../packages/moduleC\r\n├── package.json\r\n├── packages\r\n│   ├── moduleA\r\n│   ├── moduleB\r\n│   └── moduleC\r\n└── yarn.lock\r\n```\r\n### Pnpm Workspace\r\n- pnpm-workspace.yaml\r\n```\r\npackages:\r\n  - "packages/**"\r\n```\r\n- 子模块间依赖配置\r\n```\r\n// modulea\r\n\r\n{\r\n  "name": "@xx/modulea",\r\n  "version": "1.0.0",\r\n  "dependencies": {\r\n    "@xx/moduleb": "workspace:*",\r\n    "@xx/modulec": "workspace:*"\r\n  }\r\n}\r\n```\r\n- 根目录执行pnpm install命令进行依赖安装，会自动关联子模块之间的模块依赖。其依赖树结构如下\r\n```\r\n├── node_modules\r\n│   ├── @babel\r\n├── package.json\r\n├── packages\r\n│   ├── moduleA\r\n│   │   └── node_modules\r\n│   │       └── @xx\r\n│   │           ├── moduleb -> ../../../moduleB\r\n│   │           └── modulec -> ../../../moduleC\r\n│   ├── moduleB\r\n│   │   └── node_modules\r\n│   │       └── @xx\r\n│   │           └── modulec -> ../../../moduleC\r\n│   └── moduleC\r\n├── pnpm-lock.yaml\r\n└── pnpm-workspace.yaml\r\n```'},function(r,n,e){"use strict";e.r(n),n.default="## nginx实现IP黑白名单\r\n> 有时候某些接口只能开放给对应的合作商，或者购买/接入 API 的合作伙伴，那么此时就需要实现类似于IP白名单的功能。而有时候有些恶意攻击者或爬虫程序，被识别后需要禁止其再次访问网站，因此也需要实现IP黑名单。这些功能可直接在nginx中处理。主要是通过allow、deny配置项来实现。\r\n\r\n```\r\n# 允许指定的IP访问，可以用于实现白名单。\r\nallow xxx.xxx.xxx.xxx;\r\n\r\n# 禁止指定的IP访问，可以用于实现黑名单。\r\ndeny xxx.xxx.xxx.xxx; \r\n```\r\n### 要同时屏蔽/开放多个IP访问时，如果所有IP全部写在nginx.conf文件中是比较冗余的，可以新建两个文件BlackIP.conf、WhiteIP.conf声明黑名单和白名单。\r\n- BlackIP.conf 黑名单\r\n```\r\n# 屏蔽192.177.12.222访问\r\ndeny 192.177.12.222;  \r\n\r\n# 屏蔽192.177.44.201访问  \r\ndeny 192.177.44.201; \r\n```\r\n- WhiteIP.conf 白名单\r\n```\r\n# 允许192.177.12.222访问\r\nallow 192.177.12.222;   \r\n\r\n# 允许192.177.44.201访问\r\nallow 192.177.44.201;   \r\n\r\n# 除上述IP外，其他IP全部禁止访问 \r\ndeny all; \r\n```\r\n- 分别将要禁止/开放的IP添加到对应的文件后，可以将这两个文件在nginx.conf中导入\r\n> 如果要整站屏蔽/开放就在http中导入，如果只需要一个域名下屏蔽/开放就在sever中导入，如果只需要针对于某一系列接口屏蔽/开放就在location中导入。\r\n\r\n```\r\nhttp {  \r\n  # 屏蔽该文件中的所有IP  \r\n  include /nginx/IP/BlackIP.conf;   \r\n  server {  \r\n    location xxx {  \r\n      # 某一系列接口只开放给白名单中的IP  \r\n      include /nginx/IP/WhiteIP.conf;   \r\n    }  \r\n  }  \r\n} \r\n```"},function(r,n,e){"use strict";e.r(n),n.default='## gzip压缩\r\n> 如果静态资源的size越小，那么传输速度会越快，同时也会更节省带宽，因此我们在部署项目时，可以通过nginx对于静态资源实现压缩传输，可以节省带宽资源，也可以加快响应速度。\r\n\r\n```\r\nserver {\r\n  # 开启gzip压缩功能\r\n  gzip on;\r\n\r\n  # 指定会被压缩的文件类型\r\n  gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/json;\r\n\r\n  # 设置压缩级别，越高资源消耗越大，但压缩效果越好\r\n  gzip_comp_level 5;\r\n\r\n  # 在头部中添加Vary: Accept-Encoding（建议开启）\r\n  gzip_vary on;\r\n  \r\n  # 处理压缩请求的缓冲区数量和大小\r\n  gzip_buffers 16 8k;\r\n\r\n  # 对于不支持压缩功能的客户端请求不开启压缩机制\r\n  gzip_disable "MSIE [1-6]\\."; # 低版本的IE浏览器不支持压缩\r\n\r\n  # 设置压缩响应所支持的HTTP最低版本\r\n  gzip_http_version 1.1;\r\n\r\n  # 设置触发压缩的最小阈值\r\n  gzip_min_length 2k;\r\n\r\n  # 关闭对后端服务器的响应结果进行压缩\r\n  gzip_proxied off;\r\n}\r\n```\r\n'},function(r,n,e){"use strict";e.r(n),n.default="### location\r\n### http://ip\r\n> 访问时http://ip会返回/home/admin/build（root配置）目录下的index.html（index配置）文件。\r\n\r\n```\r\nserver {\r\n  location / {\r\n    # 指定根目录\r\n    root   /home/admin/build;\r\n    index  index.html index.htm;\r\n  }\r\n}\r\n```\r\n### http://ip/micro\r\n> 访问时http://ip/micro会返回/home/micro（root配置 + location路径）目录下的build/index.html（index配置）文件。\r\n\r\n```\r\nserver {\r\n  location /micro {\r\n    # 指定根目录\r\n    root   /home;\r\n    index  build/index.html build/index.htm;\r\n  }\r\n}\r\n```\r\n### location匹配规则\r\n> nginx的匹配优先顺序按照如下的顺序进行优先匹配，一旦某一个匹配命中直接退出，不再进行往下的匹配。剩下的前缀匹配（大小写敏感）会按照最长匹配长度优先级来匹配，谁匹配的越多就用谁。\r\n\r\n1. = 表示精确匹配。只有请求的url路径与后面的字符串完全相等时，才会命中。\r\n2. ^~ 表示如果该符号后面的字符是最佳匹配，采用该规则，不再进行后续的查找。\r\n3. ~ 表示该规则是使用正则定义的，区分大小写。\r\n4. ~* 表示该规则是使用正则定义的，不区分大小写。\r\n#### http://ip/document\r\n> 匹配702。因为正则匹配比普通匹配的优先级更高，而且正则是一旦匹配到就直接退出所以不会再匹配703。\r\n\r\n```\r\nserver {\r\n  location /document {\r\n    return 701;\r\n  }\r\n  location ~* ^/docume.*$ {\r\n    return 702;\r\n  }\r\n  location ~* ^/document$ {\r\n    return 703;\r\n  }\r\n}\r\n```\r\n#### http://ip/document\r\n> 匹配702。因为^~精确匹配比正则匹配优先级更高。\r\n\r\n```\r\nserver {\r\n  location ~* ^/docume.*$ {\r\n    return 701;\r\n  }\r\n  location ^~ /doc {\r\n    return 702;\r\n  }\r\n  location ~* ^/document$ {\r\n    return 703;\r\n  }\r\n}\r\n```\r\n#### http://ip/document\r\n> 匹配701。前缀匹配是按照最长匹配，跟顺序无关。\r\n\r\n```\r\nserver {\r\n  location /doc {\r\n    return 702;\r\n  }\r\n  location /docu {\r\n    return 701;\r\n  }\r\n}\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## nginx\r\n> nginx是一个高性能的HTTP和反向代理web服务器，其是一款轻量级的web服务器、反向代理服务器、电子邮件服务器，特点是占有内存少、体积小、并发能力强、性能高。nginx是目前负载均衡技术中的主流方案。\r\n\r\n### 反向代理\r\n> 反向代理是nginx使用最多的一种场景了，当服务请求量较大，一台服务器已经无法承载需要扩容使用多台服务器时我们就可以使用nginx把用户的请求下发到不同的服务器。无论增加多少台服务器，用户始终访问一个相同的域名，反向代理代理的是目标服务端，客户端请求代理服务器，代理服务器会进行转发到对应目标服务器，对客户端而言并不知道真正的服务器是谁。\r\n\r\n### 负载均衡\r\n> 当使用了三台服务器，为了保证性能最大化，需要将请求合理分配给不同的服务器。负载均衡就是会合理的把客户端的请求分配给服务器，默认可以等比例分配，可以理解为1:1:1，但是实际场景中，服务器配置可能不同，可能有好有坏，所以这里有一个权重的概率，可以自行配置哪台服务器多分配请求，哪一台少一点请求，这样的配置可以让服务器的性能得到最大化，合理分配请求将会使系统更为健壮稳固。\r\n\r\n### 动静分离\r\n> 真实请求过程中有的请求是需要动态的计算的，比如需要连接数据库去增删查改，这些属于动，而对于前端的一些html、css、js文件，并不需要后台处理，就可以通过动静分离的模式将其区分开，将这些静态文件进行缓存操作，这样就可以提高效率了，同时静态的资源不再需要后端进行处理，减少后端服务的并发量和服务器压力。\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## 反向代理\r\n- proxy_pass：定义后端服务器的地址。\r\n- proxy_set_header：修改从客户端传递到代理服务器的请求头。\r\n- proxy_hide_header：隐藏从代理服务器返回的响应头。\r\n- proxy_redirect：修改从代理服务器返回的响应头中的Location和Refresh头字段。\r\n### 访问http://192.168.1.1/proxy/test.html\r\n> 如果在proxy_pass后面的url加/，表示绝对根路径；如果没有/，表示相对路径，把匹配的路径部分也给代理走。\r\n\r\n- 代理到http://127.0.0.1/test.html\r\n```\r\nlocation /proxy {\r\n  proxy_pass http://127.0.0.1/;\r\n}\r\n```\r\n- 代理到http://127.0.0.1/proxy/test.html\r\n```\r\nlocation /proxy {\r\n  proxy_pass http://127.0.0.1;\r\n}\r\n```\r\n- 代理到http://127.0.0.1/aaa/test.html\r\n```\r\nlocation /proxy {\r\n  proxy_pass http://127.0.0.1/aaa/;\r\n}\r\n```\r\n- 代理到http://127.0.0.1/aaatest.html\r\n```\r\nlocation /proxy {\r\n  proxy_pass http://127.0.0.1/aaa;\r\n}\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## root和alias\r\n> alias是一个目录别名的定义，root则是最上层目录的含义。\r\n\r\n### 差异\r\n- root的处理结果是: root路径 + location路径；alias的处理结果是: 使用alias路径替换location路径。\r\n- 如果location路径是以/结尾，则alias也必须是以/结尾，root没有要求。\r\n- alias无法与try_files搭配使用，root可以与try_files搭配使用。\r\n\r\n### /home/micro/build/index.html目录\r\n- root\r\n```\r\nlocation /micro {\r\n  root   /home;\r\n  index  build/index.html build/index.htm;\r\n}\r\n```\r\n- alias\r\n```\r\nlocation /micro {\r\n  alias  /home/micro;\r\n  index  build/index.html build/index.htm;\r\n}\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## try_files\r\n> 单页应用history路由支持刷新时使用。有路由时会应用try_files规则，没有路由默认进入时不会应用try_files规则。nginx的alias和try_files互斥，不能同时使用。\r\n\r\n### 示例一\r\n> try_files设置文件查找规则为 $uri $uri/ /index.html。当访问/exer时$uri为/exer。\r\n\r\n```\r\nlocation / {\r\n  # 指定根目录\r\n  root   /home/admin/build;\r\n  index  index.html index.htm;\r\n\r\n  # 单页应用history支持刷新\r\n  try_files $uri $uri/ /index.html;\r\n}\r\n```\r\n- 首先检查/home/admin/build目录中是否存在exer文件，如果存在则返回文件，如果不存在则进行下一步。\r\n- 其次检查/home/admin/build目录中是否存在exer目录，如果存在则再检查exer目录中是否存在index.html或者index.htm文件(由index指定)，如果存在则返回该文件，如果不存在则进行下一步。\r\n- 最后检查/home/admin/build目录中是否存在index.html文件(root目录与try_files第三个规则的路径拼接)，如果存在则返回文件，如果不存在则返回404。\r\n### 示例二\r\n> 当访问/micro/exer时$uri为/micro/exer。\r\n\r\n```\r\nlocation /micro {\r\n  # 指定根目录\r\n  root   /home;\r\n  index  build/index.html build/index.htm;\r\n\r\n  try_files $uri $uri/ /micro/build/index.html;\r\n}\r\n```\r\n- 首先检查/home目录中是否存在/micro/exer文件，如果存在则返回文件，如果不存在则进行下一步。\r\n- 其次检查/home目录中是否存在/micro/exer目录，如果存在则在检查/micro/exer目录中是否存在build/index.html或者build/index.htm文件(由index指定)，如果存在则返回该文件，如果不存在则进行下一步。\r\n- 最后检查/home目录中是否存在/micro/build/index.html文件(root目录与try_files第三个规则的路径拼接)，如果存在则返回文件，如果不存在则返回404。\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## 常用命令\r\n### service nginx start   启动服务\r\n### service nginx stop    关闭服务\r\n### service nginx restart 重启服务\r\n> 快速的停止服务然后启动服务，启动的时候会造成短暂的服务中断。如果配置文件语法错误，有可能会造成更长时间的服务中断。\r\n\r\n### nginx -s reload 热重载(平滑重启服务)\r\n> 当运行reload命令时，master进程会尝试读取配置文件。\r\n\r\n- 如果配置文件没有问题\r\n> master进程会启动新的worker进程来运行新的配置文件并开始处理新请求，同时会通知老的worker进程不再继续接收、处理新的请求，并在处理完当前任务后退出。\r\n\r\n- 如果配置文件存在问题\r\n> 继续使用老的worker进程处理请求，不会导致nginx异常退出。\r\n\r\n### nginx -t 查看nginx.conf文件所在位置"},function(r,n,e){"use strict";e.r(n),n.default='## 常用配置\r\n### nginx.conf    nginx服务的主配置文件\r\n1. 全局块\r\n> 会设置一些影响nginx服务器整体运行的配置指令，主要包括配置运行nginx服务器的用户（组）、允许生成的worker process数，进程PID存放路径、日志存放路径和类型以及配置文件的引入等。\r\n\r\n```\r\n# 定义nginx运行的用户和用户组\r\nuser root;\r\n\r\n# nginx进程数，建议设置为等于CPU总核心数\r\nworker_processes auto;\r\n\r\n# 全局错误日志定义类型，[ debug | info | notice | warn | error | crit ]\r\nerror_log /var/log/nginx/error.log info;\r\n\r\n# 进程文件\r\npid /run/nginx.pid;\r\n\r\n# nginx worker最大打开文件数，可设置为系统优化后的ulimit -n的结果\r\nworker_rlimit_nofile 65535;\r\n```\r\n2. events块\r\n> 与网络连接有关的设置。\r\n\r\n```\r\nevents {\r\n  # epoll模型是Linux 2.6以上内核版本中的高性能网络I/O模型，如果跑在FreeBSD上面，就用kqueue模型\r\n  use epoll;\r\n\r\n  # 单个worker进程最大连接数（nginx最大连接数 = worker连接数 * 进程数）\r\n  worker_connections 768;\r\n}\r\n```\r\n3. http块\r\n> 代理、缓存和日志等绝大多数功能和第三方模块的配置都在这里。\r\n\r\n```\r\nhttp {\r\n  # 日志定义\r\n  access_log /var/log/nginx/access.log;\r\n  error_log /var/log/nginx/error.log;\r\n\r\n  # 引入其它配置文件\r\n  include /etc/nginx/conf.d/*.conf;\r\n}\r\n```\r\n4. server块\r\n> 虚拟主机的参数设置（一个http块可包含多个server块）。\r\n\r\n5. location块\r\n> 定义请求路由及页面处理方式。\r\n\r\n### default.conf  nginx服务默认配置文件\r\n> nginx.conf一般会引入default.conf文件中的配置，所以多数情况下会在default.conf中配置server块的相关规则。\r\n\r\n### 监听端口\r\n```\r\nlisten   80;\r\n```\r\n### 配置服务ip\r\n```\r\nserver_name  ip;\r\n```\r\n### index.html配置\r\n```\r\nlocation / {\r\n  # 指定根目录\r\n  root   /home/admin/build;\r\n  index  index.html index.htm;\r\n}\r\n```\r\n### 单页应用history路由支持刷新\r\n```\r\nlocation / {\r\n  # 指定根目录\r\n  root   /home/admin/build;\r\n  index  index.html index.htm;\r\n\r\n  # 单页应用history支持刷新\r\n  try_files $uri $uri/ /index.html;\r\n}\r\n```\r\n### 配置前端静态资源http缓存\r\n```\r\nlocation / {\r\n  # 指定根目录\r\n  root   /home/admin/build;\r\n  index  index.html index.htm;\r\n\r\n  # 单页应用history支持刷新\r\n  try_files $uri $uri/ /index.html;\r\n\r\n  if ($request_uri ~* .*[.](js|css|map|jpg|png|svg|ico)$) {\r\n    # 非html资源强缓存1个月\r\n    add_header Cache-Control "max-age=2592000";\r\n  }\r\n\r\n  if ($request_filename ~* ^.*[.](html|htm)$) {\r\n    # html使用协商缓存\r\n    add_header Cache-Control "no-cache";\r\n  }\r\n}\r\n```\r\n### 接口请求代理\r\n```\r\nlocation /api {\r\n  proxy_pass http://ip;\r\n}\r\n```\r\n### PC端和移动端使用不同的项目文件映射\r\n```\r\n// 资源目录\r\n/home/html\r\n    ├── mobile\r\n        ├── index.html  // 移动端静态资源\r\n    ├── pc\r\n        ├── index.html  // PC端静态资源\r\n\r\nlocation / {\r\n  # 指定根目录\r\n  root /home/html/pc;\r\n  \r\n  # 移动端访问修改root\r\n  if ($http_user_agent ~* \'(mobile|android|iphone|ipad|phone)\') {\r\n    root /home/html/mobile;\r\n  }\r\n  index index.html index.htm;\r\n}\r\n```\r\n### nginx默认request header中包含下划线的请求头会被自动忽略\r\n```\r\n# 不忽略包含下划线_的请求头\r\nunderscores_in_headers on;\r\n```\r\n### default.conf\r\n> 可以配置两个server。\r\n\r\n```\r\nserver {\r\n  # 监听端口\r\n  listen       80;\r\n\r\n  # 配置服务ip\r\n  server_name  ip;\r\n\r\n  # nginx默认request header中包含的下划线_的请求头会自动忽略。\r\n  underscores_in_headers on;\r\n\r\n  # 配置前端静态资源及http缓存\r\n  location / {\r\n    # 指定根目录\r\n    root   /home/admin/build;\r\n    index  index.html index.htm;\r\n\r\n    # 单页应用history支持刷新\r\n    try_files $uri $uri/ /index.html;\r\n\r\n    # index.html使用协商缓存\r\n    add_header Cache-Control \'no-cache\';\r\n\r\n    if ($request_uri ~* .*[.](js|css|map|jpg|png|svg|ico)$) {\r\n      # 非html资源强缓存1个月\r\n      add_header Cache-Control "max-age=2592000";\r\n    }\r\n\r\n    if ($request_filename ~* ^.*[.](html|htm)$) {\r\n      # html使用协商缓存\r\n      add_header Cache-Control "no-cache";\r\n    }\r\n  }\r\n\r\n  # 接口请求代理\r\n  location /api {\r\n    proxy_pass http://ip;\r\n  }\r\n}\r\n\r\nserver {\r\n  # 监听端口\r\n  listen       8000;\r\n\r\n  # 配置服务ip\r\n  server_name  ip;\r\n\r\n  # 配置前端静态资源\r\n  location / {\r\n    # 指定根目录\r\n    root /home/html/pc;\r\n    \r\n    # 移动端访问修改root\r\n    if ($http_user_agent ~* \'(mobile|android|iphone|ipad|phone)\') {\r\n      root /home/html/mobile;\r\n    }\r\n    index index.html index.htm;\r\n  }\r\n}\r\n```'},function(r,n,e){"use strict";e.r(n),n.default="## 正向代理反向代理\r\n### 正向代理\r\n> 比如VPN翻墙。正向代理代理的是客户端，客户端访问代理服务器，并且需要指定目标服务器，然后代理服务器会发送请求给目标服务器，响应之后响应内容由代理服务器返回给客户端。对目标服务器而言是不知道真正的客户端的。\r\n\r\n### 反向代理\r\n> 比如nginx的反向代理。反向代理代理的是目标服务端，客户端请求代理服务器，不需要指定什么目标服务器，代理服务器会进行转发到对应目标服务器，对客户端而言是不知道目标服务器的。\r\n\r\n### 正向代理和反向代理的区别\r\n> 反向代理隐藏了真正的服务器，正向代理隐藏了真正的客户端。\r\n\r\n- 正向代理是对客户端的代理，服务器不知道真正的客户端是谁；反向代理是对服务器的代理，客户端不知道真正的服务器是谁。\r\n- 正向代理一般是客户端架设的；反向代理一般是服务器架设的。\r\n- 正向代理主要是用来解决访问限制问题；反向代理则是提供负载均衡、安全防护等作用。二者都能提高访问速度。"},function(r,n,e){"use strict";e.r(n),n.default="## 解决跨域问题\r\n```\r\nlocation / {\r\n  # 允许跨域的请求，*表示所有  \r\n  add_header 'Access-Control-Allow-Origin' '*';  \r\n\r\n  # 允许携带cookie请求  \r\n  add_header 'Access-Control-Allow-Credentials' 'true';\r\n  \r\n  # 允许跨域请求的方法：GET,POST,OPTIONS,PUT  \r\n  add_header 'Access-Control-Allow-Methods' 'GET,POST,OPTIONS,PUT';  \r\n\r\n  # 允许请求时携带的头部信息，*表示所有  \r\n  add_header 'Access-Control-Allow-Headers' '*';  \r\n\r\n  # 允许发送按段获取资源的请求  \r\n  add_header 'Access-Control-Expose-Headers' 'Content-Length,Content-Range';\r\n\r\n  # 一定要有，否则post请求无法进行跨域\r\n  # 在发送post跨域请求前，会以options方式发送预检请求，服务器接受时才会正式请求  \r\n  if ($request_method = 'OPTIONS') { \r\n    add_header 'Access-Control-Max-Age' 1728000;  \r\n    add_header 'Content-Type' 'text/plain; charset=utf-8';  \r\n    add_header 'Content-Length' 0;\r\n\r\n    # 以下请求头必须有\r\n    add_header 'Access-Control-Allow-Origin' '*';  \r\n    add_header 'Access-Control-Allow-Credentials' 'true';\r\n    add_header 'Access-Control-Allow-Methods' 'GET,POST,OPTIONS,PUT';  \r\n    add_header 'Access-Control-Allow-Headers' '*'; \r\n\r\n    # 对于options方式的请求返回204，表示接受跨域请求  \r\n    return 204;  \r\n  }  \r\n} \r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## 负载均衡\r\n> 负载均衡是当有高并发请求访问服务器时，nginx作为入口服务器，先接受请求然后将请求分到不同的服务器中，保证服务的可用性，缓解服务压力，保证服务的响应速度，即使某一个应用服务不可用，也可以保证业务的正常进行。\r\n\r\n### 轮询(Nginx自带、默认)\r\n> 该策略是Nginx默认的负载均衡策略，每一个客户端请求按时间顺序轮流分配到不同的服务器上，如果后端服务不可以用，会自动过滤掉。\r\n\r\n```\r\nupstream my_servers {\r\n  server      ip:8000;\r\n  server      ip:8001;\r\n  server      ip:8002;\r\n}\r\n```\r\n### weight权重(Nginx自带)\r\n> 权重用于指定轮询的几率，默认权重都是1，可以手动设置调整，权重越高，被分配的次数越多，weight权重和访问比例是成正比的，用于解决后端服务器性能不均衡时，调整访问比例。\r\n\r\n```\r\nupstream my_servers {\r\n  server      ip:8000 weight=1;\r\n  server      ip:8001 weight=2;\r\n  server      ip:8002 weight=4;\r\n}\r\n```\r\n### ip_hash(Nginx自带)\r\n> 将请求按照访问ip的hash结果进行分配，这种方式可以保证同一个用户会固定访问一个后端服务器。优点：可以保证session会话，解决服务器之间session不能共享的问题。\r\n\r\n```\r\nupstream my_servers {\r\n  ip_hash;\r\n  server      ip:8000;\r\n  server      ip:8001;\r\n  server      ip:8002;\r\n}\r\n```\r\n### least_conn(Nginx自带)\r\n> 将请求转发给连接数较少的后端服务器。每个后端服务器配置可能不同，处理的请求也有可能不同，对于处理的请求有快有慢，least_conn是根据后端服务器的连接情况，动态的选择连接数量较少的一台服务器来处理当前的请求。\r\n\r\n```\r\nupstream my_servers {\r\n  least_conn;\r\n  server      ip:8000;\r\n  server      ip:8001;\r\n  server      ip:8002;\r\n}\r\n```\r\n### fair(第三方)\r\n> 是按照服务器端的响应时间来分配请求，响应时间短的服务器优先分配。第三方的负载均衡策略需要安装第三方的插件。\r\n\r\n```\r\nupstream my_servers {\r\n  fair;\r\n  server      ip:8000;\r\n  server      ip:8001;\r\n  server      ip:8002;\r\n}\r\n```\r\n### url_hash(第三方)\r\n> url_hash是根据url的hash结果进行分配请求，每一个url会固定到同一个服务器上，配合缓存使用，可以减少不必要的下载和资源时间的浪费。每次同一个url请求到达同一个服务器上，第一次加载后放入缓存，后面再次请求，直接取缓存资源。如果不采用url_hash，可能会导致请求到达不同的服务器，资源出现重新加载的情况。第三方的负载均衡策略需要安装第三方的插件。\r\n\r\n```\r\nupstream my_servers {\r\n  hash $request_uri;\r\n  server      ip:8000;\r\n  server      ip:8001;\r\n  server      ip:8002;\r\n}\r\n```\r\n### 完整配置 default.conf\r\n```\r\nupstream my_servers {\r\n  server          ip:8000 weight=1;\r\n  server          ip:8001 weight=4;\r\n  server          ip:8002 weight=2;\r\n}\r\n\r\nserver {\r\n  listen          80;\r\n  server_name     ip;\r\n\r\n  location / {\r\n    proxy_pass          http://my_servers;\r\n    proxy_set_header    Host $proxy_host;\r\n    proxy_set_header    X-Real-IP $remote_addr;\r\n    proxy_set_header    X-Forwarded-For $proxy_add_x_forwarded_for;\r\n  }\r\n}\r\n\r\n# 8000端口配置\r\nserver {\r\n  listen          8000;\r\n  server_name     ip;\r\n\r\n  location / {\r\n    root /home/html;\r\n    index 8000.html 8000.htm;\r\n  }\r\n}\r\n\r\n# 8001端口配置\r\nserver {\r\n  listen          8001;\r\n  server_name     ip;\r\n\r\n  location / {\r\n    root /home/html;\r\n    index 8001.html 8001.htm;\r\n  }\r\n}\r\n\r\n# 8002端口配置\r\nserver {\r\n  listen          8002;\r\n  server_name     ip;\r\n\r\n  location / {\r\n    root /home/html;\r\n    index 8002.html 8002.htm;\r\n  }\r\n}\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## 配置SSL证书\r\n> 网站接入HTTPS需要在nginx中配置SSL证书。\r\n\r\n1. 去CA机构或从云控制台中申请对应的SSL证书，审核通过后下载nginx版本的证书。\r\n2. 下载数字证书后，完整的文件总共有三个：.crt、.key、.pem：\r\n    - .crt：数字证书文件，.crt 是.pem 的拓展文件，因此有些人下载后可能没有。\r\n    - .key：服务器的私钥文件，及非对称加密的私钥，用于解密公钥传输的数据。\r\n    - .pem：Base64-encoded 编码格式的源证书文本文件，可自行根需求修改拓展名。\r\n3. 在nginx目录下新建certificate目录，并将下载好的证书/私钥等文件上传至该目录。\r\n4. 修改一下nginx.conf文件如下\r\n```\r\n# ----------HTTPS配置-----------  \r\nserver {  \r\n  # 监听HTTPS默认的443端口  \r\n  listen 443;\r\n\r\n  # 配置自己项目的域名  \r\n  server_name domain;  \r\n\r\n  # 打开SSL加密传输  \r\n  ssl on;  \r\n\r\n  # 输入域名后，首页文件所在的目录  \r\n  root html; \r\n\r\n  # 配置首页的文件名  \r\n  index index.html index.htm index.jsp index.ftl;  \r\n\r\n  # 配置自己下载的数字证书  \r\n  ssl_certificate  certificate/xxx.pem;  \r\n\r\n  # 配置自己下载的服务器私钥  \r\n  ssl_certificate_key certificate/xxx.key;  \r\n\r\n  # 停止通信时，加密会话的有效期，在该时间段内不需要重新交换密钥  \r\n  ssl_session_timeout 5m;  \r\n\r\n  # TLS握手时，服务器采用的密码套件  \r\n  ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;\r\n\r\n  # 服务器支持的TLS版本  \r\n  ssl_protocols TLSv1 TLSv1.1 TLSv1.2;  \r\n\r\n  # 开启由服务器决定采用的密码套件  \r\n  ssl_prefer_server_ciphers on;  \r\n\r\n  location / {  \r\n    ....  \r\n  }  \r\n}  \r\n  \r\n# ---------HTTP请求转HTTPS-------------  \r\nserver {  \r\n  # 监听HTTP默认的80端口  \r\n  listen 80;  \r\n\r\n  # 如果80端口出现访问该域名的请求  \r\n  server_name domain;  \r\n  \r\n  # 将请求重定向到HTTPS\r\n  rewrite ^/(.*)$ https://domain/$1 permanent;  \r\n} \r\n```\r\n### http请求重定向到https时非GET请求报405的问题\r\n> 设置301重定向后所有的请求方法都变成了GET方式，导致一些POST、DELETE等请求报405不能正常使用。可以针对非GET请求使用proxy_pass方法，GET请求使用rewrite\r\n\r\n```\r\nserver {\r\n  # 监听HTTP默认的80端口  \r\n  listen 80;  \r\n\r\n  # 如果80端口出现访问该域名的请求  \r\n  server_name domain;  \r\n  \r\n  location / {\r\n    # 非GET请求用proxy_pass来转发\r\n    if ($request_method ~ ^(POST|DELETE|OPTIONS)$) {\r\n      proxy_pass https://domain;\r\n      break;\r\n    }\r\n\r\n    # 将请求重定向到HTTPS\r\n    rewrite ^/(.*)$ https://domain/$1 permanent;  \r\n  }\r\n}\r\n```\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## 防盗链\r\n> 盗链即是指外部网站引入当前网站的资源对外展示。nginx的防盗链机制实现，跟一个头部字段Referer有关，该字段主要描述了当前请求是从哪儿发出的，那么在nginx中就可获取该值，然后判断是否为本站的资源引用请求，如果不是则不允许访问。\r\n\r\n### 配置项valid_referers\r\n- none：表示接受没有Referer字段的HTTP请求访问。\r\n- blocked：表示允许http://或https://以外的请求访问。\r\n- server_names：资源的白名单，这里可以指定允许访问的域名。\r\n- string：可自定义字符串，支配通配符、正则表达式写法。\r\n### 实现\r\n```\r\nlocation ~ .*\\.(html|htm|gif|jpg|jpeg|bmp|png|ico|txt|js|css) {  \r\n  # 最后面的值在上线前可配置为允许的域名地址  \r\n  valid_referers blocked 192.168.12.129;  \r\n  if ($invalid_referer) {\r\n    # 可以配置成返回一张禁止盗取的图片  \r\n    # rewrite   ^/ http://xx.xx.com/NO.jpg;  \r\n    # 也可直接返回403  \r\n    return   403;  \r\n  }  \r\n}\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## node安装\r\n- [下载地址](https://nodejs.org/en/download)\r\n- 安装之前版本的node在[previous-releases](https://nodejs.org/en/about/previous-releases)中找到之前对应版本，windows下推荐下载.msi文件。\r\n### [安装多个版本node](https://blog.csdn.net/qq_38405436/article/details/132279098)\r\n- 推荐使用nvm管理多版本node。"},function(r,n,e){"use strict";e.r(n),n.default='## node执行命令添加参数\r\n- node index.js dyx douyaxing\r\n```\r\nconsole.log(process.argv) // 输出数组。第三个值是dyx 第四个值是douyaxing\r\n```\r\n- package.json的命令使用\r\n```\r\n"scripts": {\r\n  "create": "node index.js"\r\n},\r\n\r\n// npm run create dyx douyaxing  输出数组。第三个值是dyx 第四个值是douyaxing\r\n// 直接在script命令后添加参数即可，每个参数使用空格分开\r\n```'},function(r,n,e){"use strict";e.r(n),n.default="## nvm\r\n- [下载地址](https://github.com/coreybutler/nvm-windows/releases)\r\n- nvm下载安装后，windows下需要在CMD或PowerShell中使用命令。\r\n- node版本管理工具，开发环境建议先安装nvm，使用nvm安装各个版本node，避免先安装node再安装nvm的各种问题。\r\n- 手动安装的node使用nvm ls查找不到，建议使用nvm安装各个版本的node。\r\n- 在安装nvm之前要将现有的node以及目录下的npm等文件全部删除，然后按照步骤安装nvm即可，使用nvm -v命令检查是否安装成功。\r\n- 当前node版本全局安装的内容只作用于当前版本。\r\n### 常用命令\r\n- nvm ls 查看已安装的版本\r\n- nvm install 6.10.0 安装指定版本\r\n- nvm uninstall 6.10.0 卸载指定版本\r\n- nvm use 6.10.0 使用指定版本\r\n### 配置镜像\r\n- 进入nvm的安装路径，在setting.txt文件中添加以下代码。\r\n```\r\nnode_mirror: https://npm.taobao.org/mirrors/node/\r\nnpm_mirror: https://npm.taobao.org/mirrors/npm/\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## path\r\n- __dirname：获得当前执行文件所在目录的完整目录名。\r\n- __filename：获得当前执行文件的带有完整绝对路径的文件名。\r\n- process.cwd()：获得当前执行node命令时候的文件夹目录名。\r\n- ./ 不使用require时候，./与process.cwd()一样，使用require时候，与__dirname一样。\r\n- path.resolve就相当于是shell下面的cd操作，从左到右执行。"},function(r,n,e){"use strict";e.r(n),n.default="## 运行npm run xxx的时候发生了什么\r\n### 简短方便的执行命令\r\n> npm run xxx的时候首先会去项目的package.json文件的scripts里找对应的命令，然后执行对应的命令，例如启动vue项目npm run serve的时候，实际上就是执行了vue-cli-service serve这条命令。\r\n\r\n### 直接执行package.json中对应的命令时系统并不存在此命令\r\n> 直接执行vue-cli-service serve会报错，因为操作系统中没有存在vue-cli-service这一条指令。\r\n\r\n### npm run xxx的时候为什么不报指令不存在的错误\r\n- 安装依赖的时候是通过 npm i xxx 来执行的，例如 npm i @vue/cli-service，npm在安装这个依赖的时候，就会node_modules/.bin/ 目录中创建好 vue-cli-service 为名的几个可执行文件了。.bin目录不是任何一个npm包。目录下的文件表示这是一个个软链接，打开文件可以看到文件顶部写着 #!/bin/sh ，表示这是一个脚本。\r\n- 当使用 npm run serve 执行 vue-cli-service  serve 时，虽然没有安装 vue-cli-service的全局命令，但是 npm 会到 ./node_modules/.bin 中找到 vue-cli-service 文件作为脚本来执行，则相当于执行了 ./node_modules/.bin/vue-cli-service serve（最后的 serve 作为参数传入）。\r\n- 所以在 npm install 时，npm读到该配置后，就将该文件软链接到 ./node_modules/.bin 目录下，而 npm 还会自动把node_modules/.bin加入$PATH，这样就可以直接作为命令运行依赖程序和开发依赖程序，不用全局安装了。\r\n- 假如我们在安装包时，使用 npm install -g xxx 来安装，那么会将其中的 bin 文件加入到全局，比如 create-react-app 和 vue-cli ，在全局安装后，就可以直接使用如 vue-cli projectName 这样的命令来创建项目了。\r\n### 为什么node_modules/bin中有三个vue-cli-service文件\r\n> 如果我们在 cmd 里运行的时候，windows一般是调用了 vue-cli-service.cmd 这个文件。所以当我们运行vue-cli-service serve这条命令的时候，就相当于运行 node_modules/.bin/vue-cli-service.cmd serve。然后这个脚本会使用 node 去运行 vue-cli-service.js这个 js 文件。\r\n\r\n```\r\n# unix 系默认的可执行文件，必须输入完整文件名\r\nvue-cli-service\r\n\r\n# windows cmd 中默认的可执行文件，当我们不添加后缀名时，自动根据 pathext 查找文件\r\nvue-cli-service.cmd\r\n\r\n# Windows PowerShell 中可执行文件，可以跨平台\r\nvue-cli-service.ps1\r\n```\r\n### 整体流程\r\n- 运行 npm run xxx的时候，npm 会先在当前目录的 node_modules/.bin 查找要执行的程序，如果找到则运行。\r\n- 没有找到则从全局的 node_modules/.bin 中查找，npm i -g xxx就是安装到到全局目录。\r\n- 如果全局目录还是没找到，那么就从 path 环境变量中查找有没有其他同名的可执行程序。\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## npm源管理(nrm)\r\n> nrm是用来管理npm源地址的。\r\n\r\n- npm install nrm -g  全局安装nrm\r\n- nrm ls 查看npm源地址列表  *为当前使用的\r\n- nrm add taobao https://registry.npmmirror.com  添加新的源\r\n- nrm use taobao  使用对应的源"},function(r,n,e){"use strict";e.r(n),n.default='## npm版本符号\r\n### 第一位为大版本，第二位为小版本 第三位为补丁版本\r\n- "1.2.3" 精确版本号。在一些比较重要的线上项目中，建议使用这种方式锁定版本。\r\n- "^1.2.3" 表示从左侧开始第一个不为0的版本不可以变，其右侧的小版本可以变化。\r\n```\r\n"^1.2.3" 等价于 ">= 1.2.3 < 2.0.0"。\r\n"^0.2.3" 等价于 ">= 0.2.3 < 0.3.0"。因为最左侧的是 "0"，那么只要第二位 "2" 不变，其他的都兼容，比如 "0.2.4" 和 "0.2.99"。\r\n"^0.0.3" 等价于 ">= 0.0.3 < 0.0.4"。大版本号和小版本号都为 "0" ，所以也就等价于精确的 "0.0.3"。\r\n```\r\n- "~1.2.3" 如果列出了小版本号（第二位），则只兼容补丁（第三位）的修改；如果没有列出小版本号，则兼容第二和第三位的修改。\r\n```\r\n"~1.2.3" 列出了小版本号 "2"，因此只兼容第三位的修改，等价于 ">= 1.2.3 < 1.3.0"。\r\n\r\n"~1.2" 也列出了小版本号 "2"，因此和上面一样兼容第三位的修改，等价于 ">= 1.2.0 < 1.3.0"。\r\n\r\n"~1" 没有列出小版本号，可以兼容第二第三位的修改，因此等价于 ">= 1.0.0 < 2.0.0"\r\n```\r\n- "*1.2.3" 安装最新版本的依赖包，会匹配 x.x.x 。\r\n### 使用场景\r\n> 可以指定特定的版本号，直接写1.2.3，但是如果依赖包发布新版本修复了一些小bug，那么需要手动修改package.json文件。使用 ~ 和 ^ 则可以解决这个问题。但是需要注意 ^ 版本更新可能比较大，会造成项目代码错误，所以建议使用 ~ 来标记版本号，这样可以保证项目不会出现大的问题，也能保证包中的小bug可以得到修复。版本号写 *，这意味着安装最新版本的依赖包，但也可能会造成版本不兼容，不建议使用。\r\n'},function(r,n,e){"use strict";e.r(n),n.default="## package-lock.json\r\n> 为了保证不同人电脑安装的所有依赖版本都是一致的，确保项目代码所执行的运行结果都一样。\r\n\r\n1. 在一个项目中npm install时候，会自动生成一个package-lock.json文件，和package.json在同一级目录下。package-lock.json记录了项目的一些信息和所依赖的模块。这样在每次安装都会出现相同的结果. 不管你在什么机器上面或什么时候安装。当我们下次再npm install时候，npm发现如果项目中有package-lock.json文件，会根据package-lock.json里的内容来处理和安装依赖而不再根据package.json。\r\n2. 如果package.json的semver-range version(指定版本的区间范围)和package-lock.json中版本兼容(package-lock.json 版本在 package.json 指定的版本范围内)，即使此时 package.json 中有新的版本，执行 npm install也还是会根据package-lock.json下载。\r\n3. 如果手动修改了package.json的version ranges，且和package-lock.json中版本不兼容，那么执行npm install时package-lock.json将会更新到兼容package.json的版本。\r\n### 不同人安装版本不同的问题\r\n> 假设在项目中的package.json的vue版本是vue: ^3.0.0，我们电脑安装的vue版本就是3.0.0版本，我们把项目代码提交后，过了一段时间vue发布了新版本3.0.1，这时其他同事执行npm install安装的时候，在他电脑的vue版本就是3.0.1了，因为我们的版本没有锁死，这样我们电脑中的vue版本就会不一样，我们的应用程序也许会产生不同的结果。如果我们在package.json上面锁死依赖包的版本号直接写vue: 3.0.0，这样大家安装vue的版本都是3.0.0版本了。但是这样只能控制你自己的项目锁死版本号，那你项目中使用的依赖包的依赖包是无法控制版本号无法锁死版本号的。\r\n\r\n### cnpm的差异\r\n> 用cnpm install时候，并不会生成package-lock.json文件，也不会根据package-lock.json来安装依赖包，还是会使用package.json来安装。"},function(r,n,e){"use strict";e.r(n),n.default="## package.json\r\n> package.json用来描述项目及项目所依赖的模块信息。帮我们管理项目中的依赖包。"},function(r,n,e){"use strict";e.r(n),n.default="## yarn\r\n- 全局安装yarn  npm install -g yarn\r\n- 查看yarn安装版本  yarn -v\r\n### yarn全局安装依赖\r\n- 全局安装依赖  yarn global add package\r\n- 查看yarn全局安装过的依赖  yarn global list --depth=0\r\n### yarn全局安装的依赖找不到\r\n- 通过yarn global bin获取yarn bin路径。\r\n- 检查path中是否加入了yarn bin路径，如未添加将其加入到环境变量。\r\n\r\n### 常见错误\r\n- 执行yarn install命令的时候报错：info There appears to be trouble with your network connection. Retrying...\r\n> 删除yarn.lock文件，重新执行yarn install。"},function(r,n,e){"use strict";e.r(n),n.default='## 修改npm包逻辑\r\n- 直接修改node_modules中npm包代码这种做法是不推荐的，因为这些改动在重新安装包或更新包时会丢失。\r\n### Fork源代码\r\n- Fork第三方包的源代码库，对其源代码进行修改，修改完成后将修改后的包发布到npm上，然后将项目中的包切换为修改后的npm包。\r\n### 提交PR\r\n- 如果新的修改对其他用户也有帮助，可以向原始包的维护者提交Pull Request，如果PR被接受并合并，那么就可以直接使用未来版本的官方包。\r\n### 本地修改生成补丁\r\n1. 直接在项目的node_modules目录下找到并修改对应的第三方包文件，虽然这种修改是临时的，但是接下来的步骤会保存这些改动。\r\n2. 使用patch-package在node_modules中的包上应用补丁，并且这些补丁可以和项目代码一起被版本控制。\r\n```\r\nnpm install patch-package postinstall-postinstall --save-dev\r\n```\r\n3. 使用patch-package生成一个补丁文件。这个命令会比较node_modules中对应npm包的修改，并将这些修改保存为一个补丁文件。执行这个命令后patch-package会在项目的根目录下创建一个patches目录，并在里面生成一个名为npm包名称+版本号.patch的文件，版本号是项目中使用的npm包的版本。\r\n```\r\nnpx patch-package packageName\r\n```\r\n4. 将应用补丁的步骤添加到package.json中的script字段，每次运行npm install时postinstall脚本都会执行，自动应用保存在patches/目录下的所有补丁。\r\n```\r\n"scripts": {\r\n  "postinstall": "patch-package"\r\n}\r\n```\r\n### 包装第三方包\r\n- 包装第三方包方法创建一个新的模块或包，通过这种方式可以在不直接修改原始包的情况下，添加新的功能、修改现有方法或者调整方法的行为。\r\n'},function(r,n,e){"use strict";e.r(n),n.default="## 常用命令\r\n### 常用参数\r\n- --save-exact：固定依赖包的版本，避免版本滑动。\r\n### 查看全局依赖\r\n- 全局安装依赖  npm install -g package\r\n- 查看全局安装依赖(会看到包的依赖)  npm ls -g\r\n- 查看全局安装依赖(显示深度0，不会看到包的依赖)  npm ls -g --depth 0\r\n### 查看npm使用的源\r\n- 查看当前的npm源  npm config get registry\r\n- 查看所有可用的npm源  npm config ls -l\r\n- 切换npm源  npm config set registry https://registry.npmmirror.com"},function(r,n,e){"use strict";e.r(n),n.default="## Context\r\n- React Context API是React库的一部分，它允许在组件之间共享全局数据，而无需通过每层组件传递props。使用Context API可以避免繁琐的props传递，提高代码的可读性和维护性。\r\n- Context API非常适合需要在多个嵌套组件中共享状态的场景，例如管理全局主题设置、用户身份验证状态或应用配置等。\r\n- 当Context的值在顶部组件使用state维护时，更新state使Context的值变化，会导致顶部组件和内部所有后代组件重新渲染，此种情况相较于通过每层组件传递props并无法减少中间组件的重新渲染。\r\n### Context使用\r\n- 使用createContext创建Context。\r\n```\r\nimport { createContext } from 'react';\r\n\r\nconst ThemeContext = createContext('light'); // 默认值\r\n```\r\n- 使用Provider指定包裹组件的值。\r\n```\r\nfunction App() {\r\n  const [theme, setTheme] = useState('light');\r\n\r\n  return (\r\n    <ThemeContext.Provider value={theme}>\r\n      <Page />\r\n    </ThemeContext.Provider>\r\n  );\r\n}\r\n```\r\n- 使用useContext()读取Context值。\r\n```\r\nfunction Button() {\r\n  const theme = useContext(ThemeContext);\r\n  return <button className={theme} />;\r\n}\r\n```\r\n### 创建多个React Context\r\n- 每当Context的值更新时，使用该Context的所有组件都会重新渲染。当更新Context中部分信息时，使用Context但并不关注此次更新信息的组件也会重新渲染。\r\n- 创建多个Context将不同部分的信息使用不同的Context存储。\r\n```\r\nfunction App() {\r\n  const [theme, setTheme] = useState('dark');\r\n  const [currentUser, setCurrentUser] = useState({ name: 'Taylor' });\r\n\r\n  return (\r\n    <ThemeContext.Provider value={theme}>\r\n      <AuthContext.Provider value={currentUser}>\r\n        <Page />\r\n      </AuthContext.Provider>\r\n    </ThemeContext.Provider>\r\n  );\r\n}\r\n```\r\n### 如何防止React Context重新渲染问题\r\n> 每当更新Context值时，所有使用该上下文的组件都将被重新渲染(即使组件被React.memo包裹)。\r\n\r\n- 使用多个React Context\r\n> 这是防止不必要重新渲染的首选方法。通过创建多个Context将相关的数据分开存储，只有使用特定Context的组件会因更新而重新渲染。\r\n\r\n- 拆分组件并传递所需的值(使用单一React Context情景)\r\n> 通过将组件拆分，并将所需的值作为props从context中传递，并将子组件包装在React.memo中，只有当其props发生变化时，组件才会重新渲染。\r\n\r\n```\r\nconst Card = () => {\r\n  const appContextValue = useContext(AppContext);\r\n  const theme = appContextValue.theme;\r\n\r\n  return (\r\n    <div>\r\n      <CardTitle theme={theme} />\r\n      <CardDescription theme={theme} />\r\n    </div>\r\n  );\r\n};\r\n\r\nconst CardTitle = React.memo(({ theme }) => {\r\n  return <h2 style={{ color: theme.text }}>title</h2>;\r\n});\r\n\r\nconst CardDescription = React.memo(({ theme }) => {\r\n  return <p style={{ color: theme.text }}>description</p>;\r\n});\r\n```\r\n- 使用React.useMemo(使用单一React Context情景)\r\n> 将组件包装在useMemo中，并将Context的值作为依赖项，只有Context的值更改时才会触发回调函数重新渲染组件。\r\n\r\n```\r\nconst Card = () => {\r\n  const appContextValue = useContext(AppContext);\r\n  const theme = appContextValue.theme;\r\n\r\n  return useMemo(\r\n    () => (\r\n      <div>\r\n        <CardTitle theme={theme} />\r\n        <CardDescription theme={theme} />\r\n      </div>\r\n    ),\r\n    [theme]\r\n  );\r\n};\r\n\r\nconst CardTitle = ({ theme }) => {\r\n  return <h2 style={{ color: theme.text }}>title</h2>;\r\n};\r\n\r\nconst CardDescription = ({ theme }) => {\r\n  return <p style={{ color: theme.text }}>description</p>;\r\n};\r\n```\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## [reactApi](https://juejin.cn/post/6950063294270930980)\r\n### 组件类\r\n#### Component\r\n- 类组件的基础。\r\n#### PureComponent\r\n- PureComponent会对类组件的State和Props进行浅比较，只有当State和Props发生变化时组件才会重新渲染。\r\n#### memo\r\n- React.memo会对函数组件的Props进行浅比较，只有当Props发生变化时组件才会重新渲染。支持第二个参数传入一个函数，如果组件需要更新就返回false，不需要更新就返回true。和shouldComponentUpdate正好相反。\r\n#### forwardRef\r\n- 想要获取深层次组件(例如孙组件)的dom元素\r\n- 高阶组件，使用ref拿到原始组件的实例\r\n#### lazy + Suspense\r\n- 构建异步渲染组件，两者要配合使用，不支持服务端渲染，服务端渲染可以使用loadable。实现代码分割，动态加载。\r\n- React.lazy接受一个函数，这个函数需要动态调用import()。它必须返回一个Promise，该Promise需要resolve一个default export的React组件。\r\n- Suspense让组件“等待”某个异步操作，直到该异步操作结束即可渲染，等待加载lazy组件时做UI层面的优雅降级(如loading显示等)。\r\n```\r\nimport React, { Suspense } from 'react';\r\n\r\nconst OtherComponent = React.lazy(() => import('./OtherComponent'));\r\n\r\nfunction MyComponent() {\r\n  return (\r\n    <div>\r\n      <Suspense fallback={<div>Loading...</div>}>\r\n        <OtherComponent />\r\n      </Suspense>\r\n    </div>\r\n  );\r\n}\r\n```\r\n#### Fragment\r\n- react不允许一个组件返回多个节点元素，使用Fragment元素包裹不会增加新的DOM节点。\r\n- 相较于<></>形式Fragment可以支持key、ref属性。\r\n- map遍历后的元素，react底层会处理，默认在外部嵌套一个Fragment元素\r\n#### Profiler\r\n- 用于开发阶段性能检测，检测一次react组件渲染用时性能开销。\r\n- 第一个参数是id，用于表识唯一性的，第二个参数是onRender回调函数，用于渲染完成，接受渲染参数。\r\n#### StrictMode\r\n- 严格模式，用于检测react项目中的潜在的问题，严格模式检查仅在开发模式下运行，不会影响生产构建。\r\n- 识别不安全的生命周期。\r\n- 关于使用过时的字符串ref API的警告。\r\n- 关于使用废弃的findDOMNode方法的警告。\r\n- 检测使用过时的Context API。\r\n- 检测意外的副作用。\r\n### 工具类\r\n#### createElement\r\n- JSX最终会被babel用createElement编译成React元素形式。\r\n- 第一个参数如果是组件类型传入组件，如果是dom元素类型传入元素类型的字符串。\r\n- 第二个参数为一个对象，在dom类型中为属性，在组件类型中为Props。\r\n- 其他参数为children，根据顺序排列。\r\n#### cloneElement\r\n- cloneElement的作用是以element元素为样板克隆并返回新的React元素。返回新的React元素可以在原基础上添加新的属性。\r\n#### createContext\r\n- createContext用于创建一个Context对象，createContext对象中包括用于传递Context对象值value的Provider，和接受value变化订阅的Consumer。\r\n#### createFactory\r\n- 返回用于生成指定类型React元素的函数，api将要被废弃，如果想要达到同样的效果，可以使用createElement。\r\n#### createRef\r\n- createRef可以创建一个ref元素。\r\n#### isValidElement\r\n- 可以用来检测是否为React element元素，接受待验证对象，返回true或者false。\r\n#### React.Children提供了用于处理this.props.children不透明数据结构的实用方法\r\n- 当children的元素的数据结构使用数组的map等方法不是很适用时，就要使用react.Chidren的方法来处理。\r\n- Children.map 遍历并返回新的数组\r\n- Children.forEach 仅遍历\r\n- Children.count 获取children中的组件总数量\r\n- Children.toArray 返回children扁平化后的结果\r\n- Children.only 验证children是否只有一个子节点，如果有则返回它，否则此方法会抛出错误。Children.only不接受Children.map的返回值，因为它是一个数组而并不是React元素\r\n### react-dom\r\n#### render\r\n- 用于渲染react元素\r\n#### hydrate\r\n- 服务端渲染使用的方法，用法同render\r\n#### createPortal\r\n- createPortal可以把当前组件或element元素的子节点，渲染到组件之外的其他地方。例如弹窗组件。\r\n#### unstable_batchedUpdates\r\n- 正常情况下react的state更新会批量更新state减少渲染次数，当在异步函数或原生事件中使用不再有此效果，想要依然实现批量更新的效果可以使用unstable_batchedUpdates方法。\r\n```\r\nhanderClick = () => {\r\n  Promise.resolve().then(() => {\r\n    ReactDOM.unstable_batchedUpdates(() => {\r\n      this.setState({ number: this.state.number + 1 });\r\n      console.log(this.state.number);\r\n      this.setState({ number: this.state.number + 1 });\r\n      console.log(this.state.number);\r\n      this.setState({ number: this.state.number + 1 });\r\n      console.log(this.state.number);\r\n    }) \r\n  })\r\n}\r\n\r\n```\r\n#### flushSync\r\n- 可以将更新任务放在一个较高的优先级。\r\n```\r\n// 打印 0 3 4 1  因为3设定了一个高优先级的更新，所以3先被打印，2 4被批量更新为4，最后打印1(setTimeout在下一轮的宏任务中执行)\r\nclass Home extends React.Component {\r\n  state = { number: 0 }\r\n\r\n  handerClick = () => {\r\n    setTimeout(() => {\r\n      this.setState({ number: 1  })\r\n    })\r\n    this.setState({ number: 2  })\r\n    ReactDOM.flushSync(() => {\r\n      this.setState({ number: 3  })\r\n    })\r\n    this.setState({ number: 4  })\r\n  }\r\n\r\n  render() {\r\n    const { number } = this.state\r\n    console.log(number)\r\n    return (\r\n      <div>\r\n        <div>{ number }</div>\r\n        <button onClick={this.handerClick} >测试flushSync</button>\r\n      </div>\r\n    )\r\n  }\r\n}\r\n```\r\n#### findDOMNode\r\n- 用于访问组件DOM元素节点，推荐使用ref获取。\r\n#### unmountComponentAtNode\r\n- 从DOM中卸载组件，会将其事件处理器和state一并清除。\r\n- 如果指定容器上没有对应已挂载的组件，这个函数什么也不会做。如果组件被移除将会返回true，如果没有组件可被移除将会返回false。 "},function(r,n,e){"use strict";e.r(n),n.default="## class组件的super\r\n- 在JS中，super引用的是父类构造函数。在React中引用的是React.Component。\r\n- JS强制在构造函数中先调用super()才能使用this。这一限制也被应用到了React组件。\r\n- 我们可以在class组件中省略构造函数，使用实例属性形式定义state。\r\n- 在class组件中一旦写了constructor就要写super()，只有写了super()才会有自己的this，否则后续使用的时候会报错。\r\n### super(props)\r\n- 调用super()时没有传入props参数，依然能够在render和其它方法中访问this.props，这是因为React在调用构造函数之后，会把props赋值给刚刚创建的实例对象。\r\n- super()中传递props才能在constructor中使用this.props。如上述React在调用构造函数之后才给实例设置props，所以super()中不传递props不能在constructor中使用this.props。"},function(r,n,e){"use strict";e.r(n),n.default='## fiber\r\n- react fiber不会让比较的时间缩短，但它使得diff的过程被分成一小段一小段的，因为它有了“保存工作进度”的能力。js会比较一部分虚拟dom，然后让渡主线程，给浏览器去做其他工作，然后继续比较，依次往复，等到最后比较完成，一次性更新到视图上。\r\n- 新的架构中，每个节点有三个指针：分别指向第一个子节点、下一个兄弟节点、父节点。这种数据结构就是fiber，它的遍历规则为从根节点开始，依次遍历该节点的子节点、兄弟节点，如果两者都遍历了，则回到它的父节点；当遍历发生中断时，只要保留下当前节点的索引，断点是可以恢复的——因为每个节点都保持着对其父节点的索引。\r\n### 组件diff的工作拆分为小段任务的操作且可中断\r\n- 主流浏览器刷新频率为60Hz，即每(1000ms / 60Hz)16.6ms浏览器刷新一次。\r\n- JS可以操作DOM，GUI渲染线程与JS线程是互斥的。所以JS脚本执行和浏览器布局、绘制不能同时执行。在每16.6ms时间内，需要完成如下工作：JS脚本执行 => 样式布局 => 样式绘制。\r\n- 当JS执行时间过长，超出了16.6ms，这次刷新就没有时间执行样式布局和样式绘制了，导致页面掉帧，造成卡顿。\r\n- 在浏览器每一帧的时间中，预留一些时间给JS线程，React利用这部分时间更新组件，当预留的时间不够用时，React将线程控制权交还给浏览器使其有时间渲染UI，React则等待下一帧时间到来继续被中断的工作。\r\n- 这种将长任务分拆到每一帧中，一次执行一小段任务的操作，被称为时间切片。而时间切片的关键是将同步的更新变为可中断的异步更新。\r\n### react16之前\r\n- 在react16引入Fiber架构之前，react会采用递归对比虚拟DOM树(深度优先遍历)，找出需要变动的节点，然后同步更新它们(对比、更新同时进行)，这个过程react称为reconcilation(协调阶段)。\r\n- 在reconcilation期间，react会一直占用浏览器资源，会导致用户触发的事件得不到响应。\r\n### react17\r\n- Fiber架构出现以后让React有了可中断更新的能力，在React17以前React依然是同步更新的，协调过程不可中断。\r\n- React17有个实验版本，通过ReactDOM.createRoot(rootNode).render()创建的应用是并发更新。\r\n### react16将同步的更新变为可中断的异步更新，如何解决中断更新时DOM渲染不完全的问题\r\n- 在React16中，Reconciler与Renderer不再是交替工作。当Scheduler将任务交给Reconciler后，Reconciler会为变化的虚拟DOM打上代表增/删/更新的标记。\r\n- 整个Scheduler与Reconciler的工作都在内存中进行，不会更新页面上的DOM，所以即使反复中断，用户也不会看见更新不完全的DOM。只有当所有组件都完成Reconciler的工作，才会统一交给Renderer。Renderer根据Reconciler为虚拟DOM打的标记，同步执行对应的真实DOM操作。\r\n### 多个Fiber节点是树的结构，但是以链表数据结构存储\r\n> 依靠三个属性，父节点(return，使用return没有使用parent是因为当子节点和子节点的兄弟节点完成工作后会返回父节点，具体实现可参考简单react实现文件中)、子节点(child)、兄弟节点(sibling)的关联生成一个树状的结构。\r\n\r\n### 双缓存\r\n> 在内存中构建并直接替换，React使用“双缓存”来完成Fiber树的构建与替换——对应着虚拟DOM树的创建与更新。\r\n\r\n### fiber树\r\n- 在React中最多会同时存在两棵Fiber树。当前屏幕上显示内容对应的Fiber树称为current Fiber树，正在内存中构建的Fiber树称为workInProgress Fiber树。\r\n- current Fiber树中的Fiber节点被称为current fiber，workInProgress Fiber树中的Fiber节点被称为workInProgress fiber，他们通过alternate属性连接，在处理workInProgress Fiber树的时候，能够获得current Fiber树的信息。\r\n### Fiber出来之后，vdom的作用只是作为蓝本进行构建Fiber树。\r\n### element、fiber和DOM元素的关系\r\n- element对象就是我们的jsx代码，上面保存了props、key、children等信息。\r\n- DOM元素就是最终呈现给用户展示的效果。\r\n- fiber就是充当element和DOM元素的桥梁，只要elemnet发生改变，就会通过fiber做一次调和，使对应的DOM元素发生改变。\r\n### 示例\r\n```\r\nimport React from "react";\r\n\r\nexport default class App extends React.Component {\r\n  constructor(...props) {\r\n    super(...props);\r\n    this.state = {\r\n      count: 1\r\n    };\r\n  }\r\n  onClick() {\r\n    this.setState({\r\n      count: this.state.count + 1\r\n    });\r\n  }\r\n  render() {\r\n    return (\r\n      <ul>\r\n        <button onClick={() => this.onClick()}>乘以{this.state.count}</button>\r\n        <li>{1 * this.state.count}</li>\r\n        <li>{2 * this.state.count}</li>\r\n        <li>{3 * this.state.count}</li>\r\n      </ul>\r\n    );\r\n  }\r\n}\r\n```\r\n- 同步更新(react15) 点击button将count从1变为2之后\r\n![同步更新](./img/v15同步更新.png)\r\n- 如果中断进行中的更新，将会看到不完全的dom\r\n![中断更新](./img/v15中断更新.png)\r\n- 异步可中断更新(react16)\r\n> 其中红框中的步骤随时可能由于以下原因被中断：有其他更高优任务需要先更新，当前帧没有剩余时间。由于红框中的工作都在内存中进行，不会更新页面上的DOM，所以即使反复中断，用户也不会看见更新不完全的。\r\n\r\n![异步中断更新](./img/v16异步更新.png)\r\n### 总结\r\n- React Fiber是React 16提出的一种更新机制，使用链表取代了树，将虚拟dom连接，使得组件diff的流程可以被中断恢复。\r\n- 它把组件diff的工作分片，到时会主动让出渲染主线程。\r\n- react fiber这种数据结构(链表)使得节点可以回溯到其父节点，只要保留下中断的节点索引，就可以恢复之前的工作进度。\r\n### Vue没有Fiber的原因\r\n- react中组件更新，会自顶向下重新渲染组件，自顶向下的含义是该组件以及它的子组件全部需要渲染，由于无法做到精确更新，所以需要使用到Fiber将组件渲染工作分割为多个小任务，可以中断和恢复，不阻塞主进程执行高优先级的任务。\r\n- Vue是基于template和watcher的组件级更新，可以做到精准更新，把每个更新任务分割得足够小，不需要使用到Fiber架构将任务进行更细粒度的拆分。\r\n'},function(r,n,e){"use strict";e.r(n),n.default="## hooks\r\n- React规定我们必须把hooks写在函数的最外层，不能写在if else条件语句中或内部函数中，来确保hooks的调用顺序在每次渲染中都是相同的。\r\n- 只在React函数组件中调用hooks，而不在普通函数中调用hooks。\r\n## useState(useState内部是基于useReducer实现的)\r\n- 第一次渲染会读取设置的初始值，之后渲染时则会忽略设置的初始值。\r\n- useState改变状态依然不是立即改变的，修改后无法实时获取到改变之后最新的值。\r\n- 传入useState参数后返回一个带有默认状态和改变状态函数(如下setInfo)的数组; \r\n```\r\nconst [info, setInfo] = useState({\r\n  name: 'dyx',\r\n  age: 24,\r\n});\r\n```\r\n- setState是非覆盖式更新状态，具备浅合并功能，只会更新传入的值，而useState是覆盖式更新状态。\r\n```\r\nconst [info, setInfo] = useState({\r\n  name: 'dyx',\r\n  age: 24,\r\n});\r\nconst changeInfo = addAge => {\r\n  setInfo({\r\n    ...info,\r\n    age: info.age + addAge,\r\n  });\r\n}\r\n```\r\n- 使用useState更新值时获取更新前的值\r\n```\r\nconst [num, setNum] = useState(2);\r\n\r\nsetNum((oldNum) => {\r\n  return oldNum + 2;\r\n})\r\n```\r\n- setState只要设置状态就会更新即使设置的值相同，useState设置相同的值不会更新。\r\n- 修改引用类型数据，必须重新返回一个新的引用。直接的修改引用类型的属性值，这样破坏了不可变值的规矩，应该通过Object.assign或者扩展运算符来重新创建一个对象进行设置。React内部会针对传入的参数进行浅比较，引用类型的数据浅比较的是其引用指向的地址而不是内容值，所以只有内容值变化引用不变化不会更新。简单类型的浅比较是比较的内容值。\r\n```\r\nconst [info, setInfo] = useState({\r\n  name: 'dyx',\r\n  age: 24,\r\n});\r\n\r\n// 页面会更新\r\nconst changeInfo = addAge => {\r\n  setInfo((oldInfo) => {\r\n    return {\r\n      ...oldInfo,\r\n      age: oldInfo.age + addAge,\r\n    }\r\n  });\r\n}\r\n\r\nconst changeInfoCopy = addAge => {\r\n  setInfo((oldInfo) => {\r\n    oldInfo.age += addAge;\r\n    // return oldInfo;  这样不会触发页面更新，引用类型数据的浅比较的是其指向的地址。\r\n    return {...oldInfo}; // 这样会更新\r\n  });\r\n}\r\n\r\n\r\n// 简单类型数据可以触发更新，简单类型的浅比较是比较的内容值。\r\nconst [num, setNum] = useState(2);\r\nconst changeNum = addNum => {\r\n  setNum((oldNum) => {\r\n    oldNum += addNum;\r\n    return oldNum;\r\n  });\r\n}\r\n```\r\n## useEffect\r\n- useEffect第二个参数中数组没有传值时代表不监听任何参数变化，只有在组件初始化时才会触发，用来代替componentDidMount\r\n```\r\nuseEffect(() => {\r\n  console.log('componentDidMount');\r\n}, [])\r\n```\r\n- 如果第二个参数中的值改变则触发第一个参数中的方法，组件初始化也会触发此方法，引用类型数据也可以监听到\r\n```\r\nconst [info, setInfo] = useState({ name: 'dyx', age: 24 });\r\nuseEffect(() => {\r\n  console.log(info); // 改变后的值\r\n}, [info]);\r\n``` \r\n- 第二个参数可以监听多个参数，有其一改变就会触发\r\n```\r\nconst [info, setInfo] = useState({ name: 'dyx', age: 24 });\r\nconst [num, setNum] = useState(2);\r\n// 只要num和info有一个变化就会触发\r\nuseEffect(() => {\r\n  console.log(info);\r\n  console.log(num);\r\n}, [info, num]);\r\n``` \r\n- 没有第二个参数时类似于componentDidMount和componentDidUpdate, 每一次渲染都会触发\r\n```\r\nuseEffect(() => {\r\n  console.log('render');\r\n})\r\n```\r\n- componentDidMount注册事件，componentWillUnmount销毁事件\r\n> removeEventListener传入的事件处理函数必须和addEventListener传入的事件处理函数是相同的，只有传入相同的事件处理函数才能正常解除事件绑定。要特别注意函数组件执行就会形成一个闭包的Capture Value特性。\r\n\r\n```\r\nconst func = () => {\r\n  console.log('func');\r\n}\r\n\r\nuseEffect(() => {\r\n  document.addEventListener('click', func);\r\n  return () => {\r\n    document.removeEventListener('click', func);\r\n  };\r\n}, []);\r\n\r\n// componentWillUnmount功能\r\nuseEffect(() => {\r\n  return () => {\r\n    console.log('componentWillUnmount');\r\n  }\r\n}, [])\r\n```\r\n- 监听props的改变，可以监听整个props或者监听某个或多个props值\r\n```\r\n// 监听props\r\nuseEffect(() => {\r\n  console.log(props);\r\n}, [props]);\r\n```\r\n## useLayoutEffect\r\n- useLayoutEffect中的代码以及其中任何计划的状态更新都会在浏览器重新绘制之前得到处理。\r\n- useLayoutEffect可能会影响性能，尽可能使用useEffect。\r\n## useRef\r\n- createRef每次渲染都会返回一个新的引用，而useRef每次都会返回相同的引用。\r\n- 创建useRef时候，会创建一个原始对象，只要函数组件不被销毁，原始对象就会一直存在，可以利用这个特性，来通过useRef保存一些数据。ref在所有的render中保持着唯一引用，因此所有对ref的赋值或取值，拿到的都是一个最终状态，不会在每个render间存在隔离。\r\n```\r\n// ref的值需要手动更新, 当无法在某一场景获取到最新的props时可以定义ref为最新的props值\r\nconst queryRef = useRef(props);\r\nuseEffect(() => {\r\n  queryRef.current = props;\r\n}, [props])\r\n```\r\n- 将ref对象传入元素，ref对象的.current属性将是当前的DOM节点。\r\n```\r\n/**\r\n * ref绑定元素的使用\r\n */\r\nimport React, { useRef } from 'react';\r\n\r\nconst DemoOne = () => {\r\n  const refEle = useRef();\r\n\r\n  const clickToFocus = () => {\r\n    refEle && refEle.current && refEle.current.focus();\r\n  }\r\n\r\n  return (\r\n    <div>\r\n      <input ref={refEle} type=\"text\" />\r\n      <button onClick={clickToFocus}>click</button>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default DemoOne;\r\n```\r\n## useImperativeHandleref\r\n> useImperativeHandle可以配合forwardRef自定义暴露给父组件的实例值。子组件如果是class类组件，我们可以通过ref获取类组件的实例，但是在子组件是函数组件的情况，我们需要使用useImperativeHandle和forwardRef配合达到获取组件实例的效果。\r\n\r\n```\r\n/**\r\n * 父组件调用子组件方法的 父组件\r\n */\r\nimport React from 'react';\r\nimport Child from './child';\r\n\r\nconst Demo = () => {\r\n  const childRef = useRef();\r\n  const getChild = () => {\r\n    console.log(childRef); // 子组件useImperativeHandle返回的值\r\n    childRef.current && childRef.current.childFunc(3);\r\n  }\r\n  \r\n  return (\r\n    <div>\r\n      <Child ref={childRef} />\r\n      <button onClick={getChild}>触发子组件方法</button>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default Demo;\r\n\r\n/**\r\n * 父组件调用子组件方法的 子组件\r\n */\r\nimport React, { useState, useImperativeHandle, forwardRef } from 'react';\r\n\r\n// props子组件中需要接受ref\r\nconst Child = (props, ref) => {\r\n  const [val, setVal] = useState(1);\r\n\r\n  const changeVal = val => {\r\n    setVal(val);\r\n  }\r\n  \r\n  // useImperativeHandle方法的的第一个参数是目标元素的ref引用\r\n  useImperativeHandle(ref, () => ({\r\n    // childFunc 就是暴露给父组件的方法\r\n    childFunc: (newVal) => {\r\n      changeVal(val + newVal);\r\n    }\r\n  }));\r\n\r\n  return (\r\n    <div>{val}</div>\r\n  );\r\n}\r\n\r\nexport default forwardRef(Child);\r\n```\r\n## useMemo\r\n- 只有依赖项改变才会调用某一个方法时可以使用useMemo，避免在每次渲染时都进行高开销的计算。返回的是函数运行的结果。\r\n```\r\n// 父组件\r\nimport React, { useState } from 'react';\r\nimport DemoOne from './demoOne';\r\n\r\nconst UseMemoDemo = (props) => {\r\n  const [count, setCount] = useState(0);\r\n  const [count1, setCount1] = useState(1);\r\n  return (\r\n    <div>\r\n      <DemoOne {...props} count={count} count1={count1} />\r\n      <button onClick={() => setCount(count + 1)}>count</button>\r\n      <button onClick={() => setCount1(count1 + 1)}>count1</button>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default UseMemoDemo;\r\n\r\n\r\n// 子组件\r\nimport React, { useState, useMemo } from 'react';\r\n\r\nconst DemoOne = (props) => {\r\n  const [num, setNum] = useState(100);\r\n  const { count, count1 } = props;\r\n\r\n  const operationProps = (props) => {\r\n    console.log('propsChange')\r\n    return {\r\n      newcount: props.count + 10,\r\n      newcount1: props.count1 + 10,\r\n    }\r\n  }\r\n\r\n  // 如果不使用useMemo在组件内部状态改变时也会重新调用operationProps方法，使用之后只有在props改变时才会重新调用operationProps方法\r\n  const { newcount, newcount1 } = useMemo(() => operationProps(props), [props]);\r\n  return (\r\n    <div>\r\n      <div>\r\n        props count: {count}  count1: {count1}\r\n      </div>\r\n      <div>\r\n        new count: {newcount}  count1: {newcount1}\r\n      </div>\r\n      <div>\r\n        num {num}\r\n        <button onClick={() => setNum(num + 1)}>changeNum</button>\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default DemoOne;\r\n```\r\n- 没有依赖项时在第一次渲染时调用方法，可以用于debounce方法的声明\r\n```\r\nimport { debounce } from 'lodash';\r\nconst onChange = () => {\r\n  console.log('onChange');\r\n}\r\n\r\nconst debounceOnChange = useMemo(() => {\r\n  return debounce(onChange, 600);\r\n}, [])\r\n```\r\n## useCallback\r\n> 返回的是函数。父组件重新渲染时，声明的函数也会重新定义，如果此函数传递给子组件，那么子组件会重新render，使用useCallback对函数进行包裹，可以避免子组件不必要的重新渲染，子组件使用React.memo包裹。\r\n\r\n```\r\n// 父组件\r\nimport React, { useState, useCallback } from 'react';\r\nimport DemoOne from './demoOne';\r\n\r\nconst UseMemoDemo = () => {\r\n  const [count, setCount] = useState(0);\r\n  const [count1, setCount1] = useState(1);\r\n\r\n  const clickCount= () => {\r\n    setCount(count + 1);\r\n  };\r\n\r\n  const clickCount1 = useCallback(() => {\r\n    setCount1(count1 + 1);\r\n  }, [count1]);\r\n\r\n  return (\r\n    <div>\r\n      <div>count: {count}, count1: {count1}</div>\r\n      <DemoOne clickCount={clickCount}>普通函数形式</DemoOne>\r\n      <DemoOne clickCount={clickCount1}>useCallback函数形式</DemoOne>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default UseMemoDemo;\r\n\r\n\r\n/**\r\n * 避免父组件重新渲染，导致传递的方法重新定义导致子组件重新渲染\r\n */\r\nimport React from 'react';\r\n\r\nconst DemoOne = (props) => {\r\n  console.log(props.children)\r\n  return (\r\n    <div>\r\n      <div>\r\n        {props.children}\r\n      </div>\r\n      <button onClick={props.clickCount}>调用父组件方法</button>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default React.memo(DemoOne);\r\n```\r\n## useContext\r\n```\r\n// colorContext.js\r\nimport { createContext } from 'react';\r\nconst ColorContext = createContext();\r\n\r\nexport default ColorContext;\r\n\r\n\r\n// useContextDemo.js\r\nimport React from 'react';\r\nimport DemoOne from './demoOne';\r\nimport ColorContext from './colorContext'\r\n\r\nconst UseContextDemo = () => {\r\n  return (\r\n    // 此处的value才是子孙组件读取到的值\r\n    <ColorContext.Provider value=\"red\">\r\n      <DemoOne />\r\n    </ColorContext.Provider>\r\n  );\r\n}\r\n\r\nexport default UseContextDemo;\r\n\r\n// demoOne.js\r\nimport React from 'react';\r\nimport DemoTwo from './demoTwo';\r\n\r\nconst DemoOne = () => {\r\n  return (\r\n    <DemoTwo />\r\n  );\r\n}\r\n\r\nexport default DemoOne;\r\n\r\n// demoTwo.js\r\nimport React, { useContext } from 'react';\r\nimport ColorContext from './colorContext'\r\n\r\nconst DemoTwo = () => {\r\n  const color = useContext(ColorContext);\r\n  return (\r\n    <div style={{ color }}>\r\n      {color}\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default DemoTwo;\r\n```\r\n## useReducer\r\n> useReducer接受的第一个参数是一个函数，我们可以认为它就是一个reducer，reducer的参数就是常规reducer里面的state和action，返回改变后的state，useReducer第二个参数为state的初始值。返回一个数组，数组的第一项就是更新之后state的值，第二个参数是派发更新的dispatch函数。\r\n\r\n- dispatch调用后，状态更新是异步的，因此立刻读取状态仍是旧的。\r\n- React对dispatch有一个优化机制：如果dispatch触发更新前后的值相等(使用Object.is判断)，出于性能考虑React不会进行重新渲染。\r\n- 在reducer里面更新对象和数组的状态，需要创建一个新的对象或数组，而不是在原对象和数组上修改，这一点和useState是一样的。\r\n```\r\nimport React, { useReducer } from 'react';\r\n\r\nconst UseReducerDemo = () => {\r\n  /* count为更新后的state值,  dispatchCount 为当前的派发函数 */\r\n  const [count, dispatchCount] = useReducer((state, action) => {\r\n    const { payload, type } = action\r\n    /* return的值为新的state */\r\n    switch(type) {\r\n      case 'add':\r\n\t      return state + 1\r\n      case 'sub':\r\n        return state - 1 \r\n      case 'reset':\r\n        return payload       \r\n    }\r\n    return state\r\n  }, 0)\r\n\r\n  return (\r\n    <div>\r\n     <div>{ count }</div>\r\n      <button onClick={() => dispatchCount({ type:'add' })}>add</button>\r\n      <button onClick={() => dispatchCount({ type:'sub' })}>sub</button>\r\n      <button onClick={() => dispatchCount({ type:'reset', payload: 123 })}>reset</button>\r\n    </div>\r\n  )\r\n}\r\n\r\nexport default UseReducerDemo\r\n```\r\n## Capture Value(函数组件执行，就会形成一个闭包)\r\n- 每次render的内容都会形成一个快照并保留下来，当re-render的时候就形成了n个render状态，而每个render状态都拥有自己固定不变的props和state。\r\n- useState中定义的变量在每一次render的时候都是一个固定的常量，只是不同的render时机，对应的常量的值可能不同。\r\n- 每次render都有自己的事件处理\r\n> 如下示例中如果将console的值由内部的状态改为父组件传过来的props，如果在3秒内父组件的props发生变化，console的值还是原来的值，不是最新的值。但是class形式组件是最新的值，虽然props是不可变的，但是this在class形式组件中是可变的，因此this.props形式的调用每次都访问最新的props。而函数组件不存在this.props的语法，因此props在一次render中时固定不变的。\r\n\r\n```\r\nimport React, { useState } from 'react';\r\n\r\nconst CaptureValueDemo = () => {\r\n  const [num, setNum] = useState(0);\r\n\r\n  const log = () => {\r\n    setTimeout(() => {\r\n      // 每一次console的值都是执行setNum之前的值\r\n      // 在log函数执行的那个render中，num的值还是执行setNum之前的值\r\n      // 执行setNum()之后会交由一个全新的render中，新的render中不会执行log函数。\r\n      // 而三秒后执行的内容是由setNum前的那个render执行的，所以console的num自然也是setNum前的那个render中的num值\r\n      // num、log都拥有Capture Value特性\r\n      console.log(num);\r\n    }, 3000);\r\n  };\r\n\r\n  return (\r\n    <div>\r\n      {num}\r\n      <button\r\n        onClick={() => {\r\n          setNum(num + 1);\r\n          log();\r\n        }}\r\n      >\r\n        click\r\n      </button>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default CaptureValueDemo;\r\n```\r\n- useRef没有Capture Value特性。ref在所有的render中保持着唯一引用，因此所有对ref的赋值或取值，拿到的都是一个最终状态，不会在每个render间存在隔离。\r\n- useEffect也一样具有Capture Value的特性\r\n```\r\n// Capture Value特性\r\nconst [num, setNum] = useState(0);\r\n\r\nuseEffect(() => {\r\n  // 由于useEffect的Capture Value的特性，拿到的num值永远是初始化的0。\r\n  // setInterval永远在num为0基础上加一，setInterval在一直循环但是后续的setNum没有什么作用\r\n  const intervalId = setInterval(() => {\r\n    setNum(num + 1);\r\n  }, 1000);\r\n  return () => clearInterval(intervalId);\r\n}, []);\r\n\r\nreturn (\r\n  <div>{num}</div>\r\n);\r\n\r\n// 监听状态\r\nconst [num, setNum] = useState(0);\r\n\r\nuseEffect(() => {\r\n  // useEffect监听num的变化可以拿到了最新的num。\r\n  // 但是计时器不准了，因为每次count变化时都会销毁并重新计时。计时器频繁的挂载和销毁 定时器带来了一定性能负担。\r\n  const intervalId = setInterval(() => {\r\n    setNum(num + 1);\r\n  }, 1000);\r\n  return () => clearInterval(intervalId); \r\n}, [num]);\r\n\r\nreturn (\r\n  <div>{num}</div>\r\n);\r\n\r\n// 不依赖外部变量(依赖useState的回调形式进行更新操作)\r\nconst [num, setNum] = useState(0);\r\n\r\nuseEffect(() => {\r\n  const intervalId = setInterval(() => {\r\n    setNum(oldNum => oldNum + 1);\r\n  }, 1000);\r\n  return () => clearInterval(intervalId);\r\n}, []);\r\n\r\nreturn (\r\n  <div>{num}</div>\r\n);\r\n```\r\n## [hooks 闭包问题](https://juejin.cn/post/7051535411042058271)\r\n> 每一个Function的执行都有与之相应的Scope，对于面向对象来说，this引用即是连接了所有Scope的Context(当然前提是在同一个Class下)，在React Hooks中每一次的render由彼时的State决定，render完成Context即刷新。useRef是可以横跨多次render生成的Scope，它能保留下已执行的渲染逻辑，却也能使已渲染的Context 得不到释放，如果说this引用是面向对象中最主要的副作用，那么useRef亦同。\r\n\r\n\r\n- [延迟调用会存在闭包问题，使用useRef会避免此问题。](https://juejin.cn/post/7046358484610187277)\r\n> useRef仅在Mount时期初始化对象，而Update时期返回Mount时期的结果(memoizedState)。这意味着一次完整的生命周期中，useRef​保留的引用始终不会改变。\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## hooks中使用防抖节流\r\n### class形式组件中使用形式\r\n```\r\nimport React, { Component } from \"react\";\r\nimport { debounce } from \"lodash\";\r\n\r\nexport default class Home extends Component {\r\n  state = {\r\n    value: ''\r\n  }\r\n\r\n  debounceSearch = debounce((value) => {\r\n    console.log(value);\r\n  }, 600);\r\n\r\n  onChange = (e) => {\r\n    const value = e.target.value;\r\n    this.setState({\r\n      value\r\n    });\r\n    this.debounceSearch(value);\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <input onChange={this.onChange} value={this.state.value} />\r\n    )\r\n  }\r\n}\r\n```\r\n### 沿用class的使用形式在hooks中使用\r\n- debounceSearch方法没有达到防抖的效果。\r\n- debounceSearch函数每次调用前都执行了setValue导致重新渲染，这使得每一次调用的debounceSearch都被重建了，每次调用的debounceSearch都是一个新函数，并且失去了之前的记忆，所以达不到防抖的效果。\r\n```\r\nimport React, { useState } from \"react\";\r\nimport { debounce } from \"lodash\";\r\n\r\nconst Home = () => {\r\n  const [value, setValue] = useState('');\r\n\r\n  const debounceSearch = debounce((value) => {\r\n    console.log(value);\r\n  }, 600);\r\n\r\n  const onChange = (e) => {\r\n    const inputValue = e.target.value;\r\n    setValue(inputValue);\r\n    debounceSearch(inputValue);\r\n  }\r\n\r\n  return (\r\n    <input onChange={onChange} value={value} />\r\n  )\r\n}\r\n\r\nexport default Home;\r\n```\r\n### 缓存debounceSearch函数，避免每一次重新渲染时debounceSearch函数重建\r\n- 使用useCallback\r\n```\r\nconst debounceSearch = useCallback(\r\n  debounce((value) => {\r\n    console.log(value);\r\n  }, 600),\r\n[])\r\n```\r\n- 使用useRef\r\n```\r\nconst debounceSearch = useRef(\r\n  debounce((value) => {\r\n    console.log(value);\r\n  }, 600)\r\n).current\r\n```\r\n- 使用useMemo\r\n```\r\nconst debounceSearch = useMemo(() => {\r\n  return debounce((value) => {\r\n    console.log(value);\r\n  }, 600)\r\n}, [])\r\n```\r\n### useDebounce\r\n```\r\nimport { useCallback } from 'react';\r\nimport { debounce } from 'lodash';\r\n\r\nexport const useDebounce = (fun, deps = [], time = 600) => useCallback(debounce(fun, time), deps);\r\n```\r\n### useThrottle\r\n```\r\nimport { useCallback } from 'react';\r\nimport { throttle } from 'lodash';\r\n\r\nexport const useThrottle = (fun, deps = [], time = 600) => useCallback(throttle(fun, time), deps);\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## hooks的作用\r\n1. 函数组件中可以有状态和生命周期。\r\n2. 更好的状态复用。可以把组件的状态逻辑抽离成自定义hooks，从而实现状态逻辑在不同组件之间复用。\r\n3. 比class组件更易用，没有了class组件的this绑定问题。\r\n4. 友好的渐进式，依然可以在项目里一边写class组件，一边写hooks组件，可以一点点深入使用。\r\n### hooks的局限\r\n1. hooks在使用层面有着严格的规则约束，不能写在判断语句中。\r\n2. 函数组件给了我们一定程度的自由，却也对开发者的水平提出了更高的要求(闭包的问题)。\r\n3. hooks还不能完整的为函数组件提供类组件的能力。\r\n### hooks不能写在判断语句中\r\n- hooks信息都会以链表的形式保存在current fiber的memoizedState中。\r\n- 更新渲染时每次构建对应的是函数组件的workingProgress fiber时，都会从对应的current fiber中延续这个以链表结构存储的hooks信息。如果有hooks写在判断语句中那么就会破坏延续的顺序，所以hooks不能写在判断语句中。\r\n### mixin(状态复用)\r\n- mixins虽然提供了状态复用的能力，但弊端太多。\r\n```\r\n// 混入文件：name-mixin.js\r\nexport default {\r\n  data() {\r\n    return {\r\n      name: genRandomName() // 假装它能生成随机的名字\r\n    }\r\n  },\r\n  methods: {\r\n    setName(name) {\r\n      this.name = name\r\n    }\r\n  }\r\n}\r\n\r\n// 组件：my-component.vue\r\n<template>\r\n  <div>{{ name }}</div>\r\n<template>\r\n<script>\r\n  import nameMixin from './name-mixin';\r\n  export default {\r\n    mixins: [nameMixin],\r\n    // 通过mixins, 你可以直接获得 nameMixin 中所定义的状态、方法、生命周期中的事件等\r\n    mounted() {\r\n      setTimeout(() => {\r\n        this.setName('Tom')\r\n      }, 3000)\r\n    }\r\n  }\r\n<script>\r\n```\r\n- 难以追溯的方法与属性\r\n```\r\nexport default {\r\n  mixins: [ a, b, c, d, e, f, g ], // 表示它混入了很多能力\r\n  mounted() {\r\n    console.log(this.name)\r\n    // 这个 this.name 来自于谁？\r\n  }\r\n}\r\n```\r\n- 覆盖、同名问题\r\n> 当同时混入mixin-a.js和mixin-b.js以同时获得它们能力的时候，当这两个mixin都定义了this.name作为属性时就会有问题\r\n\r\n- 重复使用时，需要扩展代码无法像hooks一样定义别名。\r\n### renderProps渲染属性\r\n> 渲染属性指的是使用一个值为函数的props来传递需要动态渲染的节点或组件。\r\n\r\n### 高阶组件\r\n> 一个函数接受一个组件作为参数，经过一系列加工后，最后返回一个新的组件。\r\n\r\n### hooks相对的好处\r\n> 代码以及组件的嵌套层级不会很复杂。\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## hooks模拟class生命周期\r\n### componentDidMount\r\n```\r\nuseEffect(() => {\r\n\r\n}, []);\r\n```\r\n### componentDidUpdate\r\n```\r\nuseEffect(() => {\r\n  // 所有更新都会执行\r\n\r\n});\r\n\r\nuseEffect(() => {\r\n  // 依赖改变时才会执行\r\n\r\n}, [dependencies]);\r\n```\r\n### shouldComponentUpdate\r\n```\r\nReact.memo(Component, (prevProps, nextProps) => {\r\n  // 返回false组件会更新，返回true组件不更新\r\n})\r\n```\r\n### componentWillUnmount\r\n```\r\nuseEffect(() => {\r\n  return () => {\r\n\r\n  }\r\n}, []);\r\n```\r\n### componentWillMount\r\n- 使用useState\r\n```\r\nconst useComponentWillMount = (fun) => {\r\n  const [hasRendered, setHasRendered] = useState(false);\r\n\r\n  useEffect(() => setHasRendered(true), [hasRendered]);\r\n\r\n  if (!hasRendered) {\r\n    fun();\r\n  }\r\n}\r\n```\r\n- 使用useRef\r\n```\r\nconst useComponentWillMount = (fun) => {\r\n  const hasMounted = useRef(false);\r\n\r\n  if (!hasMounted.current) {\r\n    (() => {\r\n      hasMounted.current = true;\r\n      fun();\r\n    })();\r\n  }\r\n  \r\n  return null;\r\n}\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## hooks生命周期\r\n### 挂载\r\n1. 首先react运行(惰性初始化程序)\r\n2. 第一次渲染(render)\r\n3. React更新DOM\r\n4. 运行LayoutEffects\r\n5. 浏览器绘制屏幕\r\n6. 运行Effects\r\n### 更新\r\n1. render\r\n2. React更新DOM\r\n3. 清除LayoutEffects\r\n4. 运行LayoutEffects\r\n5. 浏览器绘制屏幕hooks生命周期\r\n6. 清理Effects\r\n7. 运行Effects\r\n### 卸载\r\n1. 清理LayoutEffects\r\n2. 清理Effects\r\n### 挂载和更新之间的主要区别\r\n- 惰性初始化仅在挂载阶段\r\n- 挂载阶段不存在清理工作\r\n\r\n![hooks生命周期](./img/hooks%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png)\r\n"},function(r,n,e){"use strict";e.r(n),n.default='## JSX\r\n- 只要使用了JSX就需要引用React(React17版本之前)，因为JSX本质就是React.createElement。\r\n- JSX只是为React.createElement方法提供的语法糖，所有的JSX代码最后都会转换成React.createElement(...)，最后再转化成常规的JS对象，Babel帮助我们完成了这个转换的过程。\r\n- 在编译时会判断JSX中组件的首字母，当首字母为小写时，其被认定为原生DOM标签，React.createElement的第一个变量被编译为字符串。当首字母为大写时，其被认定为自定义组件，React.createElement的第一个变量被编译为对象。\r\n- React.createElement函数对key和ref等特殊的props进行处理，并获取defaultProps对默认props进行赋值，并且对传入的子节点进行处理，最终构造成一个ReactElement对象(虚拟DOM)。\r\n- ReactDOM.render将生成好的虚拟DOM渲染到指定容器上，最终转换为真实DOM。\r\n### JSX转换为React.createElement\r\n```\r\n// 实际开发中使用JSX来创建虚拟dom\r\nconst element = (\r\n  <div id=\'foo\'>\r\n    <a>bar</a>\r\n    <b></b>\r\n  </div>\r\n)\r\n\r\n// 使用React.createElement创建虚拟dom\r\nconst element = React.createElement(\r\n  "div", \r\n  { id: "foo" },\r\n  React.createElement("a", null, "bar"),\r\n  React.createElement("b", null)\r\n);\r\n```\r\n### JSX转换成真实DOM的过程\r\n- JSX代码编写，使用JSX语法编写React组件的界面结构。JSX允许使用类似HTML的标记来描述UI层次结构。\r\n```\r\nconst element = <div>Hello, React!</div>;\r\n```\r\n- Babel转换，JSX语法并不是浏览器原生支持的，所以需要使用工具将JSX代码转换为浏览器可识别的JavaScript代码。通常会使用Babel这样的工具来进行转换。\r\n```\r\nconst element = React.createElement("div", null, "Hello, React!");\r\n```\r\n- 创建虚拟DOM，在转换后的JavaScript代码中，React.createElement函数会创建一个称为虚拟DOM的JavaScript对象。虚拟DOM是React内部用来表示界面结构的一种轻量级表示形式。\r\n- 虚拟DOM对比，当状态发生变化导致界面需要更新时，React会使用虚拟DOM来比较前后两次状态的差异。这个过程被称为协调。\r\n- 生成真实DOM更新，通过协调过程React能够计算出哪些部分的DOM需要被更新。然后针对实际需要更新的部分生成一系列真实DOM操作，然后将其应用于浏览器的真实DOM上。React会尽量最小化真实DOM操作的次数，以提高性能。\r\n### JSX与JS的区别\r\n- JS可以被打包工具直接编译不需要额外转换，JSX需要通过babel编译，它是React.createElement的语法糖，使用JSX等价于使用React.createElement。\r\n- JSX是JS的语法扩展，允许在html中写JS。JS是原生写法，需要通过script标签引入。\r\n### Fragment\r\n- Fragment碎片概念，能够让一个组件返回多个元素，React.Fragment等价于空标签。\r\n- React.Fragment实际上是没有节点的，会被编译为React.createElement(React.Fragment, null, "")这样的形式。\r\n- Fragment允许有key，而空标签无法添加key。\r\n### React中元素和组件的区别\r\n- react组件有类组件、函数组件。\r\n- react元素是通过JSX创建的。\r\n### 由于JSX提前要被Babel编译，所以JSX是不能在运行时动态选择类型的\r\n```\r\n// 错误\r\nfunction App(props) {\r\n  return <components[props.type] data={props.data} />;\r\n}\r\n\r\n// 正确\r\nfunction App(props) {\r\n  const CurrenCom = components[props.type];\r\n  return <CurrenCom data={props.data} />;\r\n}\r\n```\r\n'},function(r,n,e){"use strict";e.r(n),n.default='## jsx转换的变化\r\n### React16版本及之前\r\n- 使用jsx语法必须显式的将React引入。\r\n- 在React16版本及之前，应用程序通过@babel/preset-react将jsx语法转换为React.createElement的js代码，因此需要显式将React引入才能正常调用createElement方法。\r\n- babel编译前\r\n```\r\nexport default class App extends Component {\r\n  render() {\r\n    return <div>dyx</div>\r\n  }\r\n}\r\n\r\nReactDom.render(<App />, document.getElementById(\'root\'));\r\n```\r\n- babel编译后\r\n```\r\nexport default class App extends Component {\r\n  render() {\r\n    return /*#__PURE__*/React.createElement("div", null, "dyx");\r\n  }\r\n}\r\n\r\nReactDom.render( /*#__PURE__*/React.createElement(App, null), document.getElementById(\'root\'));\r\n```\r\n### React17版本及之后\r\n- 只使用jsx语法不使用其它React提供的api，可以不引入React应用程序依然能够正常运行。\r\n- 在React17版本及之后，官方与babel进行了合作，直接通过react/jsx-runtime对jsx语法进行了新的转换而不依赖React.createElement，转换的结果便是可直接供ReactDOM.render使用的ReactElement对象。\r\n- 新的jsx转换不会将jsx转换为React.createElement，而是自动从React的package中引入新的入口函数(jsx方法)并调用。\r\n- babel编译前\r\n```\r\nexport default class App extends Component {\r\n  render() {\r\n    return <div>dyx</div>\r\n  }\r\n}\r\n\r\nReactDom.render(<App />, document.getElementById(\'root\'));\r\n```\r\n- babel编译后\r\n```\r\nimport { jsx as _jsx } from "react/jsx-runtime";\r\nexport default class App extends Component {\r\n  render() {\r\n    return /*#__PURE__*/_jsx("div", {\r\n      children: "dyx"\r\n    });\r\n  }\r\n}\r\n\r\nReactDom.render( /*#__PURE__*/_jsx(App, {}), document.getElementById(\'root\'));\r\n```\r\n### 升级至新的jsx转化\r\n- 更新至支持新的jsx转换的React版本(v17及以上)\r\n- 修改babel配置\r\n```\r\n// 如果使用的是@babel/preset-react\r\n{\r\n  "presets": [\r\n    [\r\n      "@babel/preset-react",\r\n      {\r\n        "runtime": "automatic"\r\n      }\r\n    ]\r\n  ]\r\n}\r\n\r\n// 如果使用的是@babel/plugin-transform-react-jsx\r\n{\r\n  "plugins": [\r\n    [\r\n      "@babel/plugin-transform-react-jsx",\r\n      {\r\n        "runtime": "automatic"\r\n      }\r\n    ]\r\n  ]\r\n}\r\n```\r\n- 修改tsconfig.json配置\r\n```\r\n{\r\n  "compilerOptions": {\r\n    // "jsx": "react",\r\n    "jsx": "react-jsx",\r\n  },\r\n}\r\n```\r\n- 需要将\'React\' must be in scope when using JSX这条判断规则禁用掉，在eslint配置文件中添加plugin即可。\r\n```\r\n\'plugin:react/jsx-runtime\'\r\n```\r\n### jsx方法和createElement的区别\r\n- createElement函数在所有React版本中可用，而jsx函数仅在React 17及更高版本中支持。\r\n- jsx函数将子元素作为属性children传递，而createElement函数将子元素作为额外的参数传递。同时子元素上的key值在jsx函数中也会以第三个参数的形式传递，而在createElement函数中，则是存在于config第二个参数中。\r\n```\r\nconst element = <div className="app" key="appKey">Hello, world!</div>;\r\n\r\n// createElement函数\r\nReact.createElement("div", { className: "app", key: "appKey" }, "Hello, world!");\r\n\r\n// jsx函数\r\nimport { jsx as _jsx } from "react/jsx-runtime";\r\n\r\n_jsx("div", { className: "app", children: "Hello, world!" }, "appKey");\r\n```'},function(r,n,e){"use strict";e.r(n),n.default="## key\r\n- key只是针对同一层级的节点进行了diff比较优化，而跨层级的节点互相之间的key值没有影响。\r\n- 建议不要用遍历的index作为节点的key属性值。\r\n- key值在比较之前都会被执行toString()操作，所以不要使用object类型的值作为key。\r\n### key的作用\r\n> 当同一层级的某个节点添加了对于其它同级节点唯一的key属性，当它在当前层级的位置发生了变化后，react Diff算法通过新旧节点比较后，如果发现了key值相同的新旧节点，就会执行移动操作复用之前的真实节点(若虚拟DOM中的内容没变，则直接使用之前的真实DOM，若虚拟DOM中的内容变了，则生成新的真实DOM，随后替换掉页面中之前的真实DOM)，而不会执行原策略的删除旧节点，创建新节点的操作。这无疑大大提高了React性能和渲染效率。\r\n\r\n### key的具体执行过程\r\n> 对新集合中的节点进行循环遍历，通过唯一的key判断新旧集合中是否存在相同的节点，如果存在相同节点，判断当前节点在旧集合中的位置与lastIndex(类似浮标)进行判断如果当前节点在旧集合中的位置(index)小于lastIndex则进行移动操作，否则不执行移动操作操作。\r\n\r\n#### 同一层级的所有节点只发生了位置变化： A、B、C、D 更新为 B、A、D、C\r\n1. B在新集合中 lastIndex(类似浮标) = 0, 在旧集合中 index = 1，index > lastIndex 就认为 B 对于集合中其他元素位置无影响，不进行移动，之后lastIndex = max(index, lastIndex) = 1\r\n2. A在旧集合中 index = 0， 此时 lastIndex = 1, 满足 index < lastIndex, 则对A进行移动操作，此时 lastIndex = max(index, lastIndex) = 1\r\n3. D和B操作相同，同第一步，不进行移动，此时lastIndex = max(index, lastIndex) = 3\r\n4. C和A操作相同，同第二步，进行移动，此时lastIndex = max(index, lastIndex) = 3\r\n#### 同一层级的所有节点发生了节点增删和节点位置变化： A、B、C、D 更新为 B、E、C、A\r\n1. B在新集合中 lastIndex(类似浮标) = 0, 在旧集合中 index = 1，index > lastIndex 就认为 B 对于集合中其他元素位置无影响，不进行移动，之后lastIndex = max(index, lastIndex) = 1\r\n2. 新集合中有E，发现旧集合中不存在E，在 lastIndex处创建E，lastIndex++\r\n3. 在旧集合中取到C，C不移动，lastIndex=2\r\n4. 在旧集合中取到A，A移动到新集合中的位置，lastIndex=2\r\n5. 完成新集合中所有节点diff后，对旧集合进行循环遍历，寻找新集合中不存在但旧集合中有的节点(此例中为D)，删除D节点。\r\n### 使用index作为key的问题\r\n> 遍历数组的时候使用index作为key，在只涉及到数据展示的时候并不会出现什么问题，但是当我们在操作数据时候，很容易出现问题。\r\n\r\n- 删除某一项\r\n> 3个input输入框依次输入随机内容，使用 index 作为 key 的时候，点击删除第一项按钮，左侧文字正确改变，但是input的内容显示不对，input输入框最后一项没了。当我们使用 index 作为 key 时，此时 key 为 0、1、2，删掉第一项后 key 变为 0、1，此时 react 在执行 diff 算法过程中，key = 0 存在，只需要更新子节点的值，所以左侧的 name 成功改变，而 input 的值非受控不会更新。同时在对比计算中少了 key = 2 这项，删除了最后一项。当我们使每一项的值作为 key 时，此时 key 为 name1、name2、name3，删掉第一项后 key 变为 name2、name3，根据 react 的 diff 算法，react 计算出删除一个节点即可。\r\n\r\n```\r\nconst Test = () => {\r\n  const [data, setData] = useState(['name1', 'name2', 'name3']);\r\n\r\n  const deleteFirstItem = () => {\r\n    const newData = [...data];\r\n    newData.shift();\r\n    setData(newData);\r\n  }\r\n\r\n  return (\r\n    <div>\r\n      {data.map((item, index) => {\r\n        return (\r\n          <div key={index}>\r\n            {item}\r\n            <input type=\"value\" />\r\n          </div>\r\n        );\r\n      })}\r\n      <button onClick={deleteFirstItem}>删除第一项</button>\r\n    </div>\r\n  )\r\n}\r\n```\r\n- 修改顺序\r\n> 效果类似于上述的删除第一项，左侧文字正常改变，input的值不会发生变化。\r\n\r\n```\r\nconst Test = () => {\r\n  const [data, setData] = useState(['name1', 'name2', 'name3']);\r\n\r\n  const reverse = () => {\r\n    setData(['name3', 'name2', 'name1']);\r\n  }\r\n\r\n  return (\r\n    <div>\r\n      {data.map((item, index) => {\r\n        return (\r\n          <div key={index}>\r\n            {item}\r\n            <input type=\"value\" />\r\n          </div>\r\n        );\r\n      })}\r\n      <button onClick={reverse}>修改顺序</button>\r\n    </div>\r\n  )\r\n}\r\n```\r\n### key机制的缺点\r\n> A、B、C、D 更新为 D、A、B、C，与旧集合相比只有 D 节点移动，而 A、B、C 仍然保持原有的顺序，理论上 diff 应该只需对 D 执行移动操作，然而由于 D 在旧集合中的位置是最大的，导致其他节点的 index < lastIndex，造成 D 没有执行移动操作，而是 A、B、C 全部移动到 D 节点后面的现象。尽量减少类似将最后一个节点移动到列表首部的操作。当节点数量过大或更新操作过于频繁时，这在一定程度上会影响 React 的渲染性能。"},function(r,n,e){"use strict";e.r(n),n.default="## key的作用\r\n- key相同是告诉React这二者之间需要进行比较，而不是告诉React这二者相同。\r\n- key用来作为唯一标识，便于新旧虚拟DOM进行比较。\r\n### 有key时的渲染过程\r\n- 旧虚拟DOM中找到了与新虚拟DOM相同的key\r\n  1. 若虚拟DOM中内容没变，直接复用真实DOM。\r\n  2. 若虚拟DOM中内容变了, 则生成新的真实DOM，随后替换掉页面中之前的真实DOM。\r\n- 旧虚拟DOM中未找到与新虚拟DOM相同的key\r\n  1. 根据数据创建新的真实DOM，随后渲染到到页面。\r\n- 旧虚拟DOM中存在的key未在新虚拟DOM中找到\r\n  1. 删除对应虚拟DOM对应的真实DOM。\r\n### key在diff过程的优化\r\n- 在diff算法中如果新旧虚拟DOM的key相同时依然需进行内容的diff，相对于没有key的形式效率提升不明显。\r\n- 在diff算法中如果新虚拟DOM的key在旧虚拟DOM中不存在，则可直接标记为新建，无需进行内容的diff，提升效率。\r\n### key在渲染真实DOM过程的优化\r\n- 通过标记key的方式，React可以直接复用真实DOM节点，优化效率。\r\n- 当列表重新排序后，如果没有key标识时真实DOM需要大量的删除重建或者更新，有key的标识后可以复用真实DOM变为移动真实DOM提升效率。\r\n### React组件的key修改之后会重新渲染。"},function(r,n,e){"use strict";e.r(n),n.default="## re-render\r\n> 已经在页面上渲染的组件进行第二次或后续多次渲染。\r\n\r\n### State更改\r\n- 当组件的State发生变化时，组件会重新渲染。\r\n### Props更改\r\n- 当组件的Props发生变化时，组件会重新渲染。\r\n### 父组件重新渲染\r\n- 如果组件的父组件重新渲染，组件也会重新渲染。\r\n- 子组件的重新渲染不会触发父组件的重新渲染。\r\n### 组件依赖的上下文(context)发生变化\r\n- 如果上下文(context)的值发生变化，React会自动重新渲染订阅了该上下文(context)的所有组件。\r\n### forceUpdate强制更新\r\n### 组件依赖的自定义hooks发生变化\r\n- 自定义hooks发生的一切都 “属于” 使用它的组件。\r\n- 组件使用自定义hooks可以理解为组件只是调用了自定义hooks中的useState和useEffect，所以自定义hooks中的状态改变，使用自定义hooks的组件也会重新render。\r\n- 自定义hooks内部的状态变化，组件会重新渲染。\r\n- 如果自定义hooks有依赖的上下文(context)，并且依赖的上下文(context)值发生变化，组件会重新渲染。"},function(r,n,e){"use strict";e.r(n),n.default="## react-router4 Prompt实现路由跳转前的提示\r\n[Demo地址](https://github.com/dyxweb/RouterPrompt)\r\n> Prompt组件是react-router4提供的组件，主要作用于路由跳转前的阻止、提示等操作，常使用于提示用户未保存等提示。\r\n\r\n### when\r\n> 当Prompt的when属性为true时，渲染Prompt该组件。\r\n\r\n### message\r\n> 阻止时的提示框的文字内容(string)，也可以使用函数形式的属性值，动态返回message值，也可以通过函数形式实现自定义提示组件。\r\n\r\n### 简单形式\r\n> 默认的Prompt提示样式。\r\n\r\n```\r\n/**\r\n * 使用Prompt的默认提示框阻止跳转\r\n */\r\nimport React, { Component } from 'react';\r\nimport { Prompt, Link } from 'react-router-dom';\r\n\r\nexport default class DefaultPrompt extends Component {\r\n  render() {\r\n    return (\r\n      <div>\r\n        <Link to=\"/function/message\">跳转到function形式的message的页面</Link>\r\n        {/* when为true时表示阻止默认的跳转行为 */}\r\n        <Prompt when={true} message='确认离开此页面？' />\r\n        <h1>\r\n          使用Prompt的默认提示框阻止跳转\r\n        </h1>\r\n      </div>\r\n    )\r\n  }\r\n}\r\n```\r\n### 使用Prompt的message的function形式实现自定义的提示样式\r\n> 可以实现自定义样式，如使用常用UI组件库的弹窗提示等，只能作用于当前组件的跳转时的自定义样式，优先级高于Router的getUserConfirmation方法。\r\n\r\n```\r\n/**\r\n * 使用Prompt的message的function形式实现自定义的提示样式\r\n */\r\nimport React, { Component } from 'react';\r\nimport { Prompt, Link } from 'react-router-dom';\r\nimport { Modal } from 'antd';\r\n\r\nexport default class FunctionMessage extends Component {\r\n  state = {\r\n    isBlock: true, // 是否阻止离开此页面\r\n  };\r\n\r\n  // 确认离开时的方法\r\n  onConfirmLeave = pathname => {\r\n    // 将isBlock设置为false，不再阻止跳转行为，并手动进行路由跳转\r\n    this.setState({\r\n      isBlock: false,\r\n    }, () => this.props.history.push(pathname));\r\n  }\r\n\r\n  render() {\r\n    const { isBlock } = this.state;\r\n    return (\r\n      <div>\r\n        <Link to=\"/default/prompt\">跳转到默认提示的页面</Link>\r\n        <Prompt\r\n          when={isBlock}\r\n          message={location => {\r\n            Modal.confirm({\r\n              title: '确认离开此页面？',\r\n              onOk: () => this.onConfirmLeave(location),\r\n            })\r\n            return false;\r\n          }}\r\n        />\r\n        <h1>\r\n          使用Message的function的用法实现自定义阻止效果\r\n        </h1>\r\n      </div>\r\n    )\r\n  }\r\n}\r\n```\r\n### 使用Router的getUserConfirmation实现自定义提示样式\r\n> 可以作用于所有使用Prompt组件的路由页面。\r\n\r\n```\r\nimport React, { Component } from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport {BrowserRouter as Router, Route, Switch, Redirect} from 'react-router-dom';\r\nimport { Modal } from 'antd';\r\nimport FunctionMessage from './FunctionMessage';\r\nimport DefaultPrompt from './DefaultPrompt';\r\n\r\nexport default class App extends Component {\r\n  // 提示框的确认的方法(移除挂载自定义提示组件的dom)\r\n  onOk = callback => {\r\n    callback(true);\r\n    const routerDom = document.getElementById('router-dom');\r\n    document.getElementsByTagName('body')[0].removeChild(routerDom);\r\n    ReactDOM.unmountComponentAtNode(routerDom);\r\n  };\r\n\r\n  // 提示框的取消的方法(移除挂载自定义提示组件的dom)\r\n  onCancel = callback => {\r\n    callback(false);\r\n    const routerDom = document.getElementById('router-dom');\r\n    document.getElementsByTagName('body')[0].removeChild(routerDom);\r\n    ReactDOM.unmountComponentAtNode(routerDom);\r\n  };\r\n\r\n  // getUserConfirmation自定义提示，message就是对应路由页面的message信息\r\n  getConfirmation = (message, callback) => {\r\n    // 在body下添加新的节点用于挂载自定义提示组件\r\n    const routerDom = document.createElement('div');\r\n    routerDom.setAttribute('id', 'router-dom');\r\n    document.getElementsByTagName('body')[0].appendChild(routerDom);\r\n    const ConFirmComponent = () => (\r\n      <Modal\r\n        title=\"使用getUserConfirmation实现自定义离开样式\"\r\n        visible={true}\r\n        onOk={() => this.onOk(callback)}\r\n        onCancel={() => this.onCancel(callback)}\r\n      >\r\n        {message}\r\n      </Modal>\r\n    )\r\n    ReactDOM.render(\r\n      <ConFirmComponent />,\r\n      document.getElementById('router-dom')\r\n    )\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <Router getUserConfirmation={this.getConfirmation}>\r\n        <Switch>\r\n          <Route path=\"/default/prompt\" component={DefaultPrompt} />\r\n          <Route path=\"/function/message\" component={FunctionMessage} />\r\n          <Redirect to=\"/default/prompt\" />\r\n        </Switch>\r\n      </Router>\r\n    )\r\n  }\r\n};\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## react-router6组件外部路由跳转\r\n\r\n### 使用unstable_HistoryRouter\r\n- 自定义history\r\n```\r\nimport { createBrowserHistory } from \"history\";\r\n\r\nexport default createBrowserHistory();\r\n```\r\n- 使用HistoryRouter传递自定义history\r\n```\r\nimport { unstable_HistoryRouter as HistoryRouter, Routes } from 'react-router-dom';\r\nimport customHistory from '@/utils/history';\r\n\r\n<HistoryRouter history={customHistory}>\r\n  <Routes>\r\n    ...\r\n  </Routes>\r\n</HistoryRouter>\r\n```\r\n- 组件外部使用自定义history路由跳转\r\n```\r\nimport customHistory from '@/utils/history';\r\nhistory.push('/login');\r\n```\r\n### 使用CustomRouter\r\n- 自定义history\r\n```\r\nimport { createBrowserHistory } from \"history\";\r\n\r\nexport default createBrowserHistory();\r\n```\r\n- 自定义CustomRouter\r\n```\r\n/**\r\n * 自定义Router(支持组件外部使用history跳转路由)\r\n */\r\nimport React, { useLayoutEffect, useState } from \"react\";\r\nimport { BrowserRouterProps, Router } from \"react-router-dom\";\r\nimport { BrowserHistory } from \"history\";\r\nimport customHistory from \"@/utils/history\";\r\n\r\ninterface Props extends BrowserRouterProps {\r\n  history: BrowserHistory;\r\n}\r\nconst CustomRouter = ({ basename, history, children }: Props) => {\r\n  const [state, setState] = useState({\r\n    action: history.action,\r\n    location: history.location,\r\n  });\r\n  useLayoutEffect(() => history.listen(setState), [history]);\r\n\r\n  return (\r\n    <Router\r\n      navigator={customHistory}\r\n      location={state.location}\r\n      navigationType={state.action}\r\n      basename={basename}\r\n    >\r\n      {children}\r\n    </Router>\r\n  );\r\n};\r\n\r\nexport default CustomRouter;\r\n```\r\n- 使用CustomRouter\r\n```\r\nimport { Routes } from 'react-router-dom';\r\nimport customHistory from '@/utils/history';\r\n\r\n<CustomRouter history={customHistory}>\r\n  <Routes>\r\n    ...\r\n  </Routes>\r\n</CustomRouter>\r\n```\r\n- 组件外部使用自定义history路由跳转\r\n```\r\nimport customHistory from '@/utils/history';\r\ncustomHistory.push('/login');\r\n```\r\n### 组件内部跳转\r\n```\r\nimport { useNavigate } from 'react-router-dom';\r\nconst navigate = useNavigate();\r\n\r\n// 跳转\r\nnavigate('/login');\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## react\r\n> React是一个UI库，它的核心思想是数据驱动视图UI = F(data), 即界面的呈现是由函数传入的参数决定的。开发者不再需要关心界面时如何渲染的，只要关心数据的生成和传递。\r\n\r\n### react设计思想\r\n- 数据驱动试图，要渲染界面，不应该直接操作DOM，而是通过修改数据(State或Props)。\r\n- 通过虚拟DOM修改真实DOM，虚拟DOM是对真实DOM的映射，通过新旧虚拟DOM对比，得到需要更新的部分，实现数据的增量更新。\r\n- 组件化，不同组件可以通过Props(单项数据流)进行数据交互。\r\n- 使用类似HTML的JSX语法来描述视图。\r\n- 通过setState修改数据。\r\n- 在不同的生命周期阶段做不同的事。\r\n- 源码底层对真实DOM事件进行封装，使用事件委托的方式来捕获DOM事件。\r\n### 状态管理\r\n- jQuery时代是手动把数据渲染到视图和执行数据变化之后的逻辑的，它可能没有明确的状态这一层，而是直接把数据渲染成DOM，下次需要数据也是从DOM获取来的。\r\n- Vue、React前端框架的时代不需要手动操作DOM和执行数据变化之后的逻辑，只要管理好状态，由前端框架负责状态变化之后的处理。\r\n\r\n"},function(r,n,e){"use strict";e.r(n),n.default='## react18变化\r\n### setState自动批处理\r\n- 自动批处理是指React将多次setState会被合并为1次执行。\r\n- 在React 18之前，React只会在合成事件和生命周期钩子函数中使用批处理，而在Promise、setTimeout、setInterval、原生事件是不会自动批处理的。\r\n- 在React 18中所有的状态更新都会自动使用批处理。如果在某种场景下不想使用批处理，可以通过flushSync来强制立即执行(比如需要在状态更新后，立刻读取新DOM上的数据等)。\r\n- flushSync可以快速改变状态但是页面渲染不一定能响应快速改变状态后的DOM。\r\n```\r\nimport React, { useState } from "react";\r\nimport { flushSync } from "react-dom";\r\n\r\nconst App = () => {\r\n  const [count, setCount] = useState(0);\r\n  const [count2, setCount2] = useState(0);\r\n\r\n  return (\r\n    <div className="App">\r\n      <button\r\n        onClick=(() => {\r\n          // 第一次更新\r\n          flushSync(()=>{\r\n            setCount(count => count + 1);\r\n          })\r\n          // 第二次更新\r\n          flushSync(() => {\r\n            setCount2(count2 => count2 + 1);\r\n          })\r\n        })\r\n      >\r\n        点击\r\n      </button>\r\n      <span>count:{count}</span>\r\n      <span>count2:{count2}</span>\t\r\n    </div>\t\r\n  )\r\n}\r\nexport default App;\r\n```\r\n### React 18提供了更合理的初始化API，使用该API会开启concurrent(并发)模式。\r\n- React 18之前\r\n```\r\nimport React from "react";\r\nimport ReactDOM from "react-dom";\r\nimport App from "./App";\r\n\r\nconst root = document.getElementById("root");\r\nReactDOM.render(root, <App />);\r\n\r\n// 卸载组件\r\nReactDOM.unmountComponentAtNode(root);\r\n```\r\n- React 18\r\n```\r\nimport React from "react";\r\nimport ReactDOM from "react-dom/client";\r\nimport App from "./App";\r\n\r\nconst root = ReactDOM.createRoot(document.getElementById("root"));\r\nroot.render(<App />);\r\n\r\n// 卸载组件\r\nroot.unmount(); \r\n```\r\n### Concurrent Mode(并发模式)\r\n- 并发模式不是一个功能，而是一个底层设计。它可以帮助应用保持响应，根据用户的设备性能和网速进行调整，它通过渲染可中断来修复阻塞渲染机制。\r\n- 在concurrent模式中使同步不可中断更新变成了异步可中断更新。\r\n- 通过startTransition或useDeferredValue用来标记一次非紧急更新。\r\n### 去掉了对IE浏览器的支持\r\n- react18引入的新特性全部基于现代浏览器，如需支持需要退回到react17版本。\r\n### react组件返回值更新\r\n- 在react17中，返回空组件只能返回null，显式返回undefined会报错。\r\n- 在react18中，支持null和undefined返回。因为在Suspense中允许fallback为undefined，所以为了保持一致性所以允许返回undefined。\r\n### strict mode更新\r\n- 当使用严格模式时，React会对每个组件返回两次渲染，以便观察一些意想不到的结果。\r\n- 在react17中去掉了一次渲染的控制台日志，以便让日志容易阅读。react18取消了这个限制，第二次渲染会以浅灰色出现在控制台日志。\r\n### Suspense不再需要fallback捕获\r\n### 支持useId\r\n- 在服务器和客户端生成相同的唯一id，避免hydrating的不兼容。\r\n### useSyncExternalStore\r\n- 用于解决外部数据撕裂问题。\r\n### useInsertionEffect\r\n- 这个hooks只建议在css in js库中使用，这个hooks执行时机在DOM生成之后，useLayoutEffect执行之前，它的工作原理大致与useLayoutEffect相同，此时无法访问DOM节点的引用，一般用于提前注入脚本。\r\n### [Suspense行为的变化](https://cloud.tencent.com/developer/article/1910191)\r\n- Suspense在并发模式下避免了非异步组件的渲染和副作用执行，提供更纯净的渲染效果。\r\n- 针对Suspense内不显示的子树做了单独的处理，既不会渲染display: none的内容，也不会执行useEffect回调。\r\n- Suspense的新行为需要遍历子树，所以促使Effects List重构为SubtreeFlags从而实现预期行为的变化。\r\n\r\n'},function(r,n,e){"use strict";e.r(n),n.default="## 并发模式(Concurrent Mode)\r\n- React团队在React 16中提出了并发模式的概念，并在React 18中开放使用，React16、17一直为此做准备。\r\n- 并发模式最大的意义在于React渲染过程可以被暂停、延迟甚至放弃，不会长时间阻塞浏览器渲染；高优先级更新可以中断低优先级更新，优先渲染。\r\n- 并发模式只是提供了可中断的能力，React并不会自动帮开发者区分不同优先级的更新。\r\n- 默认情况下所有的更新都是紧急更新不能被中断，过渡更新是低优先级的更新可以被中断。\r\n- 为了保持向后兼容性，React 18的行为和之前的版本一样，所有更新都是紧急更新，可以通过startTransition或useDeferredValue将更新标记为低优先级更新。\r\n- 在并发模式下React每执行一个任务都会看看有没有更高优先级的更新，如果有则当前低优先级的的更新会被暂停，待高优先级任务执行完之后，再继续执行或重新执行。\r\n### 开启并发模式\r\n- 开启并发模式的前提是使用ReactDOM.createRoot挂载组件。\r\n- 需要手动使用startTransition或useDeferredValue改变React渲染更新的优先级，并不是开启并发模式React自动会控制渲染过程的暂停、延迟等。\r\n### 并发模式特点\r\n- React并发模式并不会并行运行任务，它会将非紧急任务移动到过渡状态，并优先执行紧急任务。使用相同的线程来处理它们。\r\n- React的并发模式，只是让我们的项目拥有了辨别优先级的能力，并且在一定限制条件下能够快速响应用户操作。如果单个任务执行耗时很长，即使设置了startTransition也无能为力。如果存在这种情况需要将单个任务继续拆分或者利用Web Worker进行多线程处理。\r\n- **并发模式只能控制React中js的操作(Render阶段)，针对真实DOM的更新(Commit阶段)导致用户操作不能及时响应时并发模式无法处理。**\r\n- 耗时任务应该分割成组件，以便过渡正常工作，通过startTransition处理后它能够中断树遍历(中断了Render阶段)，以便浏览器可以处理高优先级任务。如果一个单一的任务耗时很长，并发模式变得无效，**并发模式是在多个任务执行耗时过长时中断而不是中断单个耗时较长的任务**。\r\n### React的状态更新可以分为两类\r\n1. 紧急更新(高优先级更新)：比如打字、点击、拖动等，需要立即响应的行为，如果不立即响应会给人很卡，或者应用出问题的感觉。\r\n2. 过渡更新(低优先级更新)：将UI从一个视图过渡到另一个视图，不需要即时响应，有些延迟是可以接受的。\r\n### 中断和切换\r\n- 在处理低优先级更新时，React在处理完每个任务后会暂停，并检查是否有高优先级更新需要处理。如果有React会暂停当前处理，切换到处理高优先级更新，处理完高优先级更新后React会返回处理低优先级更新(如果它无效了就丢弃它)。除了高优先级更新React还会检查当前渲染是否耗时过长，如果耗时过长React会将控制权还给浏览器，以便它可以重绘屏幕，避免卡顿和冻结。\r\n- 由于React只能在组件之间暂停(它不能在组件中间停下来)，所以如果有一两个特别重的组件，并发渲染帮助不大。如果组件渲染需要300毫秒，浏览器就会被阻塞300毫秒。并发渲染真正发挥作用的地方是当你的组件只是稍微慢一点，但它们的数量比较多，以至于总渲染时间相当长。\r\n- 将高优先级更新和低优先级更新分开独立考虑，高优先级更新和低优先级更新不是在一个Diff链路中，如果在一个Diff链路中时，无论Diff的先后最后更新视图(Commit)是一起的。不在同一个Diff链路时，最后更新视图(Commit)是独立的，会区分出更新的先后顺序。\r\n### startTransition\r\n> 使用startTransition只是告知React，有一些操作是不紧急的，如果遇到优先级更高的任务，不紧急的任务可以不立马执行，而是在处理完高优先级任务后才进行低优先级任务的执行。\r\n\r\n- 当用户在搜索输入框中输入时更新状态变量inputValue，然后调用startTransition，传入一个包含另一个状态更新的函数。\r\n- 传入的函数会立即被调用，React会记录其执行期间所做的任何状态更改，并将它们标记为低优先级更新。\r\n- 实际上启动了两个更新：一个是紧急的(更新inputValue)，另一个是transition(更新searchQuery)。\r\n```\r\nimport { startTransition, useState } from 'react'\r\n\r\nconst StartTransitionUsage = () => {\r\n  const [inputValue, setInputValue] = useState('')\r\n  const [searchQuery, setSearchQuery] = useState('')\r\n\r\n  const onInputChange = (value: string) => {\r\n    setInputValue(value)\r\n    startTransition(() => {\r\n      setSearchQuery(value)\r\n    })\r\n  }\r\n\r\n  return (\r\n    <div>\r\n      <SectionHeader title=\"Movies\" />\r\n      <input placeholder=\"Search\" value={inputValue} onChange={(e) => onInputChange(e.target.value)} />\r\n      <MoviesCatalog searchQuery={searchQuery} />\r\n    </div>\r\n  )\r\n}\r\n```\r\n### useTransition\r\n- 调用useTransition会返回一个boolean值(表示是否有低优先级更新正在进行)和一个用来启动transition的startTransition函数。\r\n- 以这种方式启动transition时，React实际上会进行两次渲染：\r\n    1. 一次高优先级更新将isPending变为true。\r\n    2. 一次低优先级更新startTransition函数中实际状态的更改。\r\n```\r\nimport { useTransition, useState } from 'react'\r\n\r\nconst UseTransitionUsage = () => {\r\n  const [inputValue, setInputValue] = useState('')\r\n  const [searchQuery, setSearchQuery] = useState('')\r\n  const [isPending, startTransition] = useTransition()\r\n\r\n  const onInputChange = (value: string) => {\r\n    setInputValue(value)\r\n    startTransition(() => {\r\n      setSearchQuery(value)\r\n    })\r\n  }\r\n\r\n  return (\r\n    <div>\r\n      <SectionHeader title=\"Movies\" isLoading={isPending} />\r\n      <input placeholder=\"Search\" value={inputValue} onChange={(e) => onInputChange(e.target.value)} />\r\n      <MoviesCatalog searchQuery={searchQuery} />\r\n    </div>\r\n  )\r\n}\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## react为什么需要一个根标签包裹\r\n### react能创建多个根元素\r\n- react的组件渲染的不是根元素，只有ReactDOM.render、React.createRoot才会创建根元素。\r\n- 在应用内可以多次使用ReactDOM.render，所以react能创建多个根元素。\r\n```\r\nReactDOM.render(<App />, document.getElementById('root'));\r\nReactDOM.render(<App1 />, document.getElementById('root1'));\r\n```\r\n- 很多组件库的toast、modal其实都用到创建多个根元素的技术。\r\n### react根元素能渲染多个组件\r\n- 使用数组包裹多个组件\r\n```\r\nReactDOM.render(\r\n  [<App />, <App1 />],\r\n  document.getElementById('root')\r\n);\r\n```\r\n- 使用Fragment包裹多个组件\r\n```\r\nReactDOM.render(\r\n  <Fragment>\r\n    <App />\r\n    <App1 />\r\n  </Fragment>,\r\n  document.getElementById('root')\r\n);\r\n```\r\n### react组件能渲染多个元素\r\n- 组件的返回值使用JSX的方式是可以返回多个element的。\r\n- 使用数组包裹多个element\r\n```\r\nconst App = () => {\r\n  return ([\r\n    <div>Hello</div>,\r\n    <div>World</div>\r\n  ]);\r\n};\r\n```\r\n- 使用Fragment包裹多个element\r\n```\r\nconst App = () => {\r\n  return (\r\n    <Fragment>\r\n      <div>Hello</div>\r\n      <div>World</div>\r\n    </Fragment>\r\n  );\r\n};\r\n```\r\n- 不能使用如下写法\r\n  1. 因为JSX最后会被编译为React.createElement(...)的表达式。\r\n  2. 一个函数不能返回多个表达式，可以通过数组或Fragment包裹的方式将多个表达式包裹成一个表达式。\r\n```\r\nconst App = () => {\r\n  return (\r\n    <div>Hello</div>\r\n    <div>World</div>\r\n  );\r\n};\r\n```\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## [react事件机制](https://mp.weixin.qq.com/s/DI0oQI7Q-v5vrySRkD1ckw)\r\n### 事件传播机制\r\n> 一般的事件触发都会经历三个阶段。如果想阻止事件的传播，可以在指定节点的事件监听器通过event.stopPropagation()或event.cancelBubble = true阻止事件传播。有些事件是没有冒泡阶段的，如scroll、blur、及各种媒体事件等。\r\n\r\n1. 捕获阶段，事件从 window 开始，自上而下一直传播到目标元素的阶段。\r\n2. 目标阶段，事件真正的触发元素处理事件的阶段。\r\n3. 冒泡阶段，从目标元素开始，自下而上一直传播到 window 的阶段。\r\n### 绑定事件的方法\r\n- 行内 HTML 事件绑定。\r\n> js 和 html 代码耦合。\r\n\r\n```\r\n<div onclick=\"handleClick()\">test</div>\r\n<script>\r\n  let handleClick = function(){\r\n    // ...\r\n  }\r\n\r\n  // 移除事件\r\n  handleClick = function(){}\r\n<\/script>\r\n```\r\n- 事件处理器属性(DOM0)。\r\n> 作为属性使用，一次只能绑定一个事件，多次赋值会覆盖，只能处理冒泡阶段。\r\n\r\n```\r\n<div id=\"test\">test</div>\r\n<script>\r\n  let target = document.getElementById('test')\r\n  // 绑定事件\r\n  target.onclick = function(){\r\n    // ...\r\n  }\r\n  target.onclick = function(){\r\n    // ...会覆盖上面的方法\r\n  }\r\n  // 移除事件\r\n  target.onclick = null;\r\n<\/script>\r\n```\r\n- addEventListener(DOM2)\r\n> 就是为了绑定事件而生的 api，拓展性最强，现在开发者一般都用 addEventListener 绑定事件监听器。\r\n\r\n```\r\n<div id=\"test\">test</div>\r\n<script>\r\n  let target = document.getElementById('test');\r\n  // 绑定事件\r\n  let funcA = function(){\r\n    // ...\r\n  }\r\n  let funcB = function(){\r\n    // ...\r\n  }\r\n  // 添加冒泡阶段监听器\r\n  target.addEventListener('click', funcA, false);\r\n  // 添加捕获阶段监听器\r\n  target.addEventListener('click', funcB, true);\r\n  // 移除监听器\r\n  target.removeEventListener('click', funcA);\r\n<\/script>\r\n```\r\n### 事件委托\r\n> 当节点的数量较多时，如果给每个节点都进行事件绑定的话，内存消耗大，可将事件绑定到其父节点上统一处理，减少事件绑定的数量。\r\n\r\n```\r\n<ul id=\"parent\">\r\n  <li>1</li>\r\n  <li>2</li>\r\n  <li>3</li>\r\n  ...\r\n  <li>999</li>\r\n  <li>1000</li>\r\n</ul>\r\n<script>\r\n  let parent = document.getElementById('parent');\r\n  parent.addEventListener('click', (e) => {\r\n    // 根据e.target进行处理\r\n  })\r\n<\/script>\r\n```\r\n### 浏览器事件差异\r\n> 由于浏览器厂商的实现差异，在事件的属性及方法在不同浏览器及版本上略有不同，开发者为兼容各浏览器及版本之间的差异，需要编写兼容代码。\r\n\r\n```\r\n// 阻止事件传播\r\nfunction stopPropagation(e) {\r\n  if (typeof e.stopPropagation === 'function') {\r\n    e.stopPropagation();\r\n  } else {\r\n    // 兼容ie\r\n    e.cancelBubble = true;\r\n  }\r\n}\r\n\r\n// 阻止默认事件\r\nfunction preventDefault(e) {\r\n  if (typeof e.preventDefault === 'function') {\r\n    e.preventDefault();\r\n  } else {\r\n    // 兼容ie\r\n    e.returnValue = false;\r\n  }\r\n}\r\n\r\n// 获取事件触发元素\r\nfunction getEventTarget(e) {\r\n  let target = e.target || e.srcElement || window;\r\n}\r\n```\r\n### react中的事件类型\r\n- 原生事件: 在componentDidMount生命周期里边通过addEventListener绑定的事件。\r\n- 合成事件: 通过JSX方式绑定的事件，比如onClick={() => this.handle()}。\r\n- 当事件在具体的DOM节点上被触发后，最终都会冒泡到document上，document上所绑定的统一事件处理程序会将事件分发到具体的组件实例。\r\n### 为什么 React 实现自己的事件机制\r\n- 将事件都代理到了根节点上，减少了事件监听器的创建，节省了内存。\r\n- 磨平浏览器差异，开发者无需兼容多种浏览器写法。如想阻止事件传播时需要编写event.stopPropagation() 或 event.cancelBubble = true，在 React 中只需编写event.stopPropagation()即可。\r\n- 对开发者友好。只需在对应的节点上编写如onClick、onClickCapture等代码即可完成click事件在该节点上冒泡节点、捕获阶段的监听，统一了写法。\r\n### React自己事件机制实现步骤\r\n#### 事件分类\r\n> React 对在 React 中使用的事件进行了分类，具体通过各个类型的事件处理插件分别处理。\r\n\r\n1. 这里的分类是对 React 事件进行分类的，简单事件如onClick和onClickCapture，它们只依赖了原生事件click。而有些事件是由 React 统一包装给用户使用的，如onChange，它依赖了['change','click','focusin','focusout','input','keydown','keyup','selectionchange']，这是 React 为了兼容不同表单的修改事件收集，如对于`<input type=\"checkbox\" />`和`<input type=\"radio\" />`开发者原生需要使用click事件收集表单变更后的值，而在 React 中可以统一使用onChange来收集。\r\n2. 分类并不代表依赖的原生事件之间没有交集。 如简单事件中有onKeyDown，它依赖于原生事件keydown。输入前事件有onCompositionStart，它也依赖了原生事件keydown。表单修改事件onChange，它也依赖了原生事件keydown。\r\n\r\n- SimpleEventPlugin简单事件，代表事件onClick。\r\n- BeforeInputEventPlugin输入前事件，代表事件onBeforeInput。\r\n- ChangeEventPlugin表单修改事件，代表事件onChange。\r\n- EnterLeaveEnventPlugin鼠标进出事件，代表事件onMouseEnter。\r\n- SelectEventPlugin选择事件，代表事件onSelect。\r\n#### 事件收集\r\n> React 需要对所有的事件做代理委托，所以需要事先知道浏览器支持的所有事件，这些事件都是硬编码在 React 源码的各个事件插件中的。而对于所有需要代理的原生事件，都会以原生事件名字符串的形式存储在一个名为allNativeEvents的集合中，并且在registrationNameDependencies中存储 React 事件名到其依赖的原生事件名数组的映射。\r\n\r\n1. 事件的收集是通过各个事件处理插件各自收集注册的，在页面加载时，会执行各个插件的registerEvents，将所有依赖的原生事件都注册到allNativeEvents中去，并且在registrationNameDependencies中存储映射关系。\r\n2. 对于原生事件不支持冒泡阶段的事件，硬编码的形式存储在了nonDelegatedEvents集合中，原生不支持冒泡阶段的事件在后续的事件代理环节有不一样的处理方式。\r\n```\r\n// React代码加载时就会执行以下js代码\r\nSimpleEventPlugin.registerEvents();\r\nEnterLeaveEventPlugin.registerEvents();\r\nChangeEventPlugin.registerEvents();\r\nSelectEventPlugin.registerEvents();\r\nBeforeInputEventPlugin.registerEvents();\r\n\r\n// 上述代码执行完后allNativeEvents集合中就会有cancel、click等80种事件\r\nallNativeEvents = ['cancel','click', ...]\r\n\r\n// nonDelegatedEvents有cancel、close等29种事件\r\nnonDelegatedEvents = ['cancel','close'，...]\r\n\r\n// registrationNameDependencies保存react事件和其依赖的事件的映射\r\nregistrationNameDependencies = {\r\n  onClick: ['click'],\r\n  onClickCapture: ['click'],\r\n  onChange: ['change','click','focusin','focusout','input','keydown','keyup','selectionchange'],\r\n  ...\r\n}\r\n```\r\n#### 事件代理\r\n- 原生事件支持冒泡的可代理事件。\r\n  1. 将事件委托代理到根元素的操作发生在ReactDOM.render(element, container)时。在ReactDOM.render的实现中，在创建了fiberRoot后，在开始构造fiber树前，会调用listenToAllSupportedEvents进行事件的绑定委托。\r\n  > 首先会判断根元素上的事件监听器相关的字段是否已标记完成过监听，如果没有完成，则将根标记为已监听过，并遍历allNativeEvents进行事件的委托绑定。是否完成监听的判断是避免多次调用ReactDOM.render(element, container)是对同一个container重复委托事件。listenToNativeEvent即对元素进行事件绑定的方法，第二个参数的含义是是否将监听器绑定在捕获阶段。对于不存在冒泡阶段的事件，React 只委托了捕获阶段的监听器，而对于其他的事件，则对于捕获阶段和冒泡阶段都委托了监听器。\r\n\r\n  ```\r\n  const listeningMarker =\r\n    '_reactListening' +\r\n    Math.random()\r\n      .toString(36)\r\n      .slice(2);\r\n\r\n  export function listenToAllSupportedEvents(rootContainerElement: EventTarget) {\r\n    if (enableEagerRootListeners) {\r\n      if ((rootContainerElement: any)[listeningMarker]) {\r\n        // 避免重复初始化\r\n        return;\r\n      }\r\n      // 将该根元素标记为已初始化事件监听\r\n      (rootContainerElement: any)[listeningMarker] = true;\r\n      allNativeEvents.forEach(domEventName => {\r\n        if (!nonDelegatedEvents.has(domEventName)) {\r\n          listenToNativeEvent(\r\n            domEventName,\r\n            false,\r\n            ((rootContainerElement: any): Element),\r\n            null,\r\n          );\r\n        }\r\n        listenToNativeEvent(\r\n          domEventName,\r\n          true,\r\n          ((rootContainerElement: any): Element),\r\n          null,\r\n        );\r\n      });\r\n    }\r\n  }\r\n  ```\r\n  2. listenToNativeEvent的内部会将绑定了入参的dispatchEvent使用addEventListener绑定到根元素上。\r\n  > 原生事件支持冒泡的可代理事件在根元素上绑定了捕获和冒泡阶段的回调，原生事件不支持冒泡的非代理事件在根元素上只绑定了捕获阶段的回调。\r\n\r\n  ```\r\n  export function dispatchEvent(\r\n    domEventName: DOMEventName, // 原生事件名\r\n    eventSystemFlags: EventSystemFlags, // 事件标记，如是否捕获阶段\r\n    targetContainer: EventTarget, // 绑定事件的根\r\n    nativeEvent: AnyNativeEvent, // 实际触发时传入的真实事件对象\r\n  ): void {\r\n      // ... 前三个参数在绑定到根上时已传入\r\n  }\r\n\r\n  // 提前绑定入参\r\n  const listener = dispatchEvent.bind(\r\n    null,\r\n    targetContainer,\r\n    domEventName,\r\n    eventSystemFlags,\r\n  )\r\n  if (isCapturePhaseListener) {\r\n    addEventCaptureListener(targetContainer, domEventName, listener)\r\n  } else {\r\n    addEventBubbleListener(targetContainer, domEventName, listener)\r\n  }\r\n\r\n  // 添加冒泡事件监听器\r\n  export function addEventBubbleListener(\r\n    target: EventTarget,\r\n    eventType: string,\r\n    listener: Function,\r\n  ): Function {\r\n    target.addEventListener(eventType, listener, false);\r\n    return listener;\r\n  }\r\n\r\n  // 添加捕获事件监听器\r\n  export function addEventCaptureListener(\r\n    target: EventTarget,\r\n    eventType: string,\r\n    listener: Function,\r\n  ): Function {\r\n    target.addEventListener(eventType, listener, true);\r\n    return listener;\r\n  }\r\n  ```\r\n- 原生事件不支持冒泡的非代理事件。实际上 React 对这些不可冒泡的事件都进行了冒泡模拟。\r\n> 对于非代理事件nonDelegatedEvents，由于这些事件不存在冒泡阶段，在根部代理他们的冒泡阶段监听器也不会触发，所以需要特殊处理。这些事件的代理发生在 DOM 实例的创建阶段，也就是render阶段的completeWork阶段。通过调用finalizeInitialChildren为 DOM 实例设置属性时，判断 DOM 节点类型来添加响应的冒泡阶段监听器。如为`<img />`和`<link />`标签对应的 DOM 实例添加error和load的监听器。\r\n\r\n```\r\nexport function setInitialProperties(\r\n  domElement: Element,\r\n  tag: string,\r\n  rawProps: Object,\r\n  rootContainerElement: Element | Document,\r\n): void {\r\n  // ...\r\n  switch (tag) {\r\n    // ...\r\n    case 'img':\r\n    case 'image':\r\n    case 'link':\r\n        listenToNonDelegatedEvent('error', domElement);\r\n        listenToNonDelegatedEvent('load', domElement);\r\n        break;\r\n    // ...\r\n  }\r\n  // ...\r\n}\r\n\r\n// 非代理事件监听器绑定\r\nexport function listenToNonDelegatedEvent(\r\n  domEventName: DOMEventName,\r\n  targetElement: Element,\r\n): void {\r\n  // 绑定在目标/冒泡阶段\r\n  const isCapturePhaseListener = false;\r\n  const listenerSet = getEventListenerSet(targetElement);\r\n  const listenerSetKey = getListenerSetKey(\r\n    domEventName,\r\n    isCapturePhaseListener,\r\n  );\r\n  if (!listenerSet.has(listenerSetKey)) {\r\n    addTrappedEventListener(\r\n      targetElement,\r\n      domEventName,\r\n      IS_NON_DELEGATED, // 非代理事件\r\n      isCapturePhaseListener, // 目标/冒泡阶段\r\n    );\r\n    listenerSet.add(listenerSetKey);\r\n  }\r\n}\r\n```\r\n### 合成事件\r\n> 合成事件SyntheticEvent是 React 事件系统对于原生事件跨浏览器包装器。它除了兼容所有浏览器外，它符合W3C规范，包括事件触发、事件冒泡、事件捕获、事件合成和事件派发等，它还拥有和浏览器原生事件相同的接口，包括 stopPropagation() 和 preventDefault()。当需要使用浏览器的底层事件时，只需要使用 nativeEvent 属性来获取即可。\r\n\r\n#### 合成事件作用\r\n- 在底层磨平不同浏览器的差异，React实现了统一的事件机制，不再需要处理浏览器事件机制方面的兼容问题，在上层面向开发者暴露稳定、统一的、与原生事件相同的事件接口。\r\n- React16的事件绑定在document上，React17以后事件绑定在挂载的dom上。而不是绑定在React组件对应的DOM(减少内存开销就是因为所有的事件都绑定在document上，其他节点没有绑定事件)。\r\n- React把握了事件机制的主动权，实现了对所有事件的中心化管控。\r\n- React引入事件池避免垃圾回收，在事件池中获取或释放事件对象，避免频繁的创建和销毁。\r\n#### 合成事件和原生事件的区别\r\n- 合成事件不是原生DOM事件，但它包含了原生DOM事件的引用，可以通过e.nativeEvent访问。\r\n- 合成事件无法获取到真实DOM，但可以通过React提供refAPI进行获取。\r\n#### 合成事件的使用\r\n> React 事件的命名采用小驼峰式（camelCase），而不是纯小写。以 click 事件为例，冒泡阶段用onClick，捕获阶段用onClickCapture。使用 JSX 语法需要传入一个函数作为事件处理函数，而不是一个字符串。在 React 事件中不通过返回 false 阻止默认行为，必须显示调用event.preventDefault()。由于 React 事件执行回调时的上下文并不在组件内部，所以还需要注意 this 的指向问题。\r\n\r\n```\r\n// 传统html绑定事件\r\n<button onclick=\"activateLasers()\">\r\n  test\r\n</button>\r\n\r\n// 在React中绑定事件\r\n<button onClick={activateLasers}>\r\n  test\r\n</button>\r\n```\r\n#### 磨平浏览器差异\r\n- React 通过事件normalize以让他们在不同浏览器中拥有一致的属性。React 声明了各种事件的接口，以此来磨平浏览器中的差异。\r\n  1. 如果接口中的字段值为 0，则直接使用原生事件的值。\r\n  2. 如果接口中字段的值为函数，则会以原生事件作为入参，调用该函数来返回磨平了浏览器差异的值。\r\n  ```\r\n  // 基础事件接口，timeStamp需要磨平差异\r\n  const EventInterface = {\r\n    eventPhase: 0,\r\n    bubbles: 0,\r\n    cancelable: 0,\r\n    timeStamp: function(event) {\r\n      return event.timeStamp || Date.now();\r\n    },\r\n    defaultPrevented: 0,\r\n    isTrusted: 0,\r\n  };\r\n  // UI事件接口，继承基础事件接口\r\n  const UIEventInterface: EventInterfaceType = {\r\n    ...EventInterface,\r\n    view: 0,\r\n    detail: 0,\r\n  };\r\n  // 鼠标事件接口，继承UI事件接口，getModifierState，relatedTarget、movementX、movementY等字段需要磨平差异\r\n  const MouseEventInterface: EventInterfaceType = {\r\n    ...UIEventInterface,\r\n    screenX: 0,\r\n    screenY: 0,\r\n    clientX: 0,\r\n    clientY: 0,\r\n    pageX: 0,\r\n    pageY: 0,\r\n    ctrlKey: 0,\r\n    shiftKey: 0,\r\n    altKey: 0,\r\n    metaKey: 0,\r\n    getModifierState: getEventModifierState,\r\n    button: 0,\r\n    buttons: 0,\r\n    relatedTarget: function(event) {\r\n      if (event.relatedTarget === undefined)\r\n        return event.fromElement === event.srcElement\r\n          ? event.toElement\r\n          : event.fromElement;\r\n\r\n      return event.relatedTarget;\r\n    },\r\n    movementX: function(event) {\r\n      if ('movementX' in event) {\r\n        return event.movementX;\r\n      }\r\n      updateMouseMovementPolyfillState(event);\r\n      return lastMovementX;\r\n    },\r\n    movementY: function(event) {\r\n      if ('movementY' in event) {\r\n        return event.movementY;\r\n      }\r\n      // Don't need to call updateMouseMovementPolyfillState() here\r\n      // because it's guaranteed to have already run when movementX\r\n      // was copied.\r\n      return lastMovementY;\r\n    },\r\n  };\r\n  // 指针类型，继承鼠标事件接口。还有很多其他事件类型接口...\r\n  const PointerEventInterface = {\r\n    ...MouseEventInterface,\r\n    pointerId: 0,\r\n    width: 0,\r\n    height: 0,\r\n    pressure: 0,\r\n    tangentialPressure: 0,\r\n    tiltX: 0,\r\n    tiltY: 0,\r\n    twist: 0,\r\n    pointerType: 0,\r\n    isPrimary: 0,\r\n  };\r\n  ```\r\n- 由于不同的类型的事件其字段有所不同，所以 React 实现了针对事件接口的合成事件构造函数的工厂函数。 通过传入不一样的事件接口返回对应事件的合成事件构造函数，然后在事件触发回调时根据触发的事件类型判断使用哪种类型的合成事件构造函数来实例化合成事件。\r\n> 合成事件的实例，其实就是根据事件类型对原生事件的属性做浏览器的磨平，以及关键方法的包装。\r\n\r\n```\r\n// 辅助函数，永远返回true\r\nfunction functionThatReturnsTrue() {\r\n  return true;\r\n}\r\n// 辅助函数，永远返回false\r\nfunction functionThatReturnsFalse() {\r\n  return false;\r\n}\r\n// 合成事件构造函数的工厂函数，根据传入的事件接口返回对应的合成事件构造函数\r\nfunction createSyntheticEvent(Interface: EventInterfaceType) {\r\n\r\n  // 合成事件构造函数\r\n  function SyntheticBaseEvent(\r\n    reactName: string | null,\r\n    reactEventType: string,\r\n    targetInst: Fiber,\r\n    nativeEvent: {[propName: string]: mixed},\r\n    nativeEventTarget: null | EventTarget,\r\n  ) {\r\n    // react事件名\r\n    this._reactName = reactName;\r\n    // 当前执行事件回调时的fiber\r\n    this._targetInst = targetInst;\r\n    // 真实事件名\r\n    this.type = reactEventType;\r\n    // 原生事件对象\r\n    this.nativeEvent = nativeEvent;\r\n    // 原生触发事件的DOM target\r\n    this.target = nativeEventTarget;\r\n    // 当前执行回调的DOM\r\n    this.currentTarget = null;\r\n\r\n    // 下面是磨平字段在浏览器间的差异\r\n    for (const propName in Interface) {\r\n      if (!Interface.hasOwnProperty(propName)) {\r\n        // 该接口没有这个字段，不拷贝\r\n        continue;\r\n      }\r\n      // 拿到事件接口对应的值\r\n      const normalize = Interface[propName];\r\n      // 如果接口对应字段函数，进入if分支，执行函数拿到值\r\n      if (normalize) {\r\n        // 获取磨平了浏览器差异后的值\r\n        this[propName] = normalize(nativeEvent);\r\n      } else {\r\n        // 如果接口对应值是0，则直接取原生事件对应字段值\r\n        this[propName] = nativeEvent[propName];\r\n      }\r\n    }\r\n    // 磨平defaultPrevented的浏览器差异，即磨平e.defaultPrevented和e.returnValue的表现\r\n    const defaultPrevented =\r\n      nativeEvent.defaultPrevented != null\r\n        ? nativeEvent.defaultPrevented\r\n        : nativeEvent.returnValue === false;\r\n    if (defaultPrevented) {\r\n      // 如果在处理事件时已经被阻止默认操作了，则调用isDefaultPrevented一直返回true\r\n      this.isDefaultPrevented = functionThatReturnsTrue;\r\n    } else {\r\n      // 如果在处理事件时没有被阻止过默认操作，则先用返回false的函数\r\n      this.isDefaultPrevented = functionThatReturnsFalse;\r\n    }\r\n    // 默认执行时间时，还没有被阻止继续传播，所以调用isPropagationStopped返回false\r\n    this.isPropagationStopped = functionThatReturnsFalse;\r\n    return this;\r\n  }\r\n  // 合成事件重要方法的包装\r\n  Object.assign(SyntheticBaseEvent.prototype, {\r\n    preventDefault: function() {\r\n      // 调用后设置defaultPrevented\r\n      this.defaultPrevented = true;\r\n      const event = this.nativeEvent;\r\n      if (!event) {\r\n        return;\r\n      }\r\n      // 下面是磨平e.preventDefault()和e.returnValue=false的浏览器差异，并在原生事件上执行\r\n      if (event.preventDefault) {\r\n        event.preventDefault();\r\n        // $FlowFixMe - flow is not aware of `unknown` in IE\r\n      } else if (typeof event.returnValue !== 'unknown') {\r\n        event.returnValue = false;\r\n      }\r\n      // 然后后续回调判断时都会返回true\r\n      this.isDefaultPrevented = functionThatReturnsTrue;\r\n    },\r\n\r\n    stopPropagation: function() {\r\n      const event = this.nativeEvent;\r\n      if (!event) {\r\n        return;\r\n      }\r\n      // 磨平e.stopPropagation()和e.calcelBubble = true的差异，并在原生事件上执行\r\n      if (event.stopPropagation) {\r\n        event.stopPropagation();\r\n        // $FlowFixMe - flow is not aware of `unknown` in IE\r\n      } else if (typeof event.cancelBubble !== 'unknown') {\r\n        // The ChangeEventPlugin registers a \"propertychange\" event for\r\n        // IE. This event does not support bubbling or cancelling, and\r\n        // any references to cancelBubble throw \"Member not found\".  A\r\n        // typeof check of \"unknown\" circumvents this issue (and is also\r\n        // IE specific).\r\n        event.cancelBubble = true;\r\n      }\r\n      // 然后后续判断时都会返回true，已停止传播\r\n      this.isPropagationStopped = functionThatReturnsTrue;\r\n    },\r\n    /**\r\n     * We release all dispatched `SyntheticEvent`s after each event loop, adding\r\n     * them back into the pool. This allows a way to hold onto a reference that\r\n     * won't be added back into the pool.\r\n     */\r\n    // react16的保留原生事件的方法，react17里已无效\r\n    persist: function() {\r\n      // Modern event system doesn't use pooling.\r\n    },\r\n\r\n    /**\r\n     * Checks if this event should be released back into the pool.\r\n     *\r\n     * @return {boolean} True if this should not be released, false otherwise.\r\n     */\r\n    isPersistent: functionThatReturnsTrue,\r\n  });\r\n  // 返回根据接口类型包装的合成事件构造器\r\n  return SyntheticBaseEvent;\r\n}\r\n// 使用通过给工厂函数传入鼠标事件接口获取鼠标事件合成事件构造函数\r\nexport const SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface);\r\n```\r\n### 事件触发\r\n> 当页面上触发了特定的事件时，如点击事件 click，就会触发绑定在根元素上的事件回调函数，也就是之前绑定了参数的dispatchEvent，而dispatchEvent在内部最终会调用dispatchEventsForPlugins。\r\n\r\n- dispatchEventsForPlugins\r\n```\r\nfunction dispatchEventsForPlugins(\r\n  domEventName: DOMEventName, // dispatchEvent中绑定的事件名\r\n  eventSystemFlags: EventSystemFlags, // dispatchEvent绑定的事件标记\r\n  nativeEvent: AnyNativeEvent, // 事件触发时回调传入的原生事件对象\r\n  targetInst: null | Fiber, // 事件触发目标元素对应的fiber\r\n  targetContainer: EventTarget, // 绑定事件的根元素\r\n): void {\r\n  // 磨平浏览器差异，拿到真正的target\r\n  const nativeEventTarget = getEventTarget(nativeEvent);\r\n  // 要处理事件回调的队列\r\n  const dispatchQueue: DispatchQueue = [];\r\n  // 将fiber树上的回调收集\r\n  extractEvents(\r\n    dispatchQueue,\r\n    domEventName,\r\n    targetInst,\r\n    nativeEvent,\r\n    nativeEventTarget,\r\n    eventSystemFlags,\r\n    targetContainer,\r\n  );\r\n  // 根据收集到的回调及事件标记处理事件\r\n  processDispatchQueue(dispatchQueue, eventSystemFlags);\r\n}\r\n```\r\n- extractEvents 收集事件对应回调\r\n  1. 回调的收集也是根据事件的类型分别处理的，将extractEvents的入参分别给各个事件处理插件的extractEvents进行分别处理。\r\n  ```\r\n  function extractEvents(\r\n    dispatchQueue: DispatchQueue,\r\n    domEventName: DOMEventName,\r\n    targetInst: null | Fiber,\r\n    nativeEvent: AnyNativeEvent,\r\n    nativeEventTarget: null | EventTarget,\r\n    eventSystemFlags: EventSystemFlags,\r\n    targetContainer: EventTarget,\r\n  ) {\r\n    // 抽出简单事件\r\n    SimpleEventPlugin.extractEvents(\r\n      dispatchQueue,\r\n      domEventName,\r\n      targetInst,\r\n      nativeEvent,\r\n      nativeEventTarget,\r\n      eventSystemFlags,\r\n      targetContainer,\r\n    );\r\n    const shouldProcessPolyfillPlugins =\r\n      (eventSystemFlags & SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS) === 0;\r\n    if (shouldProcessPolyfillPlugins) {\r\n      EnterLeaveEventPlugin.extractEvents(\r\n        dispatchQueue,\r\n        domEventName,\r\n        targetInst,\r\n        nativeEvent,\r\n        nativeEventTarget,\r\n        eventSystemFlags,\r\n        targetContainer,\r\n      );\r\n      ChangeEventPlugin.extractEvents(\r\n        dispatchQueue,\r\n        domEventName,\r\n        targetInst,\r\n        nativeEvent,\r\n        nativeEventTarget,\r\n        eventSystemFlags,\r\n        targetContainer,\r\n      );\r\n      SelectEventPlugin.extractEvents(\r\n        dispatchQueue,\r\n        domEventName,\r\n        targetInst,\r\n        nativeEvent,\r\n        nativeEventTarget,\r\n        eventSystemFlags,\r\n        targetContainer,\r\n      );\r\n      BeforeInputEventPlugin.extractEvents(\r\n        dispatchQueue,\r\n        domEventName,\r\n        targetInst,\r\n        nativeEvent,\r\n        nativeEventTarget,\r\n        eventSystemFlags,\r\n        targetContainer,\r\n      );\r\n    }\r\n  }\r\n  ```\r\n  2. 以SimpleEventPlugin.extractEvents为例查看如何收集事件回调\r\n    - 根据原生事件名，得到对应的 React 事件名。\r\n    - 根据原生事件名，判断需要使用的合成事件构造函数。\r\n    - 根据绑定的事件标记得出事件是否捕获阶段。\r\n    - 判断事件名是否为 scoll 且不是捕获阶段，如果是则只收集事件触发节点。\r\n    - 从触发事件的 DOM 实例对应的 fiber 节点开始，向上遍历 fiber 树，判断遍历到的 fiber 是否宿主类型 fiber 节点，是的话判断在其 props 上是否存在 React 事件名同名属性，如果存在，则 push 到数组中，遍历结束即可收集由叶子节点到根节点的回调函数。\r\n    - 如果收集的回调数组不为空，则实例化对应的合成事件，并与收集的回调函数一同收集到dispatchQueue中。\r\n  ```\r\n  // SimpleEventPlugin.js\r\n  function extractEvents(\r\n    dispatchQueue: DispatchQueue,\r\n    domEventName: DOMEventName,\r\n    targetInst: null | Fiber,\r\n    nativeEvent: AnyNativeEvent,\r\n    nativeEventTarget: null | EventTarget,\r\n    eventSystemFlags: EventSystemFlags,\r\n    targetContainer: EventTarget,\r\n  ): void {\r\n    // 根据原生事件名拿到React事件名\r\n    const reactName = topLevelEventsToReactNames.get(domEventName);\r\n    if (reactName === undefined) {\r\n      // 如果是没对应的React事件就不处理\r\n      return;\r\n    }\r\n    // 默认的合成事件构造函数，下面根据事件名重新赋值对应的合成事件构造函数\r\n    let SyntheticEventCtor = SyntheticEvent;\r\n    let reactEventType: string = domEventName;\r\n    // 根据事件名获取对应的合成事件构造函数\r\n    switch (domEventName) {\r\n      case 'keypress':\r\n      case 'keydown':\r\n      case 'keyup':\r\n        SyntheticEventCtor = SyntheticKeyboardEvent;\r\n        break;\r\n      case 'focusin':\r\n        reactEventType = 'focus';\r\n        SyntheticEventCtor = SyntheticFocusEvent;\r\n        break;\r\n      case 'focusout':\r\n        reactEventType = 'blur';\r\n        SyntheticEventCtor = SyntheticFocusEvent;\r\n        break;\r\n      case 'beforeblur':\r\n      case 'afterblur':\r\n        SyntheticEventCtor = SyntheticFocusEvent;\r\n        break;\r\n      case 'click':\r\n        // Firefox creates a click event on right mouse clicks. This removes the\r\n        // unwanted click events.\r\n        if (nativeEvent.button === 2) {\r\n          return;\r\n        }\r\n      /* falls through */\r\n      case 'auxclick':\r\n      case 'dblclick':\r\n      case 'mousedown':\r\n      case 'mousemove':\r\n      case 'mouseup':\r\n      // TODO: Disabled elements should not respond to mouse events\r\n      /* falls through */\r\n      case 'mouseout':\r\n      case 'mouseover':\r\n      case 'contextmenu':\r\n        SyntheticEventCtor = SyntheticMouseEvent;\r\n        break;\r\n      // ...这里省略了很多case\r\n      default:\r\n        // Unknown event. This is used by createEventHandle.\r\n        break;\r\n    }\r\n    // 判断是捕获阶段还是冒泡阶段\r\n    const inCapturePhase = (eventSystemFlags & IS_CAPTURE_PHASE) !== 0;\r\n    if (\r\n      enableCreateEventHandleAPI &&\r\n      eventSystemFlags & IS_EVENT_HANDLE_NON_MANAGED_NODE\r\n    ) {\r\n      // 这个分支不看\r\n    } else {\r\n      // Some events don't bubble in the browser.\r\n      // In the past, React has always bubbled them, but this can be surprising.\r\n      // We're going to try aligning closer to the browser behavior by not bubbling\r\n      // them in React either. We'll start by not bubbling onScroll, and then expand.\r\n      // 如果不是捕获阶段且事件名为scroll，则只处理触发事件的节点\r\n      const accumulateTargetOnly =\r\n        !inCapturePhase &&\r\n        // TODO: ideally, we'd eventually add all events from\r\n        // nonDelegatedEvents list in DOMPluginEventSystem.\r\n        // Then we can remove this special list.\r\n        // This is a breaking change that can wait until React 18.\r\n        domEventName === 'scroll';\r\n      // 在fiber树上收集事件名对应的props\r\n      const listeners = accumulateSinglePhaseListeners(\r\n        targetInst,\r\n        reactName,\r\n        nativeEvent.type,\r\n        inCapturePhase,\r\n        accumulateTargetOnly,\r\n      );\r\n      // 如果存在监听该事件props回调函数\r\n      if (listeners.length > 0) {\r\n        // Intentionally create event lazily.\r\n        // 则构建一个react合成事件\r\n        const event = new SyntheticEventCtor(\r\n          reactName,\r\n          reactEventType,\r\n          null,\r\n          nativeEvent,\r\n          nativeEventTarget,\r\n        );\r\n        // 并收集到队列中\r\n        dispatchQueue.push({event, listeners});\r\n      }\r\n    }\r\n  }\r\n  // 遍历fiber树的收集函数\r\n  export function accumulateSinglePhaseListeners(\r\n    targetFiber: Fiber | null,\r\n    reactName: string | null,\r\n    nativeEventType: string,\r\n    inCapturePhase: boolean,\r\n    accumulateTargetOnly: boolean,\r\n  ): Array<DispatchListener> {\r\n    const captureName = reactName !== null ? reactName + 'Capture' : null;\r\n    const reactEventName = inCapturePhase ? captureName : reactName;\r\n    const listeners: Array<DispatchListener> = [];\r\n\r\n    let instance = targetFiber;\r\n    let lastHostComponent = null;\r\n\r\n    // Accumulate all instances and listeners via the target -> root path.\r\n    while (instance !== null) {\r\n      const {stateNode, tag} = instance;\r\n      // Handle listeners that are on HostComponents (i.e. <div>)\r\n      if (tag === HostComponent && stateNode !== null) {\r\n        lastHostComponent = stateNode;\r\n        // Standard React on* listeners, i.e. onClick or onClickCapture\r\n        if (reactEventName !== null) {\r\n          // 拿到DOM节点类型上对应事件名的props\r\n          const listener = getListener(instance, reactEventName);\r\n          if (listener != null) {\r\n            // 如果这个同名props存在，则收集起来\r\n            listeners.push(\r\n              createDispatchListener(instance, listener, lastHostComponent),\r\n            );\r\n          }\r\n        }\r\n      }\r\n      // If we are only accumulating events for the target, then we don't\r\n      // continue to propagate through the React fiber tree to find other\r\n      // listeners.\r\n      // 对于只收集当前节点的事件，收集完当前节点就退出了\r\n      if (accumulateTargetOnly) {\r\n        break;\r\n      }\r\n      // 向上遍历\r\n      instance = instance.return;\r\n    }\r\n    // 返回该事件名对应收集的监听器\r\n    return listeners;\r\n  }\r\n  ```\r\n- 处理回调\r\n> 对于回调的处理，就是简单地根据收集到的回调数组，判断事件的触发是处于捕获阶段还是冒泡阶段来决定是顺序执行还是倒序执行回调数组。并且通过event.isPropagationStopped()来判断事件是否执行过event.stopPropagation()以决定是否继续执行。\r\n\r\n```\r\n// 分别处理事件队列\r\nexport function processDispatchQueue(\r\n  dispatchQueue: DispatchQueue,\r\n  eventSystemFlags: EventSystemFlags,\r\n): void {\r\n  const inCapturePhase = (eventSystemFlags & IS_CAPTURE_PHASE) !== 0;\r\n  for (let i = 0; i < dispatchQueue.length; i++) {\r\n    const {event, listeners} = dispatchQueue[i];\r\n    processDispatchQueueItemsInOrder(event, listeners, inCapturePhase);\r\n  }\r\n}\r\n\r\n// 根据事件是捕获阶段还是冒泡阶段，来决定是顺序执行还是倒序执行\r\n// 并且如果事件被调用过event.stopPropagation则退出执行\r\nfunction processDispatchQueueItemsInOrder(\r\n  event: ReactSyntheticEvent,\r\n  dispatchListeners: Array<DispatchListener>,\r\n  inCapturePhase: boolean,\r\n): void {\r\n  let previousInstance;\r\n  if (inCapturePhase) {\r\n    // 捕获阶段逆序执行\r\n    for (let i = dispatchListeners.length - 1; i >= 0; i--) {\r\n      const {instance, currentTarget, listener} = dispatchListeners[i];\r\n      if (instance !== previousInstance && event.isPropagationStopped()) {\r\n        // 如果被阻止过传播，则退出\r\n        return;\r\n      }\r\n      // 执行\r\n      executeDispatch(event, listener, currentTarget);\r\n      previousInstance = instance;\r\n    }\r\n  } else {\r\n    for (let i = 0; i < dispatchListeners.length; i++) {\r\n      const {instance, currentTarget, listener} = dispatchListeners[i];\r\n      if (instance !== previousInstance && event.isPropagationStopped()) {\r\n        return;\r\n      }\r\n      executeDispatch(event, listener, currentTarget);\r\n      previousInstance = instance;\r\n    }\r\n  }\r\n}\r\n\r\n// 执行事件回调\r\nfunction executeDispatch(\r\n  event: ReactSyntheticEvent,\r\n  listener: Function,\r\n  currentTarget: EventTarget,\r\n): void {\r\n  const type = event.type || 'unknown-event';\r\n  // 设置合成事件执行到当前DOM实例时的指向\r\n  event.currentTarget = currentTarget;\r\n  invokeGuardedCallbackAndCatchFirstError(type, listener, undefined, event);\r\n  // 不在事件的回调中时拿不到currentTarget\r\n  event.currentTarget = null;\r\n}\r\n```\r\n### React17 与 React16 事件系统的差别\r\n- 绑定位置，事件委托的节点从 React16 的 document 更改为 React17 的 React 树的根 DOM 容器。\r\n> 如果页面中存在多个 React 应用，由于他们都会在顶层document注册事件处理器，如果你在一个 React 子应用的 React 事件中调用了e.stopPropagation()，无法阻止事件冒泡到外部树，因为真实的事件早已传播到document。而将事件委托在 React 应用的根 DOM 容器则可以避免这样的问题，减少了多个 React 应用并存可能产生的问题，并且事件系统的运行也更贴近现在浏览器的表现。\r\n\r\n- 事件代理阶段\r\n> 在 React16 中，对 document 的事件委托都委托在冒泡阶段，当事件冒泡到 document 之后触发绑定的回调函数，在回调函数中重新模拟一次 捕获-冒泡 的行为，所以 React 事件中的e.stopPropagation()无法阻止原生事件的捕获和冒泡，因为原生事件的捕获和冒泡已经执行完了。在 React17 中，对 React 应用根 DOM 容器的事件委托分别在捕获阶段和冒泡阶段。\r\n\r\n  1. 当根容器接收到捕获事件时，先触发一次 React 事件的捕获阶段，然后再执行原生事件的捕获传播。所以 React 事件的捕获阶段调用e.stopPropagation()能阻止原生事件的传播。\r\n  2. 当根容器接受到冒泡事件时，会触发一次 React 事件的冒泡阶段，此时原生事件的冒泡传播已经传播到根了，所以 React 事件的冒泡阶段调用e.stopPropagation()不能阻止原生事件向根容器的传播，但是能阻止根容器到页面顶层的传播。\r\n- 去除事件池\r\n- scroll 事件不再冒泡\r\n> 在原生 scroll 里，scroll 是不存在冒泡阶段的，但是 React16 中模拟了 scroll 的冒泡阶段，React17 中将此特性去除，避免了当一个嵌套且可滚动的元素在其父元素触发事件时造成混乱。"},function(r,n,e){"use strict";e.r(n),n.default="## react架构\r\n### react15的架构\r\n#### Reconciler(协调阶段) —— 生成虚拟DOM和找出变化的虚拟DOM\r\n- 调用函数组件、或class组件的render方法，将返回的JSX转化为虚拟DOM\r\n- 将虚拟DOM和上次更新时的虚拟DOM对比\r\n- 通过对比找出本次更新中变化的虚拟DOM\r\n- 通知Renderer将变化的虚拟DOM更新到页面上\r\n#### Renderer(渲染提交阶段) —— 负责将变化的虚拟DOM更新到真实DOM上，根据宿主环境(使用平台)更新视图，一次性同步更新不可中断。\r\n### [react15架构的缺点](https://react.iamkasong.com/preparation/oldConstructure.html#react15%E6%9E%B6%E6%9E%84%E7%9A%84%E7%BC%BA%E7%82%B9)\r\n- 在Reconciler中，mount的组件会调用mountComponent，update的组件会调用updateComponent。\r\n- 这两个方法都会递归更新子组件。由于递归执行，所以更新一旦开始中途就无法中断。当层级很深时，递归更新时间超过了16ms，用户交互就会卡顿。\r\n- react15架构Reconciler和Renderer是交替工作的，当第一个需要更新的dom在页面上已经变化后，第二个需要更新的dom再进入Reconciler。由于整个过程都是同步的，所以在用户看来所有dom是同时更新的。如果中途中断更新会看见更新不完全的dom。\r\n### react16的架构\r\n- 相较于React15，React16中新增了Scheduler(调度器)。\r\n- 调度阶段和协调阶段在内存中执行，和宿主环境(使用平台)无关。\r\n- Scheduler、Reconciler都是可以中断的，Renderer不可中断。\r\n#### Scheduler(调度阶段) —— 调度任务的优先级，高优任务优先进入Reconciler\r\n- 以浏览器是否有剩余时间作为任务中断的标准，当浏览器有剩余时间时把更新任务交给Reconciler。其实部分浏览器已经实现了这个API，这就是requestIdleCallback。\r\n- React实现了功能更完备的Scheduler。除了在空闲时触发回调的功能外，Scheduler还提供了多种调度优先级任务的功能。\r\n#### Reconciler(协调阶段) —— 生成虚拟DOM和找出变化的虚拟DOM   Fiber架构\r\n- 协调阶段可以认为是Diff阶段。\r\n- 在React15中Reconciler是递归处理虚拟DOM的。React16的Reconciler工作从递归变成了可以中断的循环过程。由Stack Reconciler变成Fiber Reconciler。每次循环都会调用shouldYield判断当前是否有剩余时间。\r\n- 在React16中Reconciler与Renderer不再是交替工作。当Scheduler将任务交给Reconciler后，Reconciler会执行所有任务的协调工作，会为变化的虚拟DOM打上代表增/删/更新的标记。\r\n- 整个Scheduler与Reconciler的工作都在内存中进行(由于在内存中进行，不会更新页面上的DOM，所以即使反复中断，用户也不会看见更新不完全的DOM)。只有当所有组件都完成Reconciler的工作，才会统一交给Renderer。从而解决中断更新时DOM渲染不完全的问题。\r\n#### Renderer(渲染提交阶段) —— 负责将变化的虚拟DOM更新到真实DOM上，根据宿主环境(使用平台)更新视图，一次性同步更新不可中断。\r\n- Renderer根据Reconciler为虚拟DOM打的标记，同步执行对应的真实DOM操作。\r\n- 调用暴露给开发者的钩子方法，如componentDidUpdate、useLayoutEffect等。\r\n\r\n\r\n\r\n\r\n\r\n\r\n"},function(r,n,e){"use strict";e.r(n),n.default='## react模式\r\n### 复合模式\r\n- before：想更改label元素的位置, 就只能从Counter组件内部修改，但此时所有使用Counter组件的label元素位置都将发生变化。\r\n```\r\nimport Counter from "./Counter";\r\n\r\nexport default function App() {\r\n  return (\r\n    <div>\r\n      <h1>Compound Component Pattern</h1>\r\n      <Counter\r\n        iconIncrease="+"\r\n        iconDecrease="-"\r\n        label="My NOT so flexible counter"\r\n        hideLabel={false}\r\n        hideIncrease={false}\r\n        hideDecrease={false}\r\n      />\r\n    </div>\r\n  );\r\n}\r\n```\r\n- after：可以轻松选择使用哪些子组件, 也能灵活的调换子组件的位置。\r\n  1. 创建Context和父组件，并提供子组件所需状态。\r\n  ```\r\n  import { createContext, useContext, useState } from "react";\r\n\r\n  const CounterContext = createContext();\r\n\r\n  export default function Counter({ children }) {\r\n    const [count, setCount] = useState(0);\r\n\r\n    const increase = () => setCount((c) => c + 1);\r\n    const decrease = () => setCount((c) => c - 1);\r\n\r\n    return (\r\n      <CounterContext.Provider value={{ count, increase, decrease }}>\r\n        <span>{children}</span>\r\n      </CounterContext.Provider>\r\n    );\r\n  }\r\n  ```\r\n  2. 创建子组件用于实现通用功能。\r\n  ```\r\n  function Label({ children }) {\r\n    return <span>{children}</span>;\r\n  }\r\n  function Count() {\r\n    const { count } = useContext(CounterContext);\r\n    return <span>{count}</span>;\r\n  }\r\n  function Increase({ icon }) {\r\n    const { increase } = useContext(CounterContext);\r\n    return <button onClick={increase}>{icon}</button>;\r\n  }\r\n  function Decrease({ icon }) {\r\n    const { decrease } = useContext(CounterContext);\r\n    return <button onClick={decrease}>{icon}</button>;\r\n  }\r\n  ```\r\n  3. 将子组件作为属性添加到父组件上。\r\n  ```\r\n  Counter.Label = Label;\r\n  Counter.Count = Count;\r\n  Counter.Increase = Increase;\r\n  Counter.Decrease = Decrease;\r\n  ```\r\n  4. 灵活的使用Counter组件。\r\n  ```\r\n  import Counter from "./Counter";\r\n\r\n  export default function App() {\r\n    return (\r\n      <div>\r\n        <h1>Compound Component Pattern</h1>\r\n        <Counter>\r\n          <Counter.Label>My super flexible counter</Counter.Label>\r\n          <Counter.Decrease icon="-" />\r\n          <Counter.Count />\r\n          <Counter.Increase icon="+" />\r\n        </Counter>\r\n      </div>\r\n    );\r\n  }\r\n  ```\r\n### 高阶组件模式\r\n- before：当有新的需求时无法更改ProductList组件，一个按钮用来控制列表是否展示；一个按钮用来控制列表折叠（只显示三条）；展示产品的标题。\r\n```\r\nfunction ProductItem({ product }) {\r\n  return (\r\n    <li className="product">\r\n      <p className="product-name">{product.productName}</p>\r\n      <p className="product-price">${product.price}</p>\r\n      <p className="product-description">{product.description}</p>\r\n    </li>\r\n  );\r\n}\r\n// 假设该组件不可更改\r\nfunction ProductList({ title, items }) {\r\n  return (\r\n    <ul className="list">\r\n      {items.map((product) => (\r\n        <ProductItem key={product.productName} product={product} />\r\n      ))}\r\n    </ul>\r\n  );\r\n}\r\n```\r\n- after：使用高阶组件在不修改ProductList组件的情况下完成这三个需求。\r\n  1. 高阶组件\r\n  ```\r\n  import { useState } from "react";\r\n\r\n  //高阶组件通常以 withXXX开头\r\n  export default function withToggles(WrappedComponent) {\r\n    return function List(props) {\r\n      // 控制展示\r\n      const [isOpen, setIsOpen] = useState(true);\r\n      // 控制折叠\r\n      const [isCollapsed, setIsCollapsed] = useState(false);\r\n\r\n      const displayItems = isCollapsed ? props.items.slice(0, 3) : props.items;\r\n\r\n      function toggleOpen() {\r\n        setIsOpen((isOpen) => !isOpen);\r\n        setIsCollapsed(false);\r\n      }\r\n\r\n      return (\r\n        <div className="list-container">\r\n          <div className="heading">\r\n            // 展示标题\r\n            <h2>{props.title}</h2>\r\n            <button onClick={toggleOpen}>\r\n              {isOpen ? <span>&or;</span> : <span>&and;</span>}\r\n            </button>\r\n          </div>\r\n          {isOpen && <WrappedComponent {...props} items={displayItems} />}\r\n\r\n          <button onClick={() => setIsCollapsed((isCollapsed) => !isCollapsed)}>\r\n            {isCollapsed ? `Show all ${props.items.length}` : "Show less"}\r\n          </button>\r\n        </div>\r\n      );\r\n    };\r\n  }\r\n  ```\r\n  2. 使用高阶组件\r\n  ```\r\n  import withToggle from "./HOC.js";\r\n\r\n  const ProductListWithToggles = withToggle(ProductList);\r\n  export default function App() {\r\n    return (\r\n      <div>\r\n        <h1>Render Props Demo</h1>\r\n        <div className="col-2">\r\n          <ProductListWithToggles\r\n            title="ProductListWithToggle"\r\n            items={products}\r\n          />\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n  ```\r\n### 渲染属性模式\r\n- 复用List组件展示ProductItem和CompanyItem, 可以使用render props去代替之前的渲染逻辑。\r\n```\r\nfunction List({ title, items, render }) {\r\n  const [isOpen, setIsOpen] = useState(true);\r\n  const [isCollapsed, setIsCollapsed] = useState(false);\r\n\r\n  const displayItems = isCollapsed ? items.slice(0, 3) : items;\r\n\r\n  function toggleOpen() {\r\n    setIsOpen((isOpen) => !isOpen);\r\n    setIsCollapsed(false);\r\n  }\r\n\r\n  return (\r\n    <div className="list-container">\r\n      <div className="heading">\r\n        <h2>{title}</h2>\r\n        <button onClick={toggleOpen}>\r\n          {isOpen ? <span>&or;</span> : <span>&and;</span>}\r\n        </button>\r\n      </div>\r\n      // 渲染逻辑\r\n      {isOpen && <ul className="list">{displayItems.map(render)}</ul>}\r\n\r\n      <button onClick={() => setIsCollapsed((isCollapsed) => !isCollapsed)}>\r\n        {isCollapsed ? `Show all ${items.length}` : "Show less"}\r\n      </button>\r\n    </div>\r\n  );\r\n}\r\n```\r\n- 使用时传入render属性\r\n```\r\nexport default function App() {\r\n  return (\r\n    <div>\r\n      <h1>Render Props Demo</h1>\r\n\r\n      <div className="col-2">\r\n        <List\r\n          title="Products"\r\n          items={products}\r\n          render={(product) => (\r\n            <ProductItem key={product.productName} product={product} />\r\n          )}\r\n        />\r\n        <List\r\n          title="CompanyItem"\r\n          items={companies}\r\n          render={(companie) => (\r\n            <CompanyItem\r\n              key={companie.companyName}\r\n              company={companie}\r\n              defaultVisibility={false}\r\n            />\r\n          )}\r\n        />\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n```'},function(r,n,e){"use strict";e.r(n),n.default='## [react渲染](https://juejin.cn/post/7121378029682556958)\r\n### React element(初始元素)\r\n> 通过React.createElement创建的类似真实DOM的元素，比如在开发中通过语法糖jsx写出来的html结构都是React element。\r\n\r\n### React vDom(虚拟节点)\r\n> React会根据初始元素或其它可以生成虚拟节点的东西生成虚拟节点。React是通过虚拟节点来进行渲染的。\r\n\r\n#### 虚拟DOM节点(ReactDomComponent)\r\n- 当初始元素的type属性为字符串的时候React就会创建虚拟DOM节点。\r\n#### 虚拟组件节点(ReactComposite)\r\n- 当初始元素的type属性为函数或是类的时候React就会创建虚拟组件节点。\r\n#### 虚拟文本节点(ReactTextNode)\r\n- 直接书写字符串或者数字React会创建为虚拟文本节点。\r\n#### 虚拟空节点(ReactEmpty)\r\n- 当遇到字面量null、false、true、undefined在React中均会被创建为一个虚拟空节点。在渲染过程中如果遇到虚拟空节点，那么它将什么都不会做。\r\n#### 虚拟数组节点（ReactArrayNode）\r\n- 当React遇到数组时会创建虚拟数组节点。但是不会直接进行渲染，而是将数组里的每一项拿出来，根据不同的节点类型去做相应的事情。\r\n- 数组里的每一项只能是这里提到的五个虚拟节点类型。\r\n### 真实DOM(UI)\r\n> 通过document.createElement创建的元素就是真实DOM。\r\n\r\n### 渲染原理\r\n- React的工作是通过初始元素或可以生成虚拟节点的东西生成虚拟节点然后针对不同的节点类型去做不同的事情最终生成真实DOM挂载到页面上，对象不能直接被渲染是因为它生成不了虚拟节点。\r\n![渲染原理](./img/渲染原理.png)\r\n\r\n### 首次渲染阶段\r\n#### 虚拟DOM节点\r\n- 对于初始元素的type属性为字符串时(虚拟DOM节点)，React会通过document.createElement创建真实DOM。\r\n- 创建完真实DOM后会立即设置该真实DOM的所有属性，比如我们直接在jsx中书写的className、style等属性都会作用到真实DOM上。\r\n- 在设置完属性后React会根据children属性进行递归遍历，根据不同的节点类型去做不同的事情。\r\n#### 虚拟组件节点\r\n- 函数组件\r\n  1. 对于函数组件会直接调用函数，将函数的返回值进行递归处理，根据不同的节点类型去做不同的事情，最终生成一颗vDOM树。\r\n\r\n- 类组件\r\n  1. 首先创建类的实例(调用constructor)。\r\n  2. 调用生命周期方法static getDerivedStateFromProps。\r\n  3. 调用生命周期方法render，根据返回值进行递归处理。跟函数组件处理返回值一样，最终生成一颗vDom树。\r\n  4. 将该组件的生命周期方法componentDidMount加入到执行队列中等待真实DOM挂载到页面后执行(注意：前面说了render是一个递归处理，所以如果一个组件存在父子关系的时候，那么肯定要等子组件渲染完父组件才能走出render，所以子组件的componentDidMount一定是比父组件先入队列的，肯定先运行)。\r\n#### 虚拟文本节点\r\n- 针对虚拟文本节点，React会通过document.createTextNode创建真实的文本节点。\r\n#### 虚拟空节点\r\n- 针对虚拟空节点，React什么都不会做。\r\n#### 虚拟数组节点\r\n- React不会直接渲染数组，而是将里面的每一项拿出来遍历，根据不同的节点类型去做不同的事，直到递归处理完数组里的每一项。\r\n### 首次渲染例子\r\n> 控制台执行顺序是111、222、444、555、666、333。\r\n\r\n```\r\nimport React from \'react\';\r\nimport ReactDOM from \'react-dom/client\';\r\nconst root = ReactDOM.createRoot(document.getElementById(\'root\'));\r\n\r\n/**\r\n * 组件节点-类组件\r\n */\r\nclass ClassSon extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n    console.log("444 ClassSon constructor");\r\n  }\r\n\r\n  static getDerivedStateFromProps(props, state) {\r\n    console.log("555 ClassSon getDerivedStateFromProps");\r\n    return {};\r\n  }\r\n\r\n  componentDidMount() {\r\n    console.log("666 ClassSon componentDidMount");\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <div className="func-wrapper">\r\n        <span>\r\n          textNode22\r\n          {undefined}\r\n        </span>\r\n        {[false, "textNode33", <div>textNode44</div>]}\r\n      </div>\r\n    )\r\n  }\r\n}\r\n\r\n/**\r\n* 组件节点-类组件\r\n*/\r\nclass ClassComp extends React.Component {\r\n\r\n  constructor(props){\r\n    super(props);\r\n    console.log("111 ClassComp constructor");\r\n  }\r\n\r\n  static getDerivedStateFromProps(props, state){\r\n    console.log("222 ClassComp getDerivedStateFromProps");\r\n    return {};\r\n  }\r\n\r\n  componentDidMount(){\r\n    console.log("333 ClassComp componentDidMount");\r\n  }\r\n  \r\n  render() {\r\n    return (\r\n      <div className="class-wrapper">\r\n        <ClassSon />\r\n        <p>textNode11</p>\r\n        {123456789}\r\n      </div>\r\n    )\r\n  }\r\n}\r\n\r\nroot.render(<ClassComp />);\r\n```\r\n![首次渲染](./img/首次渲染.png)\r\n### 组件更新阶段\r\n> 使用setState来重新设置组件的状态进行重新渲染。使用setState只会更新调用此方法的类，不会涉及到兄弟节点以及父级节点，影响范围仅仅是自己的子节点。\r\n\r\n1. 运行当前类组件的生命周期静态方法static getDerivedStateFromProps。根据返回值合并当前组件的状态。\r\n2. 运行当前类组件的生命周期方法shouldComponentUpdate。如果该方法返回的false，直接终止更新流程。\r\n3. 运行当前类组件的生命周期方法render得到一个新的vDom树，进入新旧两棵树的对比更新。\r\n4. 将当前类组件的生命周期方法getSnapshotBeforeUpdate加入执行队列，等待将来执行。\r\n5. 将当前类组件的生命周期方法componentDidUpdate加入执行队列，等待将来执行。\r\n6. 重新生成vDom树。\r\n7. 根据vDom树更新真实DOM.\r\n8. 执行队列，此队列存放的是更新过程中所有新建类组件的生命周期方法componentDidMount。\r\n9. 执行队列，此队列存放的是更新过程涉及到原本存在的类组件的生命周期方法getSnapshotBeforeUpdate。\r\n10. 执行队列，此队列存放的是更新过程涉及到原本存在的类组件的生命周期方法componentDidUpdate。\r\n11. 执行队列，此队列存放的是更新过程中所有卸载的类组件的生命周期方法componentWillUnMount。\r\n### 根节点更新(ReactDOM.createRoot().render)\r\n> 无论我们在嵌套多少的组件里去调用控制区域.render，都会直接触发根节点的对比更新。一般不会这么操作，如果触发了根节点的更新，那么后续步骤是上面组件更新的6-11步。\r\n\r\n### Diff对比-节点类型一致\r\n#### 虚拟DOM节点\r\n- 如果是虚拟DOM节点，React会直接重用之前的真实DOM。将这次变化的属性记录下来，等待将来完成更新。然后遍历其子节点进行递归对比更新。\r\n#### 虚拟组件节点\r\n- 函数组件\r\n> React会重新调用函数拿到新的vDom树，然后递归进行对比更新。\r\n\r\n- 类组件\r\n> React也会重用之前的实例对象，后续步骤如下。\r\n\r\n  1. 运行生命周期静态方法static getDerivedStateFromProps。将返回值合并当前状态。\r\n  2. 运行生命周期方法shouldComponentUpdate，如果该方法返回false，终止当前流程。\r\n  3. 运行生命周期方法render，得到新的vDom树，进行新旧两棵树的递归对比更新。\r\n  4. 将生命周期方法getSnapshotBeforeUpdate加入到队列等待执行。\r\n  5. 将生命周期方法componentDidUpdate加入到队列等待执行。\r\n#### 虚拟文本节点\r\n- 如果是虚拟文本节点，React也会重用之前的真实文本节点。将新的文本记录下来，等待将来统一更新(设置nodeValue)。\r\n#### 虚拟空节点\r\n- 针对虚拟空节点，React什么都不会做。\r\n#### 虚拟数组节点\r\n- React不会直接渲染数组，而是将里面的每一项拿出来遍历，根据不同的节点类型去做不同的事，直到递归处理完数组里的每一项。\r\n### Diff对比-节点类型不一致\r\n> 如果找到了对比目标但是发现节点类型不一致，React会认为连类型都变了那么你的子节点肯定也都不一样了。就算一万个子节点，并且他们都是没有变化的，只要最外层的父节点的节点类型变了，照样会全部进行卸载重新创建，与其去一个个递归查看子节点，不如直接全部卸载重新新建。\r\n\r\n![节点类型不一致](./img/节点类型不一致.png)\r\n### Diff对比-未找到对比目标\r\n- 如果未找到对比的目标，跟节点类型不一致的做法类似，那么对于多出的节点进行挂载流程，对于旧节点进行卸载直接弃用，如果其包含子节点进行递归卸载，对于虚拟类组件节点会多一个步骤，那就是运行生命周期方法componentWillUnmount。\r\n- 应尽量保持结构的稳定性，如果未添加key的情况下，兄弟节点更新位置前后错位一个那么后续全部的比较都会错位导致找不到对比目标从而进行卸载新建流程，对性能大打折扣。\r\n![未找到对比目标](./img/未找到对比目标.png)\r\n> 从图中可以看到，经过条件渲染前后button理论上没有任何变化的情况下，照样没有重用之前的真实DOM，如果在button之后还有一万个兄弟节点，那么也全部都找不到对比目标从而进行卸载重新创建流程。所以在进行条件渲染显示隐藏时，官方推荐以下做法：\r\n\r\n  - 控制style：visibility来控制显示隐藏。\r\n  - 在隐藏时给一个空节点来保证对比前后能找到同一位置。不影响后续兄弟节点的比较。\r\n'},function(r,n,e){"use strict";e.r(n),n.default="## react错误捕获\r\n### 错误捕获的组件(参考官方文档实现)\r\n```\r\nimport React from 'react';\r\n\r\nexport default class ErrorBoundary extends React.Component {\r\n  state = {\r\n    hasError: false,\r\n  }\r\n\r\n  static getDerivedStateFromError() {\r\n    // 更新 state 使下一次渲染能够显示降级后的 UI\r\n    return { hasError: true };\r\n  }\r\n\r\n  componentDidCatch() {\r\n    this.setState({\r\n      hasError: true\r\n    })\r\n  }\r\n\r\n  render() {\r\n    const { tip } = this.props;\r\n    if (this.state.hasError) {\r\n      // 可以自定义降级后的 UI 并渲染\r\n      return <h1>{tip}</h1>;\r\n    }\r\n    return this.props.children; \r\n  }\r\n}\r\n```\r\n### react的ErrorBoundary如果直接包裹在jsx外，jsx中的错误无法捕捉到，只能捕捉到jsx中组件内的错误，正如官方所说的可以捕获发生在其子组件树任何位置的 JavaScript错误，并打印这些错误，同时展示降级UI。\r\n> 如下实例，demoOne中的jsx错误无法被ErrorBoundary捕获到，但是demoTwo中的错误可以被捕获到。\r\n\r\n```\r\n// demoOne\r\nimport React, { Component } from 'react';\r\nimport ErrorBoundary from 'components/errorBoundary';\r\n\r\nexport default class JsxTestOne extends Component {\r\n  render() {\r\n    return (\r\n      <ErrorBoundary tip=\"JsxTestOne 组件的ErrorBoundary\">\r\n        <div>ErrorBoundary直接包裹jsx无法捕捉错误</div>\r\n        <div>{user.name}</div>\r\n      </ErrorBoundary>\r\n    )\r\n  }\r\n}\r\n\r\n// demoTwo\r\nimport React, { Component } from 'react';\r\nimport ErrorBoundary from 'components/errorBoundary';\r\n\r\nclass Demo extends Component {\r\n  render() {\r\n    return (\r\n      <div>\r\n        <div>ErrorBoundary包裹组件可以捕捉错误</div>\r\n        <div>{user.name}</div>\r\n      </div>\r\n    )\r\n  }\r\n}\r\n\r\nexport default class JsxTestTwo extends Component {\r\n  render() {\r\n    return (\r\n      <ErrorBoundary tip=\"JsxTestTwo 组件的ErrorBoundary\">\r\n        <Demo />\r\n      </ErrorBoundary>\r\n    )\r\n  }\r\n}\r\n```\r\n### 一个后代组件抛错，可以被包裹其的祖先组件的ErrorBoundary组件catch到错误，但是会优先被最近包裹其的祖先组件的ErrorBoundary组件catch到错误\r\n> 如下的实例DemoThree抛错，会优先被包裹DemoThree的ErrorBoundary(tip=\"最外层子组件组件的ErrorBoundary组件\")组件catch到错误。如果DemoThree外不包裹ErrorBoundary，将会被包裹DemoTwo的ErrorBoundary(tip=\"最外层组件的ErrorBoundary组件\")组件catch到错误。\r\n\r\n```\r\n// demoOne\r\nimport React, { Component } from 'react';\r\nimport ErrorBoundary from 'components/errorBoundary';\r\nimport DemoTwo from './demoTwo';\r\n\r\nexport default class DemoOne extends Component {\r\n  render() {\r\n    return (\r\n      <div style={{ border: '1px solid green', margin: '20px 0'}}>\r\n        <div>最外层的组件</div>\r\n        <ErrorBoundary tip=\"最外层组件的ErrorBoundary组件\">\r\n          <DemoTwo />\r\n        </ErrorBoundary>\r\n      </div>\r\n    )\r\n  }\r\n}\r\n\r\n// demoTwo\r\nimport React, { Component } from 'react';\r\nimport ErrorBoundary from 'components/errorBoundary';\r\nimport DemoThree from './demoThree';\r\n\r\nexport default class DemoTwo extends Component {\r\n  state={\r\n    user: null\r\n  }\r\n  render() {\r\n    return (\r\n      <div style={{ border: '1px solid red', margin: '20px'}}>\r\n        <div>最外层的子组件</div>\r\n        <div onClick={() => this.setState({ user: { name: 'dyx' }})}>设置user</div>\r\n        <ErrorBoundary tip=\"最外层子组件组件的ErrorBoundary组件\">\r\n          <DemoThree user={this.state.user} />\r\n        </ErrorBoundary>\r\n      </div>\r\n    )\r\n  }\r\n}\r\n\r\n// demoThree\r\nimport React, { Component } from 'react';\r\n\r\nexport default class DemoThree extends Component {\r\n  render() {\r\n    const { user } = this.props;\r\n    return (\r\n      <div style={{ border: '1px solid blue', margin: '20px'}}>\r\n        最外层的孙组件\r\n        {user.name}\r\n      </div>\r\n    )\r\n  }\r\n}\r\n```\r\n### 生命周期函数的错误可以被ErrorBoundary组件catch到\r\n> 如下实例，生命周期的方法中错误会显示回退的UI。\r\n\r\n```\r\nimport React, { Component } from 'react';\r\nimport ErrorBoundary from 'components/errorBoundary';\r\n\r\nclass Demo extends Component {\r\n  componentDidMount() {\r\n    console.log(a)\r\n  }\r\n  render() {\r\n    return (\r\n      <div>\r\n        生命周期的错误\r\n      </div>\r\n    )\r\n  }\r\n}\r\n\r\nexport default class CyclifeTest extends Component {\r\n  render() {\r\n    return (\r\n      <ErrorBoundary tip=\"生命周期的错误捕捉的ErrorBoundary\">\r\n        <Demo />\r\n      </ErrorBoundary>\r\n    )\r\n  }\r\n}\r\n```\r\n### 事件处理的错误不会被ErrorBoundary组件catch到\r\n> 如下实例demoOne中func中的错误并不会被catch到，正如官方文档所说React不需要错误边界来捕获事件处理器中的错误。与render方法和生命周期方法不同，事件处理器不会在渲染期间触发。因此如果它们抛出异常React仍然能够知道需要在屏幕上显示什么。但是demTwo中如果func中的处理导致render函数或者生命周期逻辑抛错则是可以被catch到的。\r\n\r\n- 事件处理的错误不影响render函数和生命周期的正常逻辑，不会被ErrorBoundary组件catch。\r\n```\r\n// demoOne\r\nimport React, { Component } from 'react';\r\nimport ErrorBoundary from 'components/errorBoundary';\r\n\r\nclass DemoOne extends Component {\r\n  state = {\r\n    user: { name: 'dyx' },\r\n  }\r\n\r\n  func = () => {\r\n    console.log(a)\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <div onClick={this.func}>\r\n        事件处理的错误\r\n        <div>{this.state.user.name}</div>\r\n      </div>\r\n    )\r\n  }\r\n}\r\n\r\nexport default class FuncTest extends Component {\r\n  render() {\r\n    return (\r\n      <ErrorBoundary tip=\"事件处理的错误捕捉的ErrorBoundary\">\r\n        <DemoOne />\r\n      </ErrorBoundary>\r\n    )\r\n  }\r\n}\r\n```\r\n- 事件处理的错误影响render函数和生命周期的正常逻辑，会被ErrorBoundary组件catch。\r\n```\r\n// demoTwo\r\nimport React, { Component } from 'react';\r\nimport ErrorBoundary from 'components/errorBoundary';\r\n\r\nclass DemoTwo extends Component {\r\n  state = {\r\n    user: { name: 'dyx' },\r\n  }\r\n\r\n  func = () => {\r\n    this.setState({\r\n      user: null\r\n    })\r\n    console.log(a)\r\n  }\r\n\r\n  componentDidUpdate() {\r\n    console.log(this.state.user.name)\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <div onClick={this.func}>\r\n        事件处理的错误\r\n        <div>{this.state.user.name}</div> \r\n      </div>\r\n    )\r\n  }\r\n}\r\n\r\nexport default class FuncTest extends Component {\r\n  render() {\r\n    return (\r\n      <ErrorBoundary tip=\"事件处理的错误捕捉的ErrorBoundary\">\r\n        <Demo />\r\n      </ErrorBoundary>\r\n    )\r\n  }\r\n}\r\n```\r\n### 如果一个组件抛错，显示了回退的UI，此时我们在其父组件中修改此错误还是会显示回退的UI，不会正常渲染组件，所以如果错误是因为接口数据错误导致的，此时重新获取接口数据，并不会使错误的组件正常渲染，reload才会有效。\r\n> 如下实例中子组件渲染出错，此时在父组件中修改传给子组件的属性，即使此时子组件中的逻辑正确，依然不能正常渲染，因为此时ErrorBoundary中的hasError状态已经是true，所以只会显示回退的UI。\r\n\r\n```\r\n// 父组件\r\nimport React, { Component } from 'react';\r\nimport ErrorBoundary from 'components/errorBoundary';\r\nimport DemoThree from './demoThree';\r\n\r\nexport default class Demo extends Component {\r\n  state={\r\n    user: null\r\n  }\r\n  render() {\r\n    return (\r\n      <div style={{ border: '1px solid red', margin: '20px'}}>\r\n        <div onClick={() => this.setState({ user: { name: 'dyx' } })}>设置user</div>\r\n        <ErrorBoundary tip=\"最外层组件的ErrorBoundary组件\">\r\n          <DemoOne user={this.state.user} />\r\n        </ErrorBoundary>\r\n      </div>\r\n    )\r\n  }\r\n}\r\n\r\n// 子组件\r\nimport React, { Component } from 'react';\r\n\r\nexport default class DemoOne extends Component {\r\n  render() {\r\n    const { user } = this.props;\r\n    return (\r\n      <div style={{ border: '1px solid blue', margin: '20px'}}>\r\n        {user.name}\r\n      </div>\r\n    )\r\n  }\r\n}\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## ref\r\n### string ref\r\n> 这种方式已经被React官方废弃。\r\n\r\n### callback ref\r\n> ref属性传递函数时，会在commit阶段创建真实DOM时执行ref指定的函数，并将元素作为第一个参数传入，此时我们就可以利用它进行赋值以获取DOM元素或组件实例。\r\n\r\n### object ref\r\n> 常用的方式，使用createRef或者useRef创建Ref对象，并将其传给标签的ref属性即可，这种方式获取到的ref需要先调用current属性才能获取到对应的DOM元素或组件实例。\r\n\r\n- createRef\r\n> 不能在函数组件中使用createRef，因为每次函数组件渲染都是一次新的函数执行，每次执行createRef得到的都是一个新的对象，无法保留其原来的引用。\r\n\r\n```\r\nexport function createRef(): RefObject {\r\n  const refObject = {\r\n    current: null,\r\n  }\r\n  return refObject;\r\n}\r\n```\r\n- useRef\r\n> 函数组件中使用useRef创建Ref对象，React会将useRef和函数组件对应的fiber对象关联，将useRef创建的ref对象挂载到对应的fiber对象上，每次函数组件执行，只要函数组件不被销毁，那么对应的fiber对象实例也会一直存在，所以ref也能够被保留下来。"},function(r,n,e){"use strict";e.r(n),n.default="## renderProps\r\n- 组件Props的key为render，值为一个函数。\r\n- renderProps是组件用来确定渲染什么内容的Props，renderProps的函数会返回渲染的结果，从而使得该组件的内容得到动态渲染。\r\n```\r\n// 定义renderProps，作用是为了更好地复用Mouse组件\r\n<Mouse render={mouse => <Cat mouse={mouse} />} />\r\n\r\n// 在Mouse组件中传入一个值，会根据传入的值动态渲染renderProps的内容\r\n{this.props.render(this.state)}\r\n```\r\n### renderProps优点\r\n- render函数可以通过参数拿到组件内部状态、方法、任意数据。在方法内也可调用当前组件的状态、方法、props等任何数据。\r\n- 可以进行组件的复用，把组件无关的视图渲染逻辑抽象出来，交给用户自己定义。"},function(r,n,e){"use strict";e.r(n),n.default="## react-router\r\n### router中路由切换window的滚动条位置会被记录\r\n### 路由组件渲染使用render和children的差异\r\n- 使用children无论是否匹配都会渲染，使用render只有匹配上才会渲染。\r\n### react路由跳转携带参数\r\n- 使用params，会体现在url上，刷新数据不会丢失\r\n```\r\n{ path: '/detail/:id/:name', component: Detail },\r\n\r\n// 取值\r\nthis.props.match.params.id\r\n```\r\n- 使用query，不会体现在url上，刷新数据会丢失\r\n```\r\nhistory.push({ pathname: '', query: { flag: true } })\r\n\r\n// 取值\r\nthis.props.location.query.flag\r\n```\r\n- 使用state，不会体现在url上，刷新数据会丢失\r\n```\r\nhistory.push({ pathname: '', state: { flag: true} })\r\n\r\n// 取值\r\nthis.props.location.state.flag\r\n```\r\n- search传参，直接在pathname上拼接search，会体现在url上，刷新数据不会丢失\r\n```\r\nhistory.push({ pathname:'/settings/userinfos/mobile', search: '?from=user' })\r\nhistory.push(\"/settings/userinfos/mobile?from=user\")\r\n\r\n// 取值\r\nthis.props.location.search\r\n```\r\n### react-router-dom的抛错\r\n- Invalid prop `component` of type `object` supplied to `Route`, expected `function`\r\n```\r\n// 使用这样会报错\r\n<Route exact path=\"/upload\" component={UploadFile} />\r\n\r\n// 修改如下不会报错\r\n<Route exact path=\"/upload\" render={(props) => <UploadFile {...props} />} />\r\n```\r\n- Switch直接写元素会有warning提示\r\n### react路由切换动画\r\n- react-router-transition\r\n- 当使用类似整体路由模块的时候切换匹配到模块中的某一个时没有动画，因为匹配到的整体路由组件一直在挂载中，所以切换路由，没有办法捕获到组件切换的时机所以没有动画。\r\n```\r\nimport { AnimatedSwitch } from 'react-router-transition';\r\n\r\n<Router>\r\n  <AnimatedSwitch\r\n    atEnter={{ opacity: 0 }}\r\n    atLeave={{ opacity: 0 }}\r\n    atActive={{ opacity: 1 }}\r\n    className=\"switch-wrapper\"\r\n  >\r\n    <Route exact path=\"/\" component={Home} />\r\n    <Route path=\"/about/\" component={About} />\r\n    <Route path=\"/etc/\" component={Etc} />\r\n  </AnimatedSwitch>\r\n</Router>\r\n```\r\n### react异步加载路由上线后报loading chunk fail的解决\r\n```\r\ncomponentDidCatch(error, info) {\r\n  if (String(error).includes('Loading chunk')) {\r\n    window.location.reload();\r\n  }\r\n}\r\n```\r\n### basename (v4版本)\r\n- Router组件不支持basename，但是支持传入自定义的history。\r\n- BrowserRouter组件支持basename，但是不支持传入自定义的history。\r\n- 设置basename后使用router的history跳转时无需添加basename的路由前缀，但是使用自定义的history跳转时会有问题。"},function(r,n,e){"use strict";e.r(n),n.default="## setState(同步)\r\n- setState本身并不是异步的，而是如果在调用setState时，如果react正处于更新过程，当前更新会被暂存，等上一次更新执行完成后再执行，这个过程给人一种异步的假象。\r\n- 在react的生命周期和合成事件中，react仍然处于他的更新机制中，这时isBatchingUpdates为true。这时无论调用多少次setState，都不会立即执行更新，而是将要更新的state存入_pendingStateQueue，将要更新的组件存入dirtyComponent。当上一次更新机制执行完毕后会将isBatchingUpdates设置为false。这时将执行之前累积的setState。\r\n### 同步异步场景(setState、useState表现相同)\r\n- 钩子函数和React合成事件中的setState不是立即执行的。\r\n- 异步函数(setTimeout、 Promise的then回调)和原生事件中(addEventListener)的setstate是立即执行的。\r\n### setState异步假象\r\n1. 开始运行\r\n2. 结束运行\r\n3. 新增粉丝数\r\n```\r\nhandleClick = () => {\r\n  const fans = Math.floor(Math.random() * 10)\r\n  console.log('开始运行')\r\n  this.setState({\r\n    count: this.state.count + fans\r\n  }, () => {\r\n    console.log('新增粉丝数:', fans)\r\n  })\r\n  console.log('结束运行')\r\n}\r\n```\r\n### setState执行早于宏任务和微任务\r\n1. 新增粉丝数\r\n2. 微任务触发\r\n3. 宏任务触发\r\n```\r\nhandleClick = () => {\r\n  const fans = Math.floor(Math.random() * 10)\r\n  setTimeout(() => {\r\n    console.log('宏任务触发')\r\n  })\r\n  Promise.resolve().then(() => {\r\n    console.log('微任务触发')\r\n  })\r\n  this.setState({\r\n    count: this.state.count + fans\r\n  }, () => {\r\n    console.log('新增粉丝数:', fans)\r\n  })\r\n}\r\n```\r\n### setState同步现象\r\n> 在React的生命周期钩子函数以及合成事件中，所有的setState操作会先缓存到一个队列中，在整个事件结束后或者mount流程结束后，才会取出之前缓存的setState队列进行一次计算，触发state更新。只要我们跳出React的事件流或者生命周期，就能打破React对setState的掌控。最简单的方法就是把setState放到setTimeout的匿名函数中。\r\n\r\n1. 开始运行\r\n2. 新增粉丝数\r\n3. 结束运行\r\n```\r\nhandleClick = () => {\r\n  setTimeout(() => {\r\n    const fans = Math.floor(Math.random() * 10)\r\n    console.log('开始运行')\r\n    this.setState({\r\n      count: this.state.count + fans\r\n    }, () => {\r\n      console.log('新增粉丝数:', fans)\r\n    })\r\n    console.log('结束运行')\r\n  })\r\n}\r\n```\r\n### 造成state更新延迟的原因\r\n- setState方法最终会调用enqueueSetState方法，而enqueueSetState方法内部会调用scheduleUpdateOnFiber方法。\r\n- 正常调用的时候，scheduleUpdateOnFiber方法内只会调用ensureRootIsScheduled，在事件方法结束后才会调用flushSyncCallbackQueue方法​。\r\n- 脱离React事件流的时候，scheduleUpdateOnFiber在ensureRootIsScheduled调用结束后，会直接调用flushSyncCallbackQueue方法。\r\n- flushSyncCallbackQueue方法就是用来更新state并重新进行render。\r\n```\r\nfunction scheduleUpdateOnFiber(fiber, lane, eventTime) {\r\n  if (lane === SyncLane) {\r\n    // 同步操作\r\n    ensureRootIsScheduled(root, eventTime);\r\n    // 判断当前是否还在 React 事件流中\r\n    // 如果不在，直接调用 flushSyncCallbackQueue 更新\r\n    if (executionContext === NoContext) {\r\n      flushSyncCallbackQueue();\r\n    }\r\n  } else {\r\n    // 异步操作\r\n  }\r\n}\r\n```\r\n### 调用setState就会重新渲染\r\n> setState调用就会引起就会组件重新渲染，即使这个状态没有参与页面渲染，所以不要把非渲染属性放state里面，即使放在了state也不要通过setState去修改这个状态，直接调用this.state.xxx = xxx，或者这种不参与渲染的属性直接挂在this上。\r\n\r\n- 直接调用setState，无参数也会重新渲染。\r\n- 新state和老state完全一致也会重新渲染(useState更新相同的状态不会重新渲染)。\r\n### React 18中setState自动批处理\r\n- 自动批处理是指React将多次setState会被合并为1次执行。\r\n- 在React 18之前，React只会在合成事件和生命周期钩子函数中使用批处理，而在Promise、setTimeout、setInterval、原生事件是不会自动批处理的。\r\n- 在React 18中所有的状态更新都会自动使用批处理。如果在某种场景下不想使用批处理，可以通过flushSync来强制立即执行(比如需要在状态更新后，立刻读取新DOM上的数据等)。\r\n### setState为什么设计成异步 \r\n- 保证state和props的一致性\r\n  1. props必然是异步的, 因为只有当父组件重渲染了才知道props是什么，那么保证props和state一致性就很重要了, 因为实际开发中经常会将状态提升到父组件和兄弟组件进行共享, 如果state和props表现不一致那么这个操作很大概率就会引起一些bug。\r\n- 提高性能：在渲染前会有意地进行等待, 直到所有在组件的事件处理函数内调用的setState()完成之后,统一更新 state, 这样可以通过避免不必要的重新渲染来提升性能。\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## state和props\r\n> state和props的改变都会导致组件重新render。\r\n\r\n- state用于组件内部数据传递，state数据可以通过this.setState或者useState进行修改。\r\n- props用于组件之间的通信，props不能直接修改。"},function(r,n,e){"use strict";e.r(n),n.default="## useEffect和useLayoutEffect\r\n### useEffect\r\n- useEffect用来取代componentDidMount和componentDidUpdate。\r\n- 主要用于浏览器绘制之后进行一些副作用操作(比如访问DOM，请求数据)。\r\n### useLayoutEffect\r\n- useLayoutEffect中的代码以及其中任何计划的状态更新都会在浏览器重新绘制之前得到处理。\r\n- useLayoutEffect可能会影响性能，尽可能使用useEffect。\r\n### 区别\r\n- useEffect在浏览器重新绘制之后触发，useLayoutEffect在浏览器重新绘制之前触发。\r\n- useEffect异步执行不会阻塞浏览器绘制，useLayoutEffect同步执行会阻塞浏览器绘制。\r\n### 示例\r\n> 一次事件循环结束后浏览器会更新渲染。在React的底层处理中，useEffect的执行是在一个新生成的宏任务中执行的，而useLayoutEffect的执行还是在上一个宏任务重执行的。所以两者的执行时机主要差异是浏览器是否完成了更新渲染。\r\n\r\n- 为了使效果更明显在渲染期间人为地添加了延迟。\r\n- 使用useEffect时会在浏览器绘制之后再处理useEffect内部的状态更新，点击数字之后会先显示0再显示随机数，页面会有抖动效果。\r\n- 使用useLayoutEffect时会在浏览器绘制之前就处理useLayoutEffect内部的状态更新(所以useLayoutEffect会阻塞浏览器绘制)，点击数字之后会直接显示最后的随机数，页面没有抖动效果。\r\n```\r\nimport React, { useLayoutEffect, useEffect, useState } from 'react';\r\n\r\nconst App = () => {\r\n  const [count, setCount] = useState(0);\r\n  \r\n  // 人为地减慢了渲染\r\n  const now = performance.now();\r\n  while (performance.now() - now < 100) {\r\n    // 不做任何事情...\r\n  }\r\n\r\n  useEffect(() => {\r\n    if (count === 0) {\r\n      setCount(10 + Math.random() * 200);\r\n    }\r\n  }, [count]);\r\n\r\n  return (\r\n    <div onClick={() => setCount(0)}>{count}</div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## useMemo和useCallback\r\n- 缓存内容不同。useMemo是对计算结果的缓存，useCallback是对函数的缓存。\r\n- 优化方向不同。useMemo优化方向是减少重复计算，如果需要经常使用某个计算量很大的函数，可以使用useMemo进行函数计算值的缓存。useCallback优化方向是函数的缓存从而减少重复渲染，如果需要将该函数作为props传递给子组件，那么可以使用useCallback对函数进行缓存。\r\n- useMemo也能实现useCallback缓存函数的作用，useCallback更加直观。\r\n### useMemo和useCallback的作用\r\n- 减少在一次渲染中需要完成的工作量。\r\n- 减少一个组件需要重新渲染的次数。\r\n### useMemo\r\n> 只有依赖项改变才会调用某一个方法时可以使用useMemo，避免在每次渲染时都进行高开销的计算。返回的是函数运行的结果。\r\n\r\n- 父组件\r\n```\r\nimport React, { useState } from 'react';\r\nimport DemoOne from './demoOne';\r\n\r\nconst UseMemoDemo = () => {\r\n  const [count, setCount] = useState(0);\r\n  const [count1, setCount1] = useState(1);\r\n  return (\r\n    <div>\r\n      <button onClick={() => setCount(count + 1)}>count</button>\r\n      <button onClick={() => setCount1(count1 + 1)}>count1</button>\r\n      <DemoOne count={count} count1={count1} />\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default UseMemoDemo;\r\n```\r\n- 子组件\r\n```\r\nimport React, { useState, useMemo } from 'react';\r\n\r\nconst DemoOne = (props) => {\r\n  const [num, setNum] = useState(100);\r\n  const { count, count1 } = props;\r\n\r\n  const operationProps = (data) => {\r\n    console.log('propsChange');\r\n    return {\r\n      newCount: data.count + 10,\r\n      newCount1: data.count1 + 10,\r\n    }\r\n  }\r\n\r\n  // 如果不使用useMemo在组件内部状态改变时也会重新调用operationProps方法，使用之后只有在props改变时才会重新调用operationProps方法\r\n  const { newCount, newCount1 } = useMemo(() => operationProps(props), [props]);\r\n\r\n  return (\r\n    <div>\r\n      <div>\r\n        props count: {count}  count1: {count1}\r\n      </div>\r\n      <div>\r\n        new count: {newCount}  count1: {newCount1}\r\n      </div>\r\n      <div>\r\n        num {num}\r\n        <button onClick={() => setNum(num + 1)}>changeNum</button>\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default DemoOne;\r\n```\r\n### useCallback\r\n> 父组件重新渲染时声明的函数也会重新定义，如果此函数作为props传递给子组件，那么子组件会重新render。使用useCallback对函数进行缓存，子组件使用React.memo包裹，可以避免子组件不必要的重新渲染。\r\n\r\n- 父组件\r\n```\r\nimport React, { useState, useCallback } from 'react';\r\nimport DemoOne from './demoOne';\r\n\r\nconst UseCallbackDemo = () => {\r\n  const [count, setCount] = useState(0);\r\n  const [count1, setCount1] = useState(1);\r\n\r\n  const reset = () => {\r\n    setCount(0);\r\n    setCount1(0);\r\n  }\r\n\r\n  const useCallbackReset = useCallback(reset, []);\r\n\r\n  return (\r\n    <div>\r\n      <div>\r\n        count: {count}  count1: {count1}\r\n      </div>\r\n      <button onClick={() => setCount(count + 1)}>count</button>\r\n      <button onClick={() => setCount1(count1 + 1)}>count1</button>\r\n      {/* 如果传递reset函数，每一次点击按钮DemoOne都会重新渲染，传递使用useCallback缓存的useCallbackReset函数，点击按钮DemoOne不会重新渲染 */}\r\n      <DemoOne reset={useCallbackReset} />\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default UseCallbackDemo;\r\n```\r\n- 子组件\r\n```\r\nimport React from 'react';\r\n\r\nconst DemoOne = (props) => {\r\n  console.log('render');\r\n\r\n  return (\r\n    <div>\r\n      <button onClick={() => props.reset()}>reset</button>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default React.memo(DemoOne);\r\n```\r\n### 将context的value缓存\r\n- 当通过context在组件之间共享数据时，通常会传递一个大的对象作为value属性。将这个对象缓存起来减少组件渲染。\r\n- 当有多个组件使用这个context时，如果没有使用useMemo，当AuthProvider的父组件重新渲染时使用context的组件都将重新渲染。\r\n```\r\nconst AuthContext = React.createContext({});\r\n\r\nconst AuthProvider = ({ user, status, forgotPwLink, children }) => {\r\n  const memoizedValue = React.useMemo(() => {\r\n    return {\r\n      user,\r\n      status,\r\n      forgotPwLink,\r\n    };\r\n  }, [user, status, forgotPwLink]);\r\n  \r\n  return (\r\n    <AuthContext.Provider value={memoizedValue}>\r\n      {children}\r\n    </AuthContext.Provider>\r\n  );\r\n}\r\n```\r\n\r\n\r\n\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## [useReducer](https://juejin.cn/post/7274789845754445859)\r\n### 基础用法\r\n- useReducer接收三个参数：\r\n  1. reducer函数：指定如何更新状态的函数，它必须是纯函数，以state和dispatch为参数，并返回下一个状态。\r\n  2. 初始状态：初始状态的计算值。\r\n  3. 初始化参数(可选)：用于返回初始状态。如果未指定初始状态将设置为initialArg，如果有指定初始状态将被设置为调用init(initialArg)的结果。\r\n- useReducer返回两个参数：\r\n  1. 当前的状态：当前状态。在第一次渲染时它会被设置为init(initialArg)或initialArg(没有init的情况)。\r\n  2. dispatch：调度函数，用于调用reducer函数，以更新状态并触发重新渲染。\r\n```\r\nconst [state, dispatch] = useReducer(reducer, initialArg, init?)\r\n```\r\n- 计数器组件\r\n```\r\nconst initialState = { count: 0 };\r\n\r\nfunction reducer(state, action) {\r\n  switch (action.type) {\r\n    case 'increment':\r\n      return { count: state.count + 1 };\r\n    case 'decrement':\r\n      return { count: state.count - 1 };\r\n    default:\r\n      throw new Error();\r\n  }\r\n}\r\n\r\nfunction Counter() {\r\n  const [state, dispatch] = useReducer(reducer, initialState);\r\n\r\n  return (\r\n    <>\r\n      Count: {state.count}\r\n      <button onClick={() => dispatch({ type: 'decrement' })}>-</button>\r\n      <button onClick={() => dispatch({ type: 'increment' })}>+</button>\r\n    </>\r\n  );\r\n}\r\n```\r\n### 使用dispatch注意事项\r\n- dispatch调用后，状态更新是异步的，因此立刻读取状态仍是旧的。\r\n- React对dispatch有一个优化机制：如果dispatch触发更新前后的值相等(使用Object.is判断)，出于性能考虑React不会进行重新渲染。\r\n### 使用reducer注意事项\r\n- 在reducer里面更新对象和数组的状态，需要创建一个新的对象或数组，而不是在原对象和数组上修改，这一点和useState是一样的。\r\n### 初始化状态使用init函数和将第二个参数(initialArg)直接通过执行函数获取初始状态的区别\r\n> 两者都可以用于初始化状态，如果初始化逻辑简单并且没有性能顾虑，可以直接使用一个函数作为useReducer的第二个参数，但如果需要基于传入的参数来决定初始化逻辑或者想确保性能最优的做法，那么应该使用init函数。\r\n\r\n- 执行时机\r\n  1. 直接调用函数作为第二个参数，这个函数会在每次组件渲染时执行。\r\n  2. 使用init函数，init函数只在组件初次渲染时执行一次。\r\n- 访问到的数据\r\n  1. 直接调用函数作为第二个参数，这个函数只能访问到定义它时的作用域内的数据。\r\n  2. 使用init函数，由于init函数接受initialArg作为参数，这使得init函数具有更大的灵活性，能够基于传入的参数进行计算。\r\n- 代码组织\r\n  1. 直接调用函数作为第二个参数，代码更简洁适合简单的初始化逻辑。\r\n  2. 使用init函数，提供了更清晰的代码组织结构，特别是当初始化逻辑相对复杂或需要根据传入的参数变化时。\r\n- 性能\r\n  1. 直接调用函数作为第二个参数，如果这个函数执行了一些计算密集或副作用的操作，那么在每次组件渲染时都会执行，可能会导致性能问题。\r\n  2. 使用init函数，由于它只在组件的初始化阶段执行一次，所以对于那些计算密集的初始化操作，使用init函数可能会更为高效。\r\n### 中间件\r\n> 类似Redux中的中间件，可以利用dispatch创建一个中间件方法，支持调用dispatch之前或之后添加逻辑。\r\n\r\n- 通过将原始的dispatch包裹在另一个函数内部，中间件提供了在真正的状态更新前后注入自定义逻辑的机会。\r\n- 在原始的dispatch调用之前检查action的类型，可以添加任何自定义的逻辑。在原始的dispatch调用之后，可以添加任何自定义的逻辑。\r\n```\r\nfunction thunkMiddleware(dispatch) {\r\n  return function(action) {\r\n    if (typeof action === 'function') {\r\n      action(dispatch);\r\n    } else {\r\n      dispatch(action);\r\n    }\r\n    // 代码在dispatch之后执行\r\n    console.log(\"Action dispatched at: \", new Date().toISOString());\r\n  };\r\n}\r\n\r\nfunction fetchData() {\r\n  return dispatch => {\r\n    fetch(\"/api/data\")\r\n      .then(res => res.json())\r\n      .then(data => dispatch({ type: 'SET_DATA', payload: data }));\r\n  };\r\n}\r\n\r\nfunction App() {\r\n  const [state, unenhancedDispatch] = useReducer(reducer, initialState);\r\n  const dispatch = thunkMiddleware(unenhancedDispatch);\r\n  \r\n  useEffect(() => {\r\n    dispatch(fetchData());\r\n  }, [dispatch]);\r\n}\r\n```\r\n### useReducer + useContext创建简单的全局状态管理\r\n- 首先定义状态、reducer和context\r\n```\r\nconst ThemeContext = React.createContext();\r\n\r\nconst initialState = { theme: 'light' };\r\n\r\nfunction themeReducer(state, action) {\r\n  switch (action.type) {\r\n    case 'TOGGLE_THEME':\r\n      return { theme: state.theme === 'light' ? 'dark' : 'light' };\r\n    default:\r\n      return state;\r\n  }\r\n}\r\n```\r\n- 创建一个Provider组件\r\n```\r\nfunction ThemeProvider({ children }) {\r\n  const [state, dispatch] = useReducer(themeReducer, initialState);\r\n\r\n  return (\r\n    <ThemeContext.Provider\r\n      value={{\r\n        theme: state.theme,\r\n        toggleTheme: () => dispatch({ type: 'TOGGLE_THEME' })\r\n      }}\r\n    >\r\n      {children}\r\n    </ThemeContext.Provider>\r\n  );\r\n}\r\n```\r\n- 在子组件中，切换主题和读取主题\r\n```\r\nfunction ThemedButton() {\r\n  const { theme, toggleTheme } = useContext(ThemeContext);\r\n\r\n  return (\r\n    <button\r\n      style={{ backgroundColor: theme === 'light' ? '#fff' : '#000' }}\r\n      onClick={toggleTheme}\r\n    >\r\n      Toggle Theme\r\n    </button>\r\n  );\r\n}\r\n```\r\n### useReducer与 Redux 的差异\r\n> 虽然useReducer和Redux都采用了action和reducer的模式来处理状态，但它们在实现和使用上有几个主要的区别。\r\n\r\n- 范围：useReducer通常在组件或小型应用中使用，而Redux被设计为大型应用的全局状态管理工具。\r\n- 中间件和扩展：Redux支持中间件，这允许开发者插入自定义逻辑。而useReducer本身不直接支持，但可以模拟中间件的效果。\r\n- 复杂性：对于简单的状态管理useReducer通常更简单和直接。但当涉及到复杂的状态逻辑和中间件时，Redux更具优势。\r\n\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## 不依赖客户端时间的倒计时\r\n### 依赖客户端时间的问题\r\n> 客户的本地时间会影响这个倒计时的准确性，甚至可以直接通过修改本地时间来绕过倒计时。\r\n\r\n### 实现倒计时的方案\r\n- setTimeout\r\n- setInterval\r\n- requestAnimationFrame (存在兼容性问题)\r\n- Web Worker (存在兼容性问题)\r\n### setInterval VS setTimeout\r\n- setInterval实现倒计时是比较方便的，但是setInterval有两个缺点\r\n  1. 使用setInterval时，某些间隔会被跳过；\r\n  2. 可能多个定时器会连续执行；\r\n- 每个setTimeout产生的任务会直接push到任务队列中；而setInterval在每次把任务push到任务队列前，都要进行一下判断(看上次的任务是否仍在队列中)。\r\n- 主线程的渲染都会对setTimeout和setInterval的执行时间产生影响，但是setTimeout的影响小一点。\r\n### 使用setTimeout实现倒计时\r\n```\r\nconst INTERVAL = 1000;\r\n\r\ninterface CountDownProps {\r\n  restTime: number;\r\n  format?: string;\r\n  onFinish: () => void;\r\n  key: number;\r\n}\r\nexport const CountDown = ({ restTime, format = 'mm:ss', onFinish }: CountDownProps) => {\r\n  const timer = useRef<NodeJS.Timer | null>(null);\r\n  const [remainingTime, setRemainingTime] = useState(restTime);\r\n\r\n  useEffect(() => {\r\n    if (remainingTime < 0 && timer.current) {\r\n      onFinish?.();\r\n      clearTimeout(timer.current);\r\n      timer.current = null;\r\n      return;\r\n    }\r\n    timer.current = setTimeout(() => {\r\n      setRemainingTime((time) => time - INTERVAL);\r\n    }, INTERVAL);\r\n    return () => {\r\n      if (timer.current) {\r\n        clearTimeout(timer.current);\r\n        timer.current = null;\r\n      }\r\n    };\r\n  }, [remainingTime]);\r\n\r\n  return <span>{dayjs(remainingTime > 0 ? remainingTime : 0).format(format)}</span>;\r\n};\r\n```\r\n- 为了修正setTimeout的时间误差，我们需要在聚焦页面的时候以及定时一分钟请求一次服务器时间来修正误差。\r\n```\r\nconst REFRESH_INTERVAL = 60 * 1000;\r\n\r\nexport function useServerTime() {\r\n  const { data } = useSWR('/api/getCurrentTime', swrFetcher, {\r\n    refreshInterval: REFRESH_INTERVAL,\r\n  });\r\n  return { currentTime: data?.currentTime };\r\n}\r\n```\r\n- CountDown组件和useServerTime结合使用\r\n```\r\n// deadline和currentTime都是从服务器请求回来的服务器时间。\r\nfunction TitleAndCountDown() {\r\n  const { currentTime } = useServerTime();\r\n\r\n  return (\r\n    <Countdown\r\n      restTime={deadline - currentTime}\r\n      onFinish={onFinish}\r\n      key={deadline - currentTime}\r\n    />\r\n  );\r\n}\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## 受控和非受控组件\r\n### 受控组件\r\n- 组件内部state或值完全受prop控制的组件。\r\n- 就像antd里Input组件，可以通过props传一个value使得Input变为受控组件，Input组件内部状态(值)就由props控制。\r\n### 非受控组件\r\n- 组件内部state或值不受props控制的组件，由组件内部自己管理。\r\n- 就像antd里Input组件，如果不给组件传value值，那么组件就是非受控组件，Input组件内由自己管理value，这时如果要想拿到表单的value则只能通过ref等手段手动获取。"},function(r,n,e){"use strict";e.r(n),n.default="## 状态管理\r\n### 状态\r\n- 状态是表示组件当前状况的JS对象。在React中可以使用useState或者this.state维护组件内部状态，通过Props传递给子组件使用。\r\n- 为了避免状态传递过程中出现混乱，React引入了“单向数据流”的理念。主要思想是组件不会改变接收的数据，只会监听数据的变化，当数据发生变化时组件会使用接收到的新值而不是修改已有的值。当组件的更新机制触发后，组件使用新的值进行重新渲染。\r\n- 父子组件通信可以直接使用Props进行通信，深层次、兄弟组件通信需要通过Props层层传递或“状态提升”进行通信。\r\n### 状态管理常见模式\r\n- 状态提升：兄弟组件间是没法直接共享状态的，可以通过将状态提升到最近的祖先组件中，兄弟组件就可以通过Props传递获取状态。\r\n- 属性下钻：将父组件的状态以属性的形式一级级传递给深层次子组件。\r\n- Context：使用Context对于深层次子组件可以通过Context直接获取状态，不再需要通过属性下钻获取状态。\r\n- 状态组合：某些状态可能只在应用程序的特定子树中需要。最好将状态存储在尽可能接近实际需要的位置，这有助于优化渲染行为。\r\n### 状态管理库要解决的问题\r\n1. 从组件树的任何地方读取存储的状态。\r\n2. 写入存储状态的能力。\r\n3. 提供优化渲染的机制。\r\n4. 提供优化内存使用的机制。\r\n5. 与并发模式的兼容性。\r\n6. 数据的持久化。\r\n7. 上下文丢失问题。\r\n8. props失效问题。\r\n9. 孤儿问题。\r\n### React Context\r\n- 在多层级嵌套组件的场景下，使用“属性下钻”方式进行组件通信是一件成本极高的事情，React官方提供Context用于避免一级级属性传递。\r\n- Context设计目的是为了共享那些对于一个组件树而言是“全局”的数据，例如当前认证的用户、主题或首选语言。在系统中跟业务相关、会频繁变动的数据在共享时，应谨慎使用Context。\r\n- 在React里Context是个反模式的东西，不同于redux等的细粒度响应式更新，Context的值一旦变化，所有依赖该Context的组件全部都会forceUpdate，因为 Context API并不能细粒度地分析某个组件依赖了Context里的哪个属性。\r\n- 优点\r\n  1. 作为React内置的hook，不需要引入第三方库；\r\n  2. API操作还算方便。\r\n- 缺点\r\n  1. Context只能存储单一值，当数据量大起来时，需要使用createContext创建大量context；\r\n  2. 直接使用的话，会有一定的性能问题：每一次对state的某个值变更，都会导致其他使用该state的组件re-render，即使没有使用该值。可以通过useMemo来解决这个问题，但是就需要一定的成本来定制一个通用的解决方案；\r\n  3. 无法处理异步请求。对于异步的逻辑，Context API并没有提供任何API，需要自己做封装；\r\n  4. 无法处理数据间的联动。Context API并没有提供API来生成派生状态，同样也需要自行去封装一些方法来实现。\r\n### Redux\r\n> Redux 遵循“单向数据流”和“不可变状态模型”的设计思想。这使得Redux的状态变化是可预测、可调试的。\r\n\r\n- 优点\r\n  1. 繁荣的社区，像不支持异步这种问题是有成熟的中间件可以解决的。\r\n  2. 可扩展性高，中间件模式可以随心所欲的武装dispatch。\r\n  3. 单一数据源且是树形结构，这让redux支持回溯，在调试上也更方便。\r\n  4. 有成熟的开发调试工具 redux devtools。\r\n- 缺点\r\n  1. 陡峭的学习曲线。将副作用扔给中间件来处理，导致社区一堆中间件，学习成本陡然增加。\r\n  2. 大量的模版代码。使用redux开发者要编写大量和业务逻辑无关的模板代码，这给开发和后期维护都带来了额外的成本。\r\n  3. 大状态量情况下，性能较差。state更新会影响所有组件。每个action都会调用所有reducer。\r\n  4. reducer要返回新的对象，如果更新的值层级较深，更新成本也很高。\r\n  5. 更多的内存占用，由于采用单一数据源，所有状态存储在一个state中，当某些状态不再需要使用时，也不会被垃圾回收释放内存。\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## 生命周期\r\n### React v16.0前的生命周期\r\n- 挂载\r\n  1. constructor(构造函数只会执行一次)\r\n  2. componentWillMount\r\n  3. render\r\n  4. componentDidMount\r\n- 更新(re-render)\r\n  1. componentWillReceiveProps(nextProps)\r\n  2. shouldComponentUpdate(nextProps, nextState)\r\n  3. componentWillUpdate(nextProps, nextState, nextContext)\r\n  4. render\r\n  5. componentDidUpdate(prevProps, prevState)\r\n- 销毁\r\n  1. componentWillUnmount\r\n### 被废弃的生命周期\r\n> React的更新流程分为：render阶段和commit阶段。componentWillMount、componentWillReceiveProps、componentWillUpdate这三个生命周期钩子都是在render阶段执行的。在应用fiber架构之后，低优先级任务的render阶段可以被高优先级任务打断，这导致的问题就是在render阶段执行的生命周期函数可能被执行多次。\r\n\r\n1. componentWillMount\r\n2. componentWillReceiveProps\r\n3. componentWillUpdate\r\n### React v16.0后的生命周期\r\n- 挂载\r\n  1. constructor(构造函数只会执行一次)\r\n  2. static getDerivedStateFromProps(nextProps, prevState)\r\n  3. render\r\n  4. componentDidMount(首次渲染时页面将真实DOM渲染完毕之后运行)\r\n- 更新(re-render)\r\n  1. static getDerivedStateFromProps(nextProps, prevState)\r\n  2. shouldComponentUpdate(nextProps, nextState)\r\n  3. render\r\n  4. getSnapshotBeforeUpdate(prevProps, prevState) (真实DOM已经构建完成但还没有渲染到页面中)\r\n  5. componentDidUpdate(prevProps, prevState) (更新后的真实DOM已渲染到页面)\r\n- 销毁\r\n  1. componentWillUnmount\r\n### 错误捕获\r\n  1. static getDerivedStateFromError(在errorBoundary中使用)\r\n  2. componentDidCatch\r\n### getDerivedStateFromProps\r\n> 这个生命周期函数是为了替代componentWillReceiveProps，该函数会在组件实例化以及接收新props后调用(state变化也会调用，re-render都会调用)。它可以返回一个对象来更新state，或者返回null来表示新的props不需要任何state更新。函数会在每一次re-render之前调用，即使props没有改变，setState导致state改变，该函数依然会被调用，getDerivedStateFromProps是一个静态函数，也就是这个函数不能通过this访问到class的属性，不推荐直接访问属性。而是应该通过参数提供的nextProps以及prevState来进行判断，根据新传入的props来映射到state。如果props传入的内容不需要影响到你的state，那么就需要返回一个null，这个返回值是必须的。\r\n\r\n```\r\nstatic getDerivedStateFromProps(nextProps, prevState) {\r\n  const { type } = nextProps;\r\n  // 当传入的type发生变化的时候，更新state\r\n  if (type !== prevState.type) {\r\n    return {\r\n      type,\r\n    };\r\n  }\r\n  // 否则，对于state不进行任何操作\r\n  return null;\r\n}\r\n```\r\n### getSnapshotBeforeUpdate\r\n> getSnapshotBeforeUpdate生命周期将在render之后DOM变更之前被调用，此生命周期的返回值将作为第三个参数传递给componentDidUpdate生命周期。\r\n\r\n```\r\nclass ScrollingList extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.listRef = React.createRef();\r\n  }\r\n\r\n  getSnapshotBeforeUpdate(prevProps, prevState) {\r\n    if (prevProps.list.length < this.props.list.length) {\r\n      const list = this.listRef.current;\r\n      return list.scrollHeight - list.scrollTop;\r\n    }\r\n    return null;\r\n  }\r\n\r\n  componentDidUpdate(prevProps, prevState, snapshot) {\r\n    if (snapshot !== null) {\r\n      const list = this.listRef.current;\r\n      list.scrollTop = list.scrollHeight - snapshot;\r\n    }\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <div ref={this.listRef}>\r\n        {/* ...contents... */}\r\n      </div>\r\n    );\r\n  }\r\n}\r\n```\r\n### 父子组件生命周期执行顺序\r\n#### 父子组件初始化\r\n- 父组件 constructor\r\n- 父组件 getDerivedStateFromProps\r\n- 父组件 render\r\n- 子组件 constructor\r\n- 子组件 getDerivedStateFromProps\r\n- 子组件 render\r\n- 子组件 componentDidMount\r\n- 父组件 componentDidMount\r\n#### 父组件修改props\r\n- 父组件 getDerivedStateFromProps\r\n- 父组件 shouldComponentUpdate\r\n- 父组件 render\r\n- 子组件 getDerivedStateFromProps\r\n- 子组件 shouldComponentUpdate\r\n- 子组件 render\r\n- 子组件 getSnapShotBeforeUpdate\r\n- 父组件 getSnapShotBeforeUpdate\r\n- 子组件 componentDidUpdate\r\n- 父组件 componentDidUpdate\r\n#### 卸载子组件\r\n- 父组件 getDerivedStateFromProps\r\n- 父组件 shouldComponentUpdate\r\n- 父组件 render\r\n- 父组件 getSnapShotBeforeUpdate\r\n- 子组件 componentWillUnmount\r\n- 父组件 componentDidUpdate\r\n#### 卸载父组件\r\n- 父组件 componentWillUnmount\r\n- 子组件 componentWillUnmount\r\n#### 子组件修改自身state\r\n- 子组件 getDerivedStateFromProps\r\n- 子组件 shouldComponentUpdate\r\n- 子组件 render\r\n- 子组件 getSnapShotBeforeUpdate\r\n- 子组件 componentDidUpdate\r\n"},function(r,n,e){"use strict";e.r(n),n.default='## [简单react (Fiber + Diff + Render)](https://mp.weixin.qq.com/s?__biz=MzIxMzExMjYwOQ==&mid=2651896816&idx=1&sn=cd685d3f4ab5b4b9375552f9980ef3ff&scene=21#wechat_redirect)\r\n### Fiber 渲染过程\r\n> 每个 fiber节点 都有一个链接指向它的第一个子节点、下一个兄弟节点和它的父节点。这种数据结构可以让我们更方便的查找下一个工作单元。\r\n\r\n```\r\n<div>\r\n  <h1>\r\n    <p />\r\n    <a />\r\n  </h1>\r\n  <h2 />\r\n</div>\r\n```\r\n1. 从 root 开始，找到第一个子节点 div。\r\n2. 找到 div 的第一个子节点 h1。\r\n3. 找到 h1 的第一个子节点 p。\r\n4. 找 p 的第一个子节点，如无子节点，则找下一个兄弟节点，找到 p 的兄弟节点 a。\r\n5. 找 a 的第一个子节点，如无子节点，也无兄弟节点，则找它的父节点的下一个兄弟节点，找到 a 的 父节点的兄弟节点 h2。\r\n6. 找 h2 的第一个子节点，找不到，找兄弟节点，找不到，找父节点 div 的兄弟节点，也找不到，继续找 div 的父节点的兄弟节点，找到 root。\r\n7. 第 6 步已经找到了 root 节点，渲染已全部完成。\r\n### 渲染提交阶段\r\n> 由于渲染过程被我们做了可中断的，那么中断的时候，不希望浏览器给用户展示的是渲染了一半的 UI，所以需要等整个渲染过程结束才插入元素。\r\n\r\n1. 去除performUnitOfWork的appendChild的逻辑，待全部渲染结束才append。\r\n2. 新增根节点变量，存储Fiber根节点。\r\n3. 当所有Fiber工作完成时，nextUnitOfWork 为 undefined，这时再渲染真实 DOM。\r\n4. 新增渲染真实DOM的逻辑，递归将 fiber tree 渲染为真实 DOM。\r\n### code\r\n```\r\n<div id=\'container\'></div>\r\n\r\n// 创建html元素\r\nfunction createElement (type, props, ...children) {\r\n  return {\r\n    type,\r\n    props: {\r\n      ...props,\r\n      children: children.map(child => \r\n        typeof child === \'object\'\r\n        ? child \r\n        : createTextElement(child)\r\n      )\r\n    }\r\n  }\r\n}\r\n\r\n// 创建text元素\r\nfunction createTextElement (text) {\r\n  return {\r\n    type: "TEXT_ELEMENT",\r\n    props: {\r\n      nodeValue: text,\r\n      children: []\r\n    }\r\n  }\r\n}\r\n\r\nconst isEvent = key => key.startsWith("on")\r\nconst isProperty = key => key !== "children" && !isEvent(key)\r\nconst isNew = (prev, next) => key => prev[key] !== next[key]\r\nconst isGone = (prev, next) => key => !(key in next)\r\n\r\nlet nextUnitOfWork = null // 下一个Fiber节点\r\nlet wipRoot = null // 根节点\r\nlet currentRoot = null // 更新前的节点数据\r\nlet deletions = null  // 删除的元素\r\n\r\n// 创建dom\r\nfunction createDom (fiber) {\r\n  const dom = fiber.type === \'TEXT_ELEMENT\'\r\n    ? document.createTextNode("")\r\n    : document.createElement(fiber.type)\r\n  // 修改dom的属性\r\n  updateDom(dom, {}, fiber.props)\r\n  return dom\r\n}\r\n\r\n// 更新的dom属性修改\r\nfunction updateDom(dom, prevProps, nextProps) {\r\n  // 删除旧的或者有变化的事件(新的dom中不存在的事件或者新的dom事件绑定值修改的事件删除)\r\n  // 事件绑定值修改的删除是因为下方绑定新的事件后，原来的事件还会继续监听，和普通属性的直接覆盖不同\r\n  Object.keys(prevProps).filter(isEvent).filter(key =>\r\n    !(key in nextProps) ||\r\n    isNew(prevProps, nextProps)(key)\r\n  ).forEach(name => {\r\n    const eventType = name.toLowerCase().substring(2)\r\n    dom.removeEventListener(eventType, prevProps[name])\r\n  })\r\n\r\n  // 添加新的事件监听(新的dom事件绑定值修改的和新的dom新添的事件绑定)\r\n  Object.keys(nextProps).filter(isEvent).filter(isNew(prevProps, nextProps)).forEach(name => {\r\n    const eventType = name.toLowerCase().substring(2)\r\n    dom.addEventListener(eventType, nextProps[name])\r\n  })\r\n\r\n  // 删除旧的属性(新的dom中不存在的属性删除掉)\r\n  Object.keys(prevProps).filter(isProperty).filter(isGone(prevProps, nextProps)).forEach(name => {\r\n    dom[name] = ""\r\n  })\r\n\r\n  // 添加新的属性(新的dom属性值修改的和新的dom新添的属性)\r\n  Object.keys(nextProps).filter(isProperty).filter(isNew(prevProps, nextProps)).forEach(name => {\r\n    dom[name] = nextProps[name]\r\n  })\r\n}\r\n\r\n// 递归生成真实DOM\r\nfunction commitWork (fiber) {\r\n  if (!fiber) return\r\n  const domParent = fiber.parent.dom\r\n  if (\r\n    fiber.effectTag === "PLACEMENT" &&\r\n    fiber.dom != null\r\n  ) {\r\n    // 新的元素\r\n    domParent.appendChild(fiber.dom)\r\n  } else if (fiber.effectTag === "DELETION") {\r\n    // 删除的元素\r\n    domParent.removeChild(fiber.dom)\r\n  } else if (fiber.effectTag === \'UPDATE\' && fiber.dom !== null) {\r\n    // 有更新的元素\r\n    updateDom(fiber.dom, fiber.alternate.props, fiber.props)\r\n  }  \r\n  commitWork(fiber.child)\r\n  commitWork(fiber.sibling)\r\n}\r\n\r\n// 渲染真实DOM\r\nfunction commitRoot () {\r\n  deletions.forEach(commitWork)\r\n  commitWork(wipRoot.child)\r\n  // 正在应用的节点修改，下次再渲染时进行比较\r\n  currentRoot = wipRoot\r\n  wipRoot = null\r\n}\r\n\r\n// 处理当前Fiber节点，并返回下一个要处理的Fiber节点\r\nfunction performUnitOfWork(fiber) {\r\n  if (!fiber.dom) {\r\n    fiber.dom = createDom(fiber)\r\n  }\r\n\r\n  const elements = fiber.props.children\r\n  reconcileChildren(fiber, elements)\r\n\r\n  if (fiber.child) {\r\n    return fiber.child\r\n  }\r\n  let nextFiber = fiber\r\n  while (nextFiber) {\r\n    if (nextFiber.sibling) {\r\n      return nextFiber.sibling\r\n    }\r\n    nextFiber = nextFiber.parent\r\n  }\r\n}\r\n\r\n// Fiber节点的diff \r\nfunction reconcileChildren (wipFiber, elements) {\r\n  let index = 0\r\n  let oldFiber = wipFiber.alternate && wipFiber.alternate.child\r\n  let prevSibling = null\r\n\r\n  while (index < elements.length || oldFiber != null) {\r\n    const element = elements[index]\r\n    let newFiber = null\r\n\r\n    const sameType = oldFiber && element && element.type == oldFiber.type\r\n      \r\n    if (sameType) {\r\n      // 存在oldFiber的同节点类型 (更新)\r\n      newFiber = {\r\n        type: oldFiber.type,\r\n        props: element.props,\r\n        dom: oldFiber.dom,\r\n        parent: wipFiber,\r\n        alternate: oldFiber,\r\n        effectTag: "UPDATE",\r\n      }\r\n    }\r\n\r\n    // 没有oldFiber或者新旧节点的类型不同 (新建)\r\n    if (element && !sameType) {\r\n      newFiber = {\r\n        type: element.type,\r\n        props: element.props,\r\n        dom: null,\r\n        parent: wipFiber,\r\n        alternate: null,\r\n        effectTag: "PLACEMENT",\r\n      }\r\n    }\r\n\r\n    // 有oldFiber但是类型不同 (删除)\r\n    if (oldFiber && !sameType) {\r\n      oldFiber.effectTag = "DELETION"\r\n      deletions.push(oldFiber)\r\n    }    \r\n\r\n    if (oldFiber) {\r\n      // 新节点循环比较的下一个节点是旧节点的兄弟节点\r\n      oldFiber = oldFiber.sibling\r\n    }\r\n\r\n    if (index === 0) {\r\n      wipFiber.child = newFiber\r\n    } else if (element) {\r\n      prevSibling.sibling = newFiber\r\n    }\r\n\r\n    prevSibling = newFiber\r\n    index++\r\n  }\r\n}\r\n\r\n// Fiber 渲染机制\r\nfunction workLoop (deadline) {\r\n  let shouldYield = false\r\n  while (nextUnitOfWork && !shouldYield) {\r\n    nextUnitOfWork = performUnitOfWork(nextUnitOfWork)\r\n    shouldYield = deadline.timeRemaining() < 1\r\n  }\r\n  if (!nextUnitOfWork && wipRoot) {\r\n    commitRoot()\r\n  }\r\n  requestIdleCallback(workLoop)\r\n}\r\nrequestIdleCallback(workLoop)\r\n\r\n// render函数\r\nfunction render (element, container) {\r\n  wipRoot = {\r\n    dom: container,\r\n    props: {\r\n      children: [element]\r\n    },\r\n    alternate: currentRoot // 存储更新前dom结构\r\n  }\r\n  deletions = [] // 存储删除的dom\r\n  nextUnitOfWork = wipRoot\r\n}\r\n\r\nconst container = document.getElementById("container")\r\n// 更新之后改变虚拟 DOM 结构\r\nconst updateValue = e => {\r\n  const newData = Array.from(e.target.value || []).map(item => ({\r\n    "type": "div",\r\n    "props": {\r\n      "children": [\r\n        {\r\n          "type": "TEXT_ELEMENT",\r\n          "props": {\r\n            "nodeValue": item,\r\n            "children": []\r\n          }\r\n        },\r\n      ]\r\n    }\r\n  }))\r\n  element.props.children = [\r\n    {\r\n      "type": "input",\r\n      "props": {\r\n        "value": e.target.value,\r\n        "children": [],\r\n        "onInput": updateValue,\r\n      }\r\n    },\r\n    {\r\n      "type": "h2",\r\n      "props": {\r\n        "children": [\r\n          {\r\n            "type": "TEXT_ELEMENT",\r\n            "props": {\r\n              "nodeValue": `Hello ${e.target.value}`,\r\n              "children": []\r\n            }\r\n          },\r\n        ]\r\n      }\r\n    },\r\n    ...newData,\r\n  ]\r\n  render(element, container)\r\n}\r\n\r\n// 模拟 jsx 的虚拟 DOM 结构\r\nconst element = {\r\n  "type": "div",\r\n  "props": {\r\n    "children": [\r\n      {\r\n        "type": "input",\r\n        "props": {\r\n          "value": "",\r\n          "children": [],\r\n          "onInput": updateValue,\r\n        }\r\n      },\r\n      {\r\n        "type": "h2",\r\n        "props": {\r\n          "children": [\r\n            {\r\n              "type": "TEXT_ELEMENT",\r\n              "props": {\r\n                "nodeValue": "Hello",\r\n                "children": []\r\n              }\r\n            },\r\n          ]\r\n        }\r\n      }\r\n    ]\r\n  }\r\n}\r\nrender(element, container)\r\n```\r\n\r\n'},function(r,n,e){"use strict";e.r(n),n.default="## React类组件中方法绑定到类实例\r\n> 在JS中this会根据当前执行上下文变化，在React类组件方法中希望this引用的是当前的实例，因此有必要将这些方法绑定到当前实例。\r\n\r\n- constructor构造函数中绑定this。\r\n```\r\nexport default class Home extends React.Component {\r\n  constructor() {\r\n    super();\r\n    this.handleClick = this.handleClick.bind(this);\r\n  }\r\n\r\n  handleClick() {\r\n    // ...\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <button onClick={this.handleClick}>123</button>\r\n    )\r\n  }\r\n}\r\n```\r\n- 定义函数时使用箭头函数。\r\n```\r\nexport default class Home extends React.Component {\r\n  handleClick = () => {\r\n    // ...\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <button onClick={this.handleClick}>123</button>\r\n    )\r\n  }\r\n}\r\n```\r\n- 调用函数时绑定this。\r\n```\r\nexport default class Home extends React.Component {\r\n  handleClick() {\r\n    // ...\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <button onClick={this.handleClick.bind(this)}>123</button>\r\n    )\r\n  }\r\n}\r\n```\r\n- 调用函数时使用箭头函数。\r\n```\r\nexport default class Home extends React.Component {\r\n  handleClick() {\r\n    // ...\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <button onClick={() => this.handleClick()}>123</button>\r\n    )\r\n  }\r\n}\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## 组件封装\r\n### 支持传入className、style或者任何html标签的props\r\n- 透传props到组件内的容器标签，用起来体验和原生标签很类似。\r\n### 暴露组件内部的方法\r\n- 使用useImperativeHandle配合forwardRef自定义暴露给外部使用组件的方法。\r\n### 使用useMemo和useCallback来进行渲染性能优化\r\n### 使用Context来跨组件传递值\r\n- 使用Context来传递config、theme、size等全局配置信息。\r\n### React.Children + React.cloneElement对props.children做一些修改\r\n- 对props.children进行处理比如包一层组件、添加ref等参数、添加一些children等。"},function(r,n,e){"use strict";e.r(n),n.default="## 组件通信\r\n### 父组件向子组件通信\r\n- Props传递，利用React单向数据流的思想，通过Props传递。\r\n### 子组件向父组件通信\r\n- 父组件向子组件传递一个函数，通过函数回调，拿到子组件传过来的值。\r\n### 兄弟组件通信\r\n- 状态提升，通过父组件中转数据，子组件a传递给父组件，父组件再传递给子组件b。\r\n### 父组件向后代组件通信\r\n- Context\r\n### 无关组件通信\r\n- redux"},function(r,n,e){"use strict";e.r(n),n.default="## 自定义hooks\r\n- 自定义hooks可以使用官方提供的hooks和其他自定义hooks，拥有自己的状态，封装通用的逻辑。一个自定义hooks就像一个不用返回jsx的函数组件。\r\n- 自定义hooks的使用尽可能不要做无关的渲染，需要减少性能开销，一个好用的自定义hooks需要配合useMemo、useCallback等进行优化。\r\n### 获取浏览器的高度和宽度\r\n```\r\n// 获取浏览器的高度和宽度\r\nexport const useWinSize = () => {\r\n  const [windowSize, setWindowSize] = useState({\r\n    winHeight: document.documentElement.clientHeight,\r\n    winWidth: document.documentElement.clientWidth\r\n  });\r\n\r\n  const handleResize = () => {\r\n    setWindowSize({\r\n      winHeight: document.documentElement.clientHeight,\r\n      winWidth: document.documentElement.clientWidth\r\n    });\r\n  };\r\n\r\n  useEffect(() => {\r\n    window.addEventListener('resize', handleResize);\r\n    return () => window.removeEventListener('resize', handleResize);\r\n  }, []);\r\n\r\n  return windowSize;\r\n};\r\n```\r\n### 仅在组件重新渲染时调用的useEffect\r\n```\r\n// 仅在组件重新渲染时调用(第一次render不调用)\r\nexport const useNotFirstRenderEffect = (func: () => void, deps: any) => {\r\n  const hasFirstRender = useRef(false); // 是否已经完成第一次render\r\n  useEffect(() => {\r\n    if (hasFirstRender.current) {\r\n      func();\r\n    } else {\r\n      hasFirstRender.current = true;\r\n    }\r\n  }, deps);\r\n}\r\n```\r\n### 支持回调的useState\r\n```\r\n// useState改变状态后支持回调\r\nexport const useCallbackState = (initData: any) => {\r\n  const cbRef: any = useRef(); // 存储回调函数\r\n  const [data, setData] = useState(initData);\r\n\r\n  useEffect(() => {\r\n    cbRef.current && cbRef.current(data);\r\n  }, [data]);\r\n\r\n  return [\r\n    data,\r\n    function (newData: any, callback: any) {\r\n      cbRef.current = callback;\r\n      setData(newData);\r\n    }\r\n  ];\r\n}\r\n```"},function(r,n,e){"use strict";e.r(n),n.default='## 虚拟DOM\r\n- 原生的JavaScript我们直接对DOM进行创建和更改，而React会先将JSX代码转换成一个JavaScript对象，然后再将这个JavaScript对象转换成真实DOM。这个JavaScript对象就是所谓的虚拟DOM。\r\n- 当需要创建或更新元素时，React会先对虚拟DOM对象进行创建或更改，然后再将虚拟DOM对象渲染成真实DOM。\r\n- 当需要对DOM进行事件监听时，React会对虚拟DOM进行事件监听，虚拟DOM会代理原生的DOM事件从而做出响应。\r\n### 虚拟DOM优点\r\n#### 提高开发效率，代码逻辑更易维护\r\n- 使用JavaScript，我们很大的关注点在于如何更新DOM。使用React不必自己去完成属性操作、事件处理、DOM更新，React会替我们完成这一切。\r\n- 我们可以更关注我们的业务逻辑而非DOM操作，可大大提升我们的开发效率。\r\n#### 性能提升 **浏览器在处理DOM的时候会很慢，处理JavaScript会很快**\r\n- 直接操作DOM是非常耗费性能的，React使用虚拟DOM也是无法避免操作DOM的。如果是首次渲染，虚拟DOM并不具有优势，甚至要进行更多的计算，消耗更多的内存。\r\n- 虚拟DOM的优势在于React的Diff算法和批处理策略，React在更新真实DOM之前，提前计算好了如何进行更新和渲染DOM。实际上这个计算过程我们在直接操作DOM时，也是可以自己判断和实现的，但是一定会耗费非常多的精力和时间，而且往往我们自己做的是不如React好，React帮助我们计算如何更高效的更新，而不是它比DOM操作更快，在这个过程中React帮助我们提升了性能。\r\n- 虚拟DOM进行频繁修改不会引起页面的绘制，然后**一次性比较并修改**真实DOM中需要改的部分，最后在真实DOM中进行排版与重绘，减少排版重绘的次数，真实DOM频繁排版与重绘的效率是相当低的。\r\n- 减弱频繁的大面积重绘引发的性能问题。虚拟DOM有效降低大面积(真实DOM节点)的重绘与排版，因为最终与真实DOM比较差异，可以只渲染局部。\r\n- 只有虚拟DOM并不能提升性能，虚拟DOM + Diff算法才能真正的提高性能。\r\n#### 事件机制跨浏览器兼容\r\n- React基于虚拟DOM自己实现了一套事件机制，自己模拟了事件冒泡和捕获的过程，采用事件代理，批量更新等方法，抹平了各个浏览器的事件兼容性问题。\r\n#### 跨平台兼容\r\n- 以React Native为例子，根据虚拟DOM绘制出对应平台的ui层。\r\n### 虚拟DOM缺点\r\n- ⾸次渲染⼤量DOM时，由于多了⼀层虚拟DOM的计算，会⽐直接操作真实DOM慢。\r\n- ⽆法进⾏极致优化，虽然虚拟DOM + 合理的优化，⾜以应对绝⼤部分应⽤的性能需求，但在⼀些性能要求极⾼的应⽤中虚拟DOM⽆法进⾏针对性的极致优化。\r\n### 使用了虚拟DOM不一定会比直接渲染真实DOM快\r\n- React框架给的保证是在不需要手动优化的情况下，可以提供过得去的性能。\r\n- 浏览器在处理DOM的时候会很慢，处理JavaScript会很快，Diff过程是JS层面的操作，用途就是减少后续的真实DOM操作。\r\n### 虚拟DOM的结构\r\n```\r\n{\r\n  "type": "div", \r\n  "props": {\r\n    "id": "foo", \r\n    "children": [\r\n      {\r\n        "type": "a", \r\n        "props": {\r\n          "children": [\r\n            {\r\n              "type": "TEXT_ELEMENT", \r\n              "props": {\r\n                "nodeValue": "bar", \r\n                "children": []\r\n              }\r\n            }\r\n          ]\r\n        },\r\n        key: null,\r\n        ref: null,\r\n        $$typeof: Symbol.for(\'react.element\'), // 标识React元素\r\n      }, \r\n      {\r\n        "type": "b", \r\n        "props": {\r\n          "children": []\r\n        },\r\n        key: null,\r\n        ref: null,\r\n        $$typeof: Symbol.for(\'react.element\'), // 标识React元素\r\n      }\r\n    ]\r\n  }\r\n}\r\n```\r\n### React元素中$$typeof的作用\r\n- 用于标识React元素，该属性值为Symbol，主要为了防止XSS攻击。\r\n- React在处理元素时通过$$typeof就能够识别出非法元素(伪造元素)。\r\n- 浏览器不支持Symbol时React仍然会加上$$typeof字段以保证一致性，会设置一个数字0xeac7，因为0xeac7看起来有点像React。\r\n### 操作DOM会比操作JS代价更大\r\n- 访问和修改DOM元素需要通过浏览器的底层接口提供的API来实现，与直接在内存中操作JavaScript对象相比，通过浏览器接口进行DOM操作涉及到更多的层级和复杂性，从而导致性能开销增加。\r\n- DOM操作引起页面重新渲染和重排，当对DOM元素进行修改时，浏览器需要重新计算元素的布局和样式，并重新渲染整个页面或部分页面。这个过程称为重排（reflow） 和重绘（repaint），它对于页面的性能和响应时间有一定的影响，增加了页面的负担和性能开销。\r\n### 减少DOM操作的优化措施\r\n- 批量操作：将多个DOM操作合并成一个批量操作，减少页面的重排和重绘次数。\r\n- 使用文档片段（DocumentFragment）：将多个DOM元素的操作放在文档片段中，然后一次性插入到页面中，减少页面渲染的次数。\r\n- 缓存DOM查询结果：避免多次查询同一个DOM元素，将查询结果缓存在变量中以提高性能。\r\n- 使用事件委托：将事件处理程序绑定在父元素上，通过事件冒泡机制处理子元素的事件，减少事件绑定的数量。\r\n'},function(r,n,e){"use strict";e.r(n),n.default="## [高阶组件(HOC)](https://mp.weixin.qq.com/s/rxCwWIUy2kLW5unpSVhx3g)\r\n- 高阶组件不是组件而是一个函数，它会接收一个组件作为参数并返回一个经过改造的新组件。\r\n```\r\nconst EnhancedComponent = higherOrderComponent(WrappedComponent);\r\n```\r\n- 组件是将props转换为UI，而高阶组件是将组件转换为另一个组件。\r\n- 高阶组件是React中用于复用组件逻辑的一种高级技巧。\r\n- 装饰器模式在React中的实现：在不修改原组件的情况下实现组件功能的增强。\r\n### 高阶组件的作用\r\n- 实现代码复用和逻辑抽象，实现组件复用,提高开发效率和提升代码的可维护性。常见场景：页面复用。\r\n- 条件渲染，控制组件的渲染逻辑(渲染劫持)。常见场景：权限控制。\r\n- 捕获/劫持被处理组件的生命周期。常见场景：组件渲染性能追踪、日志打点。\r\n- 强化props：类似withRouter、connect为组件添加props属性，强化组件功能。\r\n- 劫持控制渲染逻辑：通过反向继承方式，拦截原组件的生命周期、渲染、内部组件状态。\r\n- 动态加载组件：根据props属性动态渲染组件，比如添加loading、错误处理等。\r\n- 为组件添加事件：为传入的组件包裹一层元素并绑定事件。\r\n### 高阶组件实现方式\r\n- 属性代理\r\n- 反向继承\r\n### 属性代理\r\n- 属性代理是最常见的实现方式，它本质上是使用组合的方式，通过将组件包装在容器组件中实现功能。\r\n- 属性代理方式实现的高阶组件和原组件的生命周期关系完全是React父子组件的生命周期关系，所以该方式实现的高阶组件会影响原组件某些生命周期等方法。\r\n#### 操作props\r\n- 通过属性代理方式实现的高阶组件包装后的组件可以拦截到父组件传递过来的props，提前对 props进行一些操作，比如增加一个type属性。\r\n```\r\nconst HOC = (WrappedComponent) => {\r\n  const newProps = { type: 'HOC' };\r\n  return props => <WrappedComponent {...props} {...newProps} />;\r\n}\r\n```\r\n#### 通过props实现条件渲染\r\n- 通过属性代理方式实现的高阶组件无法直接实现对原组件进行渲染劫(即对原组件内部render的控制并不是很强)，但可以通过props来控制是否渲染及传入数据。\r\n```\r\nconst HOC = (WrappedComponent: any) => {\r\n  return (props: any) => (\r\n    props.isShow ? <WrappedComponent {...props} /> : <div>暂无数据</div>\r\n  );\r\n}\r\n```\r\n#### 用其他元素包裹传入的组件\r\n- 实现布局或者是样式的目的。\r\n```\r\nconst HOC = (WrappedComponent) => {\r\n  return props => (\r\n    <div style={{ backgroundColor: '#ccc' }}>\r\n      <WrappedComponent {...props} />\r\n    </div>\r\n  );\r\n}\r\n```\r\n### 反向继承\r\n- 反向继承指的是使用一个函数接受一个组件作为参数传入，并返回一个继承了该传入组件的类组件，且在返回组件的render()方法中返回super.render()方法。\r\n- 相较于属性代理方式，使用反向继承方式实现的高阶组件的特点是允许高阶组件通过this访问到原组件，所以可以直接读取和操作原组件的state、ref、生命周期方法。\r\n- 反向继承方式实现的高阶组件可以通过super.render()方法获取到传入组件实例的render结果，所以可对传入组件进行渲染劫持(最大特点)。\r\n  - 有条件地展示元素树。\r\n  - 操作由render()输出的React元素树。\r\n  - 在任何由render()输出的React元素中操作props。\r\n  - 用其他元素包裹传入组件的渲染结果。\r\n#### 劫持原组件生命周期方法\r\n- 反向继承方式实现的高阶组件返回的新组件是继承于传入组件的，所以当新组件定义了同样的方法时，将会覆盖父类(传入组件)的实例方法。\r\n```\r\nconst HOC = (WrappedComponent) => {\r\n  // 继承了传入组件\r\n  return class HOC extends WrappedComponent {\r\n    // 注意：这里将重写传入组件的componentDidMount方法\r\n    componentDidMount() {\r\n      ...\r\n    }\r\n\r\n    render() {\r\n      // 使用super调用传入组件的render方法\r\n      return super.render();\r\n    }\r\n  }\r\n}\r\n```\r\n#### 劫持原组件生命周期方法：非覆盖形式。\r\n```\r\nconst HOC = (WrappedComponent) => {\r\n  const didMount = WrappedComponent.prototype.componentDidMount;\r\n  \r\n  // 继承了传入组件\r\n  return class HOC extends WrappedComponent {\r\n    componentDidMount() {\r\n      // 劫持WrappedComponent组件的生命周期\r\n      if (didMount) {\r\n        didMount.apply(this);\r\n      }\r\n      ...\r\n    }\r\n\r\n    render() {\r\n      // 使用super调用传入组件的render方法\r\n      return super.render();\r\n    }\r\n  }\r\n}\r\n```\r\n#### 读取/操作原组件的state\r\n```\r\nconst HOC = (WrappedComponent) => {\r\n  const didMount = WrappedComponent.prototype.componentDidMount;\r\n\r\n  // 继承了传入组件\r\n  return class HOC extends WrappedComponent {\r\n    async componentDidMount() {\r\n      if (didMount) {\r\n        await didMount.apply(this);\r\n      }\r\n      // 将state中的number值修改成2\r\n      this.setState({ number: 2 });\r\n    }\r\n\r\n    render() {\r\n      // 使用super调用传入组件的render方法\r\n      return super.render();\r\n    }\r\n  }\r\n}\r\n```\r\n#### 条件渲染\r\n- 根据部分参数去决定是否渲染组件(与属性代理方式类似)。\r\n```\r\nconst HOC = (WrappedComponent) => (\r\n  class extends WrappedComponent {\r\n    render() {\r\n      if (this.props.isRender) {\r\n        return super.render();\r\n      } else {\r\n        return <div>暂无数据</div>;\r\n      }\r\n    }\r\n  }\r\n)\r\n```\r\n#### 修改React元素\r\n- 通过React.cloneElement方法修改由render方法输出的React组件树。\r\n```\r\nconst HOC = (WrappedComponent) => {\r\n  return class extends WrappedComponent {\r\n    render() {\r\n      const tree = super.render();\r\n      const newProps = {};\r\n      if (tree && tree.type === 'input') {\r\n        newProps.value = 'something here';\r\n      }\r\n      const props = {\r\n        ...tree.props,\r\n        ...newProps,\r\n      };\r\n      const newTree = React.cloneElement(tree, props, tree.props.children);\r\n      return newTree;\r\n    }\r\n  };\r\n}\r\n```\r\n### 属性代理和反向继承的对比\r\n- 属性代理是从“组合”的角度出发，这样有利于从外部去操作WrappedComponent，可以操作的对象是props，或者在WrappedComponent外面加一些拦截器、控制器等。\r\n- 反向继承则是从“继承”的角度出发，是从内部去操作WrappedComponent，可以操作组件内部的state、生命周期、render函数等。\r\n- 通过反向继承方法实现的高阶组件相较于属性代理实现的高阶组件，功能更强大，个性化程度更高，因此能适应更多的场景。\r\n\r\n| 功能列表 | 属性代理 | 反向继承 |\r\n| --- | --- | --- |\r\n| 原组件能否被包裹 | √ | √ |\r\n| 原组件是否被继承 | × | √ |\r\n| 能否读取/操作原组件的props | √ | √ |\r\n| 能否读取/操作原组件的state | 乄 | √ |\r\n| 能否通过ref访问到原组件的dom元素 | 乄 | √ |\r\n| 是否影响原组件某些生命周期等方法 | √ | √ |\r\n| 是否取到原组件static方法 | √ | √ |\r\n| 能否劫持原组件生命周期方法 | × | √ |\r\n| 能否渲染劫持 | 乄 | √ |"},function(r,n,e){"use strict";e.r(n),n.default="## [高阶组件和hooks对比](https://mp.weixin.qq.com/s/P45MhphGzkrEtsSyp9GQwg)\r\n### 属性混乱\r\n- 高阶组件\r\n```\r\nconst DataTableWithFeedback = compose(\r\n  withFetch,\r\n  withError,\r\n  withLoading,\r\n)(DataTable);\r\n\r\nconst App = () => {\r\n  const url = 'https://api.mydomain/mydata';\r\n\r\n  return (\r\n    <DataTableWithFeedback\r\n      url={url}\r\n      columns={columns}\r\n    />\r\n  );\r\n};\r\n```\r\n- 从高阶组件进出的属性都以某种方式通过黑盒子传递，需要仔细观察才能真正理解在途中生成了哪些属性，哪些属性在途中被消费，哪些属性被传递。不查看高阶组件内部逻辑不知道在这些层之间发生了什么。\r\n```\r\nApp     withFetch   withError   withLoading   DataTable\r\n\r\n        data->      data->      data->        data\r\nurl->   error->     error\r\n        isLoading-> isLoading-> isLoading\r\n```\r\n- hooks\r\n> 即使不清楚useFetch的实现细节，也可以清晰看到所有传入hooks的属性，以及所有从hooks中出来的属性。\r\n\r\n```\r\nconst App = () => {\r\n  const url = 'https://api.mydomain/mydata';\r\n  const { data, isLoading, error } = useFetch(url);\r\n\r\n  if (error) {\r\n    return <div>Something went wrong ...</div>;\r\n  }\r\n\r\n  if (isLoading) {\r\n    return <div>Loading ...</div>;\r\n  }\r\n\r\n  return (\r\n    <DataTable\r\n      columns={columns}\r\n      data={data}\r\n    />\r\n  );\r\n};\r\n```\r\n### 命名冲突\r\n- 高阶组件\r\n> 当使用多次高阶组件传递具有相同名称的props时会有问题，可以尝试修改高阶组件逻辑支持，但是当逻辑要求多时会是高阶组件十分复杂。\r\n\r\n```\r\n// withFetch高阶组件调整前\r\nconst UserWithData = compose(\r\n  withFetch,\r\n  withFetch,\r\n  withError,\r\n  withLoading,\r\n)(User);\r\n\r\nconst App = () => {\r\n  const userId = '1';\r\n\r\n  return (\r\n    <UserWithData\r\n      url={`https://api.mydomain/user/${userId}`}\r\n      url={`https://api.mydomain/user/${userId}/profile`}\r\n    />\r\n  );\r\n};\r\n\r\n// withFetch高阶组件调整支持传递多个urls\r\nconst UserWithData = compose(\r\n  withFetch,\r\n  withError,\r\n  withLoading,\r\n)(User);\r\n\r\nconst App = () => {\r\n  const userId = '1';\r\n\r\n  return (\r\n    <UserWithData\r\n      urls={[\r\n        `https://api.mydomain/user/${userId}`,\r\n        `https://api.mydomain/user/${userId}/profile`,\r\n      ]}\r\n    />\r\n  );\r\n};\r\n```\r\n- hooks\r\n> 使用非常灵活，可以根据多次调用结果随意组合想要实现的逻辑。\r\n\r\n```\r\nconst App = () => {\r\n  const userId = '1';\r\n\r\n  const {\r\n    data: userData,\r\n    isLoading: userIsLoading,\r\n    error: userError\r\n  } = useFetch(`https://api.mydomain/user/${userId}`);\r\n\r\n  const {\r\n    data: userProfileData,\r\n    isLoading: userProfileIsLoading,\r\n    error: userProfileError\r\n  } = useFetch(`https://api.mydomain/user/${userId}/profile`);\r\n\r\n  if (userError || userProfileError) {\r\n    return <div>Something went wrong ...</div>;\r\n  }\r\n\r\n  if (userIsLoading) {\r\n    return <div>User is loading ...</div>;\r\n  }\r\n\r\n  const userProfile = userProfileIsLoading\r\n    ? <div>User profile is loading ...</div>\r\n    : <UserProfile userProfile={userProfileData} />;\r\n\r\n  return (\r\n    <User\r\n      user={userData}>\r\n      userProfile={userProfile}\r\n    />\r\n  );\r\n};\r\n```\r\n### 依赖关系\r\n- 高阶组件\r\n> 在两个紧密耦合的高阶组件中想要创建相互依赖的高阶组件是十分困难的。\r\n\r\n- hooks\r\n> 多个hooks它们可以相互依赖，如果它们彼此依赖，传递数据也是直截了当的。使用相互依赖的React Hooks时，依赖关系比使用高阶组件更加显式。\r\n\r\n```\r\nconst App = () => {\r\n  const userId = '1';\r\n\r\n  const {\r\n    data: userData,\r\n    isLoading: userIsLoading,\r\n    error: userError\r\n  } = useFetch(`https://api.mydomain/user/${userId}`);\r\n\r\n  const profileId = userData?.profileId;\r\n\r\n  const {\r\n    data: userProfileData,\r\n    isLoading: userProfileIsLoading,\r\n    error: userProfileError\r\n  } = useFetch(`https://api.mydomain/user/${profileId}/profile`);\r\n\r\n  if (userError || userProfileError) {\r\n    return <div>Something went wrong ...</div>;\r\n  }\r\n\r\n  if (userIsLoading || userProfileIsLoading) {\r\n    return <div>Is loading ...</div>;\r\n  }\r\n\r\n  return (\r\n    <User\r\n      user={userData}>\r\n      userProfile={userProfileData}\r\n    />\r\n  );\r\n};\r\n```\r\n### 嵌套层级\r\n- 高阶组件\r\n> 高阶组件需要实例化一个父组件来实现，加深组件嵌套层级，增加复杂度与理解成本。\r\n\r\n- hooks\r\n> hooks不会增加额外组件。\r\n\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## Component\r\n### React.Component源码\r\n```\r\nfunction Component(props, context, updater) {\r\n  // 接收 props，context，updater 进行初始化，挂载到 this 上\r\n  this.props = props;\r\n  this.context = context;\r\n  this.refs = emptyObject;\r\n  // updater 上挂载了 isMounted、enqueueForceUpdate、enqueueSetState 等触发器方法\r\n  this.updater = updater || ReactNoopUpdateQueue;\r\n}\r\n\r\n// 原型链上挂载 isReactComponent，在 ReactDOM.render 时用于和函数组件做区分\r\nComponent.prototype.isReactComponent = {};\r\n\r\n// 给类组件添加 `this.setState` 方法\r\nComponent.prototype.setState = function(partialState, callback) {\r\n  // 验证参数是否合法\r\n  invariant(\r\n    typeof partialState === 'object' ||\r\n      typeof partialState === 'function' ||\r\n      partialState == null\r\n  );\r\n  // 添加至 enqueueSetState 队列\r\n  this.updater.enqueueSetState(this, partialState, callback, 'setState');\r\n};\r\n\r\n// 给类组件添加 `this.forceUpdate` 方法\r\nComponent.prototype.forceUpdate = function(callback) {\r\n  // 添加至 enqueueForceUpdate 队列\r\n  this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');\r\n};\r\n```\r\n### React.Component流程\r\n1. 将props、context、updater挂载到this上。\r\n2. 在Component原型链上添加isReactComponent对象，用于标记类组件。\r\n3. 在Component原型链上添加setState方法。\r\n4. 在Component原型链上添加forceUpdate方法。\r\n5. 理解react类组件super()的作用，以及this.setState和this.forceUpdate的由来。\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## commit阶段\r\n- 在render阶段可以异步中断，但是在commit阶段，一旦开始就不可以被打断，会同步执行直到完成。\r\n- 源码逻辑入口主要在commitRoot方法及方法内部调用的commitRootImpl方法。\r\n \r\n### commit阶段主要工作\r\n- 真实DOM的更新。\r\n- 生命周期函数以及hooks逻辑的执行。\r\n- ref引用的处理。\r\n- Fiber树的切换，workInProgress Fiber树切换为current Fiber树。\r\n### commit阶段工作步骤\r\n- 准备工作阶段\r\n- beforeMutation阶段\r\n- Mutation阶段\r\n- Fiber树切换阶段\r\n- Layout阶段\r\n- 结束工作阶段\r\n### 准备工作阶段\r\n- commitRootImpl方法内部会先执行flushPassiveEffects方法，去完成上一次commit可能存在的useEffect，从而保证每一次commit阶段调度的useEffect必须在下一次commit执行之前先执行一次。\r\n- 然后调度本次commit阶段的useEffect，通过scheduleCallback方法生成一个新的宏任务来处理，从而保证在本次DOM更新完成后执行。\r\n### beforeMutation阶段\r\n- commitRootImpl方法内部调用commitBeforeMutationEffects方法(遍历整个Fiber树)。\r\n- commitBeforeMutationEffects方法内部调用commitBeforeMutationEffects_begin、commitBeforeMutationEffects_complete方法，实现对整个Fiber树的遍历，遍历流程与生成Fiber树的beginWork、completeWork方法类似。\r\n- commitBeforeMutationEffects_complete方法内部调用commitBeforeMutationEffectsOnFiber方法根据Fiber节点类型执行对应逻辑。\r\n  - 针对class组件更新实例上的state、props等以及处理getSnapshotBeforeUpdate生命周期方法。\r\n  - 针对HostFiber节点(根Fiber节点)清空根DOM节点内部内容方便mutation阶段的渲染。\r\n### Mutation阶段\r\n- commitRootImpl方法内部调用commitMutationEffects方法，commitMutationEffects方法内部调用commitMutationEffectsOnFiber方法。\r\n- commitMutationEffectsOnFiber方法根据Fiber节点类型执行对应逻辑。针对class组件、function组件、原生DOM节点、文本节点、HostFiber节点执行相同的逻辑调用recursivelyTraverseMutationEffects方法和commitReconciliationEffects方法自上而下开始遍历执行删除DOM操作，然后到了最底层子节点开始自下而上执行插入和更新DOM操作。\r\n- recursivelyTraverseMutationEffects方法内部根据节点的deletions属性循环执行对应删除逻辑。deletions中的节点依次调用commitDeletionEffects方法，commitDeletionEffects方法内部又会调用commitDeletionEffectsOnFiber方法。\r\n  - 针对原生DOM节点设置ref为null，向下遍历子节点执行删除操作，调用removeChild方法删除真实DOM。\r\n  - 针对class组件设置ref为null，执行componentWillUnmount生命周期函数，向下遍历子节点执行删除操作。\r\n  - 针对function组件执行useLayoutEffect的destory销毁逻辑，向下遍历子节点执行删除操作。\r\n- commitReconciliationEffects方法内部会调用commitPlacement方法执行真实DOM的更新操作。\r\n- **Mutation阶段的循环区别于beforeMutation阶段的循环，不会有向上return循环父节点时执行对应生命周期的逻辑，所以父子组件生命周期的调用顺序中componentWillUnmount生命周期方法的调用顺序区别于其它生命周期方法。**\r\n- **Mutation阶段真实DOM已经渲染完毕。**\r\n### Fiber树切换阶段\r\n- commitRootImpl方法内部调用root.current = finishedWork完成Fiber 树的切换。\r\n- 之所以在这一时机切换Fiber树是因为class组件当执行componentWillUnmount(Mutation阶段)的时候，current Fiber树仍对应UI中的树，当执行componentDidMount/componentDidUpdate(Layout阶段)的时候，current Fiber树就对应本次更新的Fiber树了，也就是原来的workInProgress Fiber树变成了current Fiber树。\r\n### Layout阶段\r\n- commitRootImpl方法内部调用commitLayoutEffects方法。\r\n- commitLayoutEffects方法内部调用commitLayoutEffects_begin、commitLayoutMountEffects_complete方法，实现对整个Fiber树的遍历，遍历流程与beforeMutation阶段类似。\r\n- commitLayoutMountEffects_complete方法内部调用commitLayoutEffectOnFiber方法，commitLayoutEffectOnFiber方法根据Fiber节点类型执行对应逻辑\r\n  - 针对function组件执行useLayoutEffect内部逻辑。\r\n  - 针对class组件执行componentDidMount或componentDidUpdate生命周期函数，之后还要处理commitUpdateQueue中的回调函数(setState的回调)。\r\n  - 针对HostFiber节点处理ReactDOM.render的回调函数。\r\n  - 针对原生DOM节点处理自动更新的情况。\r\n### 结束工作阶段\r\n- 再次处理useEffect的逻辑，先执行destory销毁逻辑再执行内部的逻辑。\r\n- 执行commit阶段相关的同步任务。\r\n- **useEffect在useLayoutEffect之后执行，useLayoutEffect在layout阶段执行。**"},function(r,n,e){"use strict";e.r(n),n.default="## createElement\r\n### React.createElement接收三个或以上参数\r\n1. type：要创建的React元素类型，可以是标签名称字符串如'div'或者'span'等。也可以是React组件类型(class组件或者函数组件)。或者是React Fragment类型。\r\n2. config：写在标签上的属性的集合，js对象格式，若标签上未添加任何属性则为null。\r\n3. children：从第三个参数开始后的参数为当前创建的React元素的子节点，每个参数的类型若是当前元素节点的textContent则为字符串类型，否则为新的React.createElement创建的元素。\r\n### React.createElement源码\r\n```\r\nexport function createElement(type, config, children) {\r\n  let propName;\r\n\r\n  // 记录标签上的属性集合\r\n  const props = {};\r\n\r\n  let key = null;\r\n  let ref = null;\r\n  let self = null;\r\n  let source = null;\r\n\r\n  // config 不为 null 时，说明标签上有属性，将属性添加到 props 中\r\n  // 其中，key 和 ref 为 react 提供的特殊属性，不加入到 props 中，而是用 key 和 ref 单独记录\r\n  if (config != null) {\r\n    if (hasValidRef(config)) {\r\n      // 有合法的 ref 时，则给 ref 赋值\r\n      ref = config.ref;\r\n      \r\n      if (__DEV__) {\r\n        warnIfStringRefCannotBeAutoConverted(config);\r\n      }\r\n    }\r\n    if (hasValidKey(config)) {\r\n      // 有合法的 key 时，则给 key 赋值\r\n      key = '' + config.key;\r\n    }\r\n\r\n    // self 和 source 是开发环境下对代码在编译器中位置等信息进行记录，用于开发环境下调试\r\n    self = config.__self === undefined ? null : config.__self;\r\n    source = config.__source === undefined ? null : config.__source;\r\n    // 将 config 中除 key、ref、__self、__source 之外的属性添加到 props 中\r\n    for (propName in config) {\r\n      if (\r\n        hasOwnProperty.call(config, propName) &&\r\n        !RESERVED_PROPS.hasOwnProperty(propName)\r\n      ) {\r\n        props[propName] = config[propName];\r\n      }\r\n    }\r\n  }\r\n\r\n  // 将子节点添加到 props 的 children 属性上\r\n  const childrenLength = arguments.length - 2;\r\n  if (childrenLength === 1) {\r\n    // 共 3 个参数时表示只有一个子节点，直接将子节点赋值给 props 的 children 属性\r\n    props.children = children;\r\n  } else if (childrenLength > 1) {\r\n    // 3 个以上参数时表示有多个子节点，将子节点 push 到一个数组中然后将数组赋值给 props 的 children\r\n    const childArray = Array(childrenLength);\r\n    for (let i = 0; i < childrenLength; i++) {\r\n      childArray[i] = arguments[i + 2];\r\n    }\r\n    // 开发环境下冻结 childArray，防止被随意修改\r\n    if (__DEV__) {\r\n      if (Object.freeze) {\r\n        Object.freeze(childArray);\r\n      }\r\n    }\r\n    props.children = childArray;\r\n  }\r\n\r\n  // 如果有 defaultProps，对其遍历并且将用户在标签上未对其手动设置属性添加进 props 中\r\n  // 此处针对 class 组件类型\r\n  if (type && type.defaultProps) {\r\n    const defaultProps = type.defaultProps;\r\n    for (propName in defaultProps) {\r\n      if (props[propName] === undefined) {\r\n        props[propName] = defaultProps[propName];\r\n      }\r\n    }\r\n  }\r\n  \r\n  // key 和 ref 不挂载到 props 上\r\n  // 开发环境下若想通过 props.key 或者 props.ref 获取则 warning\r\n  if (__DEV__) {\r\n    if (key || ref) {\r\n      const displayName =\r\n        typeof type === 'function'\r\n          ? type.displayName || type.name || 'Unknown'\r\n          : type;\r\n      if (key) {\r\n        defineKeyPropWarningGetter(props, displayName);\r\n      }\r\n      if (ref) {\r\n        defineRefPropWarningGetter(props, displayName);\r\n      }\r\n    }\r\n  }\r\n  \r\n  // 调用 ReactElement 并返回\r\n  return ReactElement(\r\n    type,\r\n    key,\r\n    ref,\r\n    self,\r\n    source,\r\n    ReactCurrentOwner.current,\r\n    props,\r\n  );\r\n}\r\n```\r\n### React.createElement流程\r\n1. 解析config参数中是否有合法的key、ref、__source和__self 属性，若存在分别赋值给key、ref、source和self，将剩余的属性解析挂载到props上。\r\n2. 除type和config外后面的参数，挂载到props.children上。\r\n3. 针对类组件，如果type.defaultProps存在，遍历type.defaultProps的属性，如果props不存在该属性，则添加到props上。\r\n4. 将type、key、ref、self、source、props等信息，调用ReactElement函数创建虚拟dom，ReactElement主要是在开发环境下通过Object.defineProperty将 _store、_self、_source设置为不可枚举，提高element比较时的性能。\r\n### ReactElement源码\r\n```\r\nconst ReactElement = function(type, key, ref, self, source, owner, props) {\r\n  const element = {\r\n    // 用于表示是否为 ReactElement\r\n    $$typeof: REACT_ELEMENT_TYPE,\r\n\r\n    // 用于创建真实 dom 的相关信息\r\n    type: type,\r\n    key: key,\r\n    ref: ref,\r\n    props: props,\r\n\r\n    _owner: owner,\r\n  };\r\n\r\n  if (__DEV__) {\r\n    element._store = {};\r\n\r\n    // 开发环境下将 _store、_self、_source 设置为不可枚举，提高 element 的比较性能\r\n    Object.defineProperty(element._store, 'validated', {\r\n      configurable: false,\r\n      enumerable: false,\r\n      writable: true,\r\n      value: false,\r\n    });\r\n\r\n    Object.defineProperty(element, '_self', {\r\n      configurable: false,\r\n      enumerable: false,\r\n      writable: false,\r\n      value: self,\r\n    });\r\n\r\n    Object.defineProperty(element, '_source', {\r\n      configurable: false,\r\n      enumerable: false,\r\n      writable: false,\r\n      value: source,\r\n    });\r\n    // 冻结 element 和 props，防止被手动修改\r\n    if (Object.freeze) {\r\n      Object.freeze(element.props);\r\n      Object.freeze(element);\r\n    }\r\n  }\r\n\r\n  return element;\r\n};\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## 源码调试\r\n### 修改node_modules里的包后没有效果\r\n- 将node_modules下的.cache目录删除，重启项目后可以读取到node_modules的更新。\r\n- 修改webpack配置，将cache置为false后可以读取到node_modules的更新。"},function(r,n,e){"use strict";e.r(n),n.default="## react-redux\r\n###  Provider实现\r\n> Provider将store放进this.context里，就能在组件中通过this.context.store这样的形式取到store，不需要再单独import store。同时也用于connect方法中更好的直接使用store。\r\n\r\n```\r\nimport React from 'react'\r\nimport PropTypes from 'prop-types'\r\n\r\nexport class Provider extends React.Component {  \r\n  // 需要声明静态属性childContextTypes来指定context对象的属性,是context的固定写法  \r\n  static childContextTypes = {    \r\n    store: PropTypes.object  \r\n  } \r\n\r\n  // 实现getChildContext方法,返回context对象,也是固定写法  \r\n  getChildContext() {    \r\n    return { store: this.store }  \r\n  }  \r\n\r\n  constructor(props, context) {    \r\n    super(props, context)    \r\n    this.store = props.store  \r\n  }  \r\n\r\n  // 渲染被Provider包裹的组件  \r\n  render() {    \r\n    return this.props.children  \r\n  }\r\n}\r\n```\r\n### Connect实现\r\n> connect接收mapStateToProps、mapDispatchToProps两个方法，然后返回一个高阶函数，这个高阶函数接收一个组件，返回一个高阶组件(其实就是给传入的组件增加一些属性和功能)，connect根据传入的map，将state和dispatch(action)挂载子组件的props上。其实context不过是给connect提供了获取store的途径，我们在connect中直接import store完全可以取代context。那么Provider存在的意义是什么，上面这个connect是自己写的，可以直接import store，但react-redux的connect是封装的，对外只提供api，所以需要让Provider传入store。\r\n\r\n```\r\nexport function connect(mapStateToProps, mapDispatchToProps) {    \r\n  return function(Component) {      \r\n    class Connect extends React.Component {        \r\n      componentDidMount() {          \r\n        // 从context获取store并订阅更新          \r\n        this.context.store.subscribe(this.handleStoreChange.bind(this));        \r\n      }       \r\n      handleStoreChange() {          \r\n        // 触发更新          \r\n        // 触发的方法有多种,这里为了简洁起见,直接forceUpdate强制更新,读者也可以通过setState来触发子组件更新          \r\n        this.forceUpdate()        \r\n      }        \r\n      render() {          \r\n        return (            \r\n          <Component              \r\n            // 传入该组件的props,需要由connect这个高阶组件原样传回原组件              \r\n            { ...this.props }              \r\n            // 根据mapStateToProps把state挂到this.props上              \r\n            { ...mapStateToProps(this.context.store.getState()) }               \r\n            // 根据mapDispatchToProps把dispatch(action)挂到this.props上              \r\n            { ...mapDispatchToProps(this.context.store.dispatch) }                 \r\n          />              \r\n        )        \r\n      }      \r\n    }      \r\n    //接收context的固定写法      \r\n    Connect.contextTypes = {        \r\n      store: PropTypes.object      \r\n    }      \r\n    return Connect    \r\n  }\r\n}\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## [redux](https://juejin.cn/post/6844904036013965325)\r\n- Redux遵循“单向数据流”和“不可变状态模型”的设计思想。\r\n- 这使得Redux的状态变化是可预测、可调试的。\r\n### 页面映射redux状态后页面更新机制\r\n- 页面映射redux中store某个状态时，只有当这个状态变化页面才会重新render，其它没有映射的状态变化不会导致页面重新render。\r\n- 注意页面映射状态(connect、useSelector)的范围，映射粒度要小，不要将整个store映射到页面上(即使页面只使用了其中的一部分状态)，只映射需要的状态。\r\n### 异步状态更新\r\n- redux执行action是同步的，但是reducer中将新状态返回更新store数据仓库的过程是异步的。\r\n- 组件通过react-redux封装后相当于包了一层高阶组件。而这一个高阶组件在redux里的state更新时会调用setState，所以redux的store的数据仓库更新才会有异步更新的现象。\r\n### 工作流程\r\n- 用户在view层触发某个事件，通过dispatch发送了action和payload。\r\n- action和payload被传入reducer函数，返回一个新的state。\r\n- store拿到reducer返回的state并做更新，同时通知view层进行re-render。\r\n### 三大要素\r\n- 单一数据源，state存储在唯一的store中。\r\n- state是只读的，唯一改变state的方法是dispatch action，action是一个用于描述已发生事件的普通对象。\r\n- 纯函数修改，通过reducer纯函数修改状态，它接收之前的state和action，并返回新的state。一定要返回一个新的对象，而不是修改之前的state。\r\n### reducer为什么要返回一个新的对象\r\n- redux源码中会比较传入的state和reducer修改之后的state，如果相同则返回旧的对象，如果不同则返回新的对象。\r\n- 比较两个javascript对象中所有的属性是否完全相同，唯一的办法就是深比较，深比较在真实的应用中代码是非常大的，非常耗性能的，需要比较的次数特别多，所以一个有效的解决方案就是做一个规定，当无论发生任何变化时开发者都要返回一个新的对象，没有变化时开发者返回旧的对象，这样直接比较对象的存储地址即可以。\r\n```\r\nfor (let i = 0; i < finalReducerKeys.length; i++) {\r\n  const key = finalReducerKeys[i]\r\n  const reducer = finalReducers[key]\r\n  const previousStateForKey = state[key]\r\n  const nextStateForKey = reducer(previousStateForKey, action)\r\n  if (typeof nextStateForKey === 'undefined') {\r\n    const errorMessage = getUndefinedStateErrorMessage(key, action)\r\n    throw new Error(errorMessage)\r\n  }\r\n  nextState[key] = nextStateForKey\r\n  hasChanged = hasChanged || nextStateForKey !== previousStateForKey\r\n}\r\nreturn hasChanged ? nextState : state\r\n```\r\n\r\n"},function(r,n,e){"use strict";e.r(n),n.default='## redux与mobx对比\r\n- 两个状态库的关键词，redux：不可变值；mobx：可观察的。\r\n- 都解决了状态管理中状态混乱，传递不便捷，无法有效同步状态的问题。\r\n### 数据流\r\n- redux\r\n![redux数据流](./img/redux数据流.png)\r\n- mobx\r\n![mobx数据流](./img/mobx数据流.png)\r\n### 设计思想\r\n- redux\r\n  - 基于单向数据流和纯函数的理念，遵循严格的单一数据源原则。\r\n  - 采用action - reducer的模式，action描述状态的变化，reducer是一个纯函数，根据旧状态和action计算并返回新状态。这种模式使得状态变化可预测，便于调试和维护。\r\n- mobx\r\n  - 基于响应式编程思想，它将状态视为可观察对象，当这些可观察对象的值发生变化时，依赖于它们的组件或计算值会自动更新。\r\n  - 强调状态的自由流动和最小化样板代码，允许在任何地方修改状态，只要遵循mobx的响应式规则。\r\n### 性能\r\n- redux\r\n  - 由于每次状态变化都需要创建新的状态对象，在处理大型数据结构时频繁创建新对象会消耗大量的内存和CPU资源。\r\n  - 当组件映射的状态不够精细时可能会导致性能问题。通过使用React-Redux的connect高阶组件或Hooks精准映射使用的state，可以优化组件的渲染，减少不必要的重新渲染。\r\n- mobx\r\n  - 可以直接在任何地方修改状态，无需创建新的状态对象。\r\n  - 采用响应式更新机制，只有依赖于发生变化的可观察对象的组件才会重新渲染，因此在性能上通常表现较好，尤其是在处理复杂的状态更新时。\r\n\r\n| redux | mobx |\r\n| --- | --- |\r\n| 需要中间件处理异步 | 可以直接处理异步 |\r\n| 需要保证数据不可变 | 数据是响应式的，可以直接修改数据 |\r\n| 状态变化是可预测的，可以记录所有的action，调试相对容易 | 调试相对复杂，因为状态的变化可以在任何地方发生，难以追踪状态的变化路径 |\r\n| 有严格的工作流程，需要写一些模板代码 | 无模板代码，非常简洁 |\r\n| 约束强，适合大型多人协作开发 | 适合简单规模不大的应用 |\r\n\r\n### mobx采用响应式更新机制，只有使用发生变化的可观察对象的组件才会重新渲染。\r\n> 在Age组件中更新store.info.detail.age时，只有Age组件会重新渲染，Sex组件不会重新渲染。因为Sex组件只使用了store.info.detail.sex，没有使用store.info.detail.age。\r\n\r\n- store.js\r\n```\r\nimport { makeAutoObservable, action } from "mobx";\r\n\r\nclass Store {\r\n  info = {\r\n    name: "dyx",\r\n    detail: {\r\n      age: 28,\r\n      sex: "man",\r\n    },\r\n  };\r\n\r\n  constructor() {\r\n    makeAutoObservable(this);\r\n  }\r\n  @action changeAge = (age) => {\r\n    this.info.detail.age = age;\r\n  };\r\n}\r\n\r\nexport default new Store();\r\n```\r\n- app.js\r\n```\r\nimport React from "react";\r\nimport { inject, observer } from "mobx-react";\r\nimport Age from "./age";\r\nimport Sex from "./sex";\r\n\r\nfunction App(props) {\r\n  return (\r\n    <div>\r\n      {props.name}\r\n      <Age />\r\n      <Sex />\r\n    </div>\r\n  );\r\n}\r\n\r\nconst mapStoreToProps = ({ store }) => {\r\n  return {\r\n    name: store.info.name,\r\n  };\r\n};\r\n\r\nexport default inject(mapStoreToProps)(observer(App));\r\n```\r\n- age.js\r\n```\r\nimport React from "react";\r\nimport { inject, observer } from "mobx-react";\r\n\r\nfunction Age(props) {\r\n  console.log("age", "dyx");\r\n  return (\r\n    <div>\r\n      {props.detail.age}\r\n      <button onClick={() => props.changeAge(props.detail.age + 1)}>+1</button>\r\n    </div>\r\n  );\r\n}\r\n\r\nconst mapStoreToProps = ({ store }) => {\r\n  return {\r\n    detail: store.info.detail,\r\n    changeAge: store.changeAge,\r\n  };\r\n};\r\n\r\nexport default inject(mapStoreToProps)(observer(Age));\r\n```\r\n- sex.js\r\n```\r\nimport React from "react";\r\nimport { inject, observer } from "mobx-react";\r\n\r\nfunction Sex(props) {\r\n  console.log("sex", "dyx");\r\n  return <div>{props.detail.sex}</div>;\r\n}\r\n\r\nconst mapStoreToProps = ({ store }) => {\r\n  return {\r\n    detail: store.info.detail,\r\n  };\r\n};\r\n\r\nexport default inject(mapStoreToProps)(observer(Sex));\r\n```\r\n### redux根据映射到组件的状态是否变化，决定是否重新渲染组件，即使组件没有使用到该状态，也会重新渲染。\r\n> 在Age组件中更新store.info.detail.age时，Age组件和Sex组件都会重新渲染，因为两个组件都映射了detail状态，如果将Sex组件精细的只映射store.info.detail.sex时，Sex组件不会重新渲染。\r\n\r\n- store.js\r\n```\r\nimport { createStore } from "redux";\r\n\r\nconst initialState = {\r\n  info: {\r\n    name: "dyx",\r\n    detail: {\r\n      age: 28,\r\n      sex: "man",\r\n    },\r\n  },\r\n};\r\n\r\nconst reducers = (state = initialState, action) => {\r\n  const payload = action.payload;\r\n  switch (action.type) {\r\n    case "changeAge":\r\n      return {\r\n        ...state,\r\n        info: {\r\n          ...state.info,\r\n          detail: {\r\n            ...state.info.detail,\r\n            age: payload,\r\n          },\r\n        },\r\n      };\r\n    default:\r\n      return state;\r\n  }\r\n};\r\n\r\nexport const store = createStore(reducers);\r\n```\r\n- app.js\r\n```\r\nimport React from "react";\r\nimport { connect } from "react-redux";\r\nimport Age from "./age";\r\nimport Sex from "./sex";\r\n\r\nfunction App(props) {\r\n  return (\r\n    <div>\r\n      {props.name}\r\n      <Age />\r\n      <Sex />\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default connect((state) => ({\r\n  name: state.info.name,\r\n}))(App);\r\n```\r\n- age.js\r\n```\r\nimport React from "react";\r\nimport { connect } from "react-redux";\r\n\r\nfunction Age(props) {\r\n  console.log("age", "dyx");\r\n  return (\r\n    <div>\r\n      {props.detail.age}\r\n      <button\r\n        onClick={() => {\r\n          props.dispatch({\r\n            type: "changeAge",\r\n            payload: props.detail.age + 1,\r\n          });\r\n        }}\r\n      >\r\n        +1\r\n      </button>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default connect((state) => ({\r\n  detail: state.info.detail,\r\n}))(Age);\r\n```\r\n- sex.js\r\n```\r\nimport React from "react";\r\nimport { connect } from "react-redux";\r\n\r\nfunction Sex(props) {\r\n  console.log("sex", "dyx");\r\n  return (\r\n    <div>\r\n      {props.detail.sex}\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default connect((state) => ({\r\n  detail: state.info.detail,\r\n}))(Sex);\r\n```'},function(r,n,e){"use strict";e.r(n),n.default="## redux实现\r\n### getState的实现\r\n```\r\nexport const createStore = () => {    \r\n  let currentState = {}       // 公共状态    \r\n  function getState() {       // getter        \r\n    return currentState    \r\n  }    \r\n  function dispatch() {}      // setter    \r\n  function subscribe() {}     // 发布订阅    \r\n  return { getState, dispatch, subscribe }\r\n}\r\n```\r\n### dispatch实现\r\n```\r\nexport const createStore = () => {    \r\n  let currentState = {}    \r\n  function getState() {        \r\n    return currentState    \r\n  }    \r\n  function dispatch(action) {        \r\n    switch (action.type) {            \r\n      case 'plus':            \r\n      currentState = {                 \r\n        ...state,                 \r\n        count: currentState.count + 1            \r\n      }        \r\n    }    \r\n  }    \r\n  function subscribe() {}    \r\n  return { getState, subscribe, dispatch }\r\n}\r\n\r\n// reducer抽离\r\n// reducer.js\r\nconst initialState = {    \r\n  count: 0\r\n}\r\nexport function reducer(state = initialState, action) {    \r\n  switch(action.type) {      \r\n    case 'plus':        \r\n    return {            \r\n      ...state,                    \r\n      count: state.count + 1        \r\n    }      \r\n    case 'subtract':        \r\n    return {            \r\n      ...state,            \r\n      count: state.count - 1        \r\n    }      \r\n    default:        \r\n    return initialState    \r\n  }\r\n}\r\n\r\nimport { reducer } from './reducer'\r\nexport const createStore = (reducer) => {    \r\n  let currentState = {}     \r\n  function getState() {        \r\n    return currentState    \r\n  }    \r\n  function dispatch(action) {         \r\n    currentState = reducer(currentState, action)  \r\n  }    \r\n  function subscribe() {}    \r\n  dispatch({ type: '@@REDUX_INIT' })  // 初始化store数据  \r\n  return { getState, dispatch, subscribe }\r\n}\r\n```\r\n### subscribe实现\r\n```\r\nimport { reducer } from './reducer'\r\nexport const createStore = (reducer) => {        \r\n  let currentState = {}        \r\n  let observers = []             // 观察者队列        \r\n  function getState() {                \r\n    return currentState        \r\n  }        \r\n  function dispatch(action) {                \r\n    currentState = reducer(currentState, action)                \r\n    observers.forEach(fn => fn())        \r\n  }        \r\n  function subscribe(fn) {                \r\n    observers.push(fn)        \r\n  }        \r\n  dispatch({ type: '@@REDUX_INIT' })  // 初始化store数据        \r\n  return { getState, subscribe, dispatch }\r\n}\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## SEO(搜索引擎优化)\r\n### 查看网站收录情况\r\n- site+域名查询法  site:iov.zhkhy.com\r\n- [站长工具中查看收录情况](https://seo.chinaz.com)\r\n### 优化手段\r\n- 设置title、description、keywords。\r\n- 在网页中添加特定的Open Graph协议，可以帮助提供更丰富的预览信息。\r\n- HTML语义化。\r\n  1. 方便其它设备进行解析，例如盲人阅读器。\r\n  2. 有利于SEO，搜索引擎更容易理解语义化页面的内容结构和主题。\r\n  3. 便于团队开发和维护，语义化更具有可读性。\r\n- sitemap站点地图帮助搜索引擎更好地发现和抓取网站上的所有页面，并提供页面优先级和更新频率的信息，帮助搜索引擎更好地分配抓取资源。sitemap.xml一般放在网站的根目录下，如果sitemap.xml没有放在根目录，需在robots.txt中指明Sitemap位置，否则搜索引擎可能无法找到。\r\n- robots文件用来告诉搜索引擎机器人应该如何抓取和索引该网站的一种标准，robots.txt文件需放置在网站的根目录下。\r\n- 各搜索引擎提交站点收录。\r\n  1. 百度：https://ziyuan.baidu.com\r\n  2. 谷歌：https://developers.google.com/search?hl=zh-cn\r\n  3. 搜狗：https://zhanzhang.sogou.com\r\n  4. 360：https://zhanzhang.so.com\r\n  5. 必应：https://www.bing.com/webmasters/about\r\n- 服务端渲染。\r\n- 网站性能，网站打开速度越快，识别效果越好，否则爬虫会认为该网站对用户不友好，降低爬取效率。\r\n- 网址规范化。\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## sourcemap\r\n> sourcemap是从已转换混淆的代码映射到原始代码的文件，包含着源代码与构建产物之间的映射关系，作用是实现运行时代码和开发时代码都能拥有相同准确的信息提示。\r\n\r\n### sourcemap文件不会影响网页性能\r\n- sourcemap只有在打开devtools的情况下才会开始下载，而大部分用户不会去打开这个面板，所以不会有性能问题。\r\n- 浏览器隐藏了sourcemap文件的下载，使用抓包工具可以看到sourcemap文件的下载。\r\n### 源文件和sourcemap文件关系\r\n- 构建工具开启了sourcemap功能之后，build后的js文件都会有一个对应的.js.map文件，而在build后的js文件中有一段注释标记了该文件对应的sourcemap文件位置。\r\n```\r\n// main.d4c530be.js\r\n...\r\n...\r\n...\r\n//# sourceMappingURL=main.d4c530be.js.map\r\n```\r\n### 通过sourcemap定位源码信息\r\n- next.js使用source-map插件会找不到mappings.wasm文件，使用source-map-js插件代替。\r\n- 解析源码使用source-map插件，直接使用error信息的source字段对应的文件可能无法解析到源码(webpack分包情况下)，可以使用error的stack堆栈信息的第一条对应的文件进行解析。\r\n- 使用error-stack-parser插件解析error的stack堆栈信息。\r\n```\r\nconst sourceMap = require(\"source-map\");\r\nconst ErrorStackParser = require('error-stack-parser');\r\nconst fs = require(\"fs\");\r\n\r\n// 解析错误堆栈信息(errorStack为js错误信息的stack字段内容)\r\nconst errorStackData = ErrorStackParser.parse(new Error(errorStack));\r\nconst { fileName, lineNumber, columnNumber } = errorStackData?.[0] || {};\r\nif (fileName.split('/').pop()) {\r\n  // 读取对应的.js.map文件\r\n  const mapObj = fs.readFileSync(`${__dirname}/../public/static/js/${fileName.split('/').pop()}.map`, 'utf-8');\r\n  const consumer = await new sourceMap.SourceMapConsumer(mapObj);\r\n  // 根据报错信息映射出报错的源文件和错误的行数、列数\r\n  const originalInfo = consumer.originalPositionFor({ line: lineNumber, column: columnNumber });\r\n  // 获取报错源文件的代码\r\n  const sourceCode = consumer.sourceContentFor(originalInfo.source);\r\n  // 错误源码信息\r\n  const errorSource = {\r\n    ...originalInfo,\r\n    sourceCode,\r\n  }\r\n}\r\n```\r\n### 将sourcemap单独打包\r\n- sourcemap默认和build文件打包到同一个文件夹。\r\n- 使用webpack.SourceMapDevToolPlugin打包到指定文件，sourcemap文件更新后会自动覆盖之前的sourcemap文件。\r\n```\r\n// static文件夹存放build后的文件，将sourcemap文件存储在sourcemaps文件夹下(和static文件夹同级目录)\r\nnew webpack.SourceMapDevToolPlugin({\r\n  filename: 'sourcemaps/[file].map',\r\n  fileContext: 'static',\r\n}),\r\n```\r\n### 浏览器中sourcemap生效\r\n- 浏览器默认会开启sourcemap，如果没有开启可以通过 settings => preferences => enable javascript source map 开启sourcemap。\r\n### sentry上传sourcemap文件\r\n- [sentry](https://juejin.cn/post/7209648356530962489#heading-10)\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## webpack中使用sourcemap\r\n> webpack中通过设置devtool的选项配置使用sourcemap功能，值类型包括以下类型的组合。\r\n\r\n- none(默认值)\r\n  1. 不会生成map文件。\r\n- eval\r\n  1. 会生成被eval函数包裹的模块内容，并在其中通过注释来注明是源文件位置，其中的sourceUrl是用来来指定文件名。\r\n  2. 优点是快因为不用生成.map文件，并且运行时代码映射到开发时代码只需要提供对应的源文件地址。\r\n  3. 缺点就是包含映射信息少，并且eval函数因为安全性问题也是不建议使用的。\r\n![eval](./img/sourcemapEval.jpg)\r\n- source-map\r\n  1. 会生成单独的.map文件包含version、file、sources、sourcesContent、names、mappings、sourceRoot等信息，需要进行mapping和编码工作。\r\n  2. 优点就是拥有单独的.map文件，使得运行时代码体积不会过大，并且能够提供详细的信息，包含文件名、行、列等信息。\r\n  3. 缺点就是慢，因为需要额外生成.map文件，并且随着模块内容的增多整体速度就越慢。\r\n![sourcemap](./img/sourcemap.jpg)\r\n- cheap\r\n  1. 和source-map的方式不同，cheap只会映射到源码的行信息，即它不会生成源码的列信息，也不包含loader的sourcemap，因此相对来说会比source-map的方式更快。\r\n  2. 优点就是速度更快，只映射到源码的行信息的原因是：通常在进行错误定位时，大多数情况下只需要关注到行就可以知道错误原因，而很少会关注到列，因此列信息其实不是必要性的。\r\n  3. 缺点就是映射信息会不够精确，因为一个文件可能会经过不同loader的处理，而它又不生成loader相关的sourcemap，自然会导致最终产物的信息不够精确。\r\n- module\r\n  1. module的方式生成的sourcemap就会包含和loader相关的sourcemap信息。\r\n  2. 需要loader相关的sourcemap信息的原因在于当一个文件被多个laoder依次进行转换处理后，其内容会发生不同的变化，就会使得我们无法去调试最初始的代码内容。\r\n- inline\r\n  1. 会将原本生成的.map文件的内容作为DataURL(base64 形式)嵌入bundle文件中，不单独生成.map文件。\r\n![sourcemapInline](./img/sourcemapInline.jpg)\r\n- hidden\r\n  1. 会生成单独的.map文件，但是相比于source-map的形式，其会在对应的bundle文件中隐藏sourceMappingURL的路径。\r\n![sourcemapHidden](./img/sourcemapHidden.jpg)\r\n- nosources\r\n  1. 在source-map生成的.map文件中的sourceContent存储的是源码内容，这样的好处是既可以根据文件路径来映射，也可以根据这部分内容来映射，source-map提供了双重保险，但也增加了.map文件体积。\r\n  2. nosources则是在能够保证文件路径可以准确建立映射的情况下，就可以把sourceContent的内容给去除掉，使得.map文件体积能够更小一些。\r\n![sourcemapNosources](./img/sourcemapNosources.jpg)\r\n![sourcemapNosourcesCompare](./img/sourcemapNosourcesCompare.jpg)\r\n### 生产环境建议使用\r\n> 生产环境下为了防止别人获取源代码，通常不会将sourcemap文件上传到静态资源服务器，而是上传到内部服务器上。当用户触发js错误时，通过前端监控系统或者其它手段收集到出错信息，然后根据内部服务器的sourcemap结合出错信息，找到出错的源代码位置。\r\n\r\n- source-map\r\n  1. 生成的map文件包含完整的原始代码，但是打包会很慢。打包后的js最后一行是map文件地址的注释。\r\n  2. 生产环境报错会正确提示错误的行数、列数，会显示源代码。source面板会显示源代码目录结构和代码。\r\n- nosources-source-map\r\n  1. 生成的map文件不包含源码。\r\n  2. 生产环境报错会正确提示错误的行数。source面板会显示源代码目录结构和文件名，不会显示代码。\r\n- hidden-source-map\r\n  1. 与source-map相同，也会生成map文件，但是打包后的js最后没有map文件地址的引用。\r\n  2. 生产环境报错不会提示错误的行数、列数，source面板不会显示源代码目录结构和代码。"},function(r,n,e){"use strict";e.r(n),n.default="## React服务端渲染\r\n- 服务器不再发送空的HTML文件，而是发送应用程序渲染生成的实际HTML，用户会收到一个完整的HTML文档。\r\n- 这个HTML文件仍然会包含script标签，因为仍然需要React在客户端上运行，以处理任何交互(事件绑定等)。但是React在浏览器端以不同的方式工作：不再从头开始创建所有的DOM节点，而是采用现有的HTML。这个过程称为“hydration”(水合)。\r\n- 一旦JS资源被下载，React将迅速遍历整个应用程序，构建UI的虚拟草图，并将其“贴合”到真实的DOM上，附加事件处理程序，触发任何效果等等。\r\n初始的页面html结构由服务端生成并返回，后续的事件操作交互等交给常规打包完成的js实现。\r\n- hydration(水合)就像用交互性和事件处理程序的“水”来滋润“干燥”的HTML。\r\n- 服务器端渲染(SSR)的要点：服务器生成初始的HTML，这样用户在下载和解析JS资源的过程中就不必盯着空白的页面。后续的事件操作交互等交给常规的JS(客户端React)实现。\r\n### React客户端渲染\r\n- 客户端接收到一个HTML文件，这个文件没有任何内容，但包含一个或多个script标签。\r\n- JS资源被下载并解析后React应用程序将启动，创建一堆DOM节点并填充UI。\r\n![客户端渲染](./img/%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B8%B2%E6%9F%93.webp)\r\n### 服务端静态渲染\r\n- 服务器进行初始渲染，数据请求相关逻辑在客户端完成。\r\n![服务端静态渲染](./img/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%9D%99%E6%80%81%E6%B8%B2%E6%9F%93.webp)\r\n### 服务端动态渲染\r\n- 服务器端进行数据请求，服务器直接发送完全填充数据DOM结构的HTML文件。\r\n![服务端动态渲染](./img/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%8A%A8%E6%80%81%E6%B8%B2%E6%9F%93.webp)\r\n### React Server Components(React服务器组件)\r\n- 专门在服务器上渲染，它们的代码不包含在JS资源中，因此它们不会进行水合处理或重新渲染。\r\n- 不能使用状态，因为状态可以更改，但服务器组件不能重新渲染。也不能使用效果，因为效果只在渲染之后在客户端上运行，而服务器组件永远不会到达客户端。\r\n- 支持异步，支持直接在渲染中进行副作用操作。\r\n- React Server Components不是服务器端渲染的替代品，可以将其视为和服务端渲染完美契合的独立拼图。\r\n```\r\nimport db from 'imaginary-db';\r\n\r\nasync function Homepage() {\r\n  const link = db.connect('localhost', 'root', 'passw0rd');\r\n  const data = await db.query(link, 'SELECT * FROM products');\r\n\r\n  return (\r\n    <>\r\n      <h1>Trending Products</h1>\r\n      {data.map((item) => (\r\n        <article key={item.id}>\r\n          <h2>{item.title}</h2>\r\n          <p>{item.description}</p>\r\n        </article>\r\n      ))}\r\n    </>\r\n  );\r\n}\r\n\r\nexport default Homepage;\r\n```\r\n### React Server Components目前只能搭配Next.js使用\r\n- 在Next.js的React Server Components模式下默认情况下所有组件都是服务器组件。\r\n- 当需要使用状态或者添加交互时可以通过use client关键字表明此文件中的组件是客户端组件，它们应该包含在JS资源中，以便它们可以在客户端重新渲染。\r\n- 使用use client关键字声明为客户端组件之后，这个客户端组件只能导入其它客户端组件，导入的组件即使没有声明use client关键字，也会隐式将导入的组件转化为客户端组件。\r\n- 为了防止一个组件声明为客户端组件之后该组件导入的所有组件都将隐式的转化为客户端组件的问题，可以将需要使用客户端组件相关功能的逻辑单独提取为一个组件，并将该组件移动到独有的文件中，从而减少使用use client关键字的影响范围。\r\n- 声明为客户端组件之后隐式将导入的组件转化为客户端组件的特性只在文件/模块级别工作，不会因为组件层级关系而隐式转化，服务端组件是客户端组件(文件中没有导入服务端组件)的子组件时不会隐式将子组件转化为客户端组件。\r\n### React Server Components的优势\r\n- 性能更好，服务器组件不包含在JS资源中，这减少了需要下载的JavaScript数量，以及需要hydration(水合)的组件数量。\r\n![no-src](./img/no-rsc.webp)\r\n![with-src](./img/with-rsc.webp)"},function(r,n,e){"use strict";e.r(n),n.default="## SSR服务端渲染\r\n- CSR(客户端渲染)和SSR(服务端渲染)最大的区别在于前者的页面DOM是JS负责生成的，而后者是服务器端直接返回HTML。\r\n### CSR(客户端渲染)的弊端\r\n- 由于页面显示过程要进行JS文件拉取和通过JS向html中填充DOM，首屏加载时间会比较慢。\r\n- 对于SEO(Search Engine Optimazition即搜索引擎优化)完全无能为力，因为搜索引擎爬虫只认识html结构的内容，而不能识别JS代码内容。"},function(r,n,e){"use strict";e.r(n),n.default="## 框架\r\n- React、Vue3、Vue2 列表的 Diff 算法对比\r\n## react\r\n- react事件机制\r\n"},function(r,n,e){"use strict";e.r(n),n.default='## export和export type的区别\r\n> 在TypeScript中，export type和export是两种不同的导出方式，它们在不同情况下有着重要的区别。\r\n\r\n### 导出为接口(interface)时\r\n- export { IContext }\t导出接口类型。\r\n- export type { IContext } 导出接口类型。\r\n- 对于纯接口两种导出方式效果相同，因为接口只存在于类型空间，没有值空间的表示。\r\n```\r\ninterface IContext {\r\n  userId: string;\r\n  // ...其他属性\r\n}\r\n```\r\n### 导出为类(class)时\r\n- export { IContext }\t同时导出类型和类的实现（可以用于类型注解和创建实例）。\r\n- export type { IContext } 只导出类型部分（只能用于类型注解，不能创建实例）。\r\n```\r\nclass IContext {\r\n  userId: string;\r\n  constructor(id: string) {\r\n    this.userId = id;\r\n  }\r\n  \r\n  getUserInfo() {\r\n    return `User ID: ${this.userId}`;\r\n  }\r\n}\r\n```\r\n### 导出为枚举(enum)时\r\n- export { IContext } 导出枚举的类型和值（可以访问枚举成员）。\r\n- export type { IContext } 只导出枚举的类型（不能访问枚举成员）。\r\n```\r\nenum IContext {\r\n  Admin = "admin",\r\n  User = "user",\r\n  Guest = "guest"\r\n}\r\n```\r\n### 导出为类型(type)时\r\n- export { IContext } 导出类型别名。\r\n- export type { IContext } 导出类型别名。\r\n- 对于类型两种导出方式效果相同，因为类型别名只存在于类型空间。\r\n```\r\ntype IContext = {\r\n  userId: string;\r\n  // ...其他属性\r\n};\r\n```\r\n### 实际应用建议\r\n- 对于纯类型（接口、类型）：\r\n  - 两种方式都可以，但使用export type更明确表示只导出类型。\r\n- 对于同时有类型和值的声明（类、枚举）：\r\n  - 使用export { IContext }导出完整定义（类型+值）。\r\n  - 使用export type { IContext }仅导出类型部分。\r\n- 重新导出时的最佳实践：\r\n  - 如果确定只需要类型：export type { IContext } from "..."\r\n  - 如果需要完整定义：export { IContext } from "..."\r\n  - 如果不确定：使用export { IContext } from "..."更安全，因为它保留了所有信息。\r\n- 使用import type的情况：\r\n  - 当只需要类型信息时可以使用import type { IContext } from \'...\'，这样可以确保在编译后的JavaScript中不会包含这些导入，有助于减小打包体积。\r\n### 总结\r\n- 对于纯类型（接口、类型），两种方式效果相似。\r\n- 对于有运行时值的声明（类、枚举），两种方式有显著差异。\r\n'},function(r,n,e){"use strict";e.r(n),n.default="## interface和type的异同\r\n- 能用interface实现就用interface，如果不能就用type。\r\n### 相同点\r\n- 都可以描述一个对象和函数。\r\n```\r\ninterface User {\r\n  name: string\r\n  age: number\r\n}\r\n\r\ninterface SetUser {\r\n  (name: string, age: number): void;\r\n}\r\n\r\ntype User = {\r\n  name: string\r\n  age: number\r\n};\r\n\r\ntype SetUser = (name: string, age: number) => void;\r\n```\r\n- interface和type都可以继承，可以相互继承\r\n  - interface继承interface\r\n  ```\r\n  interface Person {\r\n    name:string\r\n  }\r\n  interface Student extends Person { stuNo: number }\r\n  ```\r\n  - interface继承type\r\n  ```\r\n  type Person {\r\n    name:string\r\n  }\r\n  interface Student extends Person { stuNo: number }\r\n  ```\r\n  - type继承type\r\n  ```\r\n  type Person {\r\n    name:string\r\n  }\r\n  type Student = Person & { stuNo: number }\r\n  ```\r\n  - type继承interface\r\n  ```\r\n  interface Person{\r\n    name:string\r\n  }\r\n  type Student = Person & { stuNo: number }\r\n  ```\r\n### 不同点\r\n- type可以声明基本类型别名，联合类型，元组等类型，interface不可以。\r\n```\r\n// 声明基本类型\r\ntype userName = string;\r\ntype stuNo = number;\r\n\r\n// 声明联合类型(表示取值可以为多种类型中的一种)\r\ntype Student = { stuNo: number } | { classId: number }\r\n\r\n// 声明元组\r\ntype Data = [number, string];\r\n```\r\n- interface能够重复声明并且会进行合并，但是type不可以。type重复声明会报错。\r\n```\r\ninterface User {\r\n  name: string\r\n  age: number\r\n}\r\n\r\ninterface User {\r\n  sex: string\r\n}\r\n\r\n/*\r\nUser 接口为 {\r\n  name: string\r\n  age: number\r\n  sex: string \r\n}\r\n*/\r\n```\r\n"},function(r,n,e){"use strict";e.r(n),n.default='## tsconfig.json文件\r\n> tsconfig.json文件是用于描述将TypeScript转为JavaScript代码的配置文件。\r\n\r\n- IDE(代码编辑器)将会根据tsconfig.json文件对当前项目中支持不同程度的类型约束。\r\n- 对TSC编译TypeScript代码过程做一些预定义、约束入口和编译输出目录等配置。\r\n### tsconfig.json配置详解\r\n- files：用于指明需要tsc编译的一个或多个ts文件。\r\n```\r\n{\r\n  "files": [\r\n    "index.ts",\r\n    "global.d.ts"\r\n  ],\r\n}\r\n```\r\n- include：用于指明需要被tsc编译的文件或文件夹列表。\r\n```\r\n{\r\n  "include": [\r\n    "src",\r\n    "global.d.ts"\r\n  ],\r\n}\r\n```\r\n- exclude：用于排除不需要tsc编译的文件或文件夹列表。exclude字段中的声明只对include字段有排除效果，对files字段无影响，即与include字段中的值互斥。如果tsconfig.json文件中files和include字段都不存在，则默认包含tsconfig.json文件所在目录及子目录的所有文件，且排除在exclude字段中声明的文件或文件夹。\r\n```\r\n{\r\n  "exclude": [\r\n    "test.ts",\r\n    "src/test.ts"\r\n  ],\r\n}\r\n```\r\n- compileOnSave：声明是否需要在保存时候自动触发tsc编译。\r\n```\r\n{\r\n  "compileOnSave": false,\r\n}\r\n```\r\n- extends：指定继承已有的tsconfig配置规则文件。\r\n```\r\n{\r\n  "extends": "../../tsconfig.json",\r\n}\r\n```\r\n### compilerOptions\r\n> compilerOptions是描述TypeScript编译功能的大字段，其值类型是对象，包含了很多用于描述编译器功能的子字段。\r\n\r\n- target：指定经过TSC编译后代码的ECMAScript版本。\r\n```\r\n{\r\n  "compilerOptions": {\r\n    "target": "es5",\r\n  }\r\n}\r\n```\r\n- lib：编译过程中需要引入的库文件的列表。例如我们的代码会使用到浏览器中的一些对象window、document，这些全局对象API对于TypeScript Complier来说是不能识别的。显式引入相关库TS在运行时以及编译时就不会报类型错误。\r\n```\r\n{\r\n  "compilerOptions": {\r\n    "lib": ["dom", "dom.iterable", "esnext"],\r\n  }\r\n}\r\n```\r\n- module：指定编译后得到的JS代码采取哪种模块管理方式，module负责的是模块管理方式，不负责js语法版本，js语法版本是由target字段管理的。\r\n  1. CommonJS：生成的代码使用require/module.exports模块管理方式。\r\n  2. ESNext、ES2020：生成的代码使用import/export模块管理方式。\r\n  3. NodeNext：要看package.json的type字段，如果是module的话生成的代码使用import/export模块管理方式，否则使用require/module.exports模块管理方式。\r\n```\r\n{\r\n  "compilerOptions": {\r\n    "module": "esnext",\r\n  }\r\n}\r\n```\r\n- moduleResolution：决定TS按照什么样的规则找到模块获取模块信息，方便编写代码时看到类型提示等等。\r\n```\r\n{\r\n  "compilerOptions": {\r\n    "moduleResolution": "node",\r\n  }\r\n}\r\n```\r\n- baseUrl：解析非相对模块名的基准目录。\r\n```\r\n{\r\n  "compilerOptions": {\r\n    "baseUrl": ".",\r\n  }\r\n}\r\n```\r\n- paths：模块名到基于baseUrl的路径映射的列表，用于简写项目中自定义模块的文件路径。需要用构建工具去落实真正路径的转化，如webpack的resolve.alias字段。\r\n```\r\n{\r\n  "compilerOptions": {\r\n    "paths": {\r\n      "@/*": ["src/*"],\r\n    }\r\n  }\r\n}\r\n\r\nimport Toast from \'@/components/Toast.ts\' // 模块实际位置: src/components/Toast.ts\r\n```\r\n- esModuleInterop：屏蔽ESModule和CommonJS之间的差异，允许从没有设置默认导出的CommonJS模块(没有默认导出内容)中默认导入，当esModuleInterop字段设置为true时候，allowSyntheticDefaultImports字段也会自动设置为true。\r\n```\r\n{\r\n  "compilerOptions": {\r\n    "esModuleInterop": true,\r\n  }\r\n}\r\n```\r\n- allowSyntheticDefaultImports：允许从没有设置默认导出的模块中默认导入。这并不影响代码的输出，仅为了类型检查。允许通过import x from \'y\'，即使模块y没有显式指定default导出。\r\n```\r\n{\r\n  "compilerOptions": {\r\n    "allowSyntheticDefaultImports": true,\r\n  },\r\n}\r\n```\r\n- rootDir：指定TS识别读取的根目录。\r\n```\r\n{\r\n  "compilerOptions": {\r\n    "rootDir": "./src"\r\n  }\r\n}\r\n```\r\n- outDir：指定tsc编译后的输出目录。\r\n```\r\n{\r\n  "compilerOptions": {\r\n    "outDir": "./build"\r\n  }\r\n}\r\n```\r\n- jsx：指定用jsx写的代码编译为什么样的代码形式。\r\n```\r\n{\r\n  "compilerOptions": {\r\n    "jsx": "react-jsx",\r\n  },\r\n}\r\n```\r\n- importHelpers：从tslib导入辅助工具函数。\r\n```\r\n{\r\n  "compilerOptions": {\r\n    "importHelpers": true,\r\n  },\r\n}\r\n```\r\n- experimentalDecorators：启用实验性的ES装饰器。\r\n```\r\n{\r\n  "compilerOptions": {\r\n    "experimentalDecorators": true,\r\n  },\r\n}\r\n```\r\n- noEmit：不生成输出文件，设置为true时TS编译器在执行编译时不会生成任何输出文件。\r\n```\r\n{\r\n  "compilerOptions": {\r\n    "noEmit": true,\r\n  },\r\n}\r\n```\r\n- skipLibCheck：忽略所有声明文件(.d.ts)的类型检查。\r\n```\r\n{\r\n  "compilerOptions": {\r\n    "skipLibCheck": true,\r\n  },\r\n}\r\n```\r\n- allowJs：允许TS编译器编译js文件。\r\n```\r\n{\r\n  "compilerOptions": {\r\n    "allowJs": true,\r\n  },\r\n}\r\n```\r\n- strict：开启严格模式。\r\n```\r\n{\r\n  "compilerOptions": {\r\n    "strict": true,\r\n  },\r\n}\r\n```\r\n- forceConsistentCasingInFileNames：对文件名强制区分大小写。\r\n```\r\n{\r\n  "compilerOptions": {\r\n    "forceConsistentCasingInFileNames": true,\r\n  },\r\n}\r\n```\r\n- noFallthroughCasesInSwitch：报告switch语句的fallthrough错误。\r\n```\r\n{\r\n  "compilerOptions": {\r\n    "noFallthroughCasesInSwitch": true,\r\n  },\r\n}\r\n```\r\n- resolveJsonModule：允许导入.json文件。\r\n```\r\n{\r\n  "compilerOptions": {\r\n    "resolveJsonModule": true,\r\n  },\r\n}\r\n```\r\n- isolatedModules；将每个文件作为单独的模块。\r\n```\r\n{\r\n  "compilerOptions": {\r\n    "isolatedModules": true,\r\n  },\r\n}\r\n```\r\n### react应用建议配置\r\n```\r\n{\r\n  "compilerOptions": {\r\n    "target": "es5",\r\n    "lib": ["dom", "dom.iterable", "esnext"],\r\n    "baseUrl": ".",\r\n    "paths": {\r\n      "@/*": ["src/*"]\r\n    },\r\n    "allowJs": true,\r\n    "skipLibCheck": true,\r\n    "esModuleInterop": true,\r\n    "allowSyntheticDefaultImports": true,\r\n    "strict": true,\r\n    "forceConsistentCasingInFileNames": true,\r\n    "noFallthroughCasesInSwitch": true,\r\n    "module": "esnext",\r\n    "moduleResolution": "node",\r\n    "resolveJsonModule": true,\r\n    "isolatedModules": true,\r\n    "noEmit": true,\r\n    "jsx": "react-jsx"\r\n  },\r\n  "include": ["src", "global.d.ts"]\r\n}\r\n```\r\n### Webpack + TypeScript\r\n- 安装typescript和ts-loader两个模块，Webpack主要是依赖ts-loader实现对TypeScript语法的编译支持。\r\n```\r\n// webpack配置\r\nconst path = require(\'path\');\r\n\r\nmodule.exports = {\r\n  entry: \'./src/index.ts\',\r\n  module: {\r\n    rules: [\r\n      {\r\n        test: /\\.tsx?$/,\r\n        use: \'ts-loader\',\r\n        exclude: /node_modules/,\r\n      },\r\n    ],\r\n  },\r\n  resolve: {\r\n    extensions: [\'.tsx\', \'.ts\', \'.js\'],\r\n  },\r\n  output: {\r\n    filename: \'bundle.js\',\r\n    path: path.resolve(__dirname, \'dist\'),\r\n  },\r\n};\r\n```\r\n### Babel + TypeScript\r\n- Babel处理TS需要安装@babel/preset-typescript模块，然后在babel项目配置文件中声明。\r\n- Babel只会对TS代码转为JS代码(通过 parse TS文件为AST，并直接移除类型信息，然后输出目标代码)，不会去做TS类型检查，所以Babel编译TS文件相较于TSC的速度更快。\r\n- 因为Babel会根据不同的兼容环境，按需引入pollyfill，比TSC直接引入core-js更优雅，因此使用了Babel打包的体积也会更小。\r\n```\r\n// .babelrc\r\n{\r\n  "presets": ["@babel/preset-typescript"]\r\n}\r\n```\r\n### Rollup + TypeScript\r\n- 添加@rollup/plugin-typescript插件，该插件会默认读取项目根目录下的tsconfig.json配置文件。\r\n```\r\n// rollup.config.js\r\nimport typescript from \'@rollup/plugin-typescript\';\r\n\r\nexport default {\r\n  input: \'src/index.ts\',\r\n  output: {\r\n    dir: \'output\',\r\n    format: \'cjs\'\r\n  },\r\n  plugins: [typescript()]\r\n};\r\n```'},function(r,n,e){"use strict";e.r(n),n.default="## TypeScript\r\n- TypeScript是一种基于JavaScript的强类型编程语言。TypeScript是添加了类型系统的JavaScript。\r\n### 类型系统\r\n- 动态类型是指在运行时才会进行类型检查，这种语言的类型错误往往会导致运行时错误，JavaScript属于动态类型，它是一门解释型语言，没有编译阶段。\r\n- 静态类型是指编译阶段就能确定每个变量的类型，这种语言的类型错误往往会导致语法错误。由于TypeScript在运行前需要先编译为JavaScript，而在编译阶段就会进行类型检查，所以TypeScript属于静态类型。\r\n### 使用TypeScript的好处\r\n- TypeScript增强了编辑器(IDE)的功能，包括代码补全、接口提示、跳转到定义、代码重构等，这在很大程度上提高了开发效率。\r\n- TypeScript的类型系统可以提升程序的健壮性为大型项目带来更高的可维护性，从开发过程中减少BUG出现的概率。\r\n### tsc\r\n- tsc的全称是TypeScript Compiler，是将TypeScript转码为JavaScript代码的编译器。\r\n- TSC的编译结果只有部分特性做了pollyfill处理，ES6的一些特性仍然被保留，想要支持完全的降级到ES5还是需要额外引入pollyfill(在项目的入口文件import 'core-js')。\r\n- 应该将TSC作为类型检查工具，代码编译的工作尽量交给Rollup、Webpack、Babel等打包工具。\r\n```\r\n// 全局安装\r\nnpm install typescript -g\r\n\r\n// 编译index.ts文件，使用下面的命令可以得到一份编译成为JavaScript代码的index.js文件\r\ntsc ./index.ts\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## any 和 unknown\r\n### any\r\n- any可以代表任意类型的值，而且可以绕过TS的类型检查。\r\n```\r\nlet myName: any;\r\nmyName = 1;\r\n\r\n// 错误使用\r\nmyName();\r\n```\r\n### unknown\r\n- unknown可以代表任意类型的值，但是它不可以绕过TS的类型检查。\r\n\r\n```\r\nlet myName: unknown;\r\nmyName = 1;\r\n\r\n// ts error: unknown无法被调用，这被认为是不安全的\r\nmyName();\r\n\r\n// 使用typeof保护myName类型为function\r\nif (typeof myName === 'function') { \r\n  // 此时校验myName的类型为function，可以正常调用 \r\n  myName();\r\n}\r\n```\r\n### unknown代表一些并不会绕过类型检查但又暂时无法确定值的类型\r\n- 在一些无法确定函数参数类型的场景unknown类型使用比较多。\r\n```\r\n// 在不确定函数参数的类型时\r\nfunction test(val: unknown) {\r\n  if (typeof val === 'string') {  \r\n    // someThing \r\n  } else if (typeof val === 'number') { \r\n    // someThing  \r\n  } \r\n  // ...\r\n}\r\n```\r\n### unknown类型可以接收任意类型的值，但并不支持将unknown赋值给其它类型(可以赋值给any类型)。any类型同样支持接收任意类型的值，同时也支持赋值给其它任意类型(除never类型)。"},function(r,n,e){"use strict";e.r(n),n.default='## 常用示例\r\n### webpack设置alias之后报错，在tsconfig.json中compilerOptions的添加对应paths\r\n```\r\n{\r\n  "compilerOptions": {\r\n    "paths": {\r\n      "@/*": ["src/*"],\r\n    }\r\n  }\r\n}\r\n```\r\n### React中传递事件对象\r\n```\r\nconst onNavClick = (e: React.MouseEvent<HTMLDivElement>, id: number) => {\r\n  e.preventDefault();\r\n  // ...\r\n};\r\n\r\n<div onClick={(e: React.MouseEvent<HTMLDivElement>) => onNavClick(e, id)}>\r\n  {name}\r\n</div>\r\n```\r\n### 声明key和value类型固定且一致的对象\r\n```\r\nconst obj: {[key: number]: string} = {\r\n  1: \'name\',\r\n  2: \'sex\'\r\n}\r\n```\r\n### monorepo使用typescript\r\n- monorepo引入项目中其它包时提示TS的报错时，添加references即可。\r\n- 引入其它包中的其它文件时提示TS报错时，添加paths配置即可。\r\n\r\n\r\n\r\n'},function(r,n,e){"use strict";e.r(n),n.default='## 映射类型\r\n### Partial构造一个类型，其中Type的所有属性都设置为可选。\r\n```\r\ninterface User {\r\n  name: string;\r\n  age: number;\r\n  password: string;\r\n}\r\n// {\r\n//   name?: string;\r\n//   age?: number;\r\n//   password?: string;\r\n// }\r\ntype PartialUser = Partial<User>;\r\n```\r\n### Required构造一个类型，其中Type的所有属性都设置为必选。\r\n```\r\ninterface User {\r\n  name?: string;\r\n  age?: number;\r\n  password?: string;\r\n}\r\n// {\r\n//   name: string;\r\n//   age: number;\r\n//   password: string;\r\n// }\r\ntype RequiredUser = Required<User>;\r\n```\r\n### Readonly构造一个类型，其中Type的所有属性都设置为只读。\r\n```\r\ninterface User {\r\n  role: string;\r\n}\r\ntype ReadonlyUser = Readonly<User>;\r\nconst user: ReadonlyUser = { role: "ADMIN" };\r\n\r\n// Error: Cannot assign to \'role\' because it is a read-only property.\r\nuser.role = "USER"; \r\n```\r\n### Pick主要用于提取某种数据类型的属性\r\n```\r\ninterface User {\r\n  name: string;\r\n  age: number;\r\n  password: string;\r\n}\r\n// {\r\n//   name: string;\r\n//   age: number;\r\n// }\r\ntype UserPick = Pick<User, "name" | "age">;\r\n```\r\n### Omit主要用于剔除某种数据类型的属性\r\n```\r\ninterface User {\r\n  name: string;\r\n  age: number;\r\n  password: string;\r\n}\r\n// {\r\n//   name: string;\r\n//   age: number;\r\n// }\r\ntype UserOmit = Omit<User, "password">;\r\n```\r\n### Uppercase构造一个Type的所有属性都设置为大写的类型。\r\n```\r\ntype Role = "admin" | "user" | "guest";\r\n// "ADMIN" | "USER" | "GUEST"\r\ntype UppercaseRole = Uppercase<Role>;\r\n```\r\n### Lowercase构造一个Type的所有属性都设置为小写的类型。\r\n```\r\ntype Role = "ADMIN" | "USER" | "GUEST";\r\n// "admin" | "user" | "guest"\r\ntype LowercaseRole = Lowercase<Role>;\r\n```\r\n### Capitalize构造一个将Type的所有属性设置为首字母大写的类型。\r\n```\r\ntype Role = "admin" | "user" | "guest";\r\n// "Admin" | "User" | "Guest"\r\ntype CapitalizeRole = Capitalize<Role>;\r\n```\r\n### Uncapitalize构造一个将Type的所有属性设置为非首字母大写的类型。\r\n```\r\ntype Role = "Admin" | "User" | "Guest";\r\n// "admin" | "user" | "guest"\r\ntype UncapitalizeRole = Uncapitalize<Role>; \r\n```\r\n### Record构造一个具有一组类型T的属性K的类型，每个属性K都映射到类型 T。\r\n```\r\ninterface Address {\r\n  street: string;\r\n  pin: number;\r\n}\r\ninterface Addresses {\r\n  home: Address;\r\n  office: Address;\r\n}\r\ntype AddressesRecord = Record<"home" | "office", Address>;\r\n```\r\n### Exclude构造一个具有Type的所有属性的类型，除了键在联合类型Excluded中的那些。\r\n```\r\ntype Role = "ADMIN" | "USER" | "GUEST";\r\n// "USER" | "GUEST"\r\ntype NonAdmin = Exclude<Role, "ADMIN">;\r\n```\r\n### Extract构造一个具有Type的所有属性的类型，其键在联合类型Extract中。\r\n```\r\ntype Role = "ADMIN" | "USER" | "GUEST";\r\n// "ADMIN"\r\ntype Admin = Extract<Role, "ADMIN">;\r\n```\r\n### NonNullable构造一个类型，其中Type的所有属性都设置为不可为空。\r\n```\r\ntype Role = "ADMIN" | "USER" | null;\r\n// "ADMIN" | "USER"\r\ntype NonNullableRole = NonNullable<Role>; // "ADMIN" | "USER"\r\n```'},function(r,n,e){"use strict";e.r(n),n.default="## 泛型\r\n- 泛型的本质是类型参数化，将类型作为参数传递给另一种类型、函数或其它结构。\r\n- TypeScript中不建议使用any类型，不能保证类型安全。可以使用泛型来创建可重用的组件。提高了代码灵活性，使组件可重用并消除重复。\r\n### 方法的参数类型可以传递 \r\n- localStorage获取数据时可以自定义传递获取的数据类型。\r\n```\r\npublic static getItem<T>(key: string): T | null {\r\n\r\n}\r\n\r\n// 调用时传递类型\r\ngetItem<string>('user')\r\n```\r\n- 通用的接口请求方法定义返回值类型。\r\n```\r\nasync function fetchApi<T>(path: string): Promise<T> {\r\n  const response = await fetch(`https://example.com/api${path}`);\r\n  return response.json();\r\n}\r\n\r\n// 调用时传递类型\r\nconst data = await fetchApi<Array<{ name: string }>>('/users');\r\n```\r\n### react函数组件传递泛型\r\n- 子组件定义一个名为Props的接口，并指定该接口的泛型类型为T，将该接口作为参数传递给函数组件MyComponent。\r\n``` \r\ninterface Props<T> {\r\n  data: T; // 通过Props接口定义泛型类型为T\r\n}\r\n \r\nfunction MyComponent<T>(props: Props<T>) {\r\n  return <div>{props.data}</div>;\r\n}\r\n```\r\n- 父组件调用MyComponent时明确指定泛型类型为字符串`<MyComponent<string>...`\r\n```\r\nexport default function App() {\r\n  const myData = \"Hello World\";\r\n  \r\n  return (\r\n    <MyComponent<string> data={myData} />\r\n  );\r\n}\r\n```"},function(r,n,e){"use strict";e.r(n),n.default='## 类型声明文件\r\n- 类型声明文件的存放路径以及文件名没有约束，在tsconfig.json文件中的include引入对应文件即可。\r\n### 类型声明文件用处\r\n- 使用的第三方库没有提供类型声明，可通过自己定义类型声明使用。\r\n```\r\ndeclare module \'react-resizable\';\r\n```\r\n- 拓展全局变量。\r\n```\r\ndeclare interface Window {\r\n  AMap: any;\r\n}\r\n```\r\n- 定义样式文件或静态资源文件类型。\r\n```\r\ndeclare module \'*.module.css\' {\r\n  const classes: { readonly [key: string]: string }\r\n  export default classes;\r\n}\r\ndeclare module \'*.module.scss\' {\r\n  const classes: { readonly [key: string]: string }\r\n  export default classes;\r\n}\r\ndeclare module \'*.png\';\r\n```\r\n- 声明全局类型。\r\n### 声明全局类型\r\n- 不使用export、export default导出\r\n  1. 在类型声明文件中声明全局类型。\r\n  ```\r\n  // typings/module.d.ts\r\n  interface NumberStringObj {\r\n    [key: number]: string\r\n  }\r\n  ```\r\n  2. 在tsconfig.json文件中的include引入对应文件。\r\n  ```\r\n  "include": ["src", "typings/module.d.ts"]\r\n  ```\r\n  3. 直接使用即可。\r\n  ```\r\n  const laneStyle: NumberStringObj = {}\r\n  ```\r\n- 使用export、export default导出\r\n  1. 在类型声明文件中导出声明的全局类型。\r\n  ```\r\n  // typings/module.d.ts\r\n  export interface NumberStringObj {\r\n    [key: number]: string\r\n  }\r\n  ```\r\n  2. 可以在tsconfig.json的paths设置路径引用简化引入类型的路径。\r\n  ```\r\n  "paths": {\r\n    ":module": ["typings/module.d.ts"], // 分别导出形式\r\n    "&/*": ["typings/*"], // 统一导出形式\r\n  },\r\n  ```\r\n  3. 引入声明的全局类型后使用。\r\n  ```\r\n  import { NumberStringObj } from \':module\'; // 分别导出形式引入\r\n  import { NumberStringObj } from "typings/module"; // 统一导出形式引入\r\n\r\n  // 使用\r\n  const laneStyle: NumberStringObj = {}\r\n  ```\r\n\r\n'},function(r,n,e){"use strict";e.r(n),n.default="## [esbuild构建速度快于webpack](https://juejin.cn/post/7240740177449435191)\r\n- js是单线程串行，esbuild是新开一个进程，然后多线程并行，充分发挥多核优势。\r\n- go是纯机器码，肯定要比JIT快。\r\n- Esbuild选择重写包括js、ts、jsx、css等语言在内的转译工具，所以它更能保证源代码在编译步骤之间的结构一致性，比如在Webpack中使用 babel-loader 处理JavaScript 码时，可能需要经过多次如下的数据转换，源码需要经历string => AST => AST => string => AST => string，在字符串与AST之间反复横跳。而Esbuild重写大多数转译工具之后，能够在多个编译阶段共用相似的AST结构，尽可能减少字符串到AST的结构转换，提升内存使用效率。\r\n  - Webpack 读入源码，此时为字符串形式\r\n  - Babel 解析源码，转换为 AST 形式\r\n  - Babel 将源码 AST 转换为低版本 AST\r\n  - Babel 将低版本 AST generate 为低版本源码，字符串形式\r\n  - Webpack 解析低版本源码\r\n  - Webpack 将多个模块打包成最终产物\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## vite VS webpack\r\n### vite启动快\r\n#### 底层语言不同\r\n- vite是基于esbuild预构建依赖，esbuild使用go语言编写，比使用JavaScript编写的打包器预构建依赖快10-100倍。\r\n#### 启动方式不同\r\n- vite在启动的时候不需要对源码进行打包，所以不用分析模块与模块之间的依赖关系。当浏览器请求某个模块时，再根据需要对模块内容进行编译。按需动态编译可以缩减编译时间，当项目越复杂模块越多的情况下，vite明显优于webpack。\r\n- webpack: 分析依赖 => 编译打包 => 交给本地服务器进行渲染。首先分析各个模块之间的依赖，然后进行打包，再启动webpack-dev-server，请求服务器时直接显示打包结果。webpack打包之后存在的问题：随着模块的增多，会造成打出的bundle体积过大，进而会造成热更新速度明显变慢。\r\n- vite: 依赖预构建 => 启动服务器 => 请求模块时按需动态编译显示。先启动开发服务器，请求某个模块时再对该模块进行实时编译，因为现代浏览器本身支持ES Module会自动向依赖的Module发出请求。所以vite就将开发环境下的模块文件作为浏览器的执行文件，而不是像webpack进行打包后交给本地服务器。\r\n### vite热更新方面效率更高\r\n- 当改动了某个模块的时候，只用让浏览器重新请求该模块，不需要像webpack那样将模块以及模块依赖的模块全部编译一次。"},function(r,n,e){"use strict";e.r(n),n.default="## [vite配置项](https://blog.csdn.net/mjzhang1993/article/details/122706791)\r\n### index.html\r\n- index.html放在项目最外层且要以type=\"module\"的形式引入入口文件。\r\n### 支持react\r\n- 使用@vitejs/plugin-react插件支持react。\r\n- @vitejs/plugin-react-refresh插件已被禁用，使用@vitejs/plugin-react插件即可。\r\n```\r\nyarn add @vitejs/plugin-react -D\r\n\r\nimport react from '@vitejs/plugin-react';\r\n\r\nplugins: [\r\n  react(),\r\n],\r\n```\r\n### 开发环境使用https\r\n- 使用server.https选项，同时使用@vitejs/plugin-basic-ssl插件。\r\n```\r\nyarn add @vitejs/plugin-basic-ssl -D\r\n\r\nimport ssl from '@vitejs/plugin-basic-ssl';\r\n\r\nplugins: [\r\n  ssl(),\r\n],\r\nserver: {\r\n  https: true, // 使用https\r\n},\r\n```\r\n### 开发环境接口代理\r\n```\r\nserver: {\r\n  port: 3000,\r\n  open: true,\r\n  proxy: {\r\n    '/api': {\r\n      target: 'domain',\r\n      changeOrigin: true\r\n    },\r\n  },\r\n},\r\n```\r\n### 配置路径别名\r\n```\r\nresolve: {\r\n  extensions: ['.tsx', '.ts', '.jsx', '.js', '.json'],\r\n  alias: {\r\n    '@': '/src'\r\n  },\r\n},\r\n```\r\n### vite默认支持热更新。\r\n### vite默认支持区分process.env.NODE_ENV\r\n### vite提供了对.css、.scss、.sass、.less、.styl、.stylus文件的内置支持，不需要提供额外的插件支持，但必须安装相应的预处理器依赖。\r\n### vite提供了css modules的支持，文件名包含module后缀即可。\r\n### 支持postcss\r\n- vite.config.js\r\n```\r\ncss: {\r\n  postcss: 'postcss.config.js',\r\n},\r\n```\r\n- postcss.config.js\r\n```\r\nyarn add postcss postcss-preset-env -D\r\n\r\nmodule.exports = {\r\n  plugins: [\r\n    require('postcss-preset-env')()\r\n  ]\r\n};\r\n```\r\n### 代码压缩混淆\r\n- vite默认会在生产环境下开启代码压缩和混淆功能，若要关闭该功能，可以使用build.minify选项。\r\n```\r\nbuild: {\r\n  minify: false, // 关闭代码压缩和混淆\r\n},\r\n```\r\n### 打包文件输出配置\r\n```\r\nbuild: {\r\n  // 自定义打包输出目录\r\n  outDir: 'build',\r\n  rollupOptions: {\r\n    output: {\r\n      // 自定义入口JS文件输出路径和命名规则\r\n      entryFileNames: 'js/[name].[hash].js',\r\n      // 自定义分割的JS代码块输出路径和命名规则\r\n      chunkFileNames: 'js/chunks/[name].[hash].js',\r\n      // 自定义CSS文件和其它静态资源输出路径和命名规则\r\n      assetFileNames: (assetInfo) => {\r\n        let extType = assetInfo.name?.split('.').at(-1);\r\n        if (/png|jpe?g|svg|gif|tiff|bmp|ico/i.test(extType)) {\r\n          extType = 'img';\r\n        }\r\n        if (extType === 'css') {\r\n          return 'css/[name].[hash].[ext]';\r\n        }\r\n        return `${extType}/[name].[hash].[ext]`;\r\n      },\r\n      // 手动配置代码分割\r\n      manualChunks(id) {\r\n        // 将所有node_modules中的模块打包到vendor.js\r\n        if (id.includes('node_modules')) {\r\n          return 'vendor';\r\n        }\r\n      }\r\n    },\r\n  },\r\n}\r\n```\r\n### 配置gzip压缩\r\n- 使用vite-plugin-compression插件支持gzip压缩。\r\n```\r\nyarn add vite-plugin-compression -D\r\n\r\nimport viteCompression from 'vite-plugin-compression';\r\n\r\nplugins: [\r\n  viteCompression({\r\n    verbose: true,\r\n    disable: false,\r\n    threshold: 10240,\r\n    algorithm: 'gzip',\r\n    ext: '.gz',\r\n  }),\r\n],\r\n```\r\n\r\n\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## [依赖预构建](https://mp.weixin.qq.com/s/XmJLm0LJLJ-iSQuQZwH8kw)\r\n### no-bundle\r\n- vite在开发阶段提倡的是一个no-bundle的理念，不需要像webpack那样需要先将整个项目进行打包构建。但是no-bundle的理念只适合源代码部分(我们自己写的代码)，vite会将项目中的所有模块分为依赖与源码两部分。\r\n- 依赖：指的是一些不会变动的一些模块，如node_modules中的第三方依赖，这部分代码vite会在启动本地服务之前使用esbuild进行预构建。esbuild使用Go编写，比使用JavaScript编写的打包器预构建依赖快10-100倍。\r\n- 源码：指的是我们自己开发时写的那部分代码，这部分代码可能会经常变动，并且一般不会同时加载所有源代码。\r\n- no-bundle是针对源码的，而预构建是针对第三方依赖的。\r\n### [使用预构建的原因](https://mp.weixin.qq.com/s/lwjCQ5VsRCcFimLMNn3evA)\r\n- commonJS与UMD兼容：因为vite在开发阶段主要是依赖浏览器原生ES模块化规范，所以无论是我们的源代码还是第三方依赖都得符合ESM的规范，但是目前并不是所有第三方依赖都有ESM的版本，所以需要对第三方依赖进行预编译，将它们转换成EMS规范的产物。\r\n- 性能：为了提高后续页面的加载性能，vite将那些具有许多内部模块的ESM依赖项转换为单个模块。只需要发起一个HTTP请求，可以很大程度地提高加载性能。由于vite的预构建是基于性能优异的Esbuild来完成的，所以并不会造成明显的打包性能问题。\r\n### 开启预构建\r\n- vite默认开启了预构建，预构建产物会存放在：node_modules/.vite目录下，目录下有一个_metadata.json的文件，保存着已经预构建过的依赖信息。\r\n- 对于预构建产物的请求，vite会设置为强缓存，有效时间为1年，对于有效期内的请求会直接使用缓存内容，只有HTTP强缓存时如果用户更新了依赖版本，在缓存过期之前，浏览器拿到的一直是旧版本的内容。所以vite对本地文件也设置了缓存判断，如果下面几个地方任意一个地方有变动，vite将会对依赖进行重新预构建。\r\n  1. 项目依赖dependencies变更。\r\n  2. 各种包管理器的lock文件变更。\r\n  3. vite配置文件的optimizeDeps配置内容变更。\r\n  4. NODE_ENV 的值。\r\n- 如果出于某些原因想要强制Vite重新构建依赖项，可以在启动开发服务器时指定--force选项，或手动删除 node_modules/.vite 缓存目录。"},function(r,n,e){"use strict";e.r(n),n.default="## defineProperty缺陷\r\n1. 只能劫持对象的属性，因此我们需要对每个对象的每个属性进行遍历监听，如果属性值也是对象那么需要深度遍历。\r\n2. 对象属性的添加和删除无法被Object.defineProperty监听，需要手动添加监听。\r\n```\r\nvar vm = new Vue({\r\n  data: {\r\n    obj: {\r\n      a: 1\r\n    },\r\n  },\r\n  template: '<div>{{ obj.message }}{{ obj.a }}</div>'\r\n});\r\n\r\n// 无法被监听到，可以使用vm.$set(obj, propertyName, newValue)方法实现\r\nvm.obj.message = 'modified';\r\n\r\n// 无法被监听到，可以使用vm.$delete(obj, propertyName)方法实现\r\ndelete vm.obj.a;\r\n```\r\n3. 部分数组的操作无法监听到，Vue虽然针对部分数组的方法进行了包裹促使可以监听到。然而通过push、unshift方法增加的元素，`vm.items[indexOfItem] = newValue`这种是无法检测的\r\n```\r\nconst vm = new Vue({\r\n  data: {\r\n    items: [1, 2, 3, 4, 5],\r\n  },\r\n});\r\n// 对象和数组如果需要监听每个属性和元素，实际上是对每个属性或者元素进行Object.defineProperty劫持，对象是监听key而数组则是以数字下标作为key，数组的数据量可能会很大，因此Vue出于性能考虑，并没有对元素下标进行响应式处理。\r\nvm.items[1] = 8;\r\n// 无法监听到 数组新添加的元素和删除元素无法被Object.defineProperty监听。\r\nvm.items[5] = 6;\r\n// 也是由于Object.defineProperty的限制，数组的长度直接修改也无法被监听。\r\nvm.items.length = 2;\r\n```\r\n### proxy\r\n- proxy代理的是整个对象，而不是对象的某个特定属性，不需要我们通过遍历来逐个进行数据绑定。\r\n- proxy在遇到一个对象的属性还是一个对象的情况下不需要递归监听，Object.defineProperty需要递归监听。\r\n- proxy可以直接监听数组的变化。\r\n- proxy提供了更丰富的拦截方式。\r\n### [proxy与defineProperty的性能对比](https://mp.weixin.qq.com/s/uVEe5tb4WJd0Zk1crYo35A)\r\n- Proxy在对象创建时的性能明显优于Object.defineProperty。\r\n- 在浅层对象的读写性能方面Object.defineProperty表现更好，但是当对象的嵌套深度增加时，Object.defineProperty的优势会逐渐减弱。\r\n- 在性能测试中Object.defineProperty的读写优势可能更适合实际开发场景，但Proxy的性能与Object.defineProperty并没有拉开太大差距。\r\n- Vue3选择Proxy不仅仅基于性能考量，还因为Proxy提供了更为友好、现代且强大的API，使得操作更加灵活。"},function(r,n,e){"use strict";e.r(n),n.default='## v-for中加入条件判断\r\n### v-for循环中直接使用v-if进行条件判断\r\n- 直接在v-for中使用v-if可能会导致性能问题。\r\n```\r\n<ul>\r\n  <li v-for="item in items" :key="item.id" v-if="item.isActive">\r\n    {{ item.name }}\r\n  </li>\r\n</ul>\r\n```\r\n### 使用template标签\r\n- 为了避免在v-for循环中直接使用v-if（这可能会导致性能问题），可以使用template标签包裹条件判断。\r\n```\r\n<ul>\r\n  <template v-for="item in items" :key="item.id">\r\n    <li v-if="item.isActive">\r\n      {{ item.name }}\r\n    </li>\r\n  </template>\r\n</ul>\r\n```\r\n### 使用计算属性过滤数据\r\n- 如果条件判断较为复杂，可以使用计算属性先过滤数据，再进行循环渲染。\r\n```\r\ncomputed: {\r\n  activeItems() {\r\n    return this.items.filter(item => item.isActive);\r\n  }\r\n}\r\n\r\n<ul>\r\n  <li v-for="item in activeItems" :key="item.id">\r\n    {{ item.name }}\r\n  </li>\r\n</ul>\r\n```'},function(r,n,e){"use strict";e.r(n),n.default="## vue3\r\n- vue3对嵌套对象的响应式处理进行了优化，采用了一种惰性添加的方式，仅在对象被访问时才添加响应式。vue2采用了一次性递归处理整个对象的方式添加响应式。"},function(r,n,e){"use strict";e.r(n),n.default="## vue的data为什么通过方法返回\r\n- JavaScript中的对象是引用类型的数据，当多个实例引用同一个对象时，只要一个实例对这个对象进行操作，其他实例中的数据也会发生变化。\r\n- 而在Vue中，更多的是想要复用组件，那就需要每个组件都有自己的数据，这样组件之间才不会相互干扰。\r\n- 数据以函数返回值的形式定义，当每次复用组件的时候，就会返回一个新的data，也就是说每个组件都有自己的私有数据空间，它们各自维护自己的数据，不会干扰其他组件的正常运行。"},function(r,n,e){"use strict";e.r(n),n.default="## 生命周期\r\n### 单组件生命周期\r\n1. beforeCreate(创建前) 此时$el、data的值都为undefined，一次挂载只运行一次。\r\n2. created(创建后) 创建之后，此时可以拿到data的值，但是$el依旧为undefined，初始异步请求多在此进行，一次挂载只运行一次。\r\n3. beforeMount(挂载前) $el的值为“虚拟”的元素节点，一次挂载只运行一次。\r\n4. mounted(挂载后) 在触发mounted时，可以获取到$el为真实的dom元素()，一次挂载只运行一次。\r\n5. beforeUpdate(更新前)\r\n6. updated(更新后)\r\n7. beforeDestroy(销毁前)\r\n8. destroyed(销毁后)\r\n### 父子组件生命周期\r\n1. 加载渲染过程：父beforeCreate -> created -> beforeMount -> 子beforeCreate -> 子created -> 子beforeMount -> 子mounted -> 父mounted。\r\n2. 更新过程：父beforeUpdate -> 子beforeUpdate -> 子updated -> 父updated。\r\n3. 销毁过程：父beforeDestroy -> 子beforeDestroy -> 子destroyed -> 父destroyed。\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## 简单vue实现\r\n```\r\nfunction Vue(options = {}) {\r\n  this.$options = options;\r\n  let data = this._data = this.$options.data;\r\n  // 数据劫持\r\n  observe(data);\r\n  // this代理，使用this可以直接访问到data\r\n  for (let key in data) {\r\n    Object.defineProperty(this, key, {\r\n      configurable: true,\r\n      get() {\r\n        return this._data[key];\r\n      },\r\n      set(newVal) {\r\n        this._data[key] = newVal;\r\n      }\r\n    });\r\n  }\r\n  // 编译\r\n  new Compile(options.el, this);\r\n}\r\n\r\n// 数据劫持的主要逻辑\r\nfunction Observe(data) {\r\n  let dep = new Dep();\r\n  // 把data属性通过defineProperty的方式定义属性\r\n  for (let key in data) {\r\n    let val = data[key];\r\n    observe(val);   // 实现了深度的数据劫持(属性值也是对象的形式)\r\n    Object.defineProperty(data, key, {\r\n      enumerable: true,\r\n      get() {\r\n        Dep.target && dep.addSub(Dep.target);\r\n        return val;\r\n      },\r\n      set(newVal) {\r\n        if (val === newVal) {\r\n          return;\r\n        }\r\n        val = newVal;\r\n        observe(newVal);    // 修改的新值也要数据劫持(修改的值为对象的形式)\r\n        dep.notify();   // 让所有的watcher的update方法执行即可\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\n// 数据劫持的方法\r\nfunction observe(data) {\r\n  if (!data || typeof data !== 'object') {\r\n    return;\r\n  }\r\n  return new Observe(data);\r\n}\r\n\r\n// 编译\r\nfunction Compile(el, vm) {\r\n  vm.$el = document.querySelector(el);\r\n  let fragment = document.createDocumentFragment();\r\n\r\n  while (child = vm.$el.firstChild) {\r\n    fragment.appendChild(child);\r\n  }\r\n  replace(fragment);\r\n\r\n  function replace(frag) {\r\n    Array.from(frag.childNodes).forEach(function (node) {\r\n      let txt = node.textContent;\r\n      let reg = /\\{\\{(.*?)\\}\\}/g;\r\n\r\n      if (node.nodeType === 3 && reg.test(txt)) { // 即是文本节点又有大括号{}\r\n        !function replaceTxt() {\r\n          node.textContent = txt.replace(reg, (matched, placeholder) => {\r\n            new Watcher(vm, placeholder, replaceTxt);  // 监听变化，重新进行匹配替换内容\r\n            // 深层次取值的形式\r\n            return placeholder.split('.').reduce((val, key) => {\r\n              return val[key];\r\n            }, vm);\r\n          });\r\n        }();\r\n      }\r\n\r\n      if (node.nodeType === 1) {  // 元素节点 v-model的实现\r\n        let nodeAttr = node.attributes;     // 获取dom节点的属性\r\n        Array.from(nodeAttr).forEach(attr => {\r\n          let name = attr.name;\r\n          let exp = attr.value;\r\n          if (name.includes('v-')) {\r\n            node.value = vm[exp];\r\n          }\r\n          new Watcher(vm, exp, function (newVal) {\r\n            node.value = newVal;    // 当watcher触发时会自动将内容放进输入框中\r\n          });\r\n          node.addEventListener('input', function (e) {\r\n            let newVal = e.target.value;\r\n            vm[exp] = newVal;\r\n          });\r\n        });\r\n      }\r\n\r\n      // 深层次递归节点\r\n      if (node.childNodes && node.childNodes.length) {\r\n        replace(node);\r\n      }\r\n    });\r\n  }\r\n  vm.$el.appendChild(fragment);\r\n}\r\n\r\n// 发布订阅\r\nfunction Dep() {\r\n  this.subs = [];\r\n}\r\n\r\nDep.prototype.addSub = function (sub) {\r\n  this.subs.push(sub);\r\n};\r\nDep.prototype.notify = function () {\r\n  this.subs.forEach(sub => sub.update());\r\n};\r\n\r\n// watcher\r\nfunction Watcher(vm, exp, fn) {\r\n  this.fn = fn;\r\n  this.vm = vm;\r\n  this.exp = exp;\r\n  Dep.target = this;\r\n  let val = vm;\r\n  let arr = exp.split('.');\r\n  arr.forEach(key => {\r\n    val = val[key];  // 这里取值的时候Dep.target有值\r\n  });\r\n  Dep.target = null;\r\n}\r\n\r\nWatcher.prototype.update = function () {\r\n  let val = this.vm;\r\n  let arr = this.exp.split('.');\r\n  arr.forEach(key => {\r\n    val = val[key];\r\n  });\r\n  this.fn(val);\r\n};\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## chunk\r\n> webpack实现中，原始的资源模块以Module对象形式存在、流转、解析处理。而Chunk则是输出产物的基本组织单位，在生成阶段webpack按规则将entry及其它Module插入Chunk中，之后再由SplitChunksPlugin插件根据优化规则与ChunkGraph对Chunk做一系列的变化、拆解、合并操作，重新组织成一批性能(可能)更高的Chunks。运行完毕之后webpack继续将chunk一一写入物理文件中完成编译工作。chunk是无法在打包结果中看到的，打包结果中看到的是bundle。\r\n\r\n### chunk的基本分包规则\r\n> 业务模块是指开发者所编写的项目代码；runtime模块是指Webpack分析业务模块后，动态注入的用于支撑各项特性的运行时代码。\r\n\r\n- 每个entry项都会对应生成一个chunk对象，称之为initial chunk。\r\n- 每个异步模块都会对应生成一个chunk对象，称之为async chunk。\r\n- Webpack 5之后，如果entry配置中包含runtime值，则在entry之外再增加一个专门容纳runtime的chunk对象，此时可以称之为runtime chunk。\r\n### bundle vs chunk\r\n> bundle: bundle是webpack打包之后的各个文件，一般就是和chunk是一对一的关系，但有时候也不完全是一对一的关系。bundle就是对chunk进行编译压缩打包等处理之后的产出。chunk是过程中的代码块，bundle是结果的代码块。\r\n\r\n\r\n"},function(r,n,e){"use strict";e.r(n),n.default='## css-loader\r\n- webpack是无法处理css文件的，需要添加对应的css-loader。\r\n- css文件经过css-loader处理之后，将css转化为webpack能够解析的javascript才不会报错。\r\n### css-loader处理\r\n- css-loader会将css处理成字符串。\r\n- css模块经过css-loader处理之后，返回的内容变成了一个js模块。\r\n- 只经过css-loader处理在生产环境是无法正常加载样式的，因为没有用style处理。\r\n```\r\n// css原内容\r\n.wrap {\r\n  color: red;\r\n}\r\n\r\n// css-loader处理后内容\r\n\r\n// Imports\r\nimport ___CSS_LOADER_API_SOURCEMAP_IMPORT___ from "../node_modules/.pnpm/css-loader@6.7.3_webpack@5.79.0/node_modules/css-loader/dist/runtime/sourceMaps.js";\r\nimport ___CSS_LOADER_API_IMPORT___ from "../node_modules/.pnpm/css-loader@6.7.3_webpack@5.79.0/node_modules/css-loader/dist/runtime/api.js";\r\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_SOURCEMAP_IMPORT___);\r\n// Module\r\n___CSS_LOADER_EXPORT___.push([module.id, ".wrap {\\n  color: red;\\n}\\n", "",{"version":3,"sources":["webpack://./src/app.css"],"names":[],"mappings":"AAAA;EACE,UAAU;AACZ","sourcesContent":[".wrap {\\n  color: red;\\n}\\n"],"sourceRoot":""}]);\r\n// Exports\r\nexport default ___CSS_LOADER_EXPORT___;\r\n```\r\n'},function(r,n,e){"use strict";e.r(n),n.default="## css文件提取成单独的文件\r\n### webpack生产环境构建时为什么要将css文件提取成单独的文件\r\n1. 更好的缓存，当CSS和JS分开时浏览器可以缓存CSS文件并重复使用，也不用因为js内容的变化，导致css缓存失效。\r\n2. 更快的渲染速度，浏览器是同时可以并行加载多个静态资源，将css从js中抽离出来后能够加快js的加载与解析速度，最终加快页面的渲染速度。\r\n3. 更好的代码可读性，独立的css文件更方便代码的阅读与调试。\r\n### 使用mini-css-extract-plugin提取css文件\r\n- 安装依赖\r\n```\r\nnpm i mini-css-extract-plugin -D\r\n```\r\n- 修改webpack.common.js，根据环境变量设置开发环境使用style-loader，生产环境使用MiniCssExtractPlugin.loader抽离css。\r\n```\r\nconst MiniCssExtractPlugin = require('mini-css-extract-plugin');\r\nconst isDev = process.env.NODE_ENV === 'development'; // 是否是开发模式\r\n\r\nmodule.exports = {\r\n  // ...\r\n  module: {\r\n    rules: [\r\n      // ...\r\n      {\r\n        test: /\\.css$/,\r\n        use: [\r\n          isDev ? 'style-loader' : MiniCssExtractPlugin.loader,\r\n          'css-loader',\r\n          'postcss-loader'\r\n        ]\r\n      },\r\n      // ...\r\n    ]\r\n  },\r\n  // ...\r\n}\r\n```\r\n- 修改webpack.prod.js, 打包时添加抽离css插件\r\n```\r\nconst { merge } = require('webpack-merge');\r\nconst MiniCssExtractPlugin = require('mini-css-extract-plugin');\r\nconst commonConfig = require('./webpack.common.js');\r\n\r\nmodule.exports = merge(commonConfig, {\r\n  mode: 'production',\r\n  plugins: [\r\n    // 抽离css插件\r\n    new MiniCssExtractPlugin({\r\n      filename: 'static/css/[name].[contenthash:8].css' // 抽离css的输出目录和名称\r\n    }),\r\n  ]\r\n})\r\n```\r\n### mini-css-extract-plugin流程\r\n1. MiniCssExtractPlugin插件会先注册CssModuleFactory与CssDependency。\r\n2. 然后在MiniCssExtractPlugin.loader使用child compiler(webpack5.33.2之后默认使用importModule方法)以css文件为入口进行子编译，子编译流程跑完之后，最终会得到CssDependency。\r\n3. 然后webpack会根据模块是否有dependencies，继续解析子依赖，当碰到CssDenpendcy的时候会先找到CssModuleFactory，然后通过CssModuleFactory.create创建一个css module。\r\n4. 当所有模块都处理完之后，会根据MiniCssExtractPlugin插件内注册的renderManifest hook callback，将当前chunk内所有的css module合并到一起，然后webpack会根据manifest创建assets。\r\n5. 最终webpack会根据assets在生成最终的文件。"},function(r,n,e){"use strict";e.r(n),n.default="## loader\r\n> 利用 Webpack 我们不仅可以打包 JS 文件，还可以打包图片、CSS、字体等其他类型的资源文件。而支持打包非 JS 文件的特性是基于 Loader 机制来实现的。loader的设计要做到每个 Loader 的职责单一。\r\n\r\n### loader的作用\r\n> Loader 本质上是导出函数的 JavaScript 模块。所导出的函数，可用于实现内容转换。\r\n\r\n```\r\n/**\r\n * @param {string|Buffer} content 源文件的内容\r\n * @param {object} [map] 可以被 https://github.com/mozilla/source-map 使用的 SourceMap 数据\r\n * @param {any} [meta] meta 数据，可以是任何内容\r\n */\r\nfunction webpackLoader(content, map, meta) {\r\n  // 你的webpack loader代码\r\n}\r\nmodule.exports = webpackLoader;\r\n```\r\n### 样式相关\r\n- style-loader 将模块导出的内容作为样式并添加到 DOM 中\r\n- css-loader 加载 CSS 文件并解析 import 的 CSS 文件，最终返回 CSS 代码\r\n- less-loader 加载并编译 LESS 文件\r\n- sass-loader 加载并编译 SASS/SCSS 文件\r\n- postcss-loader 使用 PostCSS 加载并转换 CSS/SSS 文件\r\n### 模板相关\r\n- raw-loader\r\n> 此loader可以允许我们以字符串的形式引入文件原始内容，比如markdown文件等。\r\n\r\n```\r\n{\r\n  test: /\\.md$/,\r\n  use: 'raw-loader'\r\n}\r\n```\r\n- markdown-loader\r\n> 使用markdown-loader以及html-loader可以将引入的markdown文件转为html。代码区块有空行会显示错误。\r\n\r\n```\r\n{\r\n  test: /\\.md$/,\r\n  use: ['html-loader', 'markdown-loader'],\r\n},\r\n```\r\n### cache-loader\r\n> 打包时间的大部分都在npm install和各种loader的执行上，可以在loader之前加上cache-loader，这样这个loader执行过一次后的数据会缓存在node_modules/.cache目录下，下次再打包就会利用缓存。只有执行时间很长的loader才适合用缓存，因为读写文件也是有开销的，滥用反而会导致变慢。\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## output\r\n### output.path\r\n> output.path指示静态资源输出的目录，对应一个绝对路径。默认值：process.cwd()。\r\n\r\n```\r\noutput: {\r\n path: path.resolve(__dirname, '../build'),\r\n}\r\n```\r\n### output.publicPath\r\n> output.publicPath为项目中的所有资源指定一个基础路径，它被称为公共路径。这个最终静态资源访问路径在使用html-webpack-plugin打包后得到的html中可以看到。默认值：空字符串。\r\n\r\n- 静态资源最终访问路径 = output.publicPath + 资源loader或插件的配置路径。\r\n- 一般情况下publicPath应该以'/'结尾，而资源loader或插件的配置路径不要以'/'开头。\r\n- 当部署项目访问路径不是根路径或者需要访问cdn资源时会特殊配置output.publicPath。\r\n```\r\noutput: {\r\n  publicPath: '/build/',\r\n  filename: 'static/js/[name].[contenthash:8].js',\r\n},\r\n\r\n// 最终js的访问路径为\r\n/build/static/js/[name].[contenthash:8].js\r\n```\r\n### output.libraryTarget\r\n> output.libraryTarget配置以何种方式导出库，开发库时多使用umd的方式。\r\n\r\n### output.library\r\n> output.library配置导出库的名称。\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## output的hash\r\n### hash\r\n> 异步加载打出的每一个包的hash都相同，每次修改任何一个文件，所有文件名的hash值都将改变。所以一旦修改了任何一个文件，整个项目的文件缓存都将失效。\r\n\r\n### chunkhash\r\n> 异步加载打出的每一个包的hash不同，chunkhash根据不同的入口文件(Entry)进行依赖文件解析、构建对应的chunk，生成对应的哈希值。因为打出的css和js文件的hash值相同，只要对应css或js改变，与其关联的文件hash值也会改变，但其内容并没有改变，所以也没有达到缓存意义。\r\n\r\n### contenthash\r\n> 异步加载打出的每一个包的hash不同，针对文件内容级别的，只有自己模块的内容变了，hash值才改变。生产环境建议使用。\r\n\r\n### 占位符的解释\r\n- ext\t文件后缀名\r\n- name\t文件名\r\n- path\t文件相对路径\r\n- folder\t文件所在文件夹\r\n- hash\t每次构建生成的唯一 hash 值\r\n- chunkhash\t根据 chunk 生成 hash 值\r\n- contenthash\t根据文件内容生成hash 值"},function(r,n,e){"use strict";e.r(n),n.default="## plugin\r\n- 专注处理webpack在编译过程中的某个特定的任务的功能模块，可以称为插件。\r\n- plugin是一个扩展器，它丰富了webpack本身，针对是loader结束后webpack打包的整个过程，它并不直接操作文件，而是基于事件机制工作，会监听webpack打包过程中的某些节点，执行广泛的任务。\r\n### HotModuleReplacementPlugin\r\n- 模块热更新插件。HotModuleReplacementPlugin的热更新是依赖于webpack-dev-server，后者是在打包文件改变时更新打包文件或者reload刷新整个页面，HRM是只更新修改的部分。\r\n- HotModuleReplacementPlugin是webpack模块自带的，webpack5已经内置该插件。\r\n```\r\n// v4\r\nplugins: [\r\n  new webpack.HotModuleReplacementPlugin(), // 热更新插件\r\n]\r\n\r\n// v5\r\ndevServer: {\r\n  hot: true,\r\n}\r\n```\r\n### define-plugin\r\n> 定义全局的变量(一般用于区分生产环境和开发环境)。使用时不能通过window.QUERYHOST获取，直接通过QUERYHOST使用变量。\r\n\r\n```\r\nplugins: [\r\n  new webpack.DefinePlugin({\r\n    'QUERYHOST': JSON.stringify('http://localhost:7001/api'),\r\n  })\r\n]\r\n```\r\n### html-webpack-plugin\r\n- 生成html文件，将webpack打包生成的js、css文件插入到html文件中。\r\n- 默认添加脚本标签位置是头部而不是主体，由于脚本标记具有defer属性，因此只有在解析了HTML后脚本才会加载，所以不会有任何问题。如果仍然希望将脚本标记添加到正文的末尾，则可以使用inject选项。\r\n  1. true：默认值，根据scriptLoading选项选择插入head或body。\r\n  2. head：script标签位于head标签内。\r\n  3. body：script标签位于html文件的body底部。\r\n  4. false：不插入生成的js文件，只是单纯的生成一个html文件。\r\n- 自动引入打包后的资源(比如资源名称含hash值的情况)\r\n```\r\nnew HtmlWebpackPlugin({\r\n  filename: 'index.html', // 配置输出文件名和路径\r\n  template: path.join(__dirname, \"../template/index.html\") // 配置文件模板\r\n})\r\n```\r\n- 多入口\r\n  - filename字段不可缺省，否则默认生成的都是index.html。\r\n  - 通过chunks参数配置该html引入的js模块。\r\n```\r\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\r\nmodule.exports = {\r\n  mode:'development', // 开发模式\r\n  entry: {\r\n    main:path.resolve(__dirname,'../src/main.js'),\r\n    header:path.resolve(__dirname,'../src/header.js')\r\n  }, \r\n  output: {\r\n    filename: '[name].[hash:8].js',      // 打包后的文件名称\r\n    path: path.resolve(__dirname,'../dist')  // 打包后的目录\r\n  },\r\n  plugins:[\r\n    new HtmlWebpackPlugin({\r\n      template:path.resolve(__dirname,'../public/index.html'),\r\n      filename:'index.html',\r\n      chunks:['main'] // 与入口文件对应的模块名\r\n    }),\r\n    new HtmlWebpackPlugin({\r\n      template:path.resolve(__dirname,'../public/header.html'),\r\n      filename:'header.html',\r\n      chunks:['header'] // 与入口文件对应的模块名\r\n    }),\r\n  ]\r\n}\r\n```\r\n### clean-webpack-plugin\r\n> 当打包后的文件名字固定时，新的打包文件会自动覆盖上次的，如果文件名使用了hash，则不会自动删除上次打包的文件，使用clean-webpack-plugin可以自动清除上次打包的文件，避免多次打包后文件夹存在之前打包的文件内容。\r\n\r\n```\r\nconst { CleanWebpackPlugin } = require('clean-webpack-plugin');\r\nplugins: [\r\n  new CleanWebpackPlugin(),\r\n],\r\n```\r\n### hard-source-webpack-plugin\r\n> 可以优化构建速度,第一次构建将花费正常的时间,第二次构建将明显加快（大概提升90%的构建速度。缓存文件默认存在node_module下。webpack5.0会把hard-source-webpack-plugin内置成一个配置。\r\n\r\n```\r\nconst HardSourceWebpackPlugin = require('hard-source-webpack-plugin');\r\nplugins: [\r\n  new HardSourceWebpackPlugin({\r\n    cachePrune: {\r\n      maxAge: 2 * 24 * 60 * 60 * 1000, // 设置缓存文件过期时间为2天\r\n      sizeThreshold: 500 * 1024 * 1024, // 总缓存文件大于500M时才会自动删除过时的缓存文件\r\n    },\r\n  }),\r\n]\r\n```\r\n### mini-css-extract-plugin\r\n- 将css分开打包。\r\n### compression-webpack-plugin\r\n> 将文件压缩成gzip的形式\r\n\r\n```\r\nconst CompressionPlugin = require('compression-webpack-plugin');\r\nnew CompressionPlugin({\r\n  filename: '[path].gz[query]',\r\n  algorithm: 'gzip', // 算法\r\n  test: new RegExp(\r\n    '\\\\.(js|css|less|scss)$' // 压缩 js 与 css\r\n  ),\r\n  // threshold: 10240, // 只处理比这个值大的资源。按字节计算\r\n  // minRatio: 0.8 // 只有压缩率比这个值小的资源才会被处理\r\n}),\r\n```\r\n### copy-webpack-plugin\r\n- 在public/index.html中引入了静态资源，但是打包的时候webpack并不会帮我们拷贝到build目录，copy-webpack-plugin可以将静态资源拷贝到build目录。\r\n```\r\n// 复制public目录文件到build目录\r\nnew CopyPlugin({\r\n  patterns: [\r\n    {\r\n      from: path.resolve(__dirname, '../public'),\r\n      to: path.resolve(__dirname, '../build'),\r\n      filter: source => {\r\n        return !source.includes('public/index.html')\r\n      }\r\n    },\r\n  ],\r\n})\r\n```\r\n### IgnorePlugin\r\n- webpack内置插件，可以忽略第三方包指定目录，让这些指定目录不要被打包进去。\r\n- 忽略moment的多语言包。\r\n```\r\nconst Webpack = require('webpack')\r\n\r\nplugins: [\r\n  // moment这个库中如果引用了./locale/目录的内容，就会被忽略掉不会打包进去\r\n  new Webpack.IgnorePlugin(/\\.\\/locale/, /moment/),\r\n]\r\n```\r\n- 引入需要使用的语言包比如中文语言包\r\n```\r\nimport moment from 'moment'\r\n\r\n// 手动引入所需要的语言包\r\nimport 'moment/locale/zh-cn'\r\n```\r\n### UglifyJsPlugin\r\n- uglifyJsPlugin是vue-cli默认使用的压缩代码方式，用来对js文件进行压缩，从而减小js文件的大小，加速load速度。\r\n- 使用的是单线程压缩代码，打包时间较慢，所以可以在开发环境将其关闭，生产环境部署时再把它打开。\r\n```\r\nconst UglifyJsPlugin = require('uglifyjs-webpack-plugin')\r\n\r\nplugins: [\r\n  new UglifyJsPlugin({\r\n    uglifyOptions: {\r\n      compress: {\r\n        warnings: false\r\n      }\r\n    },\r\n    sourceMap: true,  // 是否启用文件缓存\r\n    parallel: true   // 使用多进程并行运行来提高构建速度\r\n  })\r\n]\r\n```\r\n### ParallelUglifyPlugin\r\n- 开启多个子进程，把对多个文件压缩的工作分别给多个子进程去完成，每个子进程其实还是通过UglifyJS去压缩代码，但是变成了并行执行。\r\n```\r\nconst ParallelUglifyPlugin = require('webpack-parallel-uglify-plugin')\r\n\r\nplugins: [\r\n  new ParallelUglifyPlugin({\r\n    // cacheDir用于配置缓存存放的目录路径。\r\n    cacheDir: '.cache/',\r\n    sourceMap: true,\r\n    uglifyJS: {\r\n      output: {\r\n        comments: false,\r\n      },\r\n      compress: {\r\n        warnings: false,\r\n      },\r\n    },\r\n  }),\r\n]\r\n```\r\n### terser-webpack-plugin\r\n- webpack4默认是使用terser-webpack-plugin压缩插件，在此之前是使用uglifyjs-webpack-plugin，terser-webpack-plugin对ES6的压缩更好。\r\n- 开启parallel参数，使用多进程压缩加快压缩。\r\n```\r\nconst TerserPlugin = require('terser-webpack-plugin') // 压缩js代码\r\n\r\noptimization: {\r\n  minimizer: [\r\n    new TerserPlugin({\r\n      parallel: 4, // 开启几个进程来处理压缩，默认是 os.cpus().length - 1\r\n      cache: true, // 是否缓存\r\n    }),\r\n  ]\r\n}\r\n```\r\n### css-minimizer-webpack-plugin\r\n- 压缩css\r\n```\r\nconst CssMinimizerWebpackPlugin = require('css-minimizer-webpack-plugin');\r\n\r\n// 直接在plugins中使用插件\r\nmodule.exports = {\r\n  // ...\r\n  plugins: [\r\n    // ...\r\n    new CssMinimizerWebpackPlugin(), // 压缩css\r\n  ]\r\n}\r\n\r\n// 或在optimization.minimizer中使用插件\r\nmodule.exports = {\r\n  // ...\r\n  optimization: {\r\n    minimizer: [\r\n      new CssMinimizerWebpackPlugin(), // 压缩css\r\n    ],\r\n  },\r\n}\r\n```\r\n### unused-files-webpack-plugin \r\n- 查找无用文件(webpack4)\r\n```\r\nconst { UnusedFilesWebpackPlugin } = require(\"unused-files-webpack-plugin\");\r\n \r\n// 会输出无用文件目录\r\nmodule.exports = {\r\n  plugins: [\r\n    new UnusedFilesWebpackPlugin(),\r\n  ],\r\n};\r\n\r\n// cwd  插件检索的目录\r\nglobOptions: { cwd: path.resolve(__dirname, \"../src\") },\r\n\r\n// 找到未使用的文件直接退出命令 默认false\r\nfailOnUnused: true, \r\n```\r\n- 查找无用文件(webpack5)\r\n```\r\nconst UselessFile = require('useless-files-webpack5-plugin')\r\n\r\nmodule.exports = {\r\n  plugins: [\r\n    new UselessFile({\r\n      webpack: '5',\r\n      root: path.resolve(__dirname, '../src'),\r\n      out: './fileList.json',\r\n      clean: true,\r\n    }),\r\n  ],\r\n}\r\n``` \r\n### webpack-bundle-analyzer\r\n> 运行打包命令，打开的页面会显示各个模块的大小。\r\n\r\n```\r\nconst BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;\r\nplugins: [\r\n  new BundleAnalyzerPlugin({\r\n    analyzerMode: 'server',\r\n    analyzerHost: '127.0.0.1',\r\n    analyzerPort: 8888,\r\n    reportFilename: 'report.html',\r\n    defaultSizes: 'parsed',\r\n    openAnalyzer: true,\r\n    generateStatsFile: false,\r\n    statsFilename: 'stats.json',\r\n    logLevel: 'info'\r\n  })\r\n]\r\n```\r\n### Speed Measure Plugin\r\n> 对打包过程中消耗的时间进行精确的统计，能够测量出在你的构建过程中，每一个 Loader 和 Plugin 的执行时长,在启动本地服务的命令行中显示。smp.wrap包裹所有的webpack的配置module.exports = smp.wrap({})，使用webpack-merge后不用加smp.wrap({}), 引入插件即可。\r\n\r\n```\r\nconst SpeedMeasurePlugin = require(\"speed-measure-webpack-plugin\");\r\nconst smp = new SpeedMeasurePlugin();\r\nconst webpackConfig = smp.wrap({\r\n  plugins: [\r\n    new MyPlugin(),\r\n    new MyOtherPlugin()\r\n  ]\r\n});\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## proxy\r\n> webpack proxy，即webpack提供的代理服务，基本行为就是接收客户端发送的请求后转发给其他服务器，目的是为了便于开发者在开发模式下解决跨域问题，想要实现代理首先需要一个中间服务器，webpack中提供服务器的工具为webpack-dev-server。\r\n\r\n### proxy配置\r\n> 属性的名称是需要被代理的请求路径前缀，一般为了辨别都会设置前缀为/api，值为对应的代理匹配规则，对应如下。\r\n\r\n- target：表示的是代理到的目标地址。\r\n- pathRewrite：默认情况下，我们的 /api-hy 也会被写入到URL中，如果希望删除，可以使用pathRewrite\r\n- secure：默认情况下不接收转发到https的服务器上，如果希望支持，可以设置为false\r\n- changeOrigin：它表示是否更新代理后请求的 headers 中host地址\r\n```\r\n// webpack.config.js\r\nconst path = require('path');\r\n\r\nmodule.exports = {\r\n  // ...\r\n  devServer: {\r\n    port: 8000,\r\n    proxy: {\r\n      '/api': {\r\n        target: 'https://api.com'\r\n      }\r\n    }\r\n    // ...\r\n  }\r\n}\r\n```\r\n### 工作原理\r\n> proxy工作原理实质上是利用 http-proxy-middleware 这个http代理中间件，实现请求转发给其他服务器。在开发阶段，本地地址为http://localhost:3000，该浏览器发送一个前缀带有/api标识的请求到服务端获取数据，但响应这个请求的服务器只是将请求转发到另一台服务器中。\r\n\r\n```\r\nconst express = require('express');\r\nconst proxy = require('http-proxy-middleware');\r\n\r\nconst app = express();\r\n\r\napp.use('/api', proxy({ target: 'http://www.example.org', changeOrigin: true }));\r\napp.listen(3000);\r\n\r\n// http://localhost:3000/api/foo/bar -> http://www.example.org/api/foo/bar\r\n```\r\n### 解决开发时的跨域问题\r\n> 在开发阶段， webpack-dev-server 会启动一个本地开发服务器，所以我们的应用在开发阶段是独立运行在 localhost的一个端口上，而后端服务又是运行在另外一个地址上，所以在开发阶段中，由于浏览器同源策略的原因，当本地访问后端就会出现跨域请求的问题，通过设置webpack proxy实现代理请求后，相当于浏览器与服务端中添加一个代理者，当本地发送请求的时候，代理服务器响应该请求，并将请求转发到目标服务器 (服务器与服务器之间请求数据并不会存在跨域行为，跨域行为是浏览器安全策略限制)，目标服务器响应数据后再将数据返回给代理服务器，最终再由代理服务器将数据响应给本地，在代理服务器传递数据给本地浏览器的过程中，两者同源，并不存在跨域行为，这时候浏览器就能正常接收数据。\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## [SplitChunksPlugin](https://segmentfault.com/a/1190000042093955)\r\n> 默认情况下，Webpack会将所有代码构建成一个单独的包，这在小型项目通常不会有明显的性能问题，但伴随着项目的推进，包体积逐步增长可能会导致应用的响应耗时越来越长。一个多页面应用，所有页面都依赖于相同的基础库，那么这些所有页面对应的entry都会包含有基础库代码，所以需要对产物做适当的分解拆包。\r\n\r\n### 所有资源打包成一个文件方式的弊端\r\n- 资源冗余：客户端必须等待整个应用的代码包都加载完毕才能启动运行，但可能用户当下访问的内容只需要使用其中一部分代码。\r\n- 缓存失效：将所有资源达成一个包后，所有改动——即使只是修改了一个字符，客户端都需要重新下载整个代码包，缓存命中率极低。\r\n\r\n### CommmonsChunkPlugin\r\n> CommmonsChunkPlugin的思路是将满足minChunks所设置的条件的模块移到一个新的chunk文件中去，这个思路是基于父子关系的，也就是这个新产出的new chunk是所有chunk的父亲，在加载孩子chunk的时候，父亲chunk是必须要提前加载的。\r\n\r\n- 同步模块加载\r\n```\r\n// example：\r\nentryA: vue vuex  someComponents \r\nentryB: vue axios someComponents \r\nentryC: vue vuex axios someComponents \r\n\r\nminchunks: 2\r\n\r\n// 产出后的chunk，对entryA和entryB来说，vendor-chunk都包含了多余的module。\r\nvendor-chunk：vue vuex axios \r\nchunkA~chunkC: only the components\r\n```\r\n- 异步的模块\r\n```\r\n// example：\r\nentryA: vue vuex  someComponents \r\nasyncB: vue axios someComponents \r\nentryC: vue vuex axios someComponents \r\n\r\nminchunks: 2\r\n\r\n// 产出后的chunk，如果asyncB在entryA中动态引入，则会引入多余的module。\r\nvendor-chunk：vue vuex  \r\nchunkA: only the components\r\nchunkB: vue axios someComponents \r\nchunkC: axios someComponents\r\n```\r\n#### CommonsChunkPlugin的问题：\r\n- 可能会导致许多不必要的代码代码被加载。\r\n- 会影响异步加载的chunk。\r\n- 高优的chunk产出需要的minchunks配置比较复杂。\r\n### SplitChunksPlugin\r\n> 会使用模块重复计数和模块种类自动识别哪些chunk需要被分离。基于一些启发式的规则将Module编排进不同的Chunk序列，并最终将应用代码分门别类打包出多份产物，从而实现分包功能。\r\n\r\n- 不会下载不必要的模块（只要你强制使用name属性合并chunk）\r\n- 对异步加载的chunk也有效\r\n- 处理从多个vendor chunks分离出来的vendor\r\n- 更容易使用\r\n- 更加自动化\r\n### CommmonsChunkPlugin VS SplitChunksPlugin\r\n> CommonsChunkPlugin就类似于：创建这个chunk并且把所有与minChunks字段匹配的模块移到新的chunk中。而SplitChunksPlugin就类似于：这是启发式的，确保你需要他们。（命令式vs声明式）\r\n\r\n![commmonsChunkPlugin VS SplitChunksPlugin](./img/splitChunksPlugin.png)\r\n\r\n### SplitChunksPlugin使用\r\n- SplitChunksPlugin通过module被引用频率、chunk大小、包请求数三个维度决定是否执行分包操作，这些决策都可以通过 optimization.splitChunks配置项调整定制，基于这些维度我们可以实现：单独打包某些特定路径的内容，例如node_modules打包为 vendors；单独打包使用频率较高的文件。\r\n- SplitChunksPlugin还提供配置组概念optimization.splitChunks.cacheGroup，用于为不同类型的资源设置更有针对性的配置信息。\r\n- SplitChunksPlugin还内置了default与defaultVendors两个配置组，提供一些开箱即用的特性：\r\n  - node_modules资源会命中defaultVendors规则，并被单独打包。\r\n  - 只有包体超过20kb的Chunk才会被单独打包。\r\n  - 加载 Async Chunk 所需请求数不得超过30。\r\n  - 加载 Initial Chunk 所需请求数不得超过30。\r\n#### 分包范围（chunks）\r\n> SplitChunksPlugin默认只对Async Chunk生效，开发者也可以通过optimization.splitChunks.chunks调整作用范围，该配置项支持如下值：\r\n\r\n- 字符串'all' ：对Initial Chunk与Async Chunk都生效，建议优先使用该值。\r\n- 字符串'initial'：只对Initial Chunk生效。\r\n- 字符串'async'：只对Async Chunk生效。\r\n- 函数 (chunk)=>boolean：该函数返回true时生效。\r\n```\r\nmodule.exports = {\r\n  //...\r\n  optimization: {\r\n    splitChunks: {\r\n      chunks: 'all',\r\n    },\r\n  },\r\n}\r\n```\r\n#### 根据Module使用频率分包(minChunks)\r\n> SplitChunksPlugin支持按Module被Chunk引用的次数决定是否进行分包，开发者可通过optimization.splitChunks.minChunks设定最小引用次数。\r\n\r\n```\r\nmodule.exports = {\r\n  //...\r\n  optimization: {\r\n    splitChunks: {\r\n      // 设定引用次数超过 3 的模块才进行分包\r\n      minChunks: 3\r\n    },\r\n  },\r\n}\r\n```\r\n![miniChunk](./img/miniChunk.png)\r\n> entry-a、entry-b分别被视作Initial Chunk处理；async-module被entry-a以异步方式引入，因此被视作Async Chunk处理。那么对于common模块来说，分别被三个不同的Chunk引入，此时引用次数为 3，命中optimization.splitChunks.minChunks=2规则，因此该模块「可能」会被单独分包，最终产物：entry-a.js entry-b.js async-module.js common.js。\r\n\r\n#### 限制分包数量(maxInitialRequest/maxAsyncRequests)\r\n> 在满足minChunks基础上，还可以通过maxInitialRequest/maxAsyncRequests配置项限定分包数量。这里所说的“请求数”，是指加载一个Chunk时所需同步加载的分包数。例如对于一个Chunk A，如果根据分包规则(如模块引用次数、第三方包)分离出了若干子Chunk A¡，那么请求A时，浏览器需要同时请求所有的A¡，此时并行请求数等于¡个分包加A主包，即¡+1。\r\n\r\n- maxInitialRequest：用于设置Initial Chunk最大并行请求数。\r\n- maxAsyncRequests：用于设置 Async Chunk 最大并行请求数。\r\n![maxInitialRequest](./img/maxInitialRequest.png)\r\n> 若minChunks=2，则common-1 、common-2同时命中minChunks规则被分别打包，浏览器请求entry-b时需要同时请求common-1、common-2两个分包，并行数为2+1=3，此时若maxInitialRequest= 2，则分包数超过阈值，SplitChunksPlugin会放弃common-1、common-2中体积较小的分包。maxAsyncRequest逻辑与此类似。\r\n\r\n#### 限制分包体积(minSize、maxSize.........)\r\n- minSize：超过这个尺寸的Chunk才会正式被分包。\r\n- maxSize：超过这个尺寸的Chunk会尝试继续做分包。\r\n- maxAsyncSize：与maxSize功能类似，但只对异步引入的模块生效。 \r\n- maxInitialSize：与maxSize类似，但只对entry配置的入口模块生效。\r\n- enforceSizeThreshold：超过这个尺寸的Chunk会被强制分包，忽略上述其它size限制。\r\n#### SplitChunksPlugin的主体流程\r\n- SplitChunksPlugin尝试将命中minChunks规则的Module统一抽到一个额外的Chunk对象。\r\n- 判断该Chunk是否满足maxInitialRequests阈值，若满足则进行下一步。\r\n- 判断该 Chunk 资源的体积是否大于上述配置项minSize声明的下限阈值。\r\n  - 如果体积「小于」 minSize则取消这次分包，对应的Module依然会被合并入原来的Chunk。\r\n  - 如果Chunk体积「大于」minSize则判断是否超过maxSize、maxAsyncSize、maxInitialSize声明的上限阈值，如果超过则尝试将该Chunk继续分割成更小的部分。\r\n```\r\n这些属性的优先级顺序为：\r\n\r\nmaxInitialRequest/maxAsyncRequests < maxSize < minSize\r\n\r\n而命中 enforceSizeThreshold 阈值的 Chunk 会直接跳过这些属性判断，强制进行分包。\r\n```\r\n#### cacheGroups\r\n> cacheGroups配置项用于为不同文件组设置不同的规则，通过cacheGroups属性设置vendors缓存组，所有命中vendors.test规则的模块都会被视作vendors分组，优先应用该组下的minChunks、minSize等分包配置。缓存组的作用在于能为不同类型的资源设置更具适用性的分包规则，一个典型场景是将所有node_modules下的模块统一打包到vendors产物，从而实现第三方库与业务代码的分离。\r\n\r\n- test：接受正则表达式、函数及字符串，所有符合test判断的Module或Chunk都会被分到该组。\r\n- type：接受正则表达式、函数及字符串，与test类似均用于筛选分组命中的模块，区别是它判断的依据是文件类型而不是文件名，例如type='json'会命中所有JSON文件。\r\n- name：chunk命名。\r\n- priority：数字型，用于设置该分组的优先级，若模块命中多个缓存组，则优先被分到priority更大的组。\r\n**默认分组**\r\n> 这两个配置组可以 将所有node_modules中的资源单独打包到vendors.js命名的产物。对引用次数大于等于2的模块，也就是被多个Chunk引用的模块，单独打包。\r\n\r\n```\r\nmodule.exports = {\r\n  //...\r\n  optimization: {\r\n    splitChunks: {\r\n      chunks: 'async',\r\n      minSize: 30000,\r\n      maxSize: 0,\r\n      minChunks: 1,\r\n      maxAsyncRequests: 5,\r\n      maxInitialRequests: 3,\r\n      automaticNameDelimiter: '~',\r\n      name: true,\r\n      cacheGroups: {\r\n        vendors: {\r\n          test: /[\\\\/]node_modules[\\\\/]/,\r\n          priority: -10\r\n        },\r\n        default: {\r\n          minChunks: 2,\r\n          priority: -20,\r\n          reuseExistingChunk: true\r\n        }\r\n      }\r\n    }\r\n  }\r\n};\r\n```\r\n#### SplitChunksPlugin最佳实战\r\n- 尽量将第三方库拆为独立分包\r\n- 保持按路由分包，减少首屏资源负载\r\n- 尽量保持 chunks='all'\r\n\r\n### 生产环境的output不能使用hash，应该使用contenthash或者chunkhash，开发环境只能使用hash。"},function(r,n,e){"use strict";e.r(n),n.default="## webpack5变化\r\n### 模块联邦\r\n### 更好的hash算法\r\n> webpack4有hash、chunckhash、contenthash三种。在webpack5中，把hash改成了fullhash。webpack4对于添加注释和修改变量是会影响contenthash的计算，如果是webpack5的就不会影响contenthash的计算。\r\n\r\n```\r\n// before\r\nconst num = 1;\r\nconsole.log('这里是输出', num);\r\n\r\n// after\r\nconst str = 1;\r\nconsole.log('这里是输出', str);\r\n```\r\n- hash/fullhash\r\n> hash/fullhash是根据打包中的所有文件计算出来的 hash 值，在一次打包中，所有的资源出口文件的filename获得的 hash 都是一样的。\r\n\r\n- chunckhash\r\n> chunckhash是根据打包过程中当前 chunck 计算出来的 hash 值。\r\n\r\n- contenthash\r\n> contenthash是根据打包时的内容计算出的 hash 值。\r\n\r\n### 持久性缓存来提高构建性能\r\n> 在webpack5之前，webpack是没有提供持久化缓存，需要使用类似cache-loader、模块缓存插件hard-source-webpack-plugin来做缓存方面的处理。在webpack5中加入了持久化缓存，hard-source-webpack-plugin插件内置，缓存webpack生成的模块和chunk来改善构建速度。cache会在开发模式被设置成type: 'memory'，在生产模式中被禁用。\r\n\r\n- cache.type: memory 表示会将打包生成的资源存放于内存中。\r\n- cache.type: filesystem 表示开启了文件系统缓存。\r\n```\r\n// webpack 4\r\nmodule.exports = {\r\n  module: {\r\n    rules: [\r\n      {\r\n        test: /.js$/,\r\n        use: ['cache-loader', ...loaders],\r\n        include: path.resolve('src'),\r\n      },\r\n    ],\r\n  },\r\n};\r\n\r\n// webpack 5\r\nmodule.exports = {\r\n  cache: {\r\n    type: 'filesystem',\r\n  },\r\n};\r\n```\r\n### Tree Shaking的改进\r\n> Tree shaking是一个术语，通常用于移除 JavaScript 上下文中的未引用代码(dead-code)。它依赖于 ES2015 模块语法的静态结构特性，例如 import 和 export。在webpack4中，Tree Shaking对嵌套的导出模块未使用代码无法很好进行Tree Shaking，我们可以借助一些plugin来实现，但是到了webpack5得到了很大的改进。\r\n\r\n```\r\n// a.js\r\nconst name = 'dyxweb';\r\nconst age = 26;\r\nexport { name, age };\r\n\r\n// b.js\r\nimport * as data from './a';\r\nexport { data };\r\n\r\n// index.js\r\nimport * as common from './b';\r\n// 只是使用了 age，而没有使用 name\r\nconsole.log(common.data.age);\r\n\r\n// webpack5打包会移除未使用的变量，但是webpack4没有移除\r\n```\r\n### Asset Modules资源模块\r\n> 指的是图片和字体等这一类型文件模块，它们无须使用额外的预处理器，webpack 通过一些配置就可以完成对它们的解析。在webpack5之前，没有内置资源模块，所以我们通常使用file-loader、url-loader、raw-loader之类的loader去处理。\r\n\r\n- asset/resource 发送一个单独的文件并导出 URL。之前通过使用 file-loader 实现。\r\n- asset/inline 导出一个资源的 data URI。之前通过使用 url-loader 实现。\r\n- asset/source 导出资源的源代码。之前通过使用 raw-loader 实现。\r\n- asset 在导出一个 data URI 和发送一个单独的文件之间自动选择。之前通过使用 url-loader，并且配置资源体积限制实现。\r\n\r\n### 自动清除上次打包内容\r\n> webpack5配置output.clean: true可以自动清除上次打包内容。webpack4需要使用clean-webpack-plugin清除上次打包内容。\r\n\r\n### 热更新\r\n> webpack5设置devServer.hot为true即可实现热更新。webpack4需要使用webpack.HotModuleReplacementPlugin插件实现热更新，webpack5已经内置该插件。\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## webpack5搭建react+ts项目\r\n### 初始化项目基本目录\r\n- 新建项目文件夹typescript-react\r\n- 初始化package.json\r\n```\r\nnpm init -y\r\n```\r\n- 项目文件夹下新增以下目录结构和文件\r\n```\r\n- config\r\n  - webpack.common.js    // 基本配置\r\n  - webpack.dev.js       // 开发环境配置\r\n  - webpack.prod.js      // 打包环境配置\r\n  - webpack.analysis.js  // 打包分析配置\r\n- public\r\n  - index.html  // html模版          \r\n- src\r\n  - app.tsx     // react代码\r\n  - index.tsx   // react应用入口页面\r\n- tsconfig.json // ts配置\r\n- package.json\r\n```\r\n- 安装react依赖\r\n```\r\nnpm i react react-dom -S\r\n```\r\n- 安装react类型依赖\r\n```\r\nnpm i @types/react @types/react-dom -D\r\n```\r\n- 添加public/index.html内容\r\n```\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n  <meta charset=\"UTF-8\">\r\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\r\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n  <title>typescript-react</title>\r\n</head>\r\n<body>\r\n  <noscript>You need to enable JavaScript to run this app.</noscript>\r\n  <div id=\"root\"></div>\r\n</body>\r\n</html>\r\n```\r\n- 添加tsconfig.json内容\r\n```\r\n{\r\n  \"compilerOptions\": {\r\n    \"target\": \"es5\",\r\n    \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"],\r\n    \"allowJs\": true,\r\n    \"skipLibCheck\": true,\r\n    \"esModuleInterop\": true,\r\n    \"allowSyntheticDefaultImports\": true,\r\n    \"strict\": true,\r\n    \"forceConsistentCasingInFileNames\": true,\r\n    \"noFallthroughCasesInSwitch\": true,\r\n    \"module\": \"esnext\",\r\n    \"moduleResolution\": \"node\",\r\n    \"resolveJsonModule\": true,\r\n    \"isolatedModules\": true,\r\n    \"noEmit\": true,\r\n    \"jsx\": \"react-jsx\"\r\n  },\r\n  \"include\": [\"src\"]\r\n}\r\n```\r\n- 添加src/app.tsx内容\r\n```\r\nimport React from 'react';\r\n\r\nconst App = () => <div>app</div>;\r\nexport default App;\r\n```\r\n- 添加src/index.tsx内容\r\n```\r\nimport React from 'react';\r\nimport { createRoot } from 'react-dom/client';\r\nimport App from './app';\r\n\r\nconst root = document.getElementById('root');\r\ncreateRoot(root).render(<App />);\r\n```\r\n### 安装webpack依赖\r\n```\r\nnpm i webpack webpack-cli -D\r\n```\r\n### 配置webpack的entry和output\r\n```\r\n// webpack.common.js\r\nconst path = require('path');\r\n\r\nmodule.exports = {\r\n  // 入口文件\r\n  entry: path.resolve(__dirname, '../src/index.tsx'),\r\n  // 打包文件出口\r\n  output: {\r\n    publicPath: '/', // 打包后文件的公共前缀路径\r\n    path: path.resolve(__dirname, '../build'), // 打包结果输出目录\r\n    filename: 'static/js/[name].[contenthash:8].js', // 打包文件名\r\n    clean: true, // 每一次打包清除上一次打包内容，webpack4需要配置clean-webpack-plugin\r\n  },\r\n}\r\n```\r\n### 设置模块如何被解析 resolve.extensions\r\n> 尝试按顺序解析这些后缀名文件，能够使用户在引入模块时不带文件扩展名。如果有多个文件有相同的名字但后缀名不同，webpack会解析列在数组首位的后缀的文件并跳过其余的后缀。\r\n\r\n```\r\n// webpack.common.js\r\nmodule.exports = {\r\n  // ...\r\n  resolve: {\r\n    // 默认是.js和.json。以下配置解决ts文件无法被引用解析的问题\r\n    extensions: ['.tsx', '.ts', '.jsx', '.js', '.json'],\r\n  },\r\n}\r\n```\r\n### 配置babel-loader(添加babel.config.js文件配置babel相关配置)\r\n#### 解析ts/tsx和js/jsx\r\n> webpack默认只能识别js文件不能识别ts、jsx语法，需要使用@babel/preset-typescript将ts语法转为js语法，再使用@babel/preset-react来转化jsx语法。\r\n\r\n- 安装依赖\r\n```\r\nnpm i babel-loader @babel/core @babel/preset-react @babel/preset-typescript -D\r\n```\r\n- 修改webpack.common.js配置\r\n```\r\nmodule.exports = {\r\n  // ...\r\n  module: {\r\n    rules: [\r\n      {\r\n        test: /\\.(ts|js)x?$/,\r\n        use: 'babel-loader'\r\n      }\r\n    ]\r\n  }\r\n}\r\n```\r\n- 添加babel.config.js文件\r\n```\r\nmodule.exports = {\r\n  // 预设执行顺序由右往左，所以先处理ts再处理jsx\r\n  presets: [\r\n    \"@babel/preset-react\",\r\n    \"@babel/preset-typescript\"\r\n  ]\r\n}\r\n```\r\n#### babel处理js兼容\r\n> js新增很多方便好用的标准语法来方便开发，甚至还有非标准语法比如装饰器。但前者标准语法很多低版本浏览器不支持，后者非标准语法所有的浏览器都不支持。所以需要借助babel把最新的标准语法转换为低版本语法，把非标准语法转换为标准语法才能让浏览器识别解析。\r\n\r\n- 安装依赖\r\n```\r\nnpm i @babel/preset-env @babel/plugin-transform-runtime -D\r\nnpm i core-js @babel/runtime -S\r\n```\r\n- 修改babel.config.js的配置\r\n```\r\n// babel.config.js\r\nmodule.exports = {\r\n  sourceType: \"unambiguous\",\r\n  // 执行顺序由右往左，所以先处理ts再处理jsx，最后再转换为低版本浏览器支持的语法\r\n  presets: [\r\n    [\r\n      \"@babel/preset-env\",\r\n      {\r\n        // 设置兼容目标浏览器版本，这里可以不写，babel-loader会自动寻找配置好的.browserslistrc文件\r\n        // \"targets\": {\r\n        //   > 0.2% in CN\r\n        //   last 10 versions\r\n        // },\r\n        useBuiltIns: \"usage\", // 根据配置的浏览器兼容，以及代码中使用到的api进行引入polyfill按需添加\r\n        corejs: {\r\n          version: 3,\r\n          proposals: true\r\n        } // 配置使用core-js使用的版本\r\n      }\r\n    ],\r\n    \"@babel/preset-react\",\r\n    \"@babel/preset-typescript\"\r\n  ],\r\n  plugins: [\r\n    [\r\n      \"@babel/plugin-transform-runtime\",\r\n    ],\r\n  ]\r\n}\r\n```\r\n- babel-loader添加exclude配置避免报错\r\n```\r\nmodule.exports = {\r\n  // ...\r\n  module: {\r\n    rules: [\r\n      {\r\n        test: /\\.(ts|js)x?$/,\r\n        use: 'babel-loader',\r\n        exclude: [\r\n          /\\bcore-js\\b/,\r\n          /\\bwebpack\\/buildin\\b/\r\n        ],\r\n      },\r\n    ]\r\n  }\r\n}\r\n```\r\n- 添加.browserslistrc文件\r\n```\r\n> 0.2% in CN\r\nlast 10 versions\r\n```\r\n### 使用html-webpack-plugin将webpack最终构建好的静态资源都引入到html文件中\r\n- 安装依赖\r\n```\r\nnpm i html-webpack-plugin -D\r\n```\r\n- 修改webpack.common.js配置\r\n```\r\nconst path = require('path');\r\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\r\n\r\nmodule.exports = {\r\n  // ...\r\n  plugins: [\r\n    new HtmlWebpackPlugin({\r\n      // html模板\r\n      template: path.resolve(__dirname, '../public/index.html'),\r\n    }),\r\n  ]\r\n}\r\n```\r\n### webpack开发环境配置\r\n- 安装依赖\r\n> 使用webpack-dev-server启动本地服务，还需要依赖webpack-merge来合并基本配置。\r\n\r\n```\r\nnpm i webpack-dev-server webpack-merge -D\r\n```\r\n- 修改webpack.dev.js文件配置开发环境\r\n```\r\nconst path = require('path');\r\nconst { merge } = require('webpack-merge');\r\nconst commonConfig = require('./webpack.common.js');\r\n\r\n// 合并基本配置，并添加开发环境配置\r\nmodule.exports = merge(commonConfig, {\r\n  mode: 'development', // 开发模式\r\n  devtool: 'cheap-module-source-map',\r\n  devServer: {\r\n    port: 8000, // 端口号\r\n    compress: false, // gzip压缩开发环境不开启，提升热更新速度\r\n    open: true, // 自动打开浏览器\r\n    hot: true, // 开启热更新\r\n    historyApiFallback: true, // 解决history路由404问题\r\n    static: {\r\n      directory: path.resolve(__dirname, \"../public\"), // 托管静态资源public文件夹\r\n    }\r\n  }\r\n})\r\n```\r\n- package.json添加启动本地服务脚本\r\n```\r\n// package.json\r\n\"scripts\": {\r\n  \"start\": \"webpack-dev-server --config config/webpack.dev.js\"\r\n},\r\n```\r\n### webpack打包环境配置\r\n- 修改webpack.prod.js文件配置打包环境\r\n```\r\nconst { merge } = require('webpack-merge');\r\nconst commonConfig = require('./webpack.common.js');\r\n\r\nmodule.exports = merge(commonConfig, {\r\n  mode: 'production', // 生产模式\r\n})\r\n```\r\n- package.json添加打包脚本\r\n```\r\n\"scripts\": {\r\n  // ...\r\n  \"build\": \"webpack --config config/webpack.prod.js\"\r\n},\r\n```\r\n- 浏览器查看打包结果\r\n> 执行npm run build，最终打包在build文件夹中，在本地借助node服务器serve启动打包后的项目。\r\n\r\n```\r\n// 全局安装serve\r\nnpm i serve -g\r\n\r\n// 启动打包后的项目\r\nserve -s build\r\n```\r\n### 配置环境变量\r\n> 通过环境变量可以区分是开发模式还是打包构建模式，可以使用较为通用process.env.NODE_ENV环境变量进行区分。区分项目业务环境比如开发、测试、预发、正式，可以自定义一个process.env.BASE_ENV环境变量。\r\n\r\n- 安装cross-env\r\n```\r\nnpm i cross-env -D\r\n```\r\n- 修改package.json的scripts脚本字段\r\n```\r\n\"scripts\": {\r\n  \"start\": \"cross-env NODE_ENV=development BASE_ENV=development webpack-dev-server --config config/webpack.dev.js\",\r\n  \"start:test\": \"cross-env NODE_ENV=development BASE_ENV=test webpack-dev-server --config config/webpack.dev.js\",\r\n  \"build\": \"cross-env NODE_ENV=production BASE_ENV=development webpack --config config/webpack.prod.js\",\r\n  \"build:test\": \"cross-env NODE_ENV=production BASE_ENV=test webpack --config config/webpack.prod.js\",\r\n},\r\n```\r\n- process.env.NODE_ENV环境变量webpack会自动根据设置的mode字段来给业务代码注入对应的development和production，在命令中再次设置环境变量NODE_ENV是为了在webpack和babel的配置文件中访问到。\r\n- 测试webpack中可以访问到设置的环境变量，执行npm run start:test\r\n```\r\n// webpack.common.js\r\nconsole.log('NODE_ENV', process.env.NODE_ENV) // NODE_ENV development\r\nconsole.log('BASE_ENV', process.env.BASE_ENV) // BASE_ENV test\r\n```\r\n- 将环境变量注入到业务代码中\r\n```\r\n// webpack.common.js\r\nconst webpack = require('webpack');\r\n\r\nmodule.export = {\r\n  // ...\r\n  plugins: [\r\n    // ...\r\n    new webpack.DefinePlugin({\r\n      // webpack通过命令将自定义的process.env.BASE_ENV环境变量注入到业务代码\r\n      'process.env.BASE_ENV': JSON.stringify(process.env.BASE_ENV)\r\n    })\r\n  ]\r\n```\r\n- 测试业务代码中可以访问到注入的环境变量，执行npm run start:test\r\n```\r\n// src/index.tsx\r\nconsole.log('NODE_ENV', process.env.NODE_ENV) // NODE_ENV development\r\nconsole.log('BASE_ENV', process.env.BASE_ENV) // BASE_ENV test\r\n```\r\n### 支持css使用\r\n- css-loader\r\n> 会分析出各个css文件之间的关系，把各个css文件合并为一大段css，然后将css文件编译为CommonJS模块，并把该模块引入到JS中。\r\n\r\n- style-loader\r\n> 从JS中提取出刚才引入的编译后的css，在页面的header中创建style标签并插入该css。\r\n\r\n- 安装依赖\r\n```\r\nnpm i css-loader style-loader -D\r\n```\r\n- 修改webpack.common.js配置\r\n```\r\n// webpack.common.js\r\nmodule.exports = {\r\n  // ...\r\n  module: {\r\n    rules: [\r\n      // ...\r\n      {\r\n        test: /\\.css$/,\r\n        use: ['style-loader', 'css-loader']\r\n      },\r\n    ]\r\n  }\r\n}\r\n```\r\n- 添加css文件测试\r\n```\r\n// src/app.css\r\n.app {\r\n  color: red;\r\n}\r\n\r\n// src/app.tsx\r\nimport React from 'react';\r\nimport './app.css';\r\n\r\nconst App = () => <div className=\"app\">app</div>;\r\nexport default App;\r\n```\r\n- 新建global.d.ts文件添加css类型声明\r\n```\r\ndeclare module '*.css';\r\n```\r\n- tsconfig.json文件的include属性值添加global.d.ts\r\n```\r\n{\r\n  // ...\r\n  \"include\": [\"src\", \"global.d.ts\"]\r\n}\r\n```\r\n### 支持css预处理器使用(以scss为例)\r\n- 安装依赖\r\n```\r\nnpm i sass sass-loader -D\r\n```\r\n- 修改webpack.common.js配置\r\n```\r\nmodule.exports = {\r\n  // ...\r\n  module: {\r\n    rules: [\r\n      // ...\r\n      {\r\n        test: /\\.css$/,\r\n        use: ['style-loader', 'css-loader']\r\n      },\r\n      {\r\n        test: /.(scss|sass)$/,\r\n        use: [\r\n          'style-loader',\r\n          'css-loader',\r\n          'sass-loader'\r\n        ]\r\n      },\r\n    ]\r\n  }\r\n}\r\n```\r\n- 添加scss文件测试\r\n```\r\n// src/app.scss\r\n.app {\r\n  color: blue;\r\n}\r\n\r\n// src/app.tsx\r\nimport React from 'react';\r\nimport './app.scss';\r\n\r\nconst App = () => <div className=\"app\">app</div>;\r\nexport default App;\r\n```\r\n- global.d.ts文件中添加scss类型声明\r\n```\r\ndeclare module '*.scss';\r\n```\r\n### css兼容性处理\r\n> 由于浏览器兼容性不同，需要进行css兼容性的处理。如果手动编写各种兼容样式工作量较大，可使用postcss-loader来实现css的兼容性。\r\n\r\n- postcss-loader依赖于postcss。postcss有大量的配置我们可以使用它的预设postcss-preset-env，该预设包括了autoprefixer等。\r\n```\r\nnpm i postcss-loader postcss postcss-preset-env -D\r\n```\r\n- 定义通用的postcss-loader配置，根目录新建postcss.config.js，postcss.config.js是postcss-loader的配置文件，postcss-loader会自动读取配置。\r\n```\r\n// postcss.config.js\r\nmodule.exports = {\r\n  plugins: ['postcss-preset-env']\r\n}\r\n```\r\n- postcss-loader会根据.browserslistrc文件判断要加哪些浏览器的前缀\r\n- 在每个css相关的loader配置中添加postcss-loader。postcss-loader需要在css-loader之前执行，在css预处理器的loader之后执行。\r\n```\r\n// webpack.common.js\r\nmodule.exports = {\r\n  // ...\r\n  module: {\r\n    rules: [\r\n      // ...\r\n      {\r\n        test: /\\.css$/,\r\n        use: ['style-loader', 'css-loader', 'postcss-loader']\r\n      },\r\n      {\r\n        test: /.(scss|sass)$/,\r\n        use: [\r\n          'style-loader',\r\n          'css-loader',\r\n          'postcss-loader',\r\n          'sass-loader'\r\n        ]\r\n      },\r\n    ]\r\n  },\r\n}\r\n```\r\n- 添加样式测试，css样式已经加上了浏览器内核前缀。\r\n```\r\n// src/app.scss\r\n.app {\r\n  color: blue;\r\n  transform: translateY(100px);\r\n}\r\n```\r\n### 支持css module形式\r\n- 添加css-loader的options配置\r\n```\r\n// webpack.common.js\r\nmodule.exports = {\r\n  // ...\r\n  module: {\r\n    rules: [\r\n      // ...\r\n      {\r\n        test: /\\.css$/,\r\n        use: [\r\n          'style-loader',\r\n          'css-loader',\r\n          'postcss-loader'\r\n        ]\r\n      },\r\n      {\r\n        test: /.(scss|sass)$/,\r\n        use: [\r\n          'style-loader',\r\n          {\r\n            loader: require.resolve('css-loader'),\r\n            // 开启css module\r\n            options: {\r\n              modules: {\r\n                localIdentName: '[folder]_[local]_[hash:base64:5]',\r\n              },\r\n            },\r\n          },\r\n          'postcss-loader',\r\n          'sass-loader'\r\n        ]\r\n      },\r\n    ]\r\n  },\r\n}\r\n```\r\n- 修改样式使用形式测试效果\r\n```\r\n// src/app.tsx\r\nimport React from 'react';\r\nimport styles from './app.scss';\r\n\r\nconst App = () => <div className={styles.app}>app</div>;\r\nexport default App;\r\n```\r\n### 抽取css样式文件\r\n> 开发环境我们希望css嵌入在style标签里面方便样式热替换但打包时我们希望把css单独抽离出来，方便配置http缓存策略。\r\n\r\n- 安装依赖\r\n```\r\nnpm i mini-css-extract-plugin -D\r\n```\r\n- 修改webpack.common.js，根据环境变量设置开发环境使用style-loader，打包模式抽离css。\r\n```\r\nconst MiniCssExtractPlugin = require('mini-css-extract-plugin');\r\n\r\nconst isDev = process.env.NODE_ENV === 'development'; // 是否是开发模式\r\n\r\nmodule.exports = {\r\n  // ...\r\n  module: {\r\n    rules: [\r\n      // ...\r\n      {\r\n        test: /\\.css$/,\r\n        use: [\r\n          isDev ? 'style-loader' : MiniCssExtractPlugin.loader, // 开发环境使用style-loader，打包模式抽离css\r\n          'css-loader',\r\n          'postcss-loader'\r\n        ]\r\n      },\r\n      {\r\n        test: /.(scss|sass)$/,\r\n        use: [\r\n          isDev ? 'style-loader' : MiniCssExtractPlugin.loader, // 开发环境使用style-loader，打包模式抽离css\r\n          {\r\n            loader: require.resolve('css-loader'),\r\n            // 开启css module\r\n            options: {\r\n              modules: {\r\n                localIdentName: '[folder]_[local]_[hash:base64:5]',\r\n              },\r\n            },\r\n          },\r\n          'postcss-loader',\r\n          'sass-loader'\r\n        ]\r\n      },\r\n    ]\r\n  },\r\n}\r\n```\r\n- 修改webpack.prod.js, 打包时添加抽离css插件\r\n```\r\nconst { merge } = require('webpack-merge');\r\nconst MiniCssExtractPlugin = require('mini-css-extract-plugin');\r\nconst commonConfig = require('./webpack.common.js');\r\n\r\nmodule.exports = merge(commonConfig, {\r\n  mode: 'production', // 生产模式\r\n  plugins: [\r\n    // 抽离css插件\r\n    new MiniCssExtractPlugin({\r\n      filename: 'static/css/[name].[contenthash:8].css' // 抽离css的输出目录和名称\r\n    }),\r\n  ]\r\n})\r\n```\r\n### 压缩css文件\r\n- 安装依赖\r\n```\r\nnpm i css-minimizer-webpack-plugin -D\r\n```\r\n- 修改webpack.prod.js配置\r\n```\r\nconst { merge } = require('webpack-merge');\r\nconst CssMinimizerWebpackPlugin = require('css-minimizer-webpack-plugin');\r\nconst commonConfig = require('./webpack.common.js');\r\n\r\nmodule.exports = merge(commonConfig, {\r\n  mode: 'production', // 生产模式\r\n  // ...\r\n  optimization: {\r\n    minimizer: [\r\n      new CssMinimizerWebpackPlugin(), // 压缩css\r\n    ],\r\n  },\r\n})\r\n```\r\n### 处理图片文件\r\n- webpack4使用file-loader和url-loader来处理图片文件，webpack5使用自带的asset-module来处理。\r\n```\r\n// webpack.common.js\r\nmodule.exports = {\r\n  module: {\r\n    rules: [\r\n      // ...\r\n      {\r\n        test: /.(png|jpg|jpeg|gif|svg)$/, // 匹配图片文件\r\n        type: \"asset\", // type选择asset\r\n        parser: {\r\n          dataUrlCondition: {\r\n            maxSize: 10 * 1024, // 小于10kb转base64位\r\n          }\r\n        },\r\n        generator:{ \r\n          filename: 'static/images/[name].[contenthash:8][ext]', // 文件输出目录和命名\r\n        },\r\n      },\r\n    ]\r\n  }\r\n}\r\n```\r\n- 添加图片引用测试效果\r\n```\r\n// src/app.tsx\r\nimport React from 'react';\r\nimport smallImg from './assets/4kb.png';\r\nimport bigImg from './assets/20kb.png';\r\nimport styles from './app.scss';\r\n\r\nconst App = () => (\r\n  <div className={styles.app}>\r\n    <img src={smallImg} />\r\n    <img src={bigImg} />\r\n    app\r\n  </div>\r\n);\r\nexport default App;\r\n```\r\n- global.d.ts文件中添加图片类型声明\r\n```\r\ndeclare module '*.png';\r\n```\r\n### 处理字体和媒体文件\r\n> 字体文件和媒体文件处理方式和处理图片一样，调整匹配的路径和打包后放置的路径即可。\r\n\r\n```\r\n// webpack.common.js\r\nmodule.exports = {\r\n  module: {\r\n    rules: [\r\n      // ...\r\n      {\r\n        test: /.(woff2?|eot|ttf|otf)$/, // 匹配字体图标文件\r\n        type: \"asset\", // type选择asset\r\n        parser: {\r\n          dataUrlCondition: {\r\n            maxSize: 10 * 1024, // 小于10kb转base64位\r\n          }\r\n        },\r\n        generator: {\r\n          filename: 'static/fonts/[name].[contenthash:8][ext]', // 文件输出目录和命名\r\n        },\r\n      },\r\n      {\r\n        test: /.(mp4|webm|ogg|mp3|wav|flac|aac)$/, // 匹配媒体文件\r\n        type: \"asset\", // type选择asset\r\n        parser: {\r\n          dataUrlCondition: {\r\n            maxSize: 10 * 1024, // 小于10kb转base64位\r\n          }\r\n        },\r\n        generator: {\r\n          filename: 'static/media/[name].[contenthash:8][ext]', // 文件输出目录和命名\r\n        },\r\n      },\r\n    ]\r\n  }\r\n}\r\n```\r\n### react模块热更新\r\n- 模块热更新在webpack5中只要设置devServer.hot为true即可。在webpack4中还需要在插件中添加HotModuleReplacementPlugin，webpack5已经内置该插件。\r\n- 开发模式下修改css和less文件，页面样式可以在不刷新浏览器的情况实时生效，因为此时样式都在style标签里面，style-loader做了替换样式的热更新功能。\r\n- 修改react相关代码，浏览器会自动刷新后再显示修改后的内容，我们期望的是在不需要刷新浏览器的前提下模块热更新，并且能够保留react组件的状态。\r\n- 借助@pmmmwh/react-refresh-webpack-plugin插件来实现，该插件依赖于react-refresh。\r\n- 安装依赖\r\n```\r\nnpm i @pmmmwh/react-refresh-webpack-plugin react-refresh -D\r\n```\r\n- 修改webpack.dev.js配置\r\n```\r\nconst { merge } = require('webpack-merge');\r\nconst ReactRefreshWebpackPlugin = require('@pmmmwh/react-refresh-webpack-plugin');\r\nconst commonConfig = require('./webpack.common.js');\r\n\r\nmodule.exports = merge(commonConfig, {\r\n  // ...\r\n  plugins: [\r\n    new ReactRefreshWebpackPlugin(), // 添加热更新插件\r\n  ]\r\n})\r\n```\r\n- babel-loader配置react-refesh刷新插件，修改babel.config.js文件\r\n```\r\nconst isDEV = process.env.NODE_ENV === 'development'; // 是否是开发模式\r\n\r\nmodule.exports = {\r\n  // ...\r\n  \"plugins\": [\r\n    // ...\r\n    isDEV && require.resolve('react-refresh/babel'), // 如果是开发模式，就启动react热更新插件\r\n  ].filter(Boolean) // 过滤空值\r\n}\r\n```\r\n### 开启持久化存储缓存\r\n- 在webpack5之前做缓存是使用babel-loader缓存js的解析结果，cache-loader缓存css等资源的解析结果，还有模块缓存插件hard-source-webpack-plugin，配置好缓存后第二次打包通过对文件做哈希对比来验证文件前后是否一致，如果一致则采用上一次的缓存，可以极大地节省时间。\r\n- webpack5较于webpack4，新增了持久化缓存、改进缓存算法等。通过配置webpack持久化缓存来缓存生成的webpack模块和chunk，改善下一次打包的构建速度可提速 90%左右，配置也更为简单。\r\n- 修改webpack.common.js配置\r\n```\r\nmodule.exports = {\r\n  // ...\r\n  cache: {\r\n    type: 'filesystem', // 使用文件缓存\r\n  },\r\n}\r\n```\r\n### 配置alias别名\r\n> 设置别名可以让后续引用的地方减少路径的复杂度。如下配置在项目中使用@/xxx.xx就会指向src/xxx.xx，在js/ts和css文件中都可以用。\r\n\r\n- 修改webpack.common.js配置\r\n```\r\nconst path = require('path');\r\n\r\nmodule.export = {\r\n  // ...\r\n   resolve: {\r\n    // ...\r\n    alias: {\r\n      '@': path.resolve(__dirname, '../src')\r\n    }\r\n  }\r\n}\r\n```\r\n- 修改tsconfig.json，添加baseUrl和paths\r\n```\r\n{\r\n  \"compilerOptions\": {\r\n    // ...\r\n    \"baseUrl\": \".\",\r\n    \"paths\": {\r\n      \"@/*\": [\"src/*\"]\r\n    }\r\n  }\r\n}\r\n```\r\n- 修改引用形式测试效果\r\n```\r\n// src/app.tsx\r\nimport React from 'react';\r\nimport smallImg from '@/assets/4kb.png';\r\nimport bigImg from '@/assets/20kb.png';\r\nimport styles from './app.scss';\r\n\r\nconst App = () => (\r\n  <div className={styles.app}>\r\n    <img src={smallImg} />\r\n    <img src={bigImg} />\r\n    app\r\n  </div>\r\n);\r\nexport default App;\r\n```\r\n### 代码分割第三方包和公共模块\r\n- 一般第三方包的代码变化频率比较小，可以单独把node_modules中的代码单独打包，可以有效利用http缓存。\r\n- 公共的模块也可以提取出来，避免重复打包加大代码整体体积。\r\n- 修改webpack.prod.js配置\r\n```\r\nmodule.exports = {\r\n  // ...\r\n  optimization: {\r\n    // ...\r\n    splitChunks: { // 代码分割\r\n      cacheGroups: {\r\n        vendors: { // 提取node_modules代码\r\n          test: /node_modules/, // 只匹配node_modules里面的模块\r\n          name: 'vendors', // 提取文件命名为vendors，js后缀和chunkhash会自动加\r\n          minChunks: 1, // 只要使用一次就提取出来\r\n          chunks: 'initial', // 只提取初始化就能获取到的模块，不管异步的\r\n          minSize: 0, // 提取代码体积大于0就提取出来\r\n          priority: 1, // 提取优先级为1\r\n        },\r\n        commons: { // 提取页面公共代码\r\n          name: 'commons', // 提取文件命名为commons\r\n          minChunks: 2, // 只要使用两次就提取出来\r\n          chunks: 'initial', // 只提取初始化就能获取到的模块，不管异步的\r\n          minSize: 0, // 提取代码体积大于0就提取出来\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n### 压缩js文件\r\n- 设置mode为production后webpack会使用内置插件terser-webpack-plugin压缩js文件，该插件默认支持多线程压缩。\r\n- 但配置optimization.minimizer压缩css后js压缩就失效了，需要手动再添加一下。webpack内部安装了该插件，如果使用的pnpm需要手动再安装一下依赖。\r\n- 压缩css的插件可以设置在plugins中避免js压缩失效的问题。\r\n- 修改webpack.prod.js配置\r\n```\r\nconst { merge } = require('webpack-merge');\r\nconst TerserPlugin = require('terser-webpack-plugin');\r\nconst commonConfig = require('./webpack.common.js');\r\n\r\nmodule.exports = merge(commonConfig, {\r\n  mode: 'production', // 生产模式\r\n  // ...\r\n  optimization: {\r\n    // ...\r\n    minimizer: [\r\n      // ...\r\n      new TerserPlugin({ // 压缩js\r\n        parallel: true, // 开启多线程压缩\r\n        terserOptions: {\r\n          compress: {\r\n            pure_funcs: [\"console.log\"] // 删除console.log\r\n          }\r\n        }\r\n      }),\r\n    ],\r\n  },\r\n})\r\n```\r\n### 开启gzip压缩\r\n- 前端代码在浏览器运行需要从服务器把html、css、js资源下载执行，下载的资源体积越小页面加载速度就会越快。一般会采用gzip压缩，现在大部分浏览器和服务器都支持gzip，可以有效减少静态资源文件大小，压缩率在 70% 左右。\r\n- nginx可以配置gzip: on来开启压缩，但是只在nginx层面开启会在每次请求资源时都对资源进行压缩，压缩文件会需要时间和占用服务器cpu资源，更好的方式是前端在打包的时候直接生成gzip资源，服务器接收到请求直接把对应压缩好的gzip文件返回给浏览器节省时间和cpu。\r\n- 安装依赖\r\n```\r\nnpm i compression-webpack-plugin -D\r\n```\r\n- 修改webpack.prod.js配置\r\n```\r\nconst { merge } = require('webpack-merge');\r\nconst CompressionPlugin  = require('compression-webpack-plugin');\r\nconst commonConfig = require('./webpack.common.js');\r\n\r\nmodule.exports = merge(commonConfig, {\r\n  mode: 'production', // 生产模式\r\n  // ...\r\n  plugins: [\r\n    // ...\r\n    new CompressionPlugin({\r\n      test: /.(js|css)$/, // 只生成css,js压缩文件\r\n      algorithm: 'gzip', // 压缩格式，默认是gzip\r\n      threshold: 10240, // 只有大小大于该值的资源会被处理。默认值是10k\r\n      minRatio: 0.8 // 压缩率，默认值是0.8\r\n    })\r\n  ]\r\n})\r\n```\r\n### 复制public下内容到构建出口文件夹中\r\n- 安装依赖\r\n```\r\nnpm i copy-webpack-plugin -D\r\n```\r\n- 修改webpack.prod.js配置\r\n```\r\nconst path = require('path');\r\nconst { merge } = require('webpack-merge');\r\nconst CopyPlugin = require('copy-webpack-plugin');\r\nconst commonConfig = require('./webpack.common.js');\r\n\r\nmodule.exports = merge(commonConfig, {\r\n  mode: 'production', // 生产模式\r\n  plugins: [\r\n    // 复制文件插件\r\n    new CopyPlugin({\r\n      patterns: [\r\n        {\r\n          from: path.resolve(__dirname, '../public'), // 复制public下文件\r\n          to: path.resolve(__dirname, '../build'), // 复制到build目录中\r\n          filter: source => {\r\n            return !source.includes('index.html') // 忽略index.html，html-webpack-plugin已处理\r\n          }\r\n        },\r\n      ],\r\n    }),\r\n  ]\r\n})\r\n```\r\n### 添加打包分析配置\r\n- 安装依赖\r\n```\r\nnpm i speed-measure-webpack-plugin webpack-bundle-analyzer -D\r\n```\r\n- webpack配置\r\n```\r\n// webpack.analysis.js\r\nconst { merge } = require('webpack-merge');\r\nconst SpeedMeasurePlugin = require('speed-measure-webpack-plugin');\r\nconst { BundleAnalyzerPlugin } = require('webpack-bundle-analyzer');\r\nconst prodConfig = require('./webpack.prod.js');\r\nconst smp = new SpeedMeasurePlugin();\r\n\r\nmodule.exports = smp.wrap(merge(prodConfig, {\r\n  plugins: [\r\n    new BundleAnalyzerPlugin() // 配置分析打包结果插件\r\n  ]\r\n}))\r\n```\r\n- package.json添加scripts脚本\r\n```\r\n\"scripts\": {\r\n  // ...\r\n  \"analysis\": \"cross-env NODE_ENV=production BASE_ENV=development webpack --config config/webpack.analysis.js\",\r\n},\r\n```\r\n### babel处理js非标准语法(以装饰器为例)\r\n- 安装依赖\r\n```\r\nnpm i @babel/plugin-proposal-decorators -D\r\n```\r\n- 开启一下ts装饰器支持，修改tsconfig.json文件\r\n```\r\n{\r\n  \"compilerOptions\": {\r\n    // ...\r\n    // 开启装饰器使用\r\n    \"experimentalDecorators\": true\r\n  }\r\n}\r\n```\r\n- 在babel.config.js中添加插件\r\n```\r\nmodule.exports = { \r\n  // ...\r\n  \"plugins\": [\r\n    // ...\r\n    [\r\n      \"@babel/plugin-proposal-decorators\",\r\n      { \"legacy\": true }\r\n    ]\r\n  ]\r\n}\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## webpack的作用\r\n> webpack是一个用于现代JavaScript应用程序(支持ESM和CommonJS)的静态模块打包工具，可以支持许多不同的静态资源，例如：images, fonts和stylesheets。当 webpack处理应用程序时，它会在内部从一个或多个入口点构建一个依赖图(dependency graph)，然后将你项目中所需的每一个模块组合成一个或多个bundles，它们均为静态资源，用于展示你的内容。\r\n\r\n- Entry：编译入口，webpack编译的起点。\r\n- Compiler：编译管理器，webpack启动后会创建compiler对象，该对象一直存活直到结束退出。\r\n- Compilation：单次编辑过程的管理器，比如watch=true时，运行过程中只有一个compiler但每次文件变更触发重新编译时，都会创建一个新的 compilation对象。\r\n- Dependence：依赖对象，webpack基于该类型记录模块间依赖关系。\r\n- Module：webpack内部所有资源都会以“module”对象形式存在，所有关于资源的操作、转译、合并都是以“module”为基本单位进行的。\r\n- Chunk：编译完成准备输出时，webpack会将module按特定的规则组织成一个一个的chunk，这些chunk某种程度上跟最终输出一一对应。\r\n- Loader：资源内容转换器，其实就是实现从内容A转换B的转换器。\r\n- Plugin：webpack构建过程中，会在特定的时机广播对应的事件，插件监听这些事件，在特定时间点介入编译过程。\r\n### webpack配置大体框架\r\n```\r\nmodule.exports = {\r\n  // 模式\r\n  mode: 'development',\r\n\r\n  // 入口\r\n  entry: {},\r\n\r\n  // 打包输出\r\n  output: {},\r\n\r\n  // 配置模块如何解析\r\n  resolve: {},\r\n\r\n  // 配置各种loader\r\n  module: {},\r\n\r\n  // 配置插件\r\n  plugins: [],\r\n\r\n  // 优化（可以进行代码分割）\r\n  optimization: {},\r\n\r\n  // webpack-dev-server 开发时的配置，一般用于development模式\r\n  devServer: {}\r\n};\r\n```\r\n### mode\r\n> 告知webpack使用相应模式的内置优化。默认值为production。\r\n\r\n- development开发模式，打包更加快速，省了代码优化步骤。\r\n- production生产模式，打包比较慢，会开启tree-shaking和代码压缩。\r\n- none不使用任何默认优化选项。\r\n```\r\nmodule.exports = {\r\n  mode: 'development',\r\n};\r\n\r\n// 打包命令中传递参数\r\nwebpack --mode=development\r\n```\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## 构建体积优化\r\n### webpack包分析工具\r\n> 运行打包命令，打开的页面会显示各个模块资源的大小。\r\n\r\n- 安装依赖\r\n```\r\nnpm install webpack-bundle-analyzer -D\r\n```\r\n- 添加配置\r\n```\r\n// webpack.prod.js\r\nconst { BundleAnalyzerPlugin } = require('webpack-bundle-analyzer');\r\n\r\nplugins: [\r\n  new BundleAnalyzerPlugin({\r\n    analyzerMode: 'server',\r\n    analyzerHost: '127.0.0.1',\r\n    analyzerPort: 8888,\r\n    reportFilename: 'report.html',\r\n    defaultSizes: 'parsed',\r\n    openAnalyzer: true,\r\n    generateStatsFile: false,\r\n    statsFilename: 'stats.json',\r\n    logLevel: 'info'\r\n  })\r\n]\r\n```\r\n### 抽取css样式文件\r\n- 安装依赖\r\n```\r\nnpm install -D mini-css-extract-plugin\r\n```\r\n- 将module.rules中所有 style-loader 替换为该插件提供的loader：MiniCssExtractPlugin.loader。\r\n```\r\n// webpack.common.js\r\nconst MiniCssExtractPlugin = require(\"mini-css-extract-plugin\")\r\n\r\n// 定义通用的 postcss-loader 配置\r\nconst commonPostcssLoader = {\r\n  loader: 'postcss-loader',\r\n  options: {\r\n    postcssOptions: {\r\n      plugins: [\r\n        'postcss-preset-env'\r\n      ]\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = {\r\n  // ...\r\n  module: {\r\n    rules: [\r\n      // ...\r\n      {\r\n        test: /\\.css$/,\r\n        use: [MiniCssExtractPlugin.loader, 'css-loader', commonPostcssLoader]\r\n      },\r\n      {\r\n        test: /.(scss|sass)$/,\r\n        use: [\r\n          MiniCssExtractPlugin.loader,\r\n          'css-loader',\r\n          commonPostcssLoader,\r\n          'sass-loader'\r\n        ]\r\n      },\r\n    ]\r\n  },\r\n}\r\n```\r\n- 在 plugins 中添加该插件。\r\n> 开发环境和生产环境区分独立打包的文件名，防止开发环境修改样式文件热更新失败的问题。\r\n\r\n```\r\n// webpack.prod.js\r\nconst MiniCssExtractPlugin = require(\"mini-css-extract-plugin\")\r\n\r\nmodule.exports = {\r\n  mode: 'production',\r\n  plugins: [\r\n    // 将css独立打包\r\n    new MiniCssExtractPlugin({\r\n      filename: 'static/css/[name].[contenthash:8].css',\r\n    }),\r\n  ]\r\n}\r\n\r\n// webpack.dev.js\r\nconst MiniCssExtractPlugin = require(\"mini-css-extract-plugin\")\r\n\r\nmodule.exports = {\r\n  mode: 'development',\r\n  plugins: [\r\n    // 将css独立打包\r\n    new MiniCssExtractPlugin({\r\n      filename: 'static/css/[name].css',\r\n    }),\r\n  ]\r\n}\r\n```\r\n### 压缩css文件\r\n- 安装依赖\r\n```\r\nnpm install -D css-minimizer-webpack-plugin\r\n```\r\n- 添加配置\r\n```\r\n// webpack.prod.js\r\nconst CssMinimizerWebpackPlugin = require('css-minimizer-webpack-plugin')\r\n\r\n// 直接在plugins中使用插件\r\nmodule.exports = {\r\n  // ...\r\n  plugins: [\r\n    // ...\r\n    new CssMinimizerWebpackPlugin(), // 压缩css\r\n  ]\r\n}\r\n\r\n// 在optimization.minimizer中使用插件\r\nmodule.exports = {\r\n  // ...\r\n  optimization: {\r\n    minimizer: [\r\n      new CssMinimizerWebpackPlugin(), // 压缩css\r\n    ],\r\n  },\r\n}\r\n```\r\n### JS代码压缩\r\n> 设置mode为production时，webpack会使用内置插件terser-webpack-plugin压缩js文件，该插件默认支持多线程压缩，但是在optimization.minimizer中配置压缩css后，js压缩就失效了需要手动再添加一下。\r\n\r\n- 自定义TerserPlugin配置\r\n```\r\n// webpack.prod.js\r\nconst TerserPlugin = require('terser-webpack-plugin');\r\n\r\nmodule.exports = {\r\n  // ...\r\n  optimization: {\r\n    minimizer: [\r\n      new TerserPlugin({ // 压缩js\r\n        parallel: true, // 开启多线程压缩\r\n        terserOptions: {\r\n          compress: {\r\n            pure_funcs: [\"console.log\"] // 删除console.log\r\n          }\r\n        }\r\n      }),\r\n      new CssMinimizerPlugin(),\r\n    ],\r\n  },\r\n}\r\n```\r\n- 在webpack5中可以使用 `...` 语法来扩展现有的minimizer即terser-webpack-plugin。\r\n```\r\n// webpack.prod.js\r\nconst TerserPlugin = require('terser-webpack-plugin');\r\n\r\nmodule.exports = {\r\n  // ...\r\n  optimization: {\r\n    minimizer: [\r\n      `...`,\r\n      new CssMinimizerPlugin(),\r\n    ],\r\n  },\r\n}\r\n```\r\n### gzip压缩\r\n- 安装依赖\r\n```\r\nnpm i compression-webpack-plugin -D\r\n```\r\n- 添加配置\r\n```\r\n// webpack.prod.js\r\nconst CompressionPlugin = require('compression-webpack-plugin');\r\n\r\nnew CompressionPlugin({\r\n  test: new RegExp('\\\\.(js|css)$'),\r\n  algorithm: 'gzip',\r\n  threshold: 10240,\r\n  minRatio: 0.8\r\n}),\r\n```\r\n### 代码分割第三方包和公共模块\r\n> 一般第三方包的代码变化频率比较小，可以单独把node_modules中的代码单独打包，当第三包代码没变化时对应的文件名也不会变化，可以有效利用浏览器缓存，还有公共的模块也可以提取出来，避免重复打包加大代码整体体积。\r\n\r\n```\r\n// webpack.prod.js\r\nmodule.exports = {\r\n  // ...\r\n  optimization: {\r\n    // ...\r\n    splitChunks: { // 分隔代码\r\n      cacheGroups: {\r\n        vendors: { // 提取node_modules代码\r\n          test: /node_modules/, // 只匹配node_modules里面的模块\r\n          name: 'vendors', // 提取文件命名为vendors,js后缀和chunkhash会自动加\r\n          minChunks: 1, // 只要使用一次就提取出来\r\n          chunks: 'initial', // 只提取初始化就能获取到的模块,不管异步的\r\n          minSize: 0, // 提取代码体积大于0就提取出来\r\n          priority: 1, // 提取优先级为1\r\n        },\r\n        commons: { // 提取页面公共代码\r\n          name: 'commons', // 提取文件命名为commons\r\n          minChunks: 2, // 只要使用两次就提取出来\r\n          chunks: 'initial', // 只提取初始化就能获取到的模块,不管异步的\r\n          minSize: 0, // 提取代码体积大于0就提取出来\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n### 资源懒加载\r\n> 单页应用打包默认会打包到一个js文件中，虽然使用代码分割可以把node_modules模块和公共模块分离，但页面初始加载还是会把整个项目的代码下载下来，其实只需要公共资源和当前页面的资源就可以了，其他页面资源可以等使用到的时候再加载，以有效提升首屏加载速度。使用import语法来引入资源，webpack打包的时候就会自动打包为单独的资源文件，等使用到的时候动态加载。\r\n\r\n#### 动态引入模块\r\n- 例如导出excel只会在用户点击导出按钮的时候使用，我们首先在vendor中将其拆出来。\r\n- 使用时将 import 的逻辑由首屏改到运行时异步加载。\r\n```\r\nconst buttonClick = async() => {\r\n  // 使用时异步引入xlsx模块\r\n  const xlsx = await import('xlsx');\r\n  xlsx.writeFile(wb, filename)\r\n}\r\n```\r\n#### 路由懒加载Suspense + React.lazy\r\n```\r\nconst List = React.lazy(() => import('../list'));\r\nconst Operate = React.lazy(() => import('../operate'));\r\n\r\n<Suspense fallback={<div>loading...</div>}>\r\n  <Switch>\r\n    <Route path=\"/list\" component={List}>\r\n    <Route path=\"/operate\" component={Operate}>\r\n  </Switch>\r\n</Suspense>\r\n```\r\n### externals\r\n> 引用一个库但是又不想让webpack打包，可以通过配置Externals。将这些不需要打包的静态资源从构建逻辑中剔除出去，而使用CDN的方式去引用它们。\r\n\r\n#### 在html中配置的CDN引入脚本一定要在body内的最底部\r\n- 如果放在body上面或header内，则加载会阻塞整个页面渲染。\r\n- 如果放在body外，则会在业务代码被加载之后加载，模块中使用了该模块将会报错。\r\n```\r\n// webpack.common.js\r\nmodule.exports = {\r\n  // ...\r\n  externals: {\r\n    react: 'React'\r\n  }\r\n};\r\n\r\n// 使用\r\nimport React from 'react';\r\n```\r\n### tree-shaking清理未引用js\r\n> 模式mode为production时就会默认开启tree-shaking功能以此来标记未引入代码然后移除掉。\r\n\r\n### 合理配置hash\r\n> 改过的文件需要更新hash值，而没改过的文件依然保持原本的hash值，这样浏览器访问没有改变的文件会命中缓存，从而达到性能优化的目的。\r\n\r\n```\r\noutput: {\r\n  publicPath: '/',\r\n  path: path.resolve(__dirname, '../build'),\r\n  filename: 'static/js/[name].[contenthash:8].js',\r\n  // 每一次打包清除上一次打包内容\r\n  clean: true,\r\n},\r\n```\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## 构建时间优化\r\n### Speed Measure Plugin (SMP)\r\n> 对打包过程中消耗的时间进行精确的统计，能够测量出在你的构建过程中，每一个 Loader 和 Plugin 的执行时长，在启动本地服务的命令行中显示。\r\n\r\n```\r\n// 安装\r\nnpm install --save-dev speed-measure-webpack-plugin\r\n\r\n// 使用方式\r\nconst SpeedMeasurePlugin = require(\"speed-measure-webpack-plugin\");\r\nconst smp = new SpeedMeasurePlugin();\r\nconfig.plugins.push(smp());\r\n```\r\n### 构建速度慢的原因\r\n> 构建过程中的大部分时间都消耗在编译JavaScript文件及CSS文件的各类Loader上。Webpack的构建流程主要时间花费在递归遍历各个入口文件，并基于入口文件不断寻找依赖逐个编译再递归处理的过程，每次递归都需要经历 String -> AST -> String 的流程，然后通过不同的loader处理一些字符串或者执行一些JavaScript脚本，由于NodeJS单线程的特性以及语言本身的效率限制，所以webpack的构建会较慢。\r\n\r\n### 构建慢的优化方向\r\n- 缓存\r\n- 多进程\r\n- 寻址优化\r\n- 抽离拆分\r\n- 构建工具替换\r\n### cache-loader (缓存层面优化，缓存资源，提高二次构建的速度)\r\n> 打包时间的大部分都在npm install和各种loader的执行上，可以在loader之前加上cache-loader，这样这个loader执行过一次后的数据会缓存在node_modules/.cache目录下，下次再打包就会利用缓存。在一些性能开销较大的loader之前添加 cache-loader，只有执行时间很长的loader才适合用缓存，因为读写文件也是有开销的，滥用反而会导致变慢。\r\n- webpack4\r\n```\r\n{\r\n  test: /\\.js$/,\r\n  use: [\r\n    'cache-loader',\r\n    'thread-loader',\r\n    'babel-loader'\r\n  ],\r\n}\r\n```\r\n- webpack5\r\n```\r\ncache: {\r\n  type: 'filesystem'\r\n},\r\n```\r\n### hard-source-webpack-plugin (缓存层面优化)\r\n> HardSourceWebpackPlugin 为模块提供中间缓存，缓存默认存放的路径是 node_modules/.cache/hard-source，配置了 HardSourceWebpackPlugin 之后，首次构建时间并没有太大的变化，但是第二次开始，构建时间将会大大的加快。webpack5会把hard-source-webpack-plugin内置成一个配置。\r\n\r\n```\r\nconst HardSourceWebpackPlugin = require('hard-source-webpack-plugin');\r\nplugins: [\r\n  new HardSourceWebpackPlugin({\r\n    cachePrune: {\r\n      maxAge: 2 * 24 * 60 * 60 * 1000, // 设置缓存文件过期时间为2天\r\n      sizeThreshold: 500 * 1024 * 1024, // 总缓存文件大于500M时才会自动删除过时的缓存文件\r\n    },\r\n  }),\r\n]\r\n```\r\n### 设置 babel-loader 的 cacheDirectory 以及 DLL (缓存层面优化)\r\n> 效果不明显。\r\n\r\n### thread-loader (多进程层面优化)\r\n> 把 thread-loader 放置在其它 loader 之前(cache-loader除外)，那么放置在这个 loader 之后的 loader 就会在一个单独的 worker 池中运行。这样做的好处是把原本需要串行执行的任务并行执行。\r\n\r\n```\r\n{\r\n  test: /\\.js$/,\r\n  use: [\r\n    'thread-loader',\r\n    'babel-loader'\r\n  ],\r\n}\r\n```\r\n### 合理设置loader的exclude和include属性 (寻址层面优化)\r\n> 通过配置loader的exclude选项，告诉对应的loader可以忽略某个目录，通过配置loader的include选项，告诉loader只需要处理指定的目录，loader处理的文件越少，执行速度就会更快。\r\n\r\n```\r\n{\r\n  test: /\\.js$/,\r\n  // 使用include来指定编译文件夹\r\n  include: path.resolve(__dirname, '../src'),\r\n  // 使用exclude排除指定文件夹\r\n  exclude: /node_modules/,\r\n  use: [\r\n    'babel-loader'\r\n  ]\r\n},\r\n```\r\n### 开启热更新\r\n> 修改了项目中某一个文件，会导致整个项目刷新，这非常耗时间。如果只刷新修改的这个模块，其他保持原状，将大大提高修改代码的重新构建时间。\r\n\r\n```\r\n// 只用于开发中，所以配置在webpack.dev.js\r\n\r\nconst webpack = require('webpack');\r\nplugins: [\r\n  new webpack.HotModuleReplacementPlugin()\r\n],\r\n\r\n// 最后需要在我们的devserver中配置\r\ndevServer: {\r\n  hot: true\r\n},\r\n```\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## 配置项\r\n### watch\r\n- boolean = false\r\n- 启用Watch模式意味着在初始构建之后，webpack将继续监听任何已解析文件的更改。\r\n- webpack-dev-server和webpack-dev-middleware里Watch模式默认开启。"},function(r,n,e){"use strict";e.r(n),n.default='## [plugin](https://juejin.cn/post/7160467329334607908)\r\n- Webpack Plugin向第三方开发者提供了Webpack引擎中完整的能力。\r\n- 使用阶段式的构建回调，开发者可以在Webpack构建流程中引入自定义的行为，至于在哪个阶段插入或者做什么事情都可以通过Webpack Plugin来完成。\r\n### tapable\r\n- tapable是一个类似于Node.js中的EventEmitter的库，但它更专注于自定义事件的触发和处理。通过tapable可以注册自定义事件，然后在适当的时机去触发执行。\r\n- Webpack本质上是一种事件流的机制，它的工作流程就是将各个插件串联起来，比如：\r\n  - 在打包前需要处理用户传过来的参数，判断是采用单入口还是多入口打包，就是通过EntryOptionPlugin插件来做的。\r\n  - 在打包过程中，需要知道采用哪种读文件的方式就是通过NodeEnvironmentPlugin插件来做的。\r\n  - 在打包完成后，需要先清空dist文件夹，就是通过CleanWebpackPlugin插件来完成的。\r\n- 实现上述机制的核心就是tapable。Webpack内部通过tapable会提前定义好一系列不同阶段的hook，然后在固定的时间点去执行（触发call函数）。而插件要做的就是通过tap函数注册自定义事件，从而让其控制在Webapack事件流上运行。\r\n- tapable通过tap函数注册监听函数，然后通过call函数按顺序执行之前注册的函数。\r\n```\r\nconst { SyncHook } = require("tapable"); // 这是一个同步钩子\r\n\r\n// 第一步：实例化钩子函数，可以在这里定义形参\r\nconst syncHook = new SyncHook(["author"]);\r\n\r\n// 第二步：注册事件1\r\nsyncHook.tap("监听器1", (name) => {\r\n  console.log("监听器1:", name);\r\n});\r\n\r\n// 第二步：注册事件2\r\nsyncHook.tap("监听器2", (name) => {\r\n  console.log("监听器2", name);\r\n});\r\n\r\n// 第三步：触发事件\r\nsyncHook.call("不要秃头啊");\r\n```\r\n### Compiler和Compilation \r\n- compiler对象代表了完整的webpack生命周期。这个对象在启动Webpack时被一次性建立，并配置好所有可操作的设置，包括options，loader和plugin。当在 Webpack环境中应用一个插件时，插件将收到此compiler对象的引用，可以使用它来访问Webpack的主环境。\r\n- compilation对象代表了一次资源版本构建，主要负责对模块资源的处理。当运行Webpack开发环境中间件（webpack-dev-server）时，每当检测到一个文件变化，就会创建一个新的 compilation，从而生成一组新的编译资源。一个compilation对象表现了当前的模块资源、编译生成资源、变化的文件、以及被跟踪依赖的状态信息。compilation对象也提供了很多关键时机的回调，以供插件做自定义处理时选择使用。\r\n- compilation只是compiler中某一阶段的hook，主要负责对模块资源的处理，只不过它的工作更加细化，在它内部还有一些子hook。\r\n![Compiler](./img/complier.png)\r\n- 这么处理是为了解耦，当启动Webpack的watch模式时文件模块发生变化会重新进行编译，这个时候并不需要每次都重新创建compiler实例，只需要重新创建一个compilation来记录编译信息即可。\r\n### 编写plugin\r\n- Webpack Plugin其实就是一个普通的函数，在该函数中需要定制一个apply方法。当Webpack内部进行插件挂载时会执行apply函数。可以在apply方法中订阅各种生命周期钩子，当到达对应的时间点时就会执行。\r\n- 在构建完成后打印日志。\r\n```\r\n// plugins/demo-plugin.js\r\nclass DemoPlugin {\r\n  apply(compiler) {\r\n    // 在done（构建完成后执行）这个hook上注册自定义事件\r\n    compiler.hooks.done.tap("DemoPlugin", () => {\r\n      console.log("DemoPlugin：编译结束了");\r\n    });\r\n  }\r\n}\r\n\r\nmodule.exports = DemoPlugin;\r\n\r\n\r\n// webpack.config.js\r\nconst DemoPlugin = require("./plugins/demo-plugin");\r\n\r\nmodule.exports = {\r\n  mode: "development",\r\n  entry: "./src/index.js",\r\n  devtool: false,\r\n  plugins: [new DemoPlugin()],\r\n};\r\n```'},function(r,n,e){"use strict";e.r(n),n.default="## [异步加载(懒加载)](https://juejin.cn/post/7152516872330543141/)\r\n- 懒加载或者按需加载，是一种很好的优化网页或应用的方式。\r\n- 先把代码在一些逻辑断点处分离开，然后在一些代码块中完成某些操作后再引用另外一些新的代码块。这样加快了应用的初始加载速度，减轻了应用的总体积。\r\n- 懒加载的本质实际上就是代码分离，把代码分离到不同的bundle中，然后按需加载或并行加载这些文件。\r\n### 在Webpack中常用的代码分离方法有三种：\r\n1. 入口起点：使用entry配置手动地分离代码(多入口)。\r\n2. 防止重复：使用SplitChunksPlugin去重和分离chunk。\r\n3. 动态导入：通过模块的动态导入来分离代码。\r\n    1. 使用符合ECMAScript提案的import()语法来实现动态导入。（推荐）\r\n    2. 使用Webpack特定的require.ensure功能实现动态导入。（不推荐）\r\n### import()\r\n- import()的语法十分简单，该函数只接受一个参数，就是引用模块的地址，并且使用promise式的回调获取加载的模块。\r\n- 在代码中所有被import()的模块，都将打成一个单独的模块，放在chunk存储的目录下。在浏览器运行到这一行代码时，就会自动请求这个资源，实现异步加载。\r\n- 常见使用场景：路由懒加载。\r\n### Webpack实现异步加载的原理\r\n1. 通过jsonp的方式去加载异步加载模块所对应的文件。\r\n2. 加载回来后在浏览器中执行此JS脚本，将请求过来的模块定义合并到main.js中的modules中去。\r\n3. 合并完后加载这个模块，返回的是一个export对象。\r\n4. 拿到该模块导出的内容，第三步中导出的是一个export对象，又因为是默认导出，所以使用module.default获取模块导出的内容。\r\n\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## [热更新](https://juejin.cn/post/7176963906844246074)\r\n- 热更新可以在不刷新整个页面的情况下更新页面中的部分内容，从而提高开发效率，优化开发体验。\r\n- 在引入热更新之前，应用的加载、更新都是一种页面级别的操作，即使只有单个代码文件发生变更，都需要刷新整个页面，才能将最新代码映射到浏览器上，这会丢失之前在页面执行过的所有交互与状态。而引入热更新后，虽然无法覆盖所有场景，但大多数小改动都可以通过模块热替换方式更新到页面上，从而确保连续、顺畅的开发调试体验，极大提升开发效率。\r\n### webpack-dev-server\r\n- webpack-dev-server是热更新实现的核心包。\r\n- 当运行webpack serve后，webpack-dev-server会先往客户端代码中添加了两个文件，这两个文件的目的：\r\n  1. websocket相关的代码，用来跟服务端通信。\r\n  2. 客户端接收到最新代码后，更新代码。\r\n- 接着还会启动两个服务：\r\n  1. 一个本地HTTP服务：这个本地服务会给我们提供编译之后的结果，之后浏览器通过端口请求时，就会请求本地服务中编译之后的内容。\r\n  2. 一个websocket双向通信服务器：如果有新的模块发生变化，编译成功会以消息的方式通知客户端，让客户端来请求最新代码，并进行客户端的热更新。\r\n- 然后会以watch模式开始编译，每次编译结束后会生成一个唯一的hash值。\r\n### 首次启动\r\n- 在初次编译完成（启动项目）后，webpack内部会生成一个hash = h1，并将hash = h1通过websocket的方式通知给客户端，客户端上有两个变量lastHash：上一次接收到的hash、currentHash：这一次接收到的hash。\r\n- 如果是第一次接收到hash值，代表是第一次连接，则lastHash = currentHash = hash。\r\n### 二次编译\r\n- 如果源代码发生变化，webpack对源文件重新进行编译，在编译完成后生成hash = h2，并将hash = h2发送给客户端，客户端接收到消息后，修改自身的变量：lastHash = h1，currentHash = h2。\r\n- 接着客户端通过lastHash = h1向服务端请求json数据，目的是为了获得变更的代码块。\r\n- 服务端接收到请求后，将传过来的h1和自身最新的hash = h2进行对比，找出变更的代码块后返回给客户端。\r\n- 客户端在收到响应后，知道了哪些代码块发生了变化，接着会继续通过lastHash = h1向服务端去请求变更代码块中变动的模块代码。\r\n- 服务端接收到请求后，将传过来的h1和自身最新的hash = h2再次进行对比，找出具体变更的模块代码后返回给客户端。\r\n- 最后客户端拿到了变更模块的代码，重新去执行依赖该模块的模块达到更新的目的。\r\n![热更新](./img/热更新.png)\r\n### 为什么客户端会有两个hash值\r\n- 这么设计的用意是服务端不知道现在客户端的hash是多少，比如多窗口的场景连接了多个客户端，所以需要客户端将上一次的hash返回给服务端，服务端通过比较后返回变更的信息。\r\n### 每次文件改变都重新编译，性能跟得上吗\r\n- 为了提升性能，webpack-dev-server使用了memfs库（Webpack官方自己写的），这样每次打包之后的结果并不会进行输出（把文件写入到硬盘上会耗费很长的时间），而是将打包后的文件保留在内存中，以此来提升性能。\r\n### watch模式\r\n- 使用监控模式开始启动webpack编译，在webpack的watch模式下，文件系统中某一个文件发生修改，webpack监听到文件变化，根据配置文件对模块重新编译打包，每次编译都会产生一个唯一的hash值。\r\n### 代码块（chunk）和模块（module）\r\n- chunk就是若干module打成的包，一个chunk包括多个module，一般来说最终会形成一个文件。而module就是一个个代码模块。\r\n\r\n\r\n\r\n\r\n\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## mediaDevices\r\n### avigator.mediaDevices在以下三种情况下可以获取到，否则会获取不到媒体权限navigator.mediaDevices为undefined。\r\n1. 地址为localhost://访问时\r\n2. 地址为https://访问时\r\n3. 以文件路径file:///访问时"},function(r,n,e){"use strict";e.r(n),n.default="## [CSRF](https://juejin.cn/post/6844903689702866952)\r\n- CSRF（Cross-site request forgery）跨站请求伪造，攻击者诱导受害者进入第三方网站，在第三方网站中向被攻击网站发送跨站请求。\r\n- 利用受害者在被攻击网站已经获取的登录凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。\r\n- 请求的哪个网站浏览器就会将需要请求的那个网站对应的Cookie添加到请求头，而不是在哪一个网站下发起的请求就将当前网站对应的Cookie添加到请求头。\r\n### 攻击流程\r\n1. 受害者登录a.com，并保留了登录凭证（Cookie）。\r\n2. 攻击者引诱受害者访问了b.com。\r\n3. b.com向a.com发送了一个请求：a.com/act=xx。浏览器会默认携带a.com的Cookie。\r\n4. a.com接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求。\r\n5. a.com以受害者的名义执行了act=xx。\r\n6. 攻击完成，攻击者在受害者不知情的情况下冒充受害者让a.com执行了自己定义的操作。\r\n### 攻击案例\r\n> 登录银行系统之后点进钓鱼网站，在钓鱼网站中点击按钮请求了银行系统转账的支付接口，因为在钓鱼网站中发起的支付请求携带了银行系统登录后的登录凭证（Cookie），所以能正常调用成功支付接口。\r\n\r\n1. 登录邮件系统后点击邮件中的钓鱼邮件，点击后跳转到一个空白页面。\r\n2. 空白页面中有隐藏逻辑，向邮件系统发送一个请求设置(默认会携带已经登录邮件系统的登录凭证（Cookie）)，将所有的邮件默认转发到攻击者设置的一个邮箱地址。\r\n3. 通过攻击者设置的邮箱地址获取到转发邮件的邮件信息进行信息窃取操作。\r\n### 攻击形式\r\n- GET类型的CSRF：通过img标签向被攻击网站发送包含受害者登录信息的跨域请求。\r\n- POST类型的CSRF：通过自动提交的表单向被攻击网站发送包含受害者登录信息的跨域请求。\r\n- 链接类型的CSRF：通过用户点击链接向被攻击网站发送包含受害者登录信息的跨域请求。\r\n### 攻击特点\r\n1. 攻击一般发起在第三方网站，而不是被攻击的网站。被攻击的网站无法防止攻击发生。\r\n2. 攻击利用受害者在被攻击网站的登录凭证（Cookie），冒充受害者提交操作，而不是直接窃取数据。\r\n3. 整个过程攻击者并不能获取到受害者的登录凭证，仅仅是“冒用”。\r\n4. 跨站请求可以用各种方式：图片URL、超链接、Form提交等等。部分请求方式可以直接嵌入在第三方论坛、文章中，难以进行追踪。\r\n### CSRF预防\r\n> CSRF的两个特点：通常发生在第三方域名，攻击者不能获取到Cookie等信息只是冒用。针对这两个特点制定对应的预防策略。\r\n\r\n- 阻止不明外域的访问\r\n  1. 同源检测\r\n  2. Samesite Cookie\r\n- 提交时要求附加本域才能获取的信息\r\n  1. CSRF Token\r\n  2. 双重Cookie验证\r\n#### 同源检测\r\n- 在HTTP协议中，每一个异步请求都会携带两个Header，用于标记来源域名：Origin Header，Referer Header。这两个Header在浏览器发起请求时大多数情况会自动带上，并且不能由前端自定义内容。服务器可以通过解析这两个Header中的域名，确定请求的来源域。\r\n- 使用Origin Header确定来源域名（不包含path及query），如果Origin存在那么直接使用Origin中的字段确认来源域名是否合法就可以。\r\n  1. IE11不会在跨站CORS请求上添加Origin标头，Referer头将仍然是唯一的标识。\r\n  2. 在302重定向之后Origin不包含在重定向的请求中，因为Origin可能会被认为是其他来源的敏感信息。对于302重定向的情况来说都是定向到新的服务器上的URL，因此浏览器不想将Origin泄漏到新的服务器上。\r\n- 使用Referer Header确定来源域名，如果Referer存在那么直接使用Referer中的字段确认来源域名是否合法就可以。\r\n  1. 在浏览器环境下Referrer是浏览器自己带上的，js无法修改Rerferrer，所以是不能被伪造和篡改。\r\n  2. 通过网关或者抓包可以修改Referrer，这是中间人攻击不属于CSRF攻击范畴，防中间人攻击用HTTPS。\r\n  3. 黑客通过自己后台代理，请求发到黑客自己的后台，黑客后台修改Referrer再转发到攻击网址的后台，这样可以修改Referrer，但请求发送到黑客自己后台不会带上被攻击网站的Cookie，登录态校验不通过，敏感操作做不了。\r\n- 如果Origin和Referer都不存在，建议直接进行阻止。\r\n#### Samesite Cookie\r\n> 设置Cookie是同站Cookie，不能作为第三方Cookie，不随着跨站请求发送，可以很大程度减少CSRF的攻击。\r\n\r\n- Strict：表明这个Cookie在任何情况下都不能作为第三方Cookie，浏览器完全禁止第三方请求携带此Cookie。\r\n```\r\nSet-Cookie: CookieName=CookieValue; SameSite=Strict;\r\n```\r\n- Lax(默认值)：当改变了当前页面或者打开了新页面且同时是个GET请求时，浏览器允许第三方请求携带此Cookie。\r\n```\r\nSet-Cookie: CookieName=CookieValue; SameSite=Lax;\r\n```\r\n- None：请求会自动携带上Cookie。前提是必须同时设置Secure属性（Cookie只能通过HTTPS协议发送），否则无效。\r\n```\r\nSet-Cookie: CookieName=CookieValue; SameSite=None; Secure\r\n```\r\n#### CSRF Token\r\n- 在本站发起的请求中，加一个攻击者无法获取的Token。\r\n- Token和浏览器自动携带的Cookie不一样，是需要前端手动带上的。在服务端收到请求时，如果没有Token，就可以认为是来自恶意网站。\r\n#### 双重Cookie验证\r\n- 在本站发起的请求中，加一个额外的字段其值和Cookie一致。\r\n- 攻击者没有办法获取到Cookie，只是发起请求时会自动携带。在服务端收到请求时，如果没有和Cookie值一样的额外字段，就可以认为是来自恶意网站。\r\n#### 当前用户打开其它网站链接时告知风险，由用户自己决定是否跳转。\r\n### XSS vs CSRF \r\n- XSS与CSRF最大区别在于对Cookie的使用，XSS把受害者的Cookie偷盗过来，而CSRF则是借用了受害者的Cookie。\r\n\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## React防御XSS\r\n- React防御XSS关键在于jsx的处理上。\r\n- React在它的领域范围内已经尽可能地帮我们防住了XSS攻击。\r\n  1. 使用安全的API修改DOM。\r\n  2. 禁止`<script>`执行。\r\n  3. 特殊字符转义。\r\n- React在客户端和服务端对XSS的防御方式不同。\r\n- 使用dangerouslySetInnerHTML和一些可执行代码的地方，需要提高警惕防止XSS攻击。\r\n### React客户端渲染防御XSS\r\n- jsx实际上是React.createElement的语法糖，React使用.textContent安全的API将props.children作为文本插入html，不会有XSS的问题。\r\n```\r\nconst App = () => {\r\n  const [text] = useState('<img src onerror=\"alert(1)\" />');\r\n\r\n  // 不会有XSS问题，img标签以文本形式展示\r\n  return (\r\n    <div>{text}</div>\r\n  );\r\n}\r\n```\r\n- 通过document.getElementById('input').value = xxx或者.setAttribute()安全的API设置元素属性，不会有XSS的问题。\r\n```\r\nconst App = () => {\r\n  const [text] = useState('\"><img src onerror=\"alert(1)\" />');\r\n\r\n  // 不会有XSS问题\r\n  return (\r\n    <input type=\"text\" value={text} />\r\n  );\r\n}\r\n```\r\n- jsx里加入`<script>`既不会执行，也不会显示。\r\n  1. React通过.innerHTML的方式插入`<script>`使得`<script>`不可执行。\r\n  2. 使用dangerouslySetInnerHTML属性插入`<script>`也不会执行，不会显示，因为dangerouslySetInnerHTML底层也是调用.innerHTML。\r\n```\r\nconst App = () => {\r\n  // 不会有XSS问题，也不会显示\r\n  return (\r\n    <div>\r\n      <script>alert(1)<\/script>\r\n    </div>\r\n  );\r\n}\r\n```\r\n### React服务端渲染防御XSS\r\n- 转义特殊字符：React对元素属性和内容中的5种特殊字符进行转义。\r\n### dangerouslySetInnerHTML\r\n- 在一些场景下我们需要直接往页面插入html代码，React提供dangerouslySetInnerHTML属性来实现这个功能，这有可能造成XSS攻击。\r\n```\r\nconst App = () => {\r\n  // 会有XSS问题\r\n  return (\r\n    <div dangerouslySetInnerHTML={{__html: '<img src onerror=\"alert(1)\" />'}} />\r\n  );\r\n}\r\n```\r\n### 字符串可以作为代码运行的地方\r\n- 不安全的字符串作为代码运行时有可能造成XSS攻击。\r\n```\r\nconst App = () => {\r\n  const [href] = useState('javascript:alert(1)');\r\n\r\n  // 会有XSS问题\r\n  return (\r\n    <a href={href}>跳转</a>\r\n  );\r\n}\r\n```\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## SQL注入\r\n- 通过SQL注入可以访问或修改数据库数据，或者利用潜在的数据库漏洞进行攻击。\r\n### SQL注入示例\r\n1. 登录页面服务端的SQL为`SELECT * FROM user WHERE username='${username}' AND password='${password}'`\r\n2. 如果有一个恶意攻击者输入的用户名为`admin' --`，密码随意输入，就可以直接登入系统了。\r\n3. 恶意攻击者用奇怪用户名将服务端的SQL语句变成了`SELECT * FROM user WHERE username='admin' --' AND password='xxxx'`\r\n4. 在SQL中`--`是注释后面的内容的意思，所以查询语句就变成了`SELECT * FROM user WHERE username='admin'`\r\n### SQL注入的必备条件\r\n1. 攻击者可以控制输入的数据。\r\n2. 服务器要执行的SQL语句拼接了攻击者输入的数据。\r\n### SQL注入的危害\r\n1. 获取数据库信息\r\n2. 获取服务器权限\r\n3. 读取服务器敏感文件\r\n### SQL注入的预防\r\n- 使用参数化查询或存储过程，这种方法会将输入值作为参数传递到查询中，而不是直接将其与SQL语句连接起来。这样可以有效地避免SQL注入漏洞。\r\n- 对特殊字符进行转义，在构造SQL语句时，需要确保任何包含特殊字符的输入都被正确转义。常见的特殊字符包括单引号、双引号、分号等。通过使用合适的转义函数或工具可以确保输入值得到正确处理。\r\n- 最小化数据库操作权限，只给予应用程序必要的数据库操作权限，避免使用超级管理员身份登录数据库。这样可以大大减少潜在的攻击面。\r\n"},function(r,n,e){"use strict";e.r(n),n.default='## [XSS](https://juejin.cn/post/6844903685122703367)\r\n- Cross-Site Scripting（跨站脚本攻击）简称XSS，是一种代码注入攻击。\r\n- 攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。利用这些恶意脚本，攻击者可获取用户的敏感信息如Cookie等，进而危害数据安全。\r\n- XSS的本质是恶意代码未经过滤与网站正常的代码混在一起，浏览器无法分辨哪些脚本是可信的，导致恶意脚本被执行。\r\n### XSS的危害\r\n1. 窃取Cookie。\r\n2. 监听用户行为，比如输入账号密码后直接发送到黑客服务器。\r\n3. 修改DOM伪造登录表单。\r\n4. 在页面中生成浮窗广告。\r\n### 注入恶意脚本的方法\r\n- 来自用户的UGC信息\r\n- URL参数\r\n- POST参数\r\n### 存储型XSS\r\n- 常见于带有用户保存数据功能的网站，如论坛发帖、商品评论、用户私信等。\r\n#### 攻击流程\r\n1. 攻击者通过前端页面将恶意代码提交到目标网站的数据库中。\r\n2. 用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在HTML中返回给浏览器。\r\n3. 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。\r\n4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。\r\n### 反射型XSS\r\n- 存储型XSS的恶意代码存在数据库里，反射型XSS的恶意代码存在URL里。\r\n- 反射型XSS漏洞常见于通过URL传递参数的功能，如网站搜索、跳转等。\r\n- 一般是通过给别人发送带有恶意代码参数的URL，当URL地址被打开时，特有的恶意代码参数被解析、执行。\r\n#### 攻击流程\r\n1. 攻击者构造出特殊的URL，其中包含恶意代码。\r\n2. 用户打开带有恶意代码的URL时，网站服务端将恶意代码从URL中取出，拼接在HTML中返回给浏览器。\r\n3. 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。\r\n4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。\r\n### DOM型XSS\r\n- DOM型XSS攻击中取出和执行恶意代码都由浏览器端完成，属于前端自身的安全漏洞，而其它两种XSS都属于服务端的安全漏洞。\r\n#### 攻击流程\r\n1. 攻击者构造出特殊的URL，其中包含恶意代码。\r\n2. 用户打开带有恶意代码的URL。\r\n3. 用户浏览器接收到响应后解析执行，前端JavaScript取出URL中的恶意代码并执行。\r\n4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。\r\n### XSS攻击的两大要素\r\n1. 攻击者提交恶意代码。\r\n2. 浏览器执行恶意代码。\r\n### XSS的预防\r\n#### 输入侧过滤\r\n- 用户提交时由前端过滤输入然后提交到后端的过滤方式是不可行的，攻击者绕过前端过滤直接构造请求，就可以提交恶意代码了。\r\n- 后端在写入数据库前对输入内容进行过滤然后存储，返回给前端的内容是过滤后的内容是不可行的，因为可能会出现特殊符号转义存储之后前端显示乱码的问题。\r\n- 输入侧过滤能够在某些情况下解决特定的XSS问题，但会引入很多不确定性和乱码问题。在防范XSS攻击时应避免此类方法。\r\n#### 防止浏览器执行恶意代码\r\n- 防止HTML中出现注入。\r\n- 防止JavaScript执行恶意代码。\r\n#### 预防存储型和反射型XSS攻击\r\n> 存储型和反射型XSS都是在服务端取出恶意代码后，插入到响应的HTML里的，攻击者编写的恶意代码被内嵌到HTML中，被浏览器所执行。预防这两种漏洞常见做法如下。\r\n\r\n- 改成纯前端渲染（CSR），把代码和数据分隔开。\r\n- 对HTML做充分转义（使用完善的转义库）。\r\n#### 预防DOM型XSS攻击\r\n> DOM型XSS攻击，实际上是网站前端JavaScript代码本身不够严谨，把攻击者注入的恶意代码执行了。\r\n\r\n- 在使用innerHTML、outerHTML、document.write()时要特别小心，不要把不可信的数据作为HTML插到页面上，应使用textContent、.setAttribute()等安全的API修改DOM。\r\n- 如果用Vue/React技术栈，不使用v-html/dangerouslySetInnerHTML功能，在前端render阶段避免innerHTML、outerHTML的XSS隐患。\r\n- DOM中的内联事件监听器，如location、onclick、onerror、onload、onmouseover等，`<a>`标签的href属性，JavaScript的eval()、setTimeout()、setInterval()等都能把字符串作为代码运行。如果不可信的数据拼接到字符串中传递给这些API，很容易产生安全隐患，应避免此类操作。\r\n#### HttpOnly Cookie\r\n- 禁止JavaScript读取某些敏感Cookie，攻击者完成XSS注入后也无法窃取此Cookie。\r\n\r\n```\r\ndocument.cookie = "cookieName=cookieValue; path=/; HttpOnly";\r\n```\r\n#### 输入内容长度控制\r\n- 对于不受信任的输入，都应该限定一个合理的长度。虽然无法完全防止XSS发生，但可以增加XSS攻击的难度。\r\n#### 验证码\r\n- 防止脚本冒充用户提交危险操作。\r\n#### Content Security Policy\r\n> 严格的CSP在XSS的防范中可以起到以下作用。\r\n\r\n- 禁止加载外域代码，防止复杂的攻击逻辑。\r\n- 禁止外域提交，网站被攻击后，用户的数据不会泄露到外域。\r\n- 禁止内联脚本执行。\r\n- 禁止未授权的脚本执行。\r\n- 合理使用上报可以及时发现XSS，利于尽快修复问题。'},function(r,n,e){"use strict";e.r(n),n.default="## 接口加密\r\n> 一些营销活动类的Web页面比如领红包、领券、投票、抽奖等活动。对这些重要的接口都会采用接口加密验签的方式进行保护，从而避免非正常用户通过刷活动API接口进行某些非正常操作。\r\n\r\n- 客户端和服务端约定一种接口校验逻辑，客户端在每次请求服务端接口的时候附带一个sign参数。\r\n- sign参数的逻辑自定义，可以由当前时间戳信息、设备ID、日期、双方约定好的秘钥经过一些加密算法构造而成。\r\n- 客户端根据约定的加密算法构造sign，每次请求服务器的时候附带上sign。\r\n- 服务端根据约定的加密算法和请求的数据对sign进行校验，如果检验通过，才返回数据，否则拒绝响应。"},function(r,n,e){"use strict";e.r(n),n.default="## 减少if-else的使用\r\n### 短路运算\r\n> 使用或 || 的短路运算代替一些比较简单的 if else。\r\n\r\n```\r\n// 原：\r\nlet c;\r\nif (a) {\r\n  c = a;\r\n} else {\r\n  c = b;\r\n}\r\n\r\n// 后：\r\nlet c = a || b;\r\n```\r\n### 三元运算符\r\n> 使用三元运算符替代 if else。\r\n\r\n```\r\n// 原：\r\nconst fn = (nBoolean) {\r\n  if (nBoolean) {\r\n    return 1;\r\n  } else {\r\n    return 0;\r\n  }\r\n}\r\n\r\n// 后：\r\nconst fn = (nBoolean) {\r\n  return nBoolean ? 1 : 0;\r\n}\r\n```\r\n### switch case\r\n> 对于多重条件判断使用 switch case 的可读性比 if else 更好。\r\n\r\n```\r\n// 原：\r\nlet type = 'A';\r\n\r\nif (type === 'A' || type === 'B') {\r\n  console.log(1);\r\n} else if (type === 'C') {\r\n  console.log(2);\r\n} else if(type === 'D') {\r\n  console.log(3);\r\n} else {\r\n  console.log(0);\r\n}\r\n\r\n// 后：\r\nswitch (type) {\r\n  case 'A':\r\n  case 'B':\r\n    console.log(1);\r\n    break;\r\n  case 'C':\r\n    console.log(2);\r\n    break;\r\n  case 'D':\r\n    console.log(3);\r\n    break;\r\n  default:\r\n    console.log(0);\r\n}\r\n```\r\n### 对象配置/策略模式\r\n> 对象配置看起来跟 策略模式 差不多，都是根据不同得参数使用不同得数据/算法/函数。策略模式就是将一系列算法封装起来，并使它们相互之间可以替换。被封装起来的算法具有独立性，外部不可改变其特性。对象配置不一定非要使用对象去管理我们键值对，还可以使用 Map去管理。\r\n\r\n```\r\n// 原：\r\nconst getDiscount = (userKey) => {\r\n  if (userKey === '普通会员') {\r\n    return 0.9;\r\n  } else if (userKey === '年费会员') {\r\n    return 0.85;\r\n  } else if (userKey === '超级会员') {\r\n    return 0.8;\r\n  } else {\r\n    return 1;\r\n  }\r\n}\r\nconsole.log(getDiscount('普通会员')) // 0.9\r\n\r\n// 后：\r\nconst getDiscount = (userKey) => {\r\n  // 根据用户类型来生成我们的折扣对象\r\n  const discounts = {\r\n    '普通会员': 0.9,\r\n    '年费会员': 0.85,\r\n    '超级会员': 0.8,\r\n    'default': 1,\r\n  }\r\n  return discounts[userKey] || discounts['default'];\r\n}\r\nconsole.log(getDiscount('普通会员')) // 0.9\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## antd v5实现主题切换\r\n### 通过ConfigProvider实现预设算法(algorithm)的主题切换\r\n- app.tsx\r\n```\r\nimport { IntlProvider } from 'react-intl';\r\nimport { ConfigProvider, theme } from 'antd';\r\nimport { getLocale } from '@/locale';\r\nimport configStore from '@/store/configStore';\r\nimport Routes from '@/routes';\r\nimport Message from '@/components/message';\r\n\r\nconst App = () => {\r\n  // 获取语言环境\r\n  const { locale: currentLocale, selectedTheme } = configStore(\r\n    (state: any) => state\r\n  );\r\n  const { locale, antLocale, messages } = getLocale(currentLocale);\r\n\r\n  const themeAlgorithms = [];\r\n  if (selectedTheme.includes('dark')) {\r\n    themeAlgorithms.push(theme.darkAlgorithm);\r\n  }\r\n  if (selectedTheme.includes('compact')) {\r\n    themeAlgorithms.push(theme.compactAlgorithm);\r\n  }\r\n\r\n  return (\r\n    <IntlProvider locale={locale} messages={messages}>\r\n      <ConfigProvider\r\n        locale={antLocale}\r\n        theme={{\r\n          cssVar: true,\r\n          hashed: false,\r\n          algorithm: themeAlgorithms\r\n        }}\r\n      >\r\n        <Routes />\r\n        <Message />\r\n      </ConfigProvider>\r\n    </IntlProvider>\r\n  );\r\n};\r\n\r\nexport default App;\r\n```\r\n### 业务代码中的样式使用antd提供的样式变量\r\n- variables.scss文件中定义scss变量，方便全局管理。\r\n```\r\n$primaryColor: var(--ant-color-primary, #1677ff); // 主题色(hover时、链接也使用此颜色)\r\n$successColor: var(--ant-color-success, #52c41a); // 成功色\r\n$warningColor: var(--ant-color-warning, #faad14); // 警戒色\r\n$errorColor: var(--ant-color-error, #ff4d4f); // 错误色\r\n$whiteColor: var(--ant-color-bg-base, #fff); // 白色\r\n$blackColor: var(--ant-color-text-base, #000); // 黑色\r\n$redColor: var(--ant-red, #f5222d); // 红色\r\n$backColor: var(--ant-color-bg-layout, #f5f5f5); // 背景色\r\n$tableBackColor: var(--ant-table-header-bg, #fafafa); // 表格背景色\r\n$borderColor: var(--ant-color-border-secondary, #f0f0f0); // 边框颜色\r\n$cardBorderRadius: var(--ant-border-radius-lg, 8px); // 卡片圆角\r\n$buttonSpacing: 8px; // 按钮之间的间距\r\n$textButtonSpacing: 4px; // 文字形式按钮之间的间距\r\n:export {\r\n  primaryColor: $primaryColor;\r\n  successColor: $successColor;\r\n  warningColor: $warningColor;\r\n  errorColor: $errorColor;\r\n  whiteColor: $whiteColor;\r\n  blackColor: $blackColor;\r\n  redColor: $redColor;\r\n  cardBorderRadius: $cardBorderRadius;\r\n  buttonSpacing: $buttonSpacing;\r\n  textButtonSpacing: $textButtonSpacing;\r\n  backColor: $backColor;\r\n  borderColor: $borderColor;\r\n}\r\n```\r\n- 业务代码中使用scss变量。\r\n```\r\n.spaceBetweenPageInnerContentBox {\r\n  height: 100%;\r\n  border-radius: $cardBorderRadius;\r\n  min-width: 0;\r\n  display: flex;\r\n  flex-direction: column;\r\n  padding: 12px;\r\n  background-color: $whiteColor;\r\n  .tipBox {\r\n    border-top: 1px solid $borderColor;\r\n    flex-grow: 1;\r\n    display: flex;\r\n    justify-content: center;\r\n    align-items: center;\r\n  }\r\n  .tableBox {\r\n    flex-grow: 1;\r\n    display: flex;\r\n    flex-direction: column;\r\n    overflow: auto;\r\n  }\r\n}\r\n```\r\n- 如果使用antd非全局的css变量，比如table组件的--ant-table-header-bg变量，需要额外添加table组件的样式类。\r\n```\r\n<div className={`${styles.filterColumn} css-var-r0 ant-table-css-var`}>\r\n  ...\r\n</div>\r\n\r\n.filterColumn {\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: space-between;\r\n  background: $tableBackColor;\r\n  flex-shrink: 0;\r\n  padding: 6px;\r\n}\r\n```\r\n### ConfigProvider对message.xxx、Modal.xxx、notification.xxx等静态方法不会生效。\r\n#### JSX组件中使用\r\n- 使用hooks形式方法手动植入contextHolder。\r\n```\r\nimport React from 'react';\r\nimport { Button, message } from 'antd';\r\n\r\nconst App: React.FC = () => {\r\n  const [messageApi, contextHolder] = message.useMessage();\r\n\r\n  const info = () => {\r\n    messageApi.info('Hello, Ant Design!');\r\n  };\r\n\r\n  return (\r\n    <>\r\n      {contextHolder}\r\n      <Button type=\"primary\" onClick={info}>\r\n        Display normal message\r\n      </Button>\r\n    </>\r\n  );\r\n};\r\n```\r\n\r\n- 可以通过App包裹组件简化手动植入contextHolder的问题。\r\n```\r\n// Sub page\r\nimport React from 'react';\r\nimport { App } from 'antd';\r\n\r\nconst MyPage = () => {\r\n  const { message } = App.useApp();\r\n\r\n  const showMessage = () => {\r\n    message.success('Success!');\r\n  };\r\n}\r\n\r\n// Entry component\r\nexport default () => (\r\n  <App>\r\n    <MyPage />\r\n  </App>\r\n);\r\n```\r\n#### JSX组件外部使用\r\n- 在入口组件将App.useApp返回的message对象存储到redux的store中，使用时从store中获取message对象。\r\n- [通过自定义事件实现message对象。](https://www.wenyisong.cn/js/antd-message-global/)\r\n  1. 实现Message组件。\r\n  ```\r\n  import { useEffect } from 'react';\r\n  import { message } from 'antd';\r\n  import { MESSAGE_EVENT_NAME } from '@/utils/antdMessage';\r\n\r\n  const Message = () => {\r\n    const [api, contextHolder] = message.useMessage();\r\n\r\n    useEffect(() => {\r\n      const bindEvent = (e: CustomEvent | any) => {\r\n        const func: 'success' | 'error' | 'info' | 'warning' | 'loading' =\r\n          e?.detail?.type || 'info';\r\n        const { content, duration, onClose } = e.detail?.params || {};\r\n        api[func](content, duration, onClose);\r\n      };\r\n      window.addEventListener(MESSAGE_EVENT_NAME, bindEvent);\r\n      return () => {\r\n        window.removeEventListener(MESSAGE_EVENT_NAME, bindEvent);\r\n      };\r\n    }, [api]);\r\n\r\n    return <>{contextHolder}</>;\r\n  };\r\n\r\n  export default Message;\r\n  ```\r\n  2. 挂载Message组件到App组件。\r\n  ```\r\n  import { IntlProvider } from 'react-intl';\r\n  import { ConfigProvider, theme } from 'antd';\r\n  import { getLocale } from '@/locale';\r\n  import configStore from '@/store/configStore';\r\n  import Routes from '@/routes';\r\n  import Message from '@/components/message';\r\n\r\n  const App = () => {\r\n    // 获取语言环境\r\n    const { locale: currentLocale, selectedTheme } = configStore(\r\n      (state: any) => state\r\n    );\r\n    const { locale, antLocale, messages } = getLocale(currentLocale);\r\n\r\n    const themeAlgorithms = [];\r\n    if (selectedTheme.includes('dark')) {\r\n      themeAlgorithms.push(theme.darkAlgorithm);\r\n    }\r\n    if (selectedTheme.includes('compact')) {\r\n      themeAlgorithms.push(theme.compactAlgorithm);\r\n    }\r\n\r\n    return (\r\n      <IntlProvider locale={locale} messages={messages}>\r\n        <ConfigProvider\r\n          locale={antLocale}\r\n          theme={{\r\n            cssVar: true,\r\n            hashed: false,\r\n            algorithm: themeAlgorithms\r\n          }}\r\n        >\r\n          <Routes />\r\n          <Message />\r\n        </ConfigProvider>\r\n      </IntlProvider>\r\n    );\r\n  };\r\n\r\n  export default App;\r\n  ```\r\n  3. 暴露message方法。\r\n  ```\r\n  import { JointContent } from 'antd/es/message/interface';\r\n\r\n  export const MESSAGE_EVENT_NAME = 'mock_antd_message';\r\n  export enum MESSAGE_TYPES {\r\n    SUCCESS = 'success',\r\n    ERROR = 'error',\r\n    INFO = 'info',\r\n    WARNING = 'warning',\r\n    LOADING = 'loading'\r\n  }\r\n\r\n  const dispatch = (\r\n    type: MESSAGE_TYPES,\r\n    content: JointContent,\r\n    duration?: number | VoidFunction,\r\n    onClose?: VoidFunction\r\n  ) => {\r\n    window.dispatchEvent(\r\n      new CustomEvent(MESSAGE_EVENT_NAME, {\r\n        detail: {\r\n          params: {\r\n            content,\r\n            duration,\r\n            onClose\r\n          },\r\n          type: type\r\n        }\r\n      })\r\n    );\r\n  };\r\n\r\n  export const message = {\r\n    success(\r\n      content: JointContent,\r\n      duration?: number | VoidFunction,\r\n      onClose?: VoidFunction\r\n    ) {\r\n      dispatch(MESSAGE_TYPES.SUCCESS, content, duration, onClose);\r\n    },\r\n    error(\r\n      content: JointContent,\r\n      duration?: number | VoidFunction,\r\n      onClose?: VoidFunction\r\n    ) {\r\n      dispatch(MESSAGE_TYPES.ERROR, content, duration, onClose);\r\n    },\r\n    info(\r\n      content: JointContent,\r\n      duration?: number | VoidFunction,\r\n      onClose?: VoidFunction\r\n    ) {\r\n      dispatch(MESSAGE_TYPES.INFO, content, duration, onClose);\r\n    },\r\n    warning(\r\n      content: JointContent,\r\n      duration?: number | VoidFunction,\r\n      onClose?: VoidFunction\r\n    ) {\r\n      dispatch(MESSAGE_TYPES.WARNING, content, duration, onClose);\r\n    },\r\n    loading(\r\n      content: JointContent,\r\n      duration?: number | VoidFunction,\r\n      onClose?: VoidFunction\r\n    ) {\r\n      dispatch(MESSAGE_TYPES.LOADING, content, duration, onClose);\r\n    }\r\n  };\r\n  ```\r\n  4. 在业务代码中使用message对象。\r\n  ```\r\n  import { message } from '@/utils/antdMessage';\r\n\r\n  message.error('请上传正确格式文件');\r\n  ```\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## 前端主题切换方案\r\n### link标签动态引入\r\n> 提前准备好几套CSS主题样式文件，在需要的时候，创建link标签动态加载到head标签中，或者是动态改变link标签的href属性。\r\n\r\n#### 优点\r\n- 实现了按需加载，提高了首屏加载时的性能。\r\n#### 缺点\r\n- 动态加载样式文件，如果文件过大网络情况不佳的情况下可能会有加载延迟，导致样式切换不流畅。\r\n- 如果主题样式表内定义不当，会有优先级问题。\r\n- 各个主题样式是写死的，后续针对某一主题样式表修改或者新增主题也很麻烦。\r\n### 提前引入所有主题样式，做类名切换\r\n> 这种方案与第一种比较类似，为了解决反复加载样式文件问题提前将样式全部引入，在需要切换主题的时候将指定的根元素类名更换，相当于直接做了样式覆盖，在该类名下的各个样式就统一地更换了。\r\n\r\n```\r\n/* day样式主题 */\r\nbody.day .box {\r\n  color: #f90;\r\n  background: #fff;\r\n}\r\n/* dark样式主题 */\r\nbody.dark .box {\r\n  color: #eee;\r\n  background: #333;\r\n}\r\n\r\n.box {\r\n  width: 100px;\r\n  height: 100px;\r\n  border: 1px solid #000;\r\n}\r\n\r\n<div>\r\n  <div class=\"box\">\r\n    <p>hello</p>\r\n  </div>\r\n  <p>\r\n    <button onclick=\"change('day')\">day</button>\r\n    <button onclick=\"change('dark')\">dark</button>\r\n  </p>\r\n</div>\r\n\r\n// 修改主题\r\nfunction change(theme) {\r\n  document.body.className = theme;\r\n}\r\n```\r\n#### 优点\r\n- 不用重新加载样式文件，在样式切换时不会有卡顿。\r\n#### 缺点\r\n- 首屏加载时会牺牲一些时间加载样式资源。\r\n- 如果主题样式表内定义不当，也会有优先级问题。\r\n- 各个主题样式是写死的，后续针对某一主题样式表修改或者新增主题也很麻烦。\r\n### CSS变量+类名切换\r\n> 跟方案2相似，依然是提前将样式文件载入，切换时将指定的根元素类名更换。不过这里相对灵活的是默认在根作用域下定义好CSS变量，只需要在不同的主题下更改CSS变量对应的取值即可。\r\n\r\n```\r\n/* 定义根作用域下的变量 */\r\n:root {\r\n  --theme-color: #333;\r\n  --theme-background: #eee;\r\n}\r\n/* 更改dark类名下变量的取值 */\r\n.dark{\r\n  --theme-color: #eee;\r\n  --theme-background: #333;\r\n}\r\n/* 更改pink类名下变量的取值 */\r\n.pink{\r\n  --theme-color: #fff;\r\n  --theme-background: pink;\r\n}\r\n\r\n.box {\r\n  transition: all .2s;\r\n  width: 100px;\r\n  height: 100px;\r\n  border: 1px solid #000;\r\n  /* 使用变量 */\r\n  color: var(--theme-color);\r\n  background: var(--theme-background);\r\n}\r\n```\r\n#### 优点\r\n- 不用重新加载样式文件，在样式切换时不会有卡顿。\r\n- 在需要切换主题的地方利用var()绑定变量即可，不存在优先级问题。\r\n- 新增或修改主题方便灵活，仅需新增或修改CSS变量即可，在var()绑定样式变量的地方就会自动更换。\r\n#### 缺点\r\n- IE兼容性（忽略不计）。\r\n- 首屏加载时会牺牲一些时间加载样式资源。\r\n### CSS变量+动态setProperty\r\n> 这个方案适用于由用户根据颜色面板自行设定各种颜色主题，这种是主题颜色不确定的情况，而前几种方案更适用于定义预设的几种主题。\r\n\r\n#### 实现思路\r\n- 只需在全局中设置好预设的全局CSS变量样式，无需单独为每一个主题类名下重新设定CSS变量值，因为主题是由用户动态决定。\r\n```\r\n:root {\r\n  --theme-color: #333;\r\n  --theme-background: #eee;\r\n}\r\n```\r\n- 定义一个工具类方法，用于修改指定的CSS变量值，调用的是CSSStyleDeclaration.setProperty。\r\n```\r\nexport const setCssVar = (prop: string, val: any, dom = document.documentElement) => {\r\n  dom.style.setProperty(prop, val)\r\n}\r\n```\r\n- 在样式发生改变时调用此方法即可。\r\n```\r\nsetCssVar('--theme-color', color)\r\n```\r\n#### 优点\r\n- 不用重新加载样式文件，在样式切换时不会有卡顿。\r\n- 需要切换主题的地方只用在:root上动态更改CSS变量值即可，不存在优先级问题。\r\n- 新增或修改主题方便灵活。\r\n#### 缺点\r\n- IE兼容性（忽略不计）。\r\n- 首屏加载时会牺牲一些时间加载样式资源（相对于前几种预设好的主题，这种方式的样式定义在首屏加载多使用的时间基本可以忽略不计）。"},function(r,n,e){"use strict";e.r(n),n.default="## 前端回滚\r\n- 前端项目快速回滚是前端工程化中很重要的一环，项目部署到线上后如果报错打不开或者其他原因需要回滚到上一个版本，这个时候回滚的速度就会显得尤为重要。\r\n- 正常的回滚步骤：需要git reset回退代码或者git rervet撤销上个版本的代码，然后重新打包上线，撤回代码和重新打包都需要时间，会影响线上几分钟的时间，需要一种更快的方案来实现秒级回滚。\r\n- docker是一个很好的实现秒级回滚的方案。\r\n- 当前端项目不是使用docker部署时，是通过nginx托管或者静态资源上传到OSS上进行访问的形式时需要自己实现快速回滚的策略。\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## [秒级回滚-未使用docker](https://juejin.cn/post/7251181090395111483)\r\n### 实现思路\r\n- 单页应用打包后都有一个index.html入口文件，每一次打包后的index.html里面都会引入本版本所需要的静态资源，如果我们不删除过往版本的静态资源(或者上传到oss上面)，并且每次项目打包都把本次打包的信息和index.html内容保存起来，保存一个数组列表数据。\r\n- 在需要回滚版本时，通过前端可视化界面可以选择项目中某个分支中的构建记录进行快速回滚。具体实现原理就是用回滚版本存的index.html内容替换当前项目正在使用的index.html内容，替换index.html内容后，引入的静态资源都会变成该版本打包出来的静态资源路径，从而实现快速回滚。\r\n- 整体思路就是保留历史构建的css，js，图片等静态资源，保存每一次构建的index.html内容，回滚时用对应版本的index.html内容替换当前的内容，实现真正的秒级回滚。\r\n### 存储每次打包的信息和index.html内容\r\n- 在每一次打包命令结束后执行build.js脚本，保存历史构建记录。\r\n```\r\n// build.js\r\nimport path from 'path'\r\nimport fs from 'fs'\r\n\r\nfunction start() {\r\n  // 设置存储构建的history.json文件路径\r\n  const historyPath = path.resolve('history.json')\r\n  // 如果json文不存在就创建一个，初始值为 { list: [] }\r\n  if(!fs.existsSync(historyPath)) {\r\n    fs.writeFileSync(historyPath, JSON.stringify({ list: [] }))\r\n  }\r\n  // 读取本次打包后的dist/index.html内容\r\n  const html = fs.readFileSync(path.resolve('./dist/index.html'), 'utf-8')\r\n  // 获取到当前histyory.json的内容\r\n  const history = JSON.parse(fs.readFileSync(historyPath, 'utf-8'))\r\n  // 将当前打包的信息push到history的list中，包含构建时间和index.html内容还有id\r\n  // 实际应用中还可以添加其他的很多信息\r\n  history.list.push({\r\n    time: new Date().toLocaleString('zh-cn'),\r\n    html,\r\n    // 模拟生成一个随机的id\r\n    id: Math.random().toString(16).substr(2),\r\n    // ... 分支信息，commit信息，构建时间，构建人，构建环境等字段\r\n  })\r\n\r\n  // 将最新的构建记录内容写入到history.json中\r\n  fs.writeFileSync(historyPath, JSON.stringify(history, null, 2))\r\n}\r\n\r\nstart()\r\n```\r\n### 创建一个node服务和一个前端可视化回滚页面来实现回滚逻辑\r\n- 在前端可视化页面选择某一次构建记录后，把id传给node服务器。\r\n- 服务器根据id找到对应的html内容，用html内容替换dist/index.html的内容。\r\n- 替换完成后用户访问页面就可以访问到对应版本的内容了，实现了秒级回滚。\r\n### 保留历史构建静态资源的方式还可以规避两个常见的问题：\r\n1. 前端构建时dist文件被清空，此时前端访问项目会访问不到。\r\n2. 用了路由懒加载，新版本发布后，原文件消失，用户跳转页面请求资源会404，造成页面异常。\r\n### 历史构建静态资源积累造成资源浪费\r\n- 只保留最近5次的构建结果，5次之外的构建资源去进行删除，这样既能实现秒级回滚，又不会造成太多的资源浪费。"},function(r,n,e){"use strict";e.r(n),n.default="## BFF\r\n> Backends For Frontends，服务于前端的后端。BFF就是一层nodejs实现的中间层，能做请求转发、接口聚合、数据转化。\r\n\r\n### BFF的优势\r\n- 服务端对数据展示服务进行解耦，展示服务由独立的BFF端提供，服务端可以聚焦于业务处理。\r\n- 多端展示或者多业务展示时，对于数据获取有更好的灵活性，避免数据冗余造成消耗服务端资源。\r\n- 对于复杂的前端展示，将数据获取和组装的负责逻辑在BFF端执行，降低前端处理的复杂度，提高前端页面响应效率。"},function(r,n,e){"use strict";e.r(n),n.default='## ESlint + Prettier + husky + lint-staged规范前端项目\r\n### ESlint代码检查工具\r\n> JavaScript代码的检查工具，ESlint能够查找并修复JavaScript代码中的问题。\r\n\r\n#### 安装依赖 npm i eslint -D\r\n#### 常用命令\r\n- npx eslint src          检查src目录下的代码问题\r\n- npx eslint src --quiet  只检查src目录下的代码的error问题\r\n- npx eslint --fix src    自动修复src目录下可潜在修复的错误\r\n#### ESlint配置文件\r\n- 执行命令初始化ESlint配置(根据提示进行选择) npm init @eslint/config。\r\n  1. 选择 To check syntax and find problems (检查语法和查找错误)\r\n  2. 选择ES Module的模块规范\r\n  3. 选择react框架\r\n  4. 选择使用TypeScript\r\n  5. 选择browser运行环境\r\n  6. 选择使用js文件作为配置文件\r\n  7. 根据选择安装推荐的相关依赖 eslint-plugin-react、 @typescript-eslint/eslint-plugin、 @typescript-eslint/parser\r\n  8. 生成.eslintrc.js配置文件\r\n- .eslintrc.js配置文件中的extends和rules字段定义了在项目中采用哪些规则。\r\n- .eslintrc.js使用ignorePatterns在一些目录下禁用eslint规则。\r\n```\r\n// ESlint规则禁用config文件夹\r\nignorePatterns: ["config/"]\r\n```\r\n#### 配合编辑器使用ESlint\r\n- 在VSCode中使用ESlint需要安装ESlint插件。启用插件后可以在编辑代码的同时看到哪些代码有问题，及时发现及时修复。\r\n- 启用编辑器的保存自动修复功能，不用执行额外的ESlint命令。\r\n> 左下角管理图标 => 设置 => 文本编辑器 => 在settings.json中编辑。\r\n\r\n```\r\n// VSCode settings.json\r\n{\r\n  // ...\r\n  "editor.codeActionsOnSave": {\r\n    "source.fixAll.eslint": true\r\n  }\r\n}\r\n```\r\n### Prettier代码格式化工具\r\n\r\n#### 安装依赖 npm i prettier eslint-config-prettier eslint-plugin-prettier -D\r\n#### 常用命令\r\n- npx prettier --write src  格式化src目录下的代码文件\r\n#### 解决ESlint和Prettier的冲突。\r\n> 同时使用二者需要关闭ESlint中可能和Prettier冲突的规则。.eslintrc.js文件中的extend中添加"prettier"解决ESlint和Prettier的冲突。\r\n\r\n```\r\n// .eslintrc.js\r\nmodule.exports = {\r\n  // ...\r\n  "extends": [\r\n    // ...\r\n    "prettier"\r\n  ],\r\n}\r\n```\r\n#### 创建.prettierrc文件，并配置自己的规则。\r\n```\r\n{\r\n  "endOfLine": "auto",\r\n  "printWidth": 80, \r\n  "semi": true,\r\n  "trailingComma": "none",\r\n  "singleQuote": true,\r\n  "arrowParens": "avoid"\r\n}\r\n```\r\n### Prettier vs ESLint\r\n> 都会对代码AST（语法树）进行检查，但Prettier只会进行语法分析，只能检查并归正代码的格式问题，而ESLint还会进一步对代码进行语义分析，能发现格式问题和代码模式问题。ESLint只能检查JavaScript代码以及TypeScript、JSX等衍生代码（需配置解析器），无法检查项目中的CSS、HTML等代码。Prettier则天然支持对大多数项目文件的格式化。\r\n\r\n### husky + lint-staged代码提交前检查、格式化代码\r\n#### husky\r\n> 操作git钩子的工具。\r\n\r\n- 安装依赖 npm i husky -D\r\n- 在packgae.json中添加prepare脚本。\r\n> prepare脚本会在npm install之后自动执行。当执行npm install安装完项目依赖后会执行husky install命令，该命令会创建.husky/目录并指定该目录为git hooks所在的目录。\r\n\r\n```\r\n// package.json\r\n{\r\n  // ...\r\n  "scripts": {\r\n    // ...\r\n    "prepare": "husky install"\r\n  }\r\n}\r\n```\r\n- 执行命令npm run prepare\r\n#### lint-staged\r\n> 本地暂存代码检查工具，每一次提交只检查本次提交所修改(指git暂存区里的东西)的内容，而不是每次检查是整个项目的内容。\r\n\r\n- 安装依赖 npm install lint-staged -D\r\n- package.json添加lint-staged的命令\r\n> src/**/*.{js,jsx,ts,tsx} 只对src目录下的js,jsx,ts,tsx文件进行格式化，对应的三条命令会先后分别执行，eslint --fix之后使用Prettier格式化代码，然后git add，最后执行我们的git commit。\r\n\r\n```\r\n"lint-staged": {\r\n  "src/**/*.{js,jsx,ts,tsx}": [\r\n    "eslint --fix",\r\n    "prettier --write",\r\n    "git add"\r\n  ]\r\n},\r\n```\r\n- 设置git的pre-commit钩子执行npx lint-staged命令\r\n```\r\nnpx husky add .husky/pre-commit "npx lint-staged"\r\n```\r\n### 测试commit效果\r\n- 提交时Prettier会格式化代码。\r\n![格式化前](./img/prettierBefore.png)\r\n![格式化后](./img/prettierAfter.png)\r\n- 存在eslint的error信息时commit失败。\r\n> eslint存在error信息时才会阻止提交(warning信息不会阻止提交)，如果阻止了commit提交或者代码格式化后没有任何修改，eslint --fix以及Prettier格式化不会生效。\r\n\r\n![commit失败前](./img/commitBefore.png)\r\n![commit失败结果](./img/commitAfter.png)\r\n\r\n'},function(r,n,e){"use strict";e.r(n),n.default='## [browserslist](https://browsersl.ist/)\r\n> browserslist帮助我们在浏览器兼容性和包大小之间保持适当的平衡。使用browserslist可以做到覆盖更广泛的浏览器同时包的体积也会保持最小化。\r\n\r\n### 配置方式\r\n- 可以在package.json中声明browserslist字段进行配置\r\n```\r\n"browserslist": [\r\n  "> 0.2%",\r\n  "last 10 versions",\r\n]\r\n```\r\n- 通过.browserslistrc文件配置\r\n```\r\n> 0.2%\r\nlast 10 versions\r\n```\r\n### 如何配置\r\n> 可以通过[https://browsersl.ist/](https://browsersl.ist/)网站来查看配置的内容具体支持的浏览器情况。\r\n\r\n- defaults(默认配置)，> 0.5%, last 2 versions, Firefox ESR, not dead。\r\n- 根据全球或某个国家/地区的使用率进行配置\r\n    - `> 0.2%` (全世界使用率大于0.2%)\r\n    - `> 0.2% in CN` (中国使用率大于0.2%)\r\n- 根据最近的浏览器版本进行配置\r\n    - last 10 versions (所有浏览器最新的10个版本)\r\n    - last 10 Chrome versions (Chrome浏览器最新2个版本)\r\n- dead (官方不再支持或24个月没有更新的浏览器)\r\n- 根据特定浏览器版本进行配置\r\n    - iOS 7 (支持iOS版本7的浏览器)\r\n    - Firefox > 20 (支持Firefox版本大于20的浏览器)\r\n    - ie 6-8 (支持ie版本6-8的浏览器)\r\n- 选择支持特定功能的浏览器版本\r\n    - supports es6-module (支持es6-module的浏览器)\r\n    - supports css-grid (支持css-grid的浏览器)\r\n- not (可以给任何配置使用，表示反义)\r\n- 以上条件可以组合\r\n    - `> 0.2%, last 10 versions` (使用率大于0.2%或者所有浏览器最新10个版本，等价于 > 0.2% or last 10 versions)\r\n    - `> 0.2% and last 10 versions` (使用率大于0.2%浏览器且是最新的10个版本)\r\n    - `> 0.2%, last 10 versions, not dead` (使用率大于0.2%或者所有浏览器最新10个版本且没有dead的浏览器)\r\n\r\n### 检查配置是否正确\r\n> 运行`npx browserslist-lint`命令查看配置是否有错误。\r\n\r\n### 查看配置支持的浏览器\r\n> 运行`npx browserslist`命令查看配置支持的浏览器。\r\n'},function(r,n,e){"use strict";e.r(n),n.default='## cdn\r\n- CDN的全称是(Content Delivery Network)，即内容分发网络。\r\n- 其目的是通过在现有的Internet中增加一层新的CACHE(缓存)层，将网站的内容发布到最接近用户的网络"边缘"节点，使用户可以就近取得所需的内容，提高用户访问网站的响应速度。\r\n- CDN的工作原理就是将源站的资源缓存到位于全球各地的CDN节点上，用户请求资源时，就近返回节点上缓存的资源，而不需要每个用户的请求都去源站获取，避免网络拥塞、缓解源站压力，提高内容传递的速度和效率，加快用户访问的响应速度。'},function(r,n,e){"use strict";e.r(n),n.default="## dayjs代替moment\r\n### moment\r\n- 可变对象\r\n> moment对象是可变对象（mutable），任何时间上的加减等计算都改变了其本身。这种设计让代码变得十分不可控，而且很容易带来各种隐蔽且难以调试的 bug。以至于我们在每步修改之前，都要先调用.clone克隆一次才能放心操作。\r\n\r\n- 包体积过大\r\n> 因为Momnet.js将全部的功能和所有支持的语言都打到一个包里，包的大小为280.9KB，而且对于Tree shaking无效。如果要使用时区相关的功能，包的大小为467.6 KB。有时可能只需要一个format格式化时间的方法就需要加载数百KB的库，是非常不划算的。\r\n\r\n### dayjs\r\n- 和moment相同的API\r\n> moment.js相同的API、相同的链式操作。\r\n\r\n- 不可变\r\n> 可变性是使用moment时最大的问题之一。在dayjs完全消除了这个问题，它支持不变性。\r\n\r\n- 体积小\r\n> dayjs包的大小只有2KB大小。"},function(r,n,e){"use strict";e.r(n),n.default="## 前端工程化\r\n> 利用工具链解决前端在开发过程中提升效率和质量的问题。"},function(r,n,e){"use strict";e.r(n),n.default="## 前端规范\r\n### 开发流程规范\r\n- 保障开发质量和开发效率。\r\n- 及时发现问题和规避问题。\r\n### 代码规范\r\n- 代码格式化规范Eslint + Prettier + husky + lint-staged。\r\n- 设置css变量样式文件统一使用css变量，项目样式统一且方便样式整体替换。\r\n- 使用枚举维护localStorage的key，防止多人协作过程中使用重复的key。\r\n- 变量命名语义化。\r\n- 使用错误边界对错误组件进行降级处理。\r\n- 适当添加注释。\r\n### 项目文件结构规范\r\n- 按照团队约定组织项目目录结构，方便其它同事查找对应功能代码。\r\n### UI设计规范\r\n- 选用合适的UI组件库。\r\n- UI色值和边距等内容项目保持统一。\r\n### git commit规范\r\n- 通过git提交信息可以了解到提交的大致内容，可以参考Angular团队的commit规范。\r\n- 一次提交尽可能涉及的改动内容相对独立。"},function(r,n,e){"use strict";e.r(n),n.default='## 统一Node版本\r\n> 在现代前端开发中，Node.js作为构建工具和服务端运行环境的基石，版本不一致可能导致各种问题，如依赖库兼容性问题、开发环境与生产环境不匹配等。为了确保团队协作项目的稳定性和一致性，需要采取一些措施来保证项目中的Node版本一致。\r\n\r\n### package.json的engines字段\r\n- 在项目的package.json文件中，可以使用engines字段来指定所需的Node版本。在该字段中可以定义一个范围或者具体的版本号来限制Node的版本。\r\n```\r\n// 指定特定版本号\r\n"engines": {\r\n  "node": "14.17.0"\r\n}\r\n\r\n// 范围符号：表示项目需要Node版本大于等于12.0.0且小于16.0.0。\r\n"engines": {\r\n  "node": ">=12.0.0 < 16.0.0"\r\n}\r\n\r\n// 波浪线符号：表示项目需要Node版本为14.17.x\r\n"engines": {\r\n  "node": "~14.17.0"\r\n}\r\n\r\n// 插入符号：表示项目需要Node版本为14.x.x\r\n"engines": {\r\n  "node": "^14.17.0"\r\n}\r\n```\r\n- 使用npm install时，engines配置并没有起作用，使用yarn安装时，engines配置会起作用。\r\n- engines默认不开启严格版本校验，只会给出提示，需要手动开启严格模式。在根目录.npmrc文件中添加engine-strict = true后使用npm install才会起作用。\r\n```\r\nengine-strict = true\r\n```\r\n### 使用.nvmrc文件\r\n- 使用nvm等Node版本管理工具很方便在不同项目下切换不同的Node版本。但来回切换很容易导致混淆，因此引发的一些bug还难以排查。\r\n- 创建一个.nvmrc文件，指定项目Node版本，执行nvm use自动就切换到项目指定的Node版本。\r\n```\r\nv14.17.5\r\n```'},function(r,n,e){"use strict";e.r(n),n.default='## 统一npm版本\r\n### 锁定npm版本\r\n> 利用only-allow工具包、npm scripts快速实现锁定。\r\n\r\n- 安装only-allow依赖\r\n```\r\nnpm install only-allow -D\r\n```\r\n- 在package.json文件中配置scripts.preinstall，允许输入的值为only-allow npm、only-allow pnpm、only-allow yarn。\r\n```\r\n// package.json\r\n"scripts": {\r\n  "preinstall": "only-allow npm",\r\n}\r\n```\r\n'},function(r,n,e){"use strict";e.r(n),n.default="## 负载均衡\r\n- 随着用户数量的增长和业务规模的扩大，单一的服务器无法满足高并发、大流量的需求。\r\n- 单个服务器很难通过增加硬件资源来满足需求，成本高昂且存在性能瓶颈，更为严重的是所有请求都发送到同一台服务器，一旦该服务器出现故障整个服务就会中断。\r\n- 通过增加服务器数量，负载均衡将大量的网络请求分发到多个服务器上进行处理，从而提高系统的处理能力，保证服务的高可用性。\r\n### 负载均衡好处\r\n- 提高性能和吞吐量：负载均衡可以将请求分发到多个后端服务器上，使得每个服务器处理的负载更加均衡。这样可以提高系统的整体性能和吞吐量，缩短用户的等待时间，提升用户体验。\r\n- 增强系统可用性：如通过将负载分散到多个服务器上，即使其中一个服务器发生故障，其他服务器仍然可以继续处理请求，从而提高系统的可用性和可靠性。负载均衡器可以自动检测故障并将请求转发到可用的服务器上，减少服务中断的风险。\r\n- 实现系统的伸缩性：负载均衡器可以根据实际负载情况动态地添加或删除后端服务器，实现系统的弹性扩展。当负载增加时，可以添加更多的服务器来分担负载；当负载减少时，可以减少服务器的数量以节省资源。\r\n- 解决高并发和高可用性问题：在互联网架构中，负载均衡可以有效地解决高并发和高可用性的问题。通过将请求分发到多个服务器上，可以平衡负载，避免单个服务器过载，从而提供更好的用户体验。\r\n- 提高资源利用率：负载均衡可以根据服务器的性能指标和负载情况，将请求分发到最适合的服务器上。这样可以更好地利用服务器的资源，提高资源的利用率。\r\n### 负载均衡的工作原理\r\n1. 请求接收：当用户发出请求时，请求首先会被发送到负载均衡器。\r\n2. 请求分发：负载均衡器会根据某种负载均衡算法，如轮询、最少连接、源地址哈希等，将请求分发到后端的某个服务器。这个过程中负载均衡器会考虑到后端服务器的当前负载情况，以确保所有服务器的负载都保持在一个合理的范围内。\r\n3. 响应返回：后端服务器处理完用户的请求后，会将响应返回给负载均衡器，负载均衡器再将响应返回给用户。\r\n4. 健康检查：负载均衡器会定期对后端服务器进行健康检查，如果发现某个服务器出现故障，负载均衡器会将该服务器从服务列表中移除，不再向其分发请求。当服务器恢复正常后，负载均衡器会再次将其加入到服务列表中。\r\n### 硬件负载均衡\r\n- 硬件负载均衡器是专门的物理设备，这类设备性能强劲、功能强大、具有高性能和高可靠性，适合处理大规模的网络流量，但价格昂贵，一般只有大公司才会考虑使用此类设备。\r\n### 软件负载均衡\r\n- 软件负载均衡器是运行在普通服务器上的软件，它们的成本较低，扩展性好。软件负载均衡器可以根据需要轻松地增加或减少，适合云计算和虚拟化环境。\r\n- 常见的有Nginx和LVS，其中Nginx是软件的七层负载均衡，LVS是Linux内核的四层负载均衡。\r\n### 四层负载均衡\r\n- 四层负载均衡工作在网络模型的传输层，主要根据请求的IP地址和端口号来进行负载均衡。四层负载均衡器不会关心请求的具体内容，只是简单地将请求转发到后端的某个服务器。\r\n- 四层负载均衡的处理速度较快，但是灵活性较低。\r\n### 七层负载均衡\r\n- 七层负载均衡工作在网络模型的应用层，可以根据请求的具体内容（如 URL、请求头、请求方法等）来进行负载均衡。七层负载均衡器可以理解请求的具体内容，因此可以实现更复杂的负载均衡策略，如基于URL的负载均衡、基于会话的负载均衡等。\r\n- 由于需要处理请求的具体内容，七层负载均衡的处理速度相对较慢。\r\n### 全局负载均衡\r\n- 全局负载均衡主要用于在全球范围内的多个数据中心之间进行负载均衡。它可以根据各个数据中心的负载情况、网络状况、客户端的地理位置等因素，智能地将用户的请求分发到最合适的数据中心。从而减少网络延迟，提高服务的性能和可用性。\r\n### 局部负载均衡\r\n- 局部负载均衡主要用于在单个数据中心内的多个服务器之间进行负载均衡。它通常使用更精细的负载均衡策略，如轮询、最少连接、源地址哈希等，以实现更高效的资源利用和更好的性能。\r\n### DNS负载均衡\r\n- DNS负载均衡可以实现全局负载均衡。DNS服务器可以根据客户端的地理位置、网络状况等因素，根据域名的DNS解析选择最适合的服务器IP返回给客户端，从而实现全局的流量分发。\r\n- DNS负载均衡也有一些限制。\r\n  1. DNS查询结果可能会被客户端或中间网络设备缓存，导致负载均衡策略不能实时生效。\r\n  2. DNS负载均衡无法实现会话保持，也无法根据服务器的实时负载状况、服务器性能、运行状态进行动态调整，可能分发到有问题的服务器。\r\n- DNS负载均衡通常和其他负载均衡技术（如四层负载均衡、七层负载均衡）配合使用，以实现更高效的负载均衡。\r\n### 服务端负载均衡\r\n- 负载均衡器位于服务端，所有的客户端请求都会首先发送到负载均衡器，负载均衡器会根据负载均衡算法将请求分发到后端的某个服务器。\r\n- 这种方式的优点是实现简单，透明度高，客户端无需进行任何特殊处理。但是所有的请求都需要经过负载均衡器，可能会成为性能瓶颈。\r\n- 负载均衡器根据服务器的实时负载状况、服务器性能、运行状态进行动态调整，有问题的服务器不会分发。\r\n### 客户端负载均衡\r\n- 负载均衡的逻辑实现在客户端。客户端会从服务注册中心获取所有可用的服务列表，然后根据负载均衡算法选择一个服务进行请求。\r\n- 这种方式的优点是可以避免服务端负载均衡器成为性能瓶颈，但是需要在客户端实现负载均衡逻辑，增加了客户端的复杂性。\r\n### [负载均衡算法](https://www.zhihu.com/question/61783920/answer/3223446673)\r\n- 轮询算法\r\n- 加权轮询算法\r\n- 最少连接算法\r\n- 加权最少连接算法\r\n- 源地址哈希算法\r\n- URL哈希算法\r\n- 最短响应时间算法\r\n### 负载均衡算法的选择\r\n- 服务器的性能是否均匀：如果服务器的性能差异较大，那么加权轮询或加权最少连接算法可能更合适，因为这两种算法可以通过调整权重来考虑服务器的性能差异。\r\n- 请求的处理时间是否相同：如果处理请求的时间差异较大，那么最少连接或最短响应时间算法可能更合适，因为这两种算法可以动态地根据服务器的负载情况进行负载均衡。\r\n- 是否需要维持会话状态：如果需要维持会话状态，那么源地址哈希算法可能更合适，因为这种算法可以保证来自同一源IP地址的请求总是被分配到同一台服务器。\r\n- 是否需要缓存：如果需要缓存，那么URL哈希算法可能更合适，因为这种算法可以保证同一URL的请求总是被分配到同一台服务器。\r\n- 服务器数量是否会频繁变化：如果服务器数量会频繁变化，那么轮询或最少连接算法可能更合适，因为这两种算法不依赖于服务器的数量。\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## try-catch\r\n- try-catch中不要写入太多的代码(声明太多的变量)，最好是把要执行的代码放在另一个function中，在try-catch中调用这个function。\r\n- 在代码进入try-catch的时候js引擎会拷贝当前的词法环境，拷贝的其实就是当前scope下的所有的变量，会有较大的性能消耗。\r\n- catch语句不要忽略，避免空的catch块。\r\n- try-catch捕获异常并可以使后续代码正常运行，try代码块的内容在出错之后不会再继续执行，但是不影响try-catch代码块之后的代码执行。\r\n- try-catch不能捕获异步错误(setTimeout)。\r\n```\r\ntry {\r\n  console.log(1) // 1\r\n  console.log(a)\r\n  console.log(2)\r\n} catch (error) {\r\n  console.log(error) // ReferenceError: a is not defined\r\n}\r\nconsole.log(3) // 3\r\n```\r\n- finally在try-catch语句中是可选的，finally一经使用其代码无论如何都会执行。finally会阻止return语句的终止。\r\n```\r\nconst a = () => {\r\n  try {\r\n    return 'try';\r\n  } catch (e) {\r\n    return 'catch';\r\n  } finally {\r\n    return 'finally';\r\n  }\r\n}\r\nconsole.log(a()) // finally\r\n```\r\n- try-catch嵌套使用，内层try-catch捕获错误之后就不会被外层try-catch捕获错误且不影响外层try代码块的继续执行。\r\n```\r\nconst a = () => {\r\n  try {\r\n    console.log(dyx);\r\n  } catch (error) {\r\n    console.log('inner catch'); // inner catch\r\n  }\r\n}\r\ntry {\r\n  a();\r\n  console.log('outer try');  // outer try\r\n} catch (error) {\r\n  console.log('outer error');\r\n}\r\n```"},function(r,n,e){"use strict";e.r(n),n.default='## 前端异常\r\n### Error对象\r\n- 可以通过构造函数来创建一个新的通用错误\r\n```\r\nconst err = new Error("Error");\r\nconst err = Error("Error");\r\nthrow err; // Uncaught Error: Error\r\n```\r\n- Error对象有三个属性。\r\n  1. message：带有错误消息的字符串。\r\n  2. name: 错误的类型。\r\n  3. stack：函数执行的堆栈跟踪。\r\n- 创建一个TypeError对象，该消息将携带实际的错误字符串，其name将是"TypeError"。\r\n```\r\nconst wrongError = TypeError("Expected number");\r\nconsole.log(wrongError.message); // Expected number\r\nconsole.log(wrongError.name);    // TypeError\r\n```\r\n### 使用instanceof区分异常类型\r\n```\r\ntry {\r\n  // ...\r\n} catch (err) {\r\n  if (err instanceof TypeError) {\r\n    // 处理 TypeError 错误\r\n  } else if (err instanceof RangeError) {\r\n    // 处理 RangeError 错误\r\n  } else {\r\n    // 处理其他类型错误\r\n  }\r\n}\r\n```\r\n### SyntaxError 语法异常\r\n- 在引擎执行代码之前，编译器需要对js进行编译，编译阶段包括：词法分析，语法分析。\r\n- 编译阶段发生的异常都是SyntaxError。\r\n- 绝大部分SyntaxError都可以通过配置编辑器的校验工具在开发阶段避免。\r\n```\r\n// 缺少一个引号  Uncaught SyntaxError: Invalid or unexpected token\r\nconst a = "3;\r\n```\r\n### TypeError 类型异常\r\n- TypeError在对值进行不合理操作时会发生，比如试图对一个非函数类型的值进行函数调用，或者引用null或undefined类型的值中的属性，那么引擎会抛出这种类型的异常。\r\n```\r\n// 变量name不能当作函数调用  Uncaught TypeError: name is not a function\r\nconst name = \'dyx\';\r\nname();\r\n```\r\n### ReferenceError 引用异常\r\n- 当找不到所需的变量时会报ReferenceError引用异常。\r\n```\r\n// a未定义 Uncaught ReferenceError: a is not defined\r\nconsole.log(a);\r\n```\r\n### RangeError 范围错误\r\n- 错误的数组范围。\r\n```\r\n// 错误的数组长度  Uncaught RangeError: Invalid array length\r\nnew Array(-20)\r\n```\r\n- 递归等消耗内存会导致范围错误的异常。Uncaught RangeError: Maximum call stack size exceeded\r\n- 将错误的值传递给数字方法，例如toFixed()等。\r\n```\r\n// Uncaught RangeError: toFixed() digits argument must be between 0 and 100\r\n2.2222.toFixed(111);\r\n```\r\n### URIError\r\n- 使用全局URI处理函数而产生的错误。\r\n- decodeURI, decodeURIComponent, encodeURI, encodeURIComponent这四个方法会产生这种异常。\r\n```\r\n//  Uncaught URIError: URI malformed\r\ndecodeURI(\'%%\')\r\n```\r\n### EvalError\r\n- 在eval()方法执行过程中抛出EvalError异常。\r\n- 根据ECMA2018版以后，此异常不再会被抛出，但是EvalError对象仍然保持兼容性。\r\n### InternalError 内部异常\r\n- 这种异常极为少见，在JS引擎内部发生，示例场景通常为某些成分过大。\r\n```\r\n// 过多 case 子句\r\nUncaught RangeError: too many switch cases\r\n// 正则表达式中括号过多\r\nUncaught RangeError: too many parentheses in regular expression\r\n// 数组初始化器过大 \r\nUncaught RangeError: array initializer too large\r\n```\r\n### Script Error\r\n#### 产生原因\r\n- 跨域资源引用，当a域下页面引用了b域下的js文件，运行b域下的js文件中的方法时报了一个异常，此时前端的错误捕获脚本只能检测到一个script error的异常。\r\n- 这是由于浏览器基于安全考虑故意隐藏了其它域JS文件抛出的具体错误信息。这样可以有效避免敏感信息无意中被第三方(不受控制的)脚本捕获到，因此浏览器只允许同域下的脚本捕获具体的错误信息。\r\n#### 解决办法\r\n1. 给script标签增加crossorigin属性，让浏览器允许页面请求资源。\r\n```\r\n// 以下两种写法均可\r\n<scrpit src="..." crossorigin><\/script>\r\n<scrpit src="..." crossorigin="anonymous"><\/script> \r\n```\r\n2. 给静态资源响应头增加允许跨域标记，让服务器允许资源返回。\r\n    - 服务器的HTTP响应头增加Access-Control-Allow-Origin: * 或者 Access-Control-Allow-Origin: ...\r\n    - 大部分主流CDN默认添加了Access-Control-Allow-Origin属性。\r\n#### 已添加crossorigin依然有script error\r\n- 由于部分浏览器对crossorigin属性不支持，或者无法往HTTP响应头里面添加跨域属性，因此依然可能产生script error。\r\n- 可以通过try catch获取页面报错信息，将JS错误重新抛出或者上报。\r\n```\r\ntry {\r\n  run(); // 调用b域下的js文件中的方法\r\n} catch (e) {\r\n  console.log(e);\r\n  throw e; \r\n}\r\n```\r\n### 创建自定义错误类型\r\n```\r\nclass MyError extends Error {\r\n  constructor(message) {\r\n    super();\r\n    this.name = "MyError";\r\n    this.message = message;     \r\n  }\r\n}\r\n\r\nthrow new MyError("自定义错误"); // Uncaught MyError: 自定义错误\r\n```\r\n### 抛出错误\r\n- 错误和异常不同。Error对象(错误)只有在被抛出时才会成为异常。\r\n- 在JavaScript中抛出异常，可以使用throw来抛出Error对象。\r\n```\r\nthrow TypeError("Expected number"); // Uncaught TypeError: Expected number\r\nthrow new TypeError("Expected number"); // Uncaught TypeError: Expected number\r\n```\r\n- 异常一旦抛出，就会在程序堆栈中冒泡，除非在某个地方被捕获。'},function(r,n,e){"use strict";e.r(n),n.default='## 异常处理\r\n### 同步错误处理\r\n- 常规函数的错误可以使用try-catch捕获。\r\n- 生成器函数的错误可以使用try-catch处理。\r\n### 异步错误处理\r\n#### 定时器的错误处理\r\n- setTimeout外层加try-catch无法捕获错误。\r\n```\r\ntry {\r\n  setTimeout(() => {\r\n    throw Error("error");\r\n  }, 1000);\r\n} catch (error) {\r\n  console.error(error.message);\r\n}\r\n```\r\n- setTimeout回调函数中加try-catch可以捕获错误。\r\n```\r\nsetTimeout(() => {\r\n  try {\r\n    throw Error("error");\r\n  } catch (error) {\r\n    console.error(error.message);\r\n  }\r\n}, 1000);\r\n```\r\n#### 事件的错误处理\r\n- 事件处理外层加try-catch无法捕获错误。\r\n```\r\nconst button = document.querySelector("button");\r\ntry {\r\n  button.addEventListener("click", function() {\r\n    throw Error("error");\r\n  });\r\n} catch (error) {\r\n  console.error(error.message);\r\n}\r\n```\r\n- 事件处理回调函数中加try-catch可以捕获错误。\r\n```\r\nconst button = document.querySelector("button");\r\nbutton.addEventListener("click", function() {\r\n  try {\r\n    throw Error("error");\r\n  } catch (error) {\r\n    console.error(error.message);\r\n  }\r\n});\r\n```\r\n#### onerror\r\n- 当img标签或script等HTML元素命中不存在的资源时，onerror事件处理程序就会触发。\r\n```\r\nconst image = document.querySelector("img");\r\nimage.addEventListener("error", function(event) {\r\n  console.log(event);\r\n});\r\n```\r\n#### Promise的错误处理\r\n- 使用catch方法处理被拒绝的Promise或Promise中的异常。\r\n```\r\nnew Promise((resolve, reject) => {\r\n  return reject(Error("error"));\r\n})\r\n.then(res => console.log(\'res\'))\r\n.catch(error => console.log(\'error\'))  // \'error\'\r\n\r\nnew Promise((resolve, reject) => {\r\n  throw Error("error");\r\n})\r\n.then(res => console.log(\'res\'))\r\n.catch(error => console.log(\'error\')) // \'error\'\r\n```\r\n- 使用catch方法处理Promise.all、Promise.any、Promise.race、Promise.allSettled中的异常。\r\n#### async/await的错误处理\r\n- 使用try-catch处理async/await的错误。\r\n```\r\nconst a = async() => {\r\n  throw Error("error");\r\n  return \'a\';\r\n}\r\n\r\nconst b = async() => {\r\n  try {\r\n    const res = await a();\r\n    console.log(res);\r\n  } catch (error) {\r\n    console.log(\'error\'); // \'error\'\r\n  }\r\n}\r\nb();\r\n```\r\n- 使用Promise.catch处理。\r\n> 使用Promise.catch处理相较于try-catch处理可以继续执行await后续的代码，可以通过判断await执行的返回值判断是否继续执行后续代码。\r\n\r\n```\r\nconst a = async() => {\r\n  throw Error("error");\r\n  return \'a\';\r\n}\r\n\r\nconst b = async() => {\r\n  const res = await a().catch((error) => console.log(\'error\')); // \'error\'\r\n  console.log(res); // undefined\r\n  if (!res) return;\r\n}\r\nb();\r\n```\r\n- 使用await-to-js插件处理。\r\n#### 异步生成器函数的错误可以使用try-catch处理。\r\n### 异常处理总结\r\n| 异常类型 | 同步方法 | 异步方法 | 资源加载 | Promise | async/await |\r\n| --- | --- | --- | --- | --- | --- |\r\n| try-catch | ✔️ |  |  |  | ✔️ |\r\n| onerror | ✔️ | ✔️ |  |  |  |\r\n| error事件监听 | ✔️ | ✔️ | ✔️ |  |  |\r\n| unhandledrejection事件监听 |  |  |  | ✔️ | ✔️ |\r\n'},function(r,n,e){"use strict";e.r(n),n.default="## 异常监控\r\n### 监听资源(js css img...)加载失败错误\r\n```\r\nwindow.addEventListener(\r\n  'error',\r\n  e => {\r\n    // ...\r\n  },\r\n  true\r\n);\r\n```\r\n### 监听js错误\r\n```\r\nwindow.onerror = (msg, url, line, column, error) => {\r\n  // ...\r\n};\r\n```\r\n### 监听promise错误\r\n```\r\nwindow.addEventListener(\r\n  'unhandledrejection',\r\n  e => {\r\n    // ...\r\n  },\r\n  true\r\n});\r\n```\r\n### 重写console.error事件\r\n```\r\nconst oldConsoleError = window.console.error;\r\nwindow.console.error = (...args) => {\r\n  oldConsoleError.apply(this, args);\r\n  // ...\r\n};\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## [ArrayBuffer](https://zhuanlan.zhihu.com/p/568915443)\r\n> ArrayBuffer对象用来表示通用的、固定长度的原始二进制数据缓冲区。ArrayBuffer的内容不能直接操作，只能通过DataView对象或TypedArrray对象来访问。这些对象用于读取和写入缓冲区内容。"},function(r,n,e){"use strict";e.r(n),n.default='## Base64\r\n> Base64是一种基于64个可打印字符来表示二进制数据的表示方法。Base64编码普遍应用于需要通过被设计为处理文本数据的媒介上储存和传输二进制数据而需要编码该二进制数据的场景。这样是为了保证数据的完整并且不用在传输过程中修改这些数据。\r\n\r\n### 编码解码\r\n- atob()：解码，解码一个Base64字符串；\r\n- btoa()：编码，从一个字符串或者二进制数据编码一个Base64字符串。\r\n```\r\nbtoa("JavaScript");       // \'SmF2YVNjcmlwdA==\'\r\natob(\'SmF2YVNjcmlwdA==\'); // \'JavaScript\'\r\n```\r\n### 使用场景\r\n- 使用toDataURL()方法把canvas画布内容生成base64编码格式的图片url进行展示。\r\n```\r\nconst canvas = document.getElementById(\'canvas\'); \r\nconst ctx = canvas.getContext("2d");\r\nconst dataUrl = canvas.toDataURL();\r\n```\r\n- 使用readAsDataURL()方法把上传的文件转为base64格式的图片url进行展示。\r\n```\r\n<input type="file" id="fileInput" />\r\n<img id="preview" />\r\n\r\nconst fileInput = document.getElementById("fileInput");\r\nconst preview = document.getElementById("preview");\r\nconst reader = new FileReader();\r\n\r\nfileInput.onchange = (e) => {\r\n  reader.readAsDataURL(e.target.files[0]);\r\n};\r\n\r\nreader.onload = (e) => {\r\n  preview.src = e.target.result;\r\n};\r\n```'},function(r,n,e){"use strict";e.r(n),n.default='## blob\r\n> blob全称binary large object，即二进制大对象，blob对象表示一个不可变、原始数据的类文件对象，它的数据可以按文本或二进制的格式进行读取，也可以转换成 ReadableStream来用于数据操作。\r\n\r\n### blob创建\r\n> 使用Blob()构造函数创建新的blob对象。\r\n\r\n- array：由ArrayBuffer、ArrayBufferView、Blob、DOMString等对象构成的Array，将会被放进blob。\r\n- options：可指定如下两个属性\r\n  1. type：默认值为""，表示将会被放入到blob中的数组内容的MIME类型。\r\n  2. endings：默认值为"transparent"，用于指定包含行结束符\\n的字符串如何被写入，不常用。\r\n```\r\nconst blob = new Blob(array, options);\r\n\r\nconst blob = new Blob(["Hello World"], { type: "text/plain" });\r\n```\r\n### blob属性\r\n- size属性：blob对象中所包含数据的大小（字节）；\r\n- type属性：字符串，认为该blob对象所包含的MIME类型。如果类型未知，则为空字符串。\r\n```\r\nconst blob = new Blob(["Hello World"], { type: "text/plain" });\r\n\r\nconsole.log(blob.size); // 11\r\nconsole.log(blob.type); // "text/plain"\r\n```\r\n### 将blob转化为URL\r\n> 使用URL.createObjectURL()方法将将blob转化为一个URL进行使用。\r\n\r\n```\r\nconst url = URL.createObjectURL(blob);\r\n```\r\n### blob分片\r\n> 除了使用Blob()构造函数来创建blob对象之外，还可以从blob对象中创建blob，也就是将blob对象切片。blob对象内置了slice()方法用来将blob对象分片。\r\n\r\n- start：设置切片的起点，即切片开始位置。默认值为0，意味着切片应该从第一个字节开始。\r\n- end：设置切片的结束点，会对该位置之前的数据进行切片。默认值为blob.size。\r\n- contentType：设置新blob的MIME类型。如果省略type，则默认为blob的原始值。\r\n```\r\nconst blob = new Blob(["Hello World"], { type: "text/plain" });\r\nconst subBlob = blob.slice(0, 5);\r\n```\r\n'},function(r,n,e){"use strict";e.r(n),n.default='## File\r\n> File 文件接口提供有关文件的信息，并允许网页中的JavaScript访问其内容。实际上File对象是特殊类型的Blob，且可以用在任意的Blob类型的context中。Blob的属性和方法都可以用于File对象。File对象中只存在于浏览器环境中，在Node.js环境中不存在。\r\n\r\n### 获取File对象\r\n- input元素上选择文件后返回的FileList数组，这个数组的每个元素都是一个File对象，一个上传的文件就对应一个File对象。\r\n```\r\n<input type="file" id="fileInput" multiple="multiple">\r\n\r\nconst fileInput = document.getElementById("fileInput");\r\nfileInput.onchange = (e) => {\r\n  console.log(e.target.files); // FileList数组\r\n}\r\n```\r\n- 文件拖放操作生成的DataTransfer对象。当拖放文件到拖放区域时，通过事件参数的dataTransfer属性的files获取到一个FileList数组，该数组的每一个元素都是一个File对象。\r\n```\r\n<div id="drop-zone"></div>\r\n\r\nconst dropZone = document.getElementById("drop-zone");\r\ndropZone.ondragover = (e) => {\r\n  e.preventDefault();\r\n}\r\ndropZone.ondrop = (e) => {\r\n  e.preventDefault();\r\n  const files = e.dataTransfer.files;\r\n  console.log(files); // FileList数组\r\n}\r\n```\r\n### File对象属性\r\n- lastModified：引用文件最后修改日期，为自1970年1月1日0:00以来的毫秒数。\r\n- lastModifiedDate：引用文件的最后修改日期。\r\n- name：引用文件的文件名。\r\n- size：引用文件的文件大小。\r\n- type：文件的媒体类型（MIME）。\r\n- webkitRelativePath：文件的路径或 URL。'},function(r,n,e){"use strict";e.r(n),n.default='## FileReader\r\n> FileReader是一个异步API，用于读取文件并提取其内容以供进一步使用。FileReader可以将Blob读取为不同的格式。\r\nFileReader仅用于以安全的方式从用户（远程）系统读取文件内容，不能用于从文件系统中按路径名简单地读取文件。\r\n\r\n### FileReader创建\r\n> 通过FileReader()构造函数创建FileReader对象。\r\n\r\n```\r\nconst reader = new FileReader();\r\n```\r\n### FileReader属性\r\n- error：表示在读取文件时发生的错误。\r\n- result：文件内容。该属性仅在读取操作完成后才有效，数据的格式取决于使用哪个方法来启动读取操作。\r\n- readyState：表示FileReader状态的数字。取值0：还没有加载任何数据；取值1：数据正在被加载；取值2：已完成全部读取。\r\n### FileReader方法\r\n> 下面这些方法接受一个要读取的blob对象作为参数，读取完之后会将读取的结果放入对象的result属性中。\r\n\r\n- readAsArrayBuffer()：读取指定Blob中的内容，完成之后result属性中保存的将是被读取文件的ArrayBuffer数据对象。\r\n- readAsBinaryString()：读取指定Blob中的内容，完成之后result属性中将包含所读取文件的原始二进制数据。\r\n- readAsDataURL()：读取指定Blob中的内容，完成之后result属性中将包含一个data: URL格式的Base64字符串以表示所读取文件的内容。\r\n- readAsText()：读取指定Blob中的内容，完成之后result属性中将包含一个字符串以表示所读取的文件内容。\r\n### FileReader事件处理\r\n> 这些方法可以加上前置on后在HTML元素上使用，比如onload、onerror、onabort、onprogress。由于FileReader对象继承自EventTarget，因此还可以使用addEventListener()监听上述事件。\r\n\r\n- abort：该事件在读取操作被中断时触发。\r\n- error：该事件在读取操作发生错误时触发。\r\n- load：该事件在读取操作完成时触发。\r\n- progress：该事件在读取Blob时触发。\r\n\r\n```\r\n<input type="file" id="fileInput">\r\n\r\nconst fileInput = document.getElementById("fileInput");\r\nconst reader = new FileReader();\r\nfileInput.onchange = (e) => {\r\n  reader.readAsText(e.target.files[0]);\r\n  // 上传图片文件时可以使用readAsDataURL方法获取base64编码的URL进行预览展示\r\n  reader.readAsDataURL(e.target.files[0]);\r\n}\r\nreader.onload = (e) => {\r\n  console.log(e.target.result);\r\n}\r\n\r\n// 可以通过progress事件来监控文件的读取进度\r\nreader.onprogress = (e) => {\r\n  if (e.loaded && e.total) {\r\n    const percent = (e.loaded / e.total) * 100;\r\n    console.log(`上传进度: ${Math.round(percent)} %`);\r\n  }\r\n});\r\n```\r\n\r\n'},function(r,n,e){"use strict";e.r(n),n.default='## Object URL\r\n> Object URL又称Blob URL，是HTML5中的新标准。它是一个用来表示File Object或Blob Object的URL。\r\n\r\n### createObjectURL\r\n> 可以使用URL构造函数的createObjectURL()方法创建将给出的对象的URL。这个URL对象表示指定的File对象或Blob对象。我们可以在img、script标签中或者a、link标签的href属性中使用这个URL。\r\n\r\n```\r\n<input type="file" id="fileInput" />\r\n<img id="preview" />\r\n\r\nconst fileInput = document.getElementById("fileInput");\r\nconst preview = document.getElementById("preview");\r\nfileInput.onchange = (e) => {\r\n  // 直接预览图片\r\n  preview.src = URL.createObjectURL(e.target.files[0]);\r\n};\r\n```\r\n\r\n### revokeObjectURL\r\n> 当使用createObjectURL()方法创建一个Object URL时，就需要使用revokeObjectURL()方法从内存中清除它来释放内存。虽然浏览器会在文档卸载时自动释放Object URL，但为了提高性能应该使用createObjectURL()来手动释放它。\r\n\r\n```\r\nconst blob = new Blob([\'123\']);\r\nconst url = URL.createObjectURL(blob);\r\nconst link = document.createElement(\'a\');\r\nlink.href = url;\r\nlink.download = \'123.txt\';\r\nlink.click();\r\n// 释放一个之前已经存在的、通过调用URL.createObjectURL()创建的URL对象\r\nURL.revokeObjectURL(url);\r\n```\r\n\r\n'},function(r,n,e){"use strict";e.r(n),n.default="## 前端请求文件数据流\r\n### 前端设置请求的responseType为'blob'\r\n> 指定响应的数据类型为二进制数据流，请求成功会返回文件流内容。\r\n\r\n```\r\naxios.get(url, { responseType: 'blob' })\r\n```\r\n### 转为blob对象\r\n> 使用new Blob()将请求返回的文件流转为blob对象。\r\n\r\n```\r\naxios\r\n  .get(url, { responseType: 'blob' })\r\n  .then(res => {\r\n    const blob = new Blob([res.data]);\r\n  })\r\n```\r\n### 将blob对象转成URL进行显示或下载\r\n> 使用URL.createObjectURL()将blob对象转为URL。\r\n\r\n```\r\naxios\r\n  .get(url, { responseType: 'blob' })\r\n  .then(res => {\r\n    const blob = new Blob([res.data]);\r\n    const url = URL.createObjectURL(blob);\r\n  })\r\n```\r\n### 请求文件流并下载\r\n```\r\n/**\r\n * @param url 接口请求地址\r\n * @param fileName 下载的文件名称\r\n * @returns Promise\r\n */\r\nexport const downloadFile = async(url: string, fileName: string) => {\r\n  return axios\r\n    .get(url, { responseType: 'blob' })\r\n    .then(res => {\r\n      const blob = new Blob([res.data]);\r\n      const url = URL.createObjectURL(blob);\r\n      const link = document.createElement('a');\r\n      link.href = url;\r\n      link.download = fileName;\r\n      link.click();\r\n      // 释放一个之前已经存在的、通过调用URL.createObjectURL()创建的URL对象\r\n      URL.revokeObjectURL(url);\r\n      message.success(\"下载成功\");\r\n      return res;\r\n    })\r\n    .catch((error) => {\r\n      message.error(\"下载失败\");\r\n      return Promise.reject(error);\r\n    })\r\n}\r\n```\r\n### 请求文件流失败时的处理\r\n> 请求的responseType设置为'blob'时，请求成功会返回文件流内容。但是请求失败的时候后端返回的是json，这种情况在我们通常封装的axios中判断后端返回的code值就不适用了，需要进行特殊处理。\r\n\r\n- 将responseType设置为'json'，请求成功之后将json格式转化成blob在进行导出。\r\n- 将responseType设置为'blob'，请求失败之后将blob格式转化成json格式再进行错误提示。(采用的形式)\r\n```\r\n/**\r\n * @param url 接口请求地址\r\n * @param fileName 下载的文件名称\r\n * @returns Promise\r\n */\r\nexport const downloadFile = async(url: string, fileName: string) => {\r\n  return axios\r\n    .get(url, { responseType: 'blob' })\r\n    .then(res => {\r\n      // 请求失败之后的处理 (请求失败时的content-type为application/json)\r\n      if (res.headers['content-type'] === 'application/json') {\r\n        // 将blob转为json进行解析\r\n        const reader = new FileReader();\r\n        reader.readAsText(res.data, 'utf-8');\r\n        reader.onload = function() {\r\n          const parseObj = JSON.parse(reader.result);\r\n          message.error(parseObj.msg || '导出失败');\r\n        }\r\n        return Promise.reject('导出失败');\r\n      }\r\n      const blob = new Blob([res.data]);\r\n      const url = URL.createObjectURL(blob);\r\n      const link = document.createElement('a');\r\n      link.href = url;\r\n      link.download = fileName;\r\n      link.click();\r\n      // 释放一个之前已经存在的、通过调用URL.createObjectURL()创建的URL对象\r\n      URL.revokeObjectURL(url);\r\n      message.success(\"下载成功\");\r\n      return res;\r\n    })\r\n    .catch((error) => {\r\n      message.error(\"下载失败\");\r\n      return Promise.reject(error);\r\n    })\r\n}\r\n```\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## 大文件切片上传\r\n1. 使用Blob.prototype.slice方法将大文件分割成指定大小文件切片。\r\n2. 使用formData并行上传所有文件切片数据（由于并行上传，将文件切片的顺序告诉服务端）。\r\n3. 所有切片全部上传后通知服务端进行文件合并。\r\n4. 服务端使用multiparty处理前端传的formData数据，存储所有文件切片数据。\r\n5. 服务端根据文件切片的顺序使用读写流进行文件合并，合并成功后删除文件切片数据。\r\n### 前端代码\r\n```\r\nimport React, { useState } from 'react';\r\nimport { Button, message } from 'antd';\r\nimport request from '@/utils/request';\r\n\r\nconst SIZE = 10 * 1024 * 1024; // 单个文件切片大小\r\nconst BigFileUpload = () => {\r\n  const [uploadStatus, setUploadStatus] = useState(''); // 上传的状态\r\n  const [selectFile, setSelectFile] = useState<any>(null); // 选择的文件\r\n\r\n  // 选择上传文件时存储文件信息\r\n  const onUploadChange = (e: any) => {\r\n    const [file] = e.target.files;\r\n    if (file) {\r\n      setSelectFile(file);\r\n    }\r\n  };\r\n\r\n  // 生成文件切片\r\n  const createFileChunk = (file: any) => {\r\n    const fileChunkList = [];\r\n    let cur = 0;\r\n    while (cur < file.size) {\r\n      fileChunkList.push({ file: file.slice(cur, cur + SIZE) });\r\n      cur += SIZE;\r\n    }\r\n    return fileChunkList;\r\n  };\r\n\r\n  // 上传文件\r\n  const uploadFile = () => {\r\n    if (selectFile) {\r\n      setUploadStatus('loading');\r\n      const fileChunkList = createFileChunk(selectFile);\r\n      const fileChunkData: any = fileChunkList.map(({ file }, index) => ({\r\n        index,\r\n        chunk: file,\r\n        size: file.size\r\n      }));\r\n      uploadChunks(fileChunkData);\r\n    }\r\n  };\r\n\r\n  // 上传切片\r\n  const uploadChunks = async (fileChunkData: any) => {\r\n    const requestList = fileChunkData\r\n      .map(({ chunk, index }: { chunk: any; index: number }) => {\r\n        const formData = new FormData();\r\n        formData.append('chunk', chunk);\r\n        formData.append('filename', selectFile.name);\r\n        formData.append('index', String(index));\r\n        return { formData, index };\r\n      })\r\n      .map(({ formData }: { formData: any; index: number }) =>\r\n        request({\r\n          url: '/upload',\r\n          method: 'POST',\r\n          data: formData\r\n        })\r\n      );\r\n    await Promise.all(requestList);\r\n    await mergeFile();\r\n  };\r\n\r\n  // 通知服务端合并切片\r\n  const mergeFile = async () => {\r\n    await request({\r\n      url: '/merge',\r\n      method: 'POST',\r\n      data: JSON.stringify({\r\n        size: SIZE,\r\n        filename: selectFile.name\r\n      })\r\n    });\r\n    message.success('上传成功');\r\n    setUploadStatus('');\r\n  };\r\n\r\n  return (\r\n    <div>\r\n      {/* 正在上传中时disabled */}\r\n      <input\r\n        type=\"file\"\r\n        onChange={onUploadChange}\r\n        disabled={uploadStatus === 'loading'}\r\n      />\r\n      {/* 没有选择文件或正在上传中时disabled */}\r\n      <Button\r\n        onClick={uploadFile}\r\n        disabled={!selectFile || uploadStatus === 'loading'}\r\n      >\r\n        上传\r\n      </Button>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default BigFileUpload;\r\n```\r\n### 服务端代码\r\n```\r\nconst multiparty = require(\"multiparty\");\r\nconst fse = require(\"fs-extra\");\r\nconst path = require(\"path\");\r\n\r\n// 大文件存储目录\r\nconst UPLOAD_DIR = path.resolve(__dirname, \"..\", \"files\");\r\n\r\n// 写入文件流\r\nconst pipeStream = (path, writeStream) =>\r\n  new Promise(resolve => {\r\n    const readStream = fse.createReadStream(path);\r\n    readStream.on(\"end\", () => {\r\n      fse.unlinkSync(path);\r\n      resolve();\r\n    });\r\n    readStream.pipe(writeStream);\r\n  });\r\n\r\n// 提取POST请求参数\r\nconst resolvePost = req =>\r\n  new Promise(resolve => {\r\n    let chunk = \"\";\r\n    req.on(\"data\", data => {\r\n      chunk += data;\r\n    });\r\n    req.on(\"end\", () => {\r\n      resolve(JSON.parse(chunk));\r\n    });\r\n  });\r\n\r\n// 创建临时文件夹用于临时存储chunk (添加 chunkDir 前缀与文件名做区分)\r\nconst getChunkDir = fileName => path.resolve(UPLOAD_DIR, `chunkDir_${fileName}`);\r\n\r\n// 合并切片\r\nconst mergeFileChunk = async (filePath, filename, size) => {\r\n  const chunkDir = getChunkDir(filename);\r\n  const chunkPaths = await fse.readdir(chunkDir);\r\n  // 根据切片下标进行排序，否则直接读取目录的获得的顺序会错乱\r\n  chunkPaths.sort((a, b) => a - b);\r\n\r\n  // 并发写入文件\r\n  await Promise.all(\r\n    chunkPaths.map((chunkPath, index) =>\r\n      pipeStream(\r\n        path.resolve(chunkDir, chunkPath),\r\n        // 根据 size 在指定位置创建可写流\r\n        fse.createWriteStream(filePath, {\r\n          start: index * size\r\n        })\r\n      )\r\n    )\r\n  );\r\n  // 合并后删除保存切片的目录\r\n  fse.rmdirSync(chunkDir);\r\n};\r\n\r\nmodule.exports = class {\r\n  // 处理文件切片\r\n  async handleFormData(req, res) {\r\n    const multipart = new multiparty.Form();\r\n    multipart.parse(req, async (err, fields, files) => {\r\n      if (err) {\r\n        console.error(err);\r\n        res.status = 500;\r\n        res.end(\r\n          JSON.stringify({\r\n            code: 100,\r\n            message: \"file error\"\r\n          })\r\n        );\r\n        return;\r\n      }\r\n      const [chunk] = files.chunk;\r\n      const [filename] = fields.filename;\r\n      const [index] = fields.index;\r\n      const filePath = path.resolve(\r\n        UPLOAD_DIR,\r\n        `${filename}`\r\n      ); // 最终合并后的文件路径\r\n      const chunkDir = getChunkDir(filename); // 存放chunk的文件夹路径\r\n      const chunkPath = path.resolve(chunkDir, index); // 存放每个切片文件的路径\r\n\r\n      // 最终合并后的文件已经存在直接返回\r\n      if (fse.existsSync(filePath)) {\r\n        res.end(\r\n          JSON.stringify({\r\n            code: 0,\r\n            message: \"file exist\"\r\n          })\r\n        );\r\n        return;\r\n      }\r\n\r\n      // 切片存在直接返回\r\n      if (fse.existsSync(chunkPath)) {\r\n        res.end(\r\n          JSON.stringify({\r\n            code: 0,\r\n            message: \"chunk exist\"\r\n          })\r\n        );\r\n        return;\r\n      }\r\n\r\n      // 切片目录不存在，创建切片目录\r\n      if (!fse.existsSync(chunkDir)) {\r\n        await fse.mkdirs(chunkDir);\r\n      }\r\n\r\n      await fse.move(chunk.path, chunkPath);\r\n      res.end(\r\n        JSON.stringify({\r\n          code: 0,\r\n          message: \"success\"\r\n        })\r\n      );\r\n    });\r\n  }\r\n\r\n  // 合并切片\r\n  async handleMerge(req, res) {\r\n    const data = await resolvePost(req);\r\n    const { filename, size } = data;\r\n    const filePath = path.resolve(UPLOAD_DIR, `${filename}`);\r\n    await mergeFileChunk(filePath, filename, size);\r\n    res.end(\r\n      JSON.stringify({\r\n        code: 0,\r\n        message: \"success\"\r\n      })\r\n    );\r\n  }\r\n};\r\n```\r\n### 显示上传进度条\r\n- 使用axios的onUploadProgress方法获取到切片上传的进度，可以独立显示每个文件切片的上传进度。\r\n- 根据每个切片的上传进度计算出整个文件的上传进度可以显示整个文件的上传进度。"},function(r,n,e){"use strict";e.r(n),n.default="\r\n## 大文件断点续传\r\n- 记住已上传的切片，下次上传时跳过已上传的文件切片。\r\n  1. 前端使用localStorage存储已上传的切片（切换浏览器后失效）\r\n  2. 服务端存储，前端每次上传前询问服务端已上传的部分（建议使用）。\r\n- 使用spark-md5计算文件hash值作为文件的唯一标识，因为使用文件名作为标识时，文件名一修改就失去效果。计算hash是非常耗费时间，使用web-worker在worker线程计算hash，这样用户仍可以在主界面正常的交互。\r\n- 暂停上传使用axios的CancelToken取消请求。\r\n- 恢复上传时询问服务端已经成功上传的文件切片，重新上传时过滤掉已经上传的文件切片。\r\n### 前端代码\r\n```\r\nimport React, { useEffect, useState, useRef } from 'react';\r\nimport { Button, message, Table, Progress } from 'antd';\r\nimport axios from 'axios';\r\nimport request from '@/utils/request';\r\n\r\nconst { CancelToken } = axios;\r\nconst SIZE = 100 * 1024 * 1024; // 单个文件切片大小\r\nconst BigFileContinueUpload = () => {\r\n  const cancelRequestRef = useRef<any>([]); // 取消请求的存储\r\n  const [uploadStatus, setUploadStatus] = useState(''); // 上传的状态\r\n  const [selectFile, setSelectFile] = useState<any>(null); // 选择的文件\r\n  const [selectFileHash, setSelectFileHash] = useState<any>(null); // 选择的文件hash值\r\n  const [chunkData, setChunkData] = useState<any>([]); // 切片文件数据\r\n  const [totalPercentage, setTotalPercentage] = useState<number>(0); // 上传总进度\r\n\r\n  // 监听文件切片上传进度影响总进度\r\n  useEffect(() => {\r\n    let percentage = 0;\r\n    chunkData.forEach((item: any) => (percentage += item.percentage));\r\n    setTotalPercentage(percentage / 3);\r\n  }, [chunkData]);\r\n\r\n  // 选择上传文件时存储文件信息\r\n  const onUploadChange = (e: any) => {\r\n    const [file] = e.target.files;\r\n    if (file) {\r\n      setSelectFile(file);\r\n    }\r\n  };\r\n\r\n  // 生成文件hash\r\n  const calculateHash = (fileChunkList: any) => {\r\n    return new Promise(resolve => {\r\n      const worker = new Worker('/hash.js');\r\n      worker.postMessage({ fileChunkList });\r\n      worker.onmessage = e => {\r\n        const { hash } = e.data;\r\n        if (hash) {\r\n          resolve(hash);\r\n        }\r\n      };\r\n    });\r\n  };\r\n\r\n  // 生成文件切片\r\n  const createFileChunk = (file: any) => {\r\n    const fileChunkList = [];\r\n    let cur = 0;\r\n    while (cur < file.size) {\r\n      fileChunkList.push({ file: file.slice(cur, cur + SIZE) });\r\n      cur += SIZE;\r\n    }\r\n    return fileChunkList;\r\n  };\r\n\r\n  // 上传文件\r\n  const uploadFile = async () => {\r\n    if (selectFile) {\r\n      setUploadStatus('loading');\r\n      const fileChunkList = createFileChunk(selectFile);\r\n      const fileHash = await calculateHash(fileChunkList);\r\n      setSelectFileHash(fileHash);\r\n      const fileChunkData: any = fileChunkList.map(({ file }, index) => ({\r\n        index,\r\n        chunk: file,\r\n        size: file.size,\r\n        percentage: 0\r\n      }));\r\n      setChunkData(fileChunkData);\r\n      uploadChunks(fileChunkData, fileHash);\r\n    }\r\n  };\r\n\r\n  // 上传切片\r\n  const uploadChunks = async (\r\n    fileChunkData: any,\r\n    fileHash: any,\r\n    hasUploadedChunk: any = []\r\n  ) => {\r\n    const requestList = fileChunkData\r\n      // 断点续传时过滤掉已经上传的文件切片\r\n      .filter(\r\n        ({ index }: { index: number }) =>\r\n          !hasUploadedChunk.includes(String(index))\r\n      )\r\n      .map(({ chunk, index }: { chunk: any; index: number }) => {\r\n        const formData = new FormData();\r\n        formData.append('chunk', chunk);\r\n        formData.append('filename', selectFile.name);\r\n        formData.append('filehash', fileHash);\r\n        formData.append('index', String(index));\r\n        return { formData, index };\r\n      })\r\n      .map(({ formData, index }: { formData: any; index: number }) =>\r\n        request({\r\n          url: '/upload',\r\n          method: 'POST',\r\n          data: formData,\r\n          // 处理上传进度\r\n          onUploadProgress: function (progressEvent: any) {\r\n            const percentCompleted = Math.round(\r\n              (progressEvent.loaded * 100) / progressEvent.total\r\n            );\r\n            setChunkData((prev: any) => {\r\n              const newData = [...prev];\r\n              newData[index].percentage = percentCompleted;\r\n              return newData;\r\n            });\r\n          },\r\n          cancelToken: new CancelToken((cancel: any) => {\r\n            cancelRequestRef.current.push(cancel);\r\n          })\r\n        })\r\n      );\r\n    await Promise.all(requestList);\r\n    await mergeFile(fileHash);\r\n  };\r\n\r\n  // 通知服务端合并切片\r\n  const mergeFile = async (fileHash: any) => {\r\n    await request({\r\n      url: '/merge',\r\n      method: 'POST',\r\n      data: JSON.stringify({\r\n        size: SIZE,\r\n        filename: selectFile.name,\r\n        fileHash: fileHash\r\n      })\r\n    });\r\n    message.success('上传成功');\r\n    setUploadStatus('');\r\n  };\r\n\r\n  // 暂停上传\r\n  const pauseUpload = () => {\r\n    (cancelRequestRef.current || []).forEach((cancel: any) => cancel());\r\n  };\r\n\r\n  // 继续上传\r\n  const resumeUpload = async () => {\r\n    const res = await request({\r\n      url: '/verify',\r\n      method: 'POST',\r\n      data: JSON.stringify({\r\n        fileHash: selectFileHash\r\n      })\r\n    });\r\n    uploadChunks(chunkData, selectFileHash, res.data?.uploadedList || []);\r\n  };\r\n\r\n  const columns = [\r\n    {\r\n      title: '切片',\r\n      dataIndex: 'index',\r\n      render: (value: number) => `${selectFile.name}-${value}`\r\n    },\r\n    {\r\n      title: '切片大小',\r\n      dataIndex: 'size'\r\n    },\r\n    {\r\n      title: '进度',\r\n      dataIndex: 'percentage',\r\n      render: (value: number) => <Progress percent={value} size=\"small\" />\r\n    }\r\n  ];\r\n\r\n  return (\r\n    <div>\r\n      {/* 正在上传中时disabled */}\r\n      <input\r\n        type=\"file\"\r\n        onChange={onUploadChange}\r\n        disabled={uploadStatus === 'loading'}\r\n      />\r\n      {/* 没有选择文件或正在上传中时disabled */}\r\n      <Button\r\n        onClick={uploadFile}\r\n        disabled={!selectFile || uploadStatus === 'loading'}\r\n        type=\"primary\"\r\n      >\r\n        上传\r\n      </Button>\r\n      <Button onClick={pauseUpload}>暂停上传</Button>\r\n      <Button onClick={resumeUpload}>继续上传</Button>\r\n      <h6>总上传进度</h6>\r\n      <Progress percent={totalPercentage} style={{ width: '90%' }} />\r\n      <h6>文件切片上传进度</h6>\r\n      <Table columns={columns} dataSource={chunkData} />\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default BigFileContinueUpload;\r\n```\r\n### 服务端代码\r\n```\r\n/**\r\n * 大文件断点续传\r\n */\r\n/* eslint-disable */\r\nconst multiparty = require(\"multiparty\");\r\nconst fse = require(\"fs-extra\");\r\nconst path = require(\"path\");\r\n\r\n// 大文件存储目录\r\nconst UPLOAD_DIR = path.resolve(__dirname, \"..\", \"files\");\r\n\r\n// 写入文件流\r\nconst pipeStream = (path, writeStream) =>\r\n  new Promise(resolve => {\r\n    const readStream = fse.createReadStream(path);\r\n    readStream.on(\"end\", () => {\r\n      fse.unlinkSync(path);\r\n      resolve();\r\n    });\r\n    readStream.pipe(writeStream);\r\n  });\r\n\r\n// 提取POST请求参数\r\nconst resolvePost = req =>\r\n  new Promise(resolve => {\r\n    let chunk = \"\";\r\n    req.on(\"data\", data => {\r\n      chunk += data;\r\n    });\r\n    req.on(\"end\", () => {\r\n      resolve(JSON.parse(chunk));\r\n    });\r\n  });\r\n\r\n// 创建临时文件夹用于临时存储chunk (添加 chunkDir 前缀与文件hash做区分)\r\nconst getChunkDir = fileHash => path.resolve(UPLOAD_DIR, `chunkDir_${fileHash}`);\r\n\r\n// 返回已上传的所有切片名\r\nconst createUploadedList = async fileHash =>\r\n  fse.existsSync(getChunkDir(fileHash))\r\n    ? await fse.readdir(getChunkDir(fileHash))\r\n    : [];\r\n\r\n// 合并切片\r\nconst mergeFileChunk = async (filePath, size, fileHash) => {\r\n  const chunkDir = getChunkDir(fileHash);\r\n  const chunkPaths = await fse.readdir(chunkDir);\r\n  // 根据切片下标进行排序，否则直接读取目录的获得的顺序会错乱\r\n  chunkPaths.sort((a, b) => a - b);\r\n\r\n  // 并发写入文件\r\n  await Promise.all(\r\n    chunkPaths.map((chunkPath, index) =>\r\n      pipeStream(\r\n        path.resolve(chunkDir, chunkPath),\r\n        // 根据 size 在指定位置创建可写流\r\n        fse.createWriteStream(filePath, {\r\n          start: index * size\r\n        })\r\n      )\r\n    )\r\n  );\r\n  // 合并后删除保存切片的目录\r\n  fse.rmdirSync(chunkDir);\r\n};\r\n\r\nmodule.exports = class {\r\n  // 获取已上传的文件切片\r\n  async handleVerifyUpload(req, res) {\r\n    const data = await resolvePost(req);\r\n    const { fileHash } = data;\r\n    res.end(\r\n      JSON.stringify({\r\n        uploadedList: await createUploadedList(fileHash)\r\n      })\r\n    );\r\n  }\r\n\r\n  // 处理文件切片\r\n  async handleFormData(req, res) {\r\n    const multipart = new multiparty.Form();\r\n    multipart.parse(req, async (err, fields, files) => {\r\n      if (err) {\r\n        console.error(err);\r\n        res.status = 500;\r\n        res.end(\r\n          JSON.stringify({\r\n            code: 100,\r\n            message: \"file error\"\r\n          })\r\n        );\r\n        return;\r\n      }\r\n      const [chunk] = files.chunk;\r\n      const [filename] = fields.filename;\r\n      const [index] = fields.index;\r\n      const [filehash] = fields.filehash;\r\n      const filePath = path.resolve(\r\n        UPLOAD_DIR,\r\n        `${filename}`\r\n      ); // 最终合并后的文件路径\r\n      const chunkDir = getChunkDir(filehash); // 存放chunk的文件夹路径\r\n      const chunkPath = path.resolve(chunkDir, index); // 存放每个切片文件的路径\r\n\r\n      // 最终合并后的文件已经存在直接返回\r\n      if (fse.existsSync(filePath)) {\r\n        res.end(\r\n          JSON.stringify({\r\n            code: 0,\r\n            message: \"file exist\"\r\n          })\r\n        );\r\n        return;\r\n      }\r\n\r\n      // 切片存在直接返回\r\n      if (fse.existsSync(chunkPath)) {\r\n        res.end(\r\n          JSON.stringify({\r\n            code: 0,\r\n            message: \"chunk exist\"\r\n          })\r\n        );\r\n        return;\r\n      }\r\n\r\n      // 切片目录不存在，创建切片目录\r\n      if (!fse.existsSync(chunkDir)) {\r\n        await fse.mkdirs(chunkDir);\r\n      }\r\n\r\n      await fse.move(chunk.path, chunkPath);\r\n      res.end(\r\n        JSON.stringify({\r\n          code: 0,\r\n          message: \"success\"\r\n        })\r\n      );\r\n    });\r\n  }\r\n\r\n  // 合并切片\r\n  async handleMerge(req, res) {\r\n    const data = await resolvePost(req);\r\n    const { filename, size, fileHash } = data;\r\n    const filePath = path.resolve(UPLOAD_DIR, `${filename}`);\r\n    await mergeFileChunk(filePath, size, fileHash);\r\n    res.end(\r\n      JSON.stringify({\r\n        code: 0,\r\n        message: \"success\"\r\n      })\r\n    );\r\n  }\r\n};\r\n```"},function(r,n,e){"use strict";e.r(n),n.default='## 文件上传\r\n### 单文件上传\r\n> accept属性并不能完全限制上传类型，用户可以修改。\r\n\r\n```\r\n<input type="file" id="fileInput">\r\n\r\nconst fileInput = document.getElementById("fileInput");\r\nfileInput.onchange = (e) => {\r\n  console.log(e.target.files); // FileList数组\r\n}\r\n```\r\n### 多文件上传\r\n> 利用input元素的multiple属性。\r\n\r\n```\r\n<input type="file" id="fileInput" multiple>\r\n\r\nconst fileInput = document.getElementById("fileInput");\r\nfileInput.onchange = (e) => {\r\n  console.log(e.target.files); // FileList数组\r\n}\r\n```\r\n### 目录上传\r\n> 利用input元素上的webkitdirectory属性支持目录上传。\r\n\r\n```\r\n<input type="file" id="fileInput" webkitdirectory>\r\n\r\nconst fileInput = document.getElementById("fileInput");\r\nfileInput.onchange = (e) => {\r\n  console.log(e.target.files); // FileList数组\r\n}\r\n```\r\n### 压缩目录上传\r\n> 在目录上传的基础上，利用JSZip实现压缩目录。\r\n\r\n### 拖拽上传\r\n> 文件拖放操作生成的DataTransfer对象。当拖放文件到拖放区域时，通过事件参数的dataTransfer属性的files获取到一个FileList数组，该数组的每一个元素都是一个File对象。\r\n\r\n```\r\n<div id="drop-zone"></div>\r\n\r\nconst dropZone = document.getElementById("drop-zone");\r\ndropZone.ondragover = (e) => {\r\n  e.preventDefault();\r\n}\r\ndropZone.ondrop = (e) => {\r\n  e.preventDefault();\r\n  const files = e.dataTransfer.files;\r\n  console.log(files); // FileList数组\r\n}\r\n```\r\n### 剪贴板上传\r\n> 利用异步Clipboard API监听容器的粘贴事件，读取并解析剪贴板中的内容，动态构建FormData对象并上传。\r\n\r\n```\r\n<div id="upload-area">\r\n   <p>请先复制图片后再执行粘贴操作</p>\r\n</div>\r\n\r\n// 获取文件\r\nconst uploadAreaEle = document.getElementById("upload-area");\r\nuploadAreaEle.addEventListener("paste", async (e) => {\r\n  e.preventDefault();\r\n  const files = [];\r\n  if (navigator.clipboard) {\r\n    let clipboardItems = await navigator.clipboard.read();\r\n    for (const clipboardItem of clipboardItems) {\r\n      for (const type of clipboardItem.types) {\r\n        const blob = await clipboardItem.getType(type);\r\n        files.push(blob);\r\n       }\r\n     }\r\n  } else {\r\n    const items = e.clipboardData.items;\r\n    for (let i = 0; i < items.length; i++) {\r\n      let file = items[i].getAsFile();\r\n      files.push(file);\r\n    }\r\n  }\r\n  console.log(files); // FileList数组\r\n});\r\n```\r\n### 大文件切片上传\r\n> 利用Blob.slice分割文件实现大文件并发上传的功能。\r\n\r\n### 服务端上传\r\n> 服务器上传就是把文件从一台服务器上传到另外一台服务器。利用第三方库form-data实现服务端文件流式上传的功能。'},function(r,n,e){"use strict";e.r(n),n.default="## 文件下载\r\n### a标签\r\n- download属性用来指定下载的文件名，如果不指定那么下载的文件名就会根据响应头中的Content-Disposition来确定，如果响应头没有Content-Disposition会使用请求的URL的最后一部分作为文件名。\r\n- 如果响应头中的Content-Disposition属性指定了一个不同的文件名，那么会优先使用Content-Disposition中指定的文件名，优先级高于download属性指定的文件名。\r\n- a标签添加download属性只适用于下载同源的URL。\r\n    1. 同源URL会进行下载操作\r\n    2. 非同源URL会进行导航预览操作\r\n    3. 非同源的资源仍需要进行下载，可以将其转换为blob: URL和data: URL的形式进行下载。\r\n- 通过a标签实现\r\n```\r\n<a href=\"url\" download=\"filename\">下载</a>\r\n```\r\n- 通过js实现\r\n```\r\nconst a = document.createElement('a');\r\na.href = 'url';\r\na.download = 'filename';\r\na.click();\r\n```\r\n### window.open\r\n- 上面使用a标签的案例也可以通过window.open来实现。\r\n- 对比于a标签window.open这种方式不能下载.html、.htm、.xml、.xhtml等文件，因为这些文件会被当成html文件来处理，所以会直接在页面中打开。\r\n- 只适用于下载同源的URL。\r\n```\r\nwindow.open('url', '_blank', 'download=filename');\r\n```\r\n###  location.href\r\n> 这种方式和window.open(url)效果是一样的。\r\n\r\n```\r\nlocation.href = 'url';\r\n```\r\n### 通过ajax请求文件流下载\r\n> 请求成功后拿到文件数据流，将文件数据流转换成blob对象，通过URL.createObjectURL来创建一个URL，然后通过a标签的download属性来实现文件下载。\r\n\r\n```\r\n/**\r\n * @param url 接口请求地址\r\n * @param fileName 下载的文件名称\r\n * @returns Promise\r\n */\r\nexport const downloadFile = async(url: string, fileName: string) => {\r\n  return axios\r\n    .get(url, { responseType: 'blob' })\r\n    .then(res => {\r\n      const blob = new Blob([res.data]);\r\n      const url = URL.createObjectURL(blob);\r\n      const link = document.createElement('a');\r\n      link.href = url;\r\n      link.download = fileName;\r\n      link.click();\r\n      // 释放一个之前已经存在的、通过调用URL.createObjectURL()创建的URL对象\r\n      URL.revokeObjectURL(url);\r\n      message.success(\"下载成功\");\r\n      return res;\r\n    })\r\n    .catch((error) => {\r\n      message.error(\"下载失败\");\r\n      return Promise.reject(error);\r\n    })\r\n}\r\n```\r\n### 大文件切片下载\r\n- 服务器端将大文件切割成多个切片，并为每个切片生成唯一的标识符。\r\n- 客户端发送请求获取切片列表，同时开始下载第一个切片。\r\n- 客户端在下载过程中，根据切片列表发起并发请求下载其他切片，并逐渐拼接合并下载的数据。\r\n- 当所有切片都下载完成后，客户端将下载的数据合并为完整的文件。\r\n```\r\n/**\r\n * @param url 文件下载请求接口请求地址\r\n * @param chunkUrl 切片下载请求接口请求地址\r\n * @param fileName 下载的文件名称\r\n */\r\nexport const downloadFile = async(url: string, chunkUrl: string, fileName: string) => {\r\n  // 发起文件下载请求\r\n  axios.get(url)\r\n    .then(res => {\r\n      const totalSize = res.data.totalSize;\r\n      const totalChunks = res.data.totalChunks;\r\n      let downloadedChunks = 0;\r\n      let chunks = [];\r\n\r\n      // 下载每个切片\r\n      for (let chunkNumber = 0; chunkNumber < totalChunks; chunkNumber++) {\r\n        axios\r\n          .get(chunkUrl, { responseType: 'blob' })\r\n          .then(res => {\r\n            downloadedChunks++;\r\n            chunks.push(res.data);\r\n\r\n            // 当所有切片都下载完成时\r\n            if (downloadedChunks === totalChunks) {\r\n              // 合并切片\r\n              const mergedBlob = new Blob(chunks);\r\n              const url = URL.createObjectURL(mergedBlob);\r\n              const link = document.createElement('a');\r\n              link.href = url;\r\n              link.download = fileName;\r\n              link.click();\r\n              // 释放一个之前已经存在的、通过调用URL.createObjectURL()创建的URL对象\r\n              URL.revokeObjectURL(url);\r\n              message.success(\"下载成功\");\r\n            }\r\n          })\r\n      }\r\n    })\r\n    .catch(error => {\r\n      message.error(\"下载失败\");\r\n    });\r\n}\r\n```\r\n### 使用浏览器默认下载，类似软件下载网站的形式\r\n- location.href或者window.open可以实现类似效果。\r\n- 可以把token存在cookie中当用户发起请求的时候会默认带上，后端将下载的接口进行扩展支持从cookie中获取token。"},function(r,n,e){"use strict";e.r(n),n.default="## 文件预览\r\n### 图片预览\r\n```\r\n<img src={url} />\r\n```\r\n### word文件预览\r\n- 安装依赖\r\n```\r\nnpm i docx-preview --save\r\n```\r\n- 使用\r\n```\r\nimport React, { useEffect, useRef } from 'react';\r\nimport { renderAsync } from 'docx-preview';\r\n\r\nconst DocxPreviewModal = (props) => {\r\n  const { data } = props; // data的格式是blob文件流\r\n  const docxPreviewRef = useRef(null); // 展示文件的dom\r\n\r\n  // 预览\r\n  useEffect(() => {\r\n    renderAsync(data, docxPreviewRef.current);\r\n  }, []);\r\n\r\n  return (\r\n    <div ref={docxPreviewRef}></div>\r\n  );\r\n};\r\n```\r\n### excel文件预览\r\n- 安装依赖\r\n```\r\nnpm i xlsx docx-preview --save\r\n```\r\n- 使用\r\n```\r\nimport React, { useEffect, useRef } from 'react';\r\nimport { renderAsync } from 'docx-preview';\r\nimport XLSX from 'xlsx';\r\n\r\nconst XlsxPreviewModal = (props) => {\r\n  const { data } = props; // data的格式是blob文件流\r\n  const xlsxPreviewRef = useRef(null); // 展示文件的dom\r\n\r\n  // 预览\r\n  useEffect(() => {\r\n    const reader = new FileReader();\r\n    // 通过readAsArrayBuffer将blob转换为ArrayBuffer\r\n    reader.readAsArrayBuffer(data) // data的格式是blob文件流\r\n    reader.onload = (event) => {\r\n      // 读取ArrayBuffer数据变成Uint8Array\r\n      const transData = new Uint8Array(event.target.result);\r\n      // 这里的transData里面的类型和后面的type类型要对应\r\n      const workbook = XLSX.read(transData, { type: \"array\" });\r\n      const sheetNames = workbook.SheetNames; // 工作表名称\r\n      const worksheet = workbook.Sheets[sheetNames[0]];\r\n      // const excelData = XLSX.utils.sheet_to_json(worksheet); //JSON\r\n      const html = XLSX.utils.sheet_to_html(worksheet);\r\n      xlsxPreviewRef.current.innerHTML = html;\r\n    };\r\n  }, []);\r\n\r\n  return (\r\n    <div ref={xlsxPreviewRef}></div>\r\n  );\r\n};\r\n```\r\n### pdf文件预览\r\n#### pdf.js使用\r\n- 下载[pdf.js资源](http://mozilla.github.io/pdf.js/getting_started/#download)，下载适用旧版本浏览器的资源\r\n- 将资源放在和项目index.html相同的目录下。\r\n- 项目中使用pdf.js实现预览pdf文件。\r\n```\r\n// pdfUrl为需要预览的pdf文件资源路径\r\n<iframe\r\n  src={`/pdfjs/web/viewer.html?file=${encodeURIComponent(pdfUrl)}`}\r\n  width=\"100%\"\r\n  height=\"100%\"\r\n/>\r\n```\r\n#### 预览跨域的PDF资源文件\r\n- 项目的pdf资源跨域时注释viewer.js以下代码。\r\n```\r\nif (fileOrigin !== viewerOrigin) {\r\n  throw new Error(\"file origin does not match viewer's\");\r\n}\r\n```\r\n#### pdf.js屏蔽功能按钮\r\n- viewer.html，将功能按钮直接设置成style='display:none'。\r\n- 通过js修改参数，viewer.html添加代码隐藏对应按钮。body标签添加onload事件，onload=\"onBodyLoad()\"。\r\n```\r\n<script>\r\n  function onBodyLoad() {\r\n    var appConfig = PDFViewerApplication.appConfig;\r\n    appConfig.toolbar.viewBookmark.setAttribute('hidden', 'true');\r\n    appConfig.secondaryToolbar.viewBookmarkButton.setAttribute('hidden', 'true');\r\n    appConfig.toolbar.openFile.setAttribute('hidden', 'true');\r\n    appConfig.secondaryToolbar.openFileButton.setAttribute('hidden', 'true');\r\n    appConfig.toolbar.download.setAttribute('hidden', 'true');\r\n    appConfig.secondaryToolbar.downloadButton.setAttribute('hidden', 'true');\r\n    appConfig.toolbar.print.setAttribute('hidden', 'true');\r\n    appConfig.secondaryToolbar.printButton.setAttribute('hidden', 'true');\r\n  }\r\n<\/script>\r\n```\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## 格式转化\r\n### ArrayBuffer → blob\r\n```\r\nconst blob = new Blob([new Uint8Array(buffer, byteOffset, length)]);\r\n```\r\n### ArrayBuffer → base64\r\n```\r\nconst base64 = btoa(String.fromCharCode.apply(null, new Uint8Array(arrayBuffer)));\r\n```\r\n### base64 → blob\r\n```\r\nconst base64toBlob = (base64Data, contentType, sliceSize) => {\r\n  const byteCharacters = atob(base64Data);\r\n  const byteArrays = [];\r\n\r\n  for (let offset = 0; offset < byteCharacters.length; offset += sliceSize) {\r\n    const slice = byteCharacters.slice(offset, offset + sliceSize);\r\n\r\n    const byteNumbers = new Array(slice.length);\r\n    for (let i = 0; i < slice.length; i++) {\r\n      byteNumbers[i] = slice.charCodeAt(i);\r\n    }\r\n\r\n    const byteArray = new Uint8Array(byteNumbers);\r\n    byteArrays.push(byteArray);\r\n  }\r\n\r\n  const blob = new Blob(byteArrays, { type: contentType });\r\n  return blob;\r\n}\r\n```\r\n### blob → ArrayBuffer\r\n```\r\nfunction blobToArrayBuffer(blob) { \r\n  return new Promise((resolve, reject) => {\r\n    const reader = new FileReader();\r\n    reader.onload = () => resolve(reader.result);\r\n    reader.onerror = () => reject;\r\n    reader.readAsArrayBuffer(blob);\r\n  });\r\n}\r\n```\r\n### blob → base64\r\n```\r\nfunction blobToBase64(blob) {\r\n  return new Promise((resolve) => {\r\n    const reader = new FileReader();\r\n    reader.onload = () => resolve(reader.result);\r\n    reader.onerror = () => reject;\r\n    reader.readAsDataURL(blob);\r\n  });\r\n}\r\n```\r\n### blob → Object URL\r\n```\r\nconst objectUrl = URL.createObjectURL(blob);\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## ES Module\r\n- ES6在语言标准的层面上，实现了模块功能，export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。\r\n- export、import命令可以出现在模块的任何位置，只要处于模块顶层就可以。如果处于块级作用域内就会报错，这是因为处于条件代码块之中就没法做静态优化了，违背了ES6模块的设计初衷。\r\n- 自从出了ES Module，AMD及CMD基本不用了。\r\n```\r\n// 导出模块\r\nexport function hello() {\r\n\r\n};\r\nexport default {\r\n  // ...\r\n};\r\n\r\n// 引入模块\r\nimport { readFile } from 'fs';\r\nimport React from 'react';\r\n```\r\n### export\r\n- export导出的是变量的引用，下面这种方式会报错\r\n```\r\n// b.js\r\nexport { b: 1 };  // SyntaxError: Unexpected token ':'\r\n```\r\n- export导出常用方式\r\n```\r\n// a.js\r\nexport let a = 1;\r\n```\r\n- export另一种导出方式\r\n```\r\n// b.js\r\nlet b = 1;\r\nexport { b };\r\n```\r\n- 上述两种导出方式的导入方式一样\r\n```\r\nimport { a } from 'xx/a.js';\r\nimport { b } from 'xx/b.js';\r\n```\r\n- 上述两种导出方式混用\r\n> 会报重复导出的错误，这两种export导出方式是不会产生冲突覆盖的。\r\n\r\n```\r\nvar b = 1;\r\nexport { b }\r\nexport var b = 2;  // SyntaxError: Duplicate export of 'b'\r\n```\r\n### import\r\n- import准确来讲并没有创建新的变量，但是这个关键字导入了被导入模块的变量的引用，而在js引擎层面并没有声明新的变量。\r\n### 导出从其它模块导入的内容\r\n- 常用方式\r\n```\r\n// main.js\r\nexport { default as a } from 'xxx/a.xxx';\r\n```\r\n- 这种情况下，a这个变量在main.js这个模块中是访问不到的。如果想要在main.js这个模块中访问到a模块，需要使用import语句进行导入，再使用export暴露给外界。\r\n```\r\n// main.js\r\nimport a from 'xxx/a.xxx';\r\nexport a;\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## export和export default的区别\r\n1. export导出的是变量的引用，而export default导出的是变量的值。\r\n2. 模块里面的内容只能在模块内部修改，模块外部只能使用。ES Module在语法层面做了一层浅层的保护（即将import导入的变量声明为常量）。\r\n3. 而变量的引用必须通过var、let、const、function这些关键字声明才可以由js引擎生成，而变量的值（或者说数据）可以通过变量运算或者字面量直接生成。\r\n### 测试案例\r\n- a.js\r\n```\r\nexport let a = 'a';\r\nexport let objA = { a: 'a' };\r\n\r\nlet defaultA = 1;\r\nexport default defaultA;\r\n\r\nexport function fn(str) {\r\n  a = str;\r\n  defaultA = str;\r\n}\r\n```\r\n- test1.js\r\n```\r\nimport b, { a, fn, objA } from './a.js';\r\n\r\nconsole.log(a, '---', b, '---', objA.a, '---', 'test1.js');\r\n\r\nsetTimeout(() => {\r\n  objA.a = 'hello world';\r\n  fn('hello world');\r\n  console.log(a, '---', b, '---', objA.a, '---', 'test1.js');\r\n})\r\n```\r\n- test2.js\r\n```\r\nimport b, { a, objA } from './a.js';\r\n\r\nconsole.log(a, '---', b, '---', objA.a, '---', 'test2.js');\r\n\r\nsetTimeout(() => {\r\n  console.log(a, '---', b, '---', objA.a, '---', 'test2.js');\r\n}, 100)\r\n```\r\n- main.js\r\n```\r\nimport './test1.js';\r\nimport './test2.js';\r\n```\r\n- 运行main.js，输出结果如下\r\n```\r\na --- 1 --- a --- test1.js\r\na --- 1 --- a --- test2.js\r\nhello world --- 1 --- hello world --- test1.js\r\nhello world --- 1 --- hello world --- test2.js\r\n```\r\n### 测试案例分析\r\n- 通过a值的变化可以看出，在test1.js中的修改会影响到test2.js中a的值，验证我们说的导出变量引用这个观点。\r\n- 通过b的运行结果可以验证export default导出变量值的观点。\r\n- 通过objA.a的运行结果可以验证浅层保护的观点，其实和引用类型变量是一样的逻辑，我们可以修改引用类型变量的属性，只要不对引用类型变量重新赋值都是允许的。\r\n\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## module.exports和exports的区别\r\n> module.exports可以直接赋值，module.exports = function() {}; exports不可以直接赋值，只能添加方法或者属性，exports.add = function() {} ;\r\n\r\n- module.exports 初始值为一个空对象{}\r\n- exports 是指向的 module.exports 的引用\r\n- require() 返回的是 module.exports 而不是 exports\r\n- 两者的关系为var exports = module.exports = {}; 给exports直接赋值是无效的，因为赋值后，module.exports仍然是空对象{}，因为直接给exports赋值，会直接改变exports的指向，并不会改变module.exports的值，而require() 返回的是 module.exports 而不是 exports，所以给exports赋值是不允许的。但是由于exports是module.exports的一个引用，因为引用类型的特性，以添加属性的形式改变exports的值同时module.exports的值也会改变，因为两者指向同一地址，所以require返回的内容就是修改后的内容。\r\n- 建议使用module.exports可以避免某些问题。\r\n### exports\r\n#### 使用exports添加属性的形式\r\n```\r\n// exportFile.js\r\nconst name = 'dyx';\r\nconst sayName = name => {\r\n  console.log(name);\r\n}\r\nexports.name = name;\r\nexports.sayName = sayName;\r\n\r\n// requireFile.js\r\nconst requireData = require('./exportFile');\r\nconsole.log(requireData); // { name: 'dyx', sayName: fn }\r\nconsole.log(requireData.name); // dyx\r\n```\r\n#### 使用exports直接赋值形式\r\n```\r\n// exportFile.js\r\nconst name = 'dyx';\r\nconst sayName = name => {\r\n  console.log(name);\r\n}\r\nexports = { name: name, sayName: sayName };\r\n\r\n// requireFile.js\r\nconst requireData = require('./exportFile');\r\nconsole.log(requireData); // {} 相当于引入了module.exports的初始值{}\r\nconsole.log(requireData.name); // undefined\r\n```\r\n### module.exports\r\n#### 使用module.exports添加属性的形式\r\n```\r\n// exportFile.js\r\nconst name = 'dyx';\r\nconst sayName = name => {\r\n  console.log(name);\r\n}\r\nmodule.exports.name = name;\r\nmodule.exports.sayName = sayName;\r\n\r\n// requireFile.js\r\nconst requireData = require('./exportFile');\r\nconsole.log(requireData); // { name: 'dyx', sayName: fn }\r\nconsole.log(requireData.name); // dyx\r\n```\r\n#### 使用module.exports直接赋值形式\r\n```\r\n// exportFile.js\r\nconst name = 'dyx';\r\nconst sayName = name => {\r\n  console.log(name);\r\n}\r\nmodule.exports = { name: name, sayName: sayName };\r\n\r\n// requireFile.js\r\nconst requireData = require('./exportFile');\r\nconsole.log(requireData); // { name: 'dyx', sayName: fn }\r\nconsole.log(requireData.name); // dyx\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## UMD\r\n- UMD是一种通用的模块定义规范，旨在使同一个模块能够在不同的环境中使用，包括浏览器、Node.js等。\r\n- UMD采用一种灵活的方式，既支持类似CommonJS的同步模块加载方式，也支持类似AMD的异步模块加载方式，同时兼容浏览器全局变量的使用。\r\n### UMD的实现\r\n> UMD 模块通常通过一定的判断逻辑来确定当前的模块加载环境，从而决定采用何种加载方式。这种灵活性使得开发者能够编写一次模块代码，然后在不同的环境中使用，无需修改代码。\r\n\r\n1. 先判断是否支持CommonJS2规范（exports是否存在以及module是否存在），存在则使用的是CommonJS2方式加载。\r\n2. 再判断是否支持AMD（define是否存在，因为AMD规范是通过define来定义模块的），存在则使用AMD方式加载模块。\r\n3. 其次判断是否支持CommonJS规范（exports是否存在），存在则使用的是CommonJS方式加载模块。\r\n4. 如果前面判断都不成立，则将模块公开到全局（window 或 global）。\r\n\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## 前端模块化\r\n> 实现“模块”功能的奥妙就在于JavaScript是一种函数式编程语言，它支持闭包。如果我们把一段JavaScript代码用一个函数包装起来，这段代码的所有“全局”变量就变成了函数内部的局部变量。ES6模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS和AMD模块，属于运行时加载，都只能在运行时确定这些东西。\r\n\r\n### 没有模块化时的使用\r\n> 通过`<script>`标签引入各个文件，把每个文件看成是一个模块，每个模块的接口通常是暴露在全局作用域下的，也就是定义在window对象中。通过这种方式做模块化，当项目变得越来越大时，很容易造成全局变量冲突，项目也会变得越来越难以管理。\r\n\r\n```\r\n<script src=\"module1.js\"><\/script>\r\n<script src=\"module2.js\"><\/script>\r\n<script src=\"module3.js\"><\/script>\r\n```\r\n### 为什么需要模块化\r\n> 模块化的开发方式可以提供代码复用率，方便进行代码的管理。一个模块有自己的作用域，只向外暴露特定的变量和函数。有了模块，我们就可以更方便地使用别人的代码，想要什么功能，就加载什么模块。\r\n\r\n- 减少全局变量污染\r\n- 控制依赖\r\n- 增强代码的可维护性\r\n- 增加代码的复用性\r\n### CommonJS\r\n> Node.js是commonJS规范的主要实践者，使用module.exports定义当前模块对外输出的接口（不推荐直接用exports），用require加载模块。\r\n\r\n```\r\n// a.js\r\nconst name = 'Bob'\r\nfunction sayHello(name) {\r\n console.log(`Hello ${name}`)\r\n}\r\nmodule.exports.name = name\r\nmodule.exports.sayHello = sayHello\r\n\r\n// b.js\r\nconst a = require('./a')\r\nconst name = a.name\r\nconsole.log(name) // Bob\r\na.sayHello(name) // Hello Bob\r\n```\r\n#### 特点\r\n- commonJS用同步的方式加载模块。在服务端模块文件都存在本地磁盘，读取非常快，所以这样做不会有问题。但是在浏览器端，限于网络原因，更合理的方案是使用异步加载。\r\n- 加载时执行，即脚本代码在require的时候，就会全部执行。\r\n#### module.exports和exports的区别\r\n> module.exports可以直接赋值,module.exports = function() {}; exports不可以直接赋值，只能添加方法或者属性,exports.add = function() {} ;\r\n\r\n1. module.exports 初始值为一个空对象 {}\r\n2. exports 是指向的 module.exports 的引用\r\n3. require() 返回的是 module.exports 而不是 exports\r\n4. 两者的关系为var exports = module.exports = {}; 给exports直接赋值是无效的，因为赋值后，module.exports仍然是空对象{}，因为直接给exports赋值，会直接改变exports的指向，并不会改变module.exports的值，而require() 返回的是 module.exports 而不是 exports，所以给exports赋值是不允许的。但是由于exports是module.exports的一个引用，因为引用类型的特性，以添加属性的形式改变exports的值同时module.exports的值也会改变，因为两者指向同一地址，所以require返回的内容就是修改后的内容。\r\n5. 建议使用module.exports可以避免某些问题\r\n#### commonJS是值的浅拷贝\r\n- 在模块外为简单类型赋值\r\n```\r\n// a.js\r\nlet val = 1;\r\nconst setVal = (newVal) => {\r\n  val = newVal;\r\n}\r\nmodule.exports = {\r\n  val,\r\n  setVal\r\n}\r\n\r\n// b.js\r\nconst { val, setVal } = require('./a.js');\r\nconsole.log(val); // 1\r\nsetVal(101);\r\nconsole.log(val); // 1\r\n```\r\n- 在模块外为引用类型赋值\r\n```\r\n// a.js\r\nlet obj = {\r\n  val: 1\r\n};\r\nconst setVal = (newVal) => {\r\n  obj.val = newVal;\r\n}\r\nmodule.exports = {\r\n  obj,\r\n  setVal\r\n}\r\n\r\n// b.js\r\nconst { obj, setVal } = require('./a.js');\r\nconsole.log(obj); // { val: 1 }\r\nsetVal(101);\r\nconsole.log(obj); // { val: 101 }\r\n```\r\n- 在模块内导出后改变简单类型\r\n```\r\n// a.js\r\nlet val = 1;\r\nsetTimeout(() => {\r\n  val = 101;\r\n}, 100);\r\nmodule.exports = {\r\n  val\r\n}\r\n\r\n// b.js\r\nconst { val } = require('./a.js')\r\nconsole.log(val); // 1\r\nsetTimeout(() => {\r\n  console.log(val); // 1\r\n}, 200)\r\n```\r\n- 在模块内导出后用 module.exports 再导出一次\r\n```\r\n// a.js\r\nsetTimeout(() => {\r\n  module.exports = {\r\n    val: 101\r\n  }\r\n}, 100);\r\nmodule.exports = {\r\n  val: 1\r\n}\r\n\r\n// b.js\r\nconst a = require('./a.js');\r\nconsole.log(a); // { val: 1 }\r\nsetTimeout(() => {\r\n  console.log(a); // { val: 1 }\r\n}, 200);\r\n```\r\n- 在模块内导出后用 exports 再导出一次\r\n```\r\n// a.js\r\nsetTimeout(() => {\r\n  module.exports.val = 101;\r\n}, 100)\r\nmodule.exports.val = 1;\r\n\r\n// b.js\r\nconst a = require('./a.js');\r\nconsole.log(a); // { val: 1 }\r\nsetTimeout(() => {\r\n  console.log(a); // { val: 101 }\r\n}, 200)\r\n```\r\n#### 值的拷贝\r\n> 其值拷贝发生在给 module.exports 赋值的那一刻。\r\n\r\n```\r\n// 做的事情仅仅是给 module.exports 赋予了一个新的对象，在这个对象里有一个key叫做val，这个val的值是当前模块中 val 的值\r\n\r\nlet val = 1;\r\nmodule.exports = {\r\n  val\r\n}\r\n```\r\n### AMD和require.js\r\n> AMD规范采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。依赖前置，能够异步加载模块, 适合在浏览器中运行, 但是不能够按需加载, 必须提前加载模块。不过require.js从2.0开始，也改成可以延迟执行（根据写法不同，处理方式不同）。\r\n\r\n```\r\nrequire([module], callback) // 导入模块\r\ndefine(id, [depends], callback) // 导出模块\r\n\r\n// 新建 a.js, 输入以下内容\r\ndefine(function() {\r\n  let alertName = function(str) {\r\n    alert('I am ' + str)\r\n  }\r\n  let alertAge = function(num) {\r\n    alert('I am ' + num + ' years old')\r\n  }\r\n  return {\r\n    alertName: alertName,\r\n    alertAge: alertAge\r\n  }\r\n})\r\n\r\n// 在 test.html 中调用 a 模块\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n  <head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\r\n    <title>Document</title>\r\n  </head>\r\n  <body>\r\n    <script src=\"./require.js\"><\/script>\r\n    <script>\r\n      require(['a'], function (alert) {\r\n        alert.alertName('JohnZhu')\r\n        alert.alertAge(21)\r\n      })\r\n    <\/script>\r\n  </body>\r\n</html>\r\n```\r\n### CMD和sea.js 实现。实现了按需加载。\r\n> CMD是另一种js模块化方案，它与AMD很类似，不同点在于：AMD推崇依赖前置、提前执行，CMD推崇依赖就近、延迟执行。\r\n\r\n```\r\n// 定义模块 math.js\r\ndefine(function(require, exports, module) {\r\n  var $ = require('jquery.js');\r\n  var add = function(a, b){\r\n    return a + b;\r\n  }\r\n  exports.add = add;\r\n});\r\n\r\n// 加载模块\r\nseajs.use(['math.js'], function(math) {\r\n  var sum = math.add(1, 2);\r\n});\r\n```\r\n### CMD和AMD区别\r\n> AMD 推崇依赖前置(在定义模块的时候就要声明其依赖的模块)、提前执行(AMD 在依赖模块加载完成后就直接执行依赖模块，依赖模块的执行顺序和我们书写的顺序不一定一致)，CMD推崇依赖就近(只有在用到某个模块的时候再去 require)、延迟执行(而 CMD 在依赖模块加载完成后并不执行，只是下载而已，等到所有的依赖模块都加载好后，进入回调函数逻辑，遇到 require 语句 的时候才执行对应的模块，这样模块的执行顺序就和我们书写的顺序保持一致了)。\r\n\r\n```\r\n// AMD写法\r\ndefine([\"./a\", \"./b\"], function(a, b) { \r\n  // 等于在最前面声明并初始化了要用到的所有模块\r\n  a.doSomething();\r\n  if (false) {\r\n    // 即便没用到某个模块 b，但 b 还是提前执行了\r\n    b.doSomething()\r\n  } \r\n});\r\n\r\n// CMD写法\r\ndefine(function(require, exports, module) {\r\n  var a = require('./a');\r\n  a.doSomething();\r\n  if (false) {\r\n    // 在需要使用时申明\r\n    var b = require('./b');\r\n    b.doSomething();\r\n  }\r\n});\r\n```\r\n\r\n\r\n\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## webpack插件上传sourcemap\r\n### 实现webpack插件\r\n```\r\nconst fs = require('fs');\r\nconst http = require('http');\r\nconst glob = require('glob');\r\nconst path = require('path');\r\n\r\nclass UploadSourceMapWebpackPlugin {\r\n  constructor(options) {\r\n    this.options = options;\r\n  }\r\n\r\n  // 调用http接口上传sourcemap文件\r\n  upload(url, file) {\r\n    return new Promise(resolve => {\r\n      const req = http.request(\r\n        `${url}?name=${path.basename(file)}`,\r\n        {\r\n          method: 'POST',\r\n          headers: {\r\n            'Content-Type': 'application/octet-stream',\r\n            Connection: \"keep-alive\",\r\n            \"Transfer-Encoding\": \"chunked\"\r\n          }\r\n        }\r\n      );\r\n\r\n      fs.createReadStream(file).on(\"data\", chunk => {\r\n        req.write(chunk);\r\n      }).on(\"end\", () => {\r\n        req.end();\r\n        resolve();\r\n      });\r\n    })\r\n  }\r\n\r\n  apply(compiler) {\r\n    // 定义在打包后执行\r\n    compiler.hooks.done.tap('upload-sourecemap-plugin', async status => {\r\n      // 读取sourcemap文件\r\n      const list = glob.sync(path.join(status.compilation.outputOptions.path, `./**/*.{js.map,}`));\r\n      for (let filename of list) {\r\n        await this.upload(this.options.uploadUrl, filename);\r\n      }\r\n    })\r\n  }\r\n}\r\n\r\nmodule.exports = UploadSourceMapWebpackPlugin;\r\n```\r\n### 使用webpack插件\r\n```\r\n// 上传sourcemap的插件\r\nconst UploadSourceMapWebpackPlugin = require('./plugin/uploadSourceMapWebPackPlugin');\r\n\r\nplugins: [\r\n  // 添加自动上传插件\r\n  new UploadSourceMapWebpackPlugin({\r\n    uploadUrl:'http://localhost:7001/monitor/sourcemap',\r\n    apiKey: 'dyxweb'\r\n  })\r\n]\r\n```\r\n### 服务端添加sourcemap上传接口\r\n```\r\nasync upload() {\r\n  const { ctx } = this;\r\n  const stream = ctx.req;\r\n  const filename = ctx.query.name;\r\n  const dir = path.join(this.config.baseDir, 'uploads');\r\n  // 判断upload目录是否存在\r\n  if (!fs.existsSync(dir)) {\r\n    fs.mkdirSync(dir);\r\n  }\r\n  const target = path.join(dir, filename);\r\n  const writeStream = fs.createWriteStream(target);\r\n  stream.pipe(writeStream);\r\n}\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## 前端监控\r\n1. 数据采集与上报\r\n2. 数据整理和存储\r\n3. 数据展示\r\n4. 监控告警\r\n### 数据采集\r\n1. 错误数据采集\r\n2. 接口请求错误数据采集\r\n3. 行为数据采集\r\n4. 性能数据采集\r\n### 数据上报\r\n#### 上报方法\r\n1. sendBeacon\r\n2. XMLHttpRequest\r\n3. image\r\n#### 上报时机\r\n1. 采用requestIdleCallback/setTimeout延时上报。\r\n2. 在beforeunload回调函数里上报。\r\n3. 缓存上报数据，达到一定数量后再上报。\r\n#### 三种方式结合上报\r\n1. 先缓存上报数据，缓存到一定数量后，利用requestIdleCallback/setTimeout延时上报。\r\n2. 在页面离开时统一将未上报的数据进行上报。\r\n### 参考文章\r\n- [https://juejin.cn/post/7017974567943536671](https://juejin.cn/post/7017974567943536671)\r\n- [https://juejin.cn/post/6987681953424080926](https://juejin.cn/post/6987681953424080926)\r\n- [https://juejin.cn/post/7172072612430872584](https://juejin.cn/post/7172072612430872584)\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## 性能数据采集\r\n### web-vitals\r\n- web-vitals库提供了非常简单的API获取各个性能指标数据。\r\n### FP、FCP数据采集\r\n```\r\nconst paintMonitor = () => {\r\n  if (!window.PerformanceObserver) {\r\n    return;\r\n  }\r\n\r\n  const entryHandler = list => {\r\n    for (const entry of list.getEntries()) {\r\n      if (entry.name === 'first-contentful-paint') {\r\n        observer.disconnect();\r\n      }\r\n      const json = entry.toJSON();\r\n      const reportData = {\r\n        type: 'performance',\r\n        subType: entry.name,\r\n        time: dayjs().format('YYYY-MM-DD HH:mm:ss'),\r\n        page: location.href,\r\n        data: JSON.stringify({\r\n          time: json.startTime\r\n        })\r\n      };\r\n      lazyReportCache(reportData);\r\n    }\r\n  };\r\n\r\n  const observer = new PerformanceObserver(entryHandler);\r\n  // buffered属性表示是否观察缓存数据，观察代码添加时机比事情触发时机晚也可以正常使用。\r\n  observer.observe({ type: 'paint', buffered: true });\r\n};\r\n```\r\n### LCP数据采集\r\n```\r\nconst lcpMonitor = () => {\r\n  if (!window.PerformanceObserver) {\r\n    return;\r\n  }\r\n\r\n  const entryHandler = list => {\r\n    for (const entry of list.getEntries()) {\r\n      const json = entry.toJSON();\r\n      const reportData = {\r\n        type: 'performance',\r\n        subType: entry.entryType,\r\n        time: dayjs().format('YYYY-MM-DD HH:mm:ss'),\r\n        page: location.href,\r\n        data: JSON.stringify({\r\n          time: json.startTime\r\n        })\r\n      };\r\n      lazyReportCache(reportData);\r\n    }\r\n    if (observer) {\r\n      observer.disconnect();\r\n    }\r\n  };\r\n\r\n  const observer = new PerformanceObserver(entryHandler);\r\n  // buffered属性表示是否观察缓存数据，观察代码添加时机比事情触发时机晚也可以正常使用。\r\n  observer.observe({ type: 'largest-contentful-paint', buffered: true });\r\n};\r\n```\r\n### DOMContentLoaded、load事件数据采集\r\n```\r\nconst onEvent = type => {\r\n  const callback = () => {\r\n    lazyReportCache({\r\n      type: 'performance',\r\n      subType: type,\r\n      time: dayjs().format('YYYY-MM-DD HH:mm:ss'),\r\n      page: location.href,\r\n      data: JSON.stringify({\r\n        time: performance.now()\r\n      })\r\n    });\r\n    window.removeEventListener(type, callback, true);\r\n  };\r\n  window.addEventListener(type, callback, true);\r\n};\r\n\r\nconst loadMonitor = () => {\r\n  ['load', 'DOMContentLoaded'].forEach(type => onEvent(type));\r\n};\r\n```\r\n### 浏览器往返缓存BFC(back/forward cache)\r\n- bfcache是一种内存缓存，它会将整个页面保存在内存中。当用户返回时可以马上看到整个页面，而不用再次刷新。部分浏览器才支持bfcache。\r\n- bfcache也是有缺点的，当用户返回并从bfcache中恢复页面时，原来页面的代码不会再次执行。为此浏览器提供了一个pageshow事件，可以把需要再次执行的代码放在里面。\r\n```\r\nwindow.addEventListener('pageshow', (event) => {\r\n  // 如果该属性为true，表示是从bfcache中恢复的页面\r\n  if (event.persisted) {\r\n    console.log('bfcache');\r\n  } else {\r\n    console.log('normally');\r\n  }\r\n}, true);\r\n```\r\n- 从bfcache中恢复的页面，收集FP、FCP、LCP各种时间。\r\n  1. 在pageshow事件触发后，用当前时间减去事件触发时间，这个时间差值就是性能指标的绘制时间。\r\n  2. 从bfcache中恢复的页面的这些性能指标值一般都很小，可以给它们加个标识字段bfc: true。\r\n```\r\nconst onBFCacheRestore = (callback) => {\r\n  window.addEventListener('pageshow', (event) => {\r\n    if (event.persisted) {\r\n      callback(event);\r\n    }\r\n  }, true);\r\n}\r\n\r\nonBFCacheRestore(event => {\r\n  requestAnimationFrame(() => {\r\n    ['first-paint', 'first-contentful-paint', 'largest-contentful-paint', 'load', 'DOMContentLoaded'].forEach(type => {\r\n      lazyReportCache({\r\n        type: 'performance',\r\n        subType: type,\r\n        time: dayjs().format('YYYY-MM-DD HH:mm:ss'),\r\n        page: location.href,\r\n        data: JSON.stringify({\r\n          bfc: true,\r\n          time: performance.now() - event.timeStamp,\r\n        })\r\n      });\r\n    })\r\n  })\r\n})\r\n```\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## 接口请求错误数据采集\r\n- 接口请求错误一般可分为两种，一种是http状态码错误类型比如接口请求404，还有一种是业务逻辑错误，http状态码正常，但是根据约定返回的响应数据格式判断为业务逻辑错误。\r\n### 接口请求的http错误上报\r\n```\r\nexport const httpErrorMonitor = error => {\r\n  const {\r\n    config: { url, method, data, params },\r\n    response: { status },\r\n    message\r\n  } = error;\r\n  lazyReportCache({\r\n    type: 'requestError',\r\n    subType: 'http',\r\n    time: dayjs().format('YYYY-MM-DD HH:mm:ss'),\r\n    page: location.href,\r\n    data: JSON.stringify({\r\n      path: url,\r\n      method,\r\n      status,\r\n      requestData: method === 'get' ? params : (data ? JSON.parse(data) : null),\r\n      message\r\n    })\r\n  });\r\n};\r\n```\r\n### 接口请求的业务错误上报\r\n```\r\nexport const businessErrorMonitor = error => {\r\n  const {\r\n    config: { url, method, data, params },\r\n    status,\r\n    data: { code, msg }\r\n  } = error;\r\n  lazyReportCache({\r\n    type: 'requestError',\r\n    subType: 'business',\r\n    time: dayjs().format('YYYY-MM-DD HH:mm:ss'),\r\n    page: location.href,\r\n    data: JSON.stringify({\r\n      path: url,\r\n      method,\r\n      status,\r\n      requestData: method === 'get' ? params : (data ? JSON.parse(data) : null),\r\n      message: msg,\r\n      businessCode: code,\r\n    })\r\n  });\r\n};\r\n```\r\n### 以axios为例上报请求错误\r\n```\r\nimport axios from 'axios';\r\nimport { message } from 'antd';\r\nimport qs from 'qs';\r\n\r\nconst request = axios.create({\r\n  baseURL: '',\r\n  timeout: 300000,\r\n  paramsSerializer: function (params) {\r\n    return qs.stringify(params, { arrayFormat: 'brackets' });\r\n  }\r\n});\r\n\r\nrequest.interceptors.response.use(\r\n  response => {\r\n    const {\r\n      data: { code, msg }\r\n    } = response;\r\n    if (code && code !== 0) {\r\n      message.warning(msg);\r\n      // code非0表示接口业务逻辑错误\r\n      businessErrorMonitor(response);\r\n    }\r\n    return response;\r\n  },\r\n  error => {\r\n    message.error(error.message || '请求失败，请重试');\r\n    // 接口请求http错误\r\n    httpErrorMonitor(error);\r\n    return Promise.reject(error);\r\n  }\r\n);\r\n\r\nexport default request;\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## 数据上报\r\n### 上报方法\r\n> 使用sendBeacon方法会异步地向服务器发送数据，同时不会延迟页面的卸载或影响下一导航的载入性能。在不支持sendBeacon的浏览器下可以使用XMLHttpRequest来进行上报，在beforeunload用XMLHttpRequest发送30kb的数据(一般待上报数据很少会有这么大)都可以成功发出去。\r\n\r\n1. sendBeacon\r\n2. XMLHttpRequest\r\n3. image\r\n### 上报时机\r\n> 建议将以下方式结合一起上报，先缓存上报数据缓存到一定数量后利用requestIdleCallback/setTimeout延时上报。在页面离开时统一将未上报的数据进行上报。\r\n\r\n1. 采用requestIdleCallback/setTimeout延时上报。\r\n2. 在beforeunload回调函数里上报。\r\n3. 缓存上报数据，达到一定数量后再上报。\r\n### 上报逻辑\r\n- 缓存数据\r\n```\r\nimport { deepCopy } from './utils';\r\n\r\nconst cache = [];\r\n\r\nexport const getCache = () => {\r\n  return deepCopy(cache);\r\n}\r\n\r\nexport const addCache = (data) => {\r\n  cache.push(data);\r\n}\r\n\r\nexport const clearCache = () => {\r\n  cache.length = 0;\r\n}\r\n```\r\n- 上报方法\r\n```\r\n// 上报的配置信息\r\nconst config = {\r\n  // ...\r\n}\r\n\r\n// 使用XMLHttpRequest上报\r\nexport const reportWithXHR = (url, data) => {\r\n  const xhr = new XMLHttpRequest();\r\n  xhr.open('post', url);\r\n  // 设置Content-Type为application/json才能被eggjs的post请求正常解析\r\n  xhr.setRequestHeader('Content-Type', 'application/json');\r\n  xhr.send(JSON.stringify(data));\r\n};\r\n\r\n// 兼容处理上报方法\r\nconst sendBeacon = (url, reportData) => {\r\n  if (window.navigator?.sendBeacon) {\r\n    // sendBeacon发送json格式数据\r\n    const blob = new Blob([JSON.stringify(reportData)], {\r\n      type: 'application/json; charset=UTF-8'\r\n    });\r\n    window.navigator.sendBeacon(url, blob);\r\n  } else {\r\n    reportWithXHR(url, reportData);\r\n  }\r\n};\r\n\r\n// 上报方法\r\nexport const report = (data, isImmediate = false) => {\r\n  const { url, appKey, userId, userPhone } = config;\r\n  // 上报信息\r\n  let reportData = null;\r\n  // 兼容处理直接上报和缓存数据上报(数组格式)两种形式\r\n  if (Array.isArray(data)) {\r\n    reportData = data.map(item => {\r\n      return {\r\n        appKey,\r\n        userId,\r\n        userPhone,\r\n        ...item\r\n      };\r\n    });\r\n  } else {\r\n    reportData = {\r\n      appKey,\r\n      userId,\r\n      userPhone,\r\n      ...data\r\n    };\r\n  }\r\n  // 立即上报\r\n  if (isImmediate) {\r\n    sendBeacon(url, reportData);\r\n    return;\r\n  }\r\n\r\n  // 兼容处理延时上报逻辑\r\n  if (window.requestIdleCallback) {\r\n    window.requestIdleCallback(\r\n      () => {\r\n        sendBeacon(url, reportData);\r\n      },\r\n      { timeout: 3000 }\r\n    );\r\n  } else {\r\n    setTimeout(() => {\r\n      sendBeacon(url, reportData);\r\n    });\r\n  }\r\n};\r\n\r\n// 缓存部分数据后再上报\r\nlet timer = null;\r\nexport const lazyReportCache = (data, timeout = 3000) => {\r\n  addCache(data);\r\n  clearTimeout(timer);\r\n  timer = setTimeout(() => {\r\n    const data = getCache();\r\n    if (data.length) {\r\n      report(data);\r\n      clearCache();\r\n    }\r\n  }, timeout);\r\n};\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## 行为数据采集\r\n### 用户行为信息上报通用方法\r\n```\r\nconst behaviorMonitor = (subType, data) => {\r\n  lazyReportCache({\r\n    type: 'behavior',\r\n    subType,\r\n    time: getTime(),\r\n    page: getPage(),\r\n    data: JSON.stringify(data)\r\n  });\r\n};\r\n```\r\n### PV、UV数据采集\r\n- PV(page view)是页面浏览量，UV(Unique visitor)用户访问量。PV只要访问一次页面就算一次，UV同一天内多次访问只算一次。\r\n- 对于前端来说，只要每次进入页面上报一次PV就行，UV可以根据PV的数据统计出来。\r\n```\r\nbehaviorMonitor('pv', {});\r\n```\r\n### 点击数据采集\r\n```\r\nbehaviorMonitor('click', {});\r\n```\r\n### 页面跳转数据采集(单页应用)\r\n- 利用addEventListener()监听popstate、hashchange页面跳转事件。\r\n- popstate事件只会在浏览器某些行为下触发, 比如点击后退、前进按钮或者调用history.back()、history.forward()、history.go()方法。\r\n- history.pushState()或者history.replaceState()改变路由不会触发popstate事件。通过dispatchEvent改写这两个方法实现对这两个方法的监听。\r\n```\r\nexport const pageChangeMonitor = () => {\r\n  let from = window.location.href;\r\n\r\n  // 第一次加载页面上报pv信息\r\n  behaviorMonitor(\r\n    'pv',\r\n    { pageKey: from }\r\n  );\r\n\r\n  // 监听popstate事件\r\n  window.addEventListener('popstate', () => {\r\n    const to = window.location.href; // 获取跳转后的页面路径\r\n    // 上报页面跳转信息\r\n    behaviorMonitor(\r\n      'pageChange',\r\n      { fromPageKey: from, toPageKey: to } \r\n    );\r\n    // 上报pv信息\r\n    behaviorMonitor(\r\n      'pv',\r\n      { pageKey: to }\r\n    );\r\n    from = to;\r\n  }, true);\r\n  \r\n  // 监听hashchange事件\r\n  window.addEventListener('hashchange', event => {\r\n    const { oldURL, newURL}  = event; // 获取跳转后的页面路径\r\n    // 上报页面跳转信息\r\n    behaviorMonitor(\r\n      'pageChange',\r\n      { fromPageKey: oldURL, toPageKey: newURL }\r\n    );\r\n    // 上报pv信息\r\n    behaviorMonitor(\r\n      'pv',\r\n      { pageKey: newURL }\r\n    );\r\n  }, true);\r\n\r\n  const _wr = (type) => {\r\n    const orig = history[type];\r\n    return function () {\r\n      const rv = orig.apply(this, arguments);\r\n      const e = new Event(type);\r\n      e.arguments = arguments;\r\n      window.dispatchEvent(e);\r\n      return rv;\r\n    }\r\n  }\r\n\r\n  // 重写pushState、replaceState事件可以被监听到\r\n  history.pushState = _wr('pushState');\r\n  history.replaceState = _wr('replaceState');\r\n  ['pushState', 'replaceState'].forEach(item => {\r\n    window.addEventListener(item, () => {\r\n      const to = window.location.href; // 获取跳转后的页面路径\r\n      // 上报页面跳转信息\r\n      behaviorMonitor(\r\n        'pageChange',\r\n        { fromPageKey: from, toPageKey: to }\r\n      );\r\n      // 上报pv信息\r\n      behaviorMonitor(\r\n        'pv',\r\n        { pageKey: to }\r\n      );\r\n      from = to;\r\n    });\r\n  })\r\n}\r\n```\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## 解析错误信息源码\r\n- 解析源码使用source-map插件，直接使用error信息的source字段对应的文件可能无法解析到源码(webpack分包情况下)，可以使用error的stack堆栈信息的第一条对应的文件进行解析。\r\n- 使用error-stack-parser插件解析error的stack堆栈信息。\r\n```\r\nconst sourceMap = require(\"source-map\");\r\nconst ErrorStackParser = require('error-stack-parser');\r\nconst fs = require(\"fs\");\r\n\r\n// 解析错误堆栈信息(errorStack为js错误信息的stack字段内容)\r\nconst errorStackData = ErrorStackParser.parse(new Error(errorStack));\r\nconst { fileName, lineNumber, columnNumber } = errorStackData?.[0] || {};\r\nif (fileName.split('/').pop()) {\r\n  // 读取对应的.js.map文件\r\n  const mapObj = fs.readFileSync(`${__dirname}/../public/static/js/${fileName.split('/').pop()}.map`, 'utf-8');\r\n  const consumer = await new sourceMap.SourceMapConsumer(mapObj);\r\n  // 根据报错信息映射出报错的源文件和错误的行数、列数\r\n  const originalInfo = consumer.originalPositionFor({ line: lineNumber, column: columnNumber });\r\n  // 获取报错源文件的代码\r\n  const sourceCode = consumer.sourceContentFor(originalInfo.source);\r\n  // 错误源码信息\r\n  const errorSource = {\r\n    ...originalInfo,\r\n    sourceCode,\r\n  }\r\n}\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## 错误数据采集\r\n### js错误使用window.onerror捕获\r\n- window.onerror可以捕获常规运行时的错误。\r\n- window.onerror可以捕获异步错误(setTimeout)。\r\n- window.onerror无法捕获资源错误和promise的错误。\r\n```\r\nwindow.onerror = (message, source, lineno, colno, error) => {\r\n  // 上报错误\r\n  lazyReportCache({\r\n    type: 'error',\r\n    subType: 'js',\r\n    time: dayjs().format('YYYY-MM-DD HH:mm:ss'),\r\n    page: location.href,\r\n    data: JSON.stringify({\r\n      message,\r\n      source,\r\n      lineno,\r\n      colno,\r\n      // 错误栈\r\n      errorStack: error.stack\r\n    })\r\n  });\r\n}\r\n```\r\n### 资源加载错误使用window.addEventListener('error', () => {})捕获\r\n- js的错误也能被window.addEventListener('error', () => {})捕获到，判断触发错误的事件对象当只有资源加载错误时才处理。\r\n- 当一项资源(图片或脚本)加载失败，加载资源的元素会触发一个Event接口的error事件，error事件不会向上冒泡到window，window.onerror不能捕获到，可以通过window.addEventListener('error', () => {})捕获资源加载错误。\r\n- window.addEventListener('error', () => {})不能捕获new Image的错误，new Image的错误可以单独处理。\r\n- window.addEventListener('error', () => {})不能捕获promise的错误。\r\n```\r\nwindow.addEventListener('error', e => {\r\n  const target = e.target;\r\n  if (!target) return;\r\n  // 判断是否为资源加载错误\r\n  if (target.src || target.href) {\r\n    const url = target.src || target.href;\r\n    lazyReportCache({\r\n      type: 'error',\r\n      subType: 'resource',\r\n      time: dayjs().format('YYYY-MM-DD HH:mm:ss'),\r\n      page: location.href,\r\n      data: JSON.stringify({\r\n        message: `${url} 资源加载失败`,\r\n        url,\r\n        html: target.outerHTML,\r\n        resourceType: target.tagName\r\n      })\r\n    });\r\n  }\r\n}, true);\r\n```\r\n### promise错误使用window.addEventListener('unhandledrejection', () => {})捕获\r\n```\r\nwindow.addEventListener('unhandledrejection', e => {\r\n  lazyReportCache({\r\n    type: 'error',\r\n    subType: 'promise',\r\n    time: dayjs().format('YYYY-MM-DD HH:mm:ss'),\r\n    page: location.href,\r\n    data: JSON.stringify({\r\n      message: e.reason?.message,\r\n      // 错误栈\r\n      errorStack: e.reason?.stack\r\n    })\r\n  });\r\n})\r\n```\r\n### React错误\r\n- React错误可以通过onerror和error事件监听捕获到，通过componentDidCatch声明一个错误边界组件在页面崩溃时显示回退UI，同时在错误边界组件(ErrorBoundary)中上报错误。\r\n- ErrorBoundary只捕捉发生在React生命周期中的错误，不会捕捉React事件处理、异步代码、ErrorBoundary自己抛出的错误。\r\n- [react的错误开发环境会触发两次，生产环境正常触发一次。](https://github.com/facebook/react/issues/11499)\r\n- [antd的Form的onFinish方法中的错误无法被捕获到](https://github.com/ant-design/ant-design/issues/33876)。\r\n```\r\nclass ErrorBoundary extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = { hasError: false };\r\n  }\r\n\r\n  static getDerivedStateFromError(error) {\r\n    // 更新state使下一次渲染能够显示降级后的UI\r\n    return { hasError: true };\r\n  }\r\n\r\n  componentDidCatch(error) {\r\n    lazyReportCache({\r\n      type: 'error',\r\n      subType: 'react',\r\n      time: dayjs().format('YYYY-MM-DD HH:mm:ss'),\r\n      page: location.href,\r\n      data: JSON.stringify({\r\n        message: error?.message,\r\n        errorStack: error?.stack\r\n      })\r\n    });\r\n  }\r\n\r\n  render() {\r\n    if (this.state.hasError) {\r\n      // 自定义的降级UI\r\n      return <h1>Something went wrong.</h1>;\r\n    }\r\n    return this.props.children; \r\n  }\r\n}\r\n\r\n// 使用ErrorBoundary包裹根组件<App />\r\nconst root = ReactDOM.createRoot(document.getElementById('root') as Element);\r\nroot.render(<ErrorBoundary><App /></ErrorBoundary>);\r\n```\r\n### Vue错误\r\n- 由于Vue会捕获所有Vue单文件组件或者Vue.extend继承的代码，所以在Vue里面出现的错误，并不会直接被window.onerror捕获，而是会抛给Vue.config.errorHandler。\r\n- 可以在Vue.config.errorHandler中将捕获到的错误直接throw给onerror处理。\r\n```\r\nVue.config.errorHandler = (err) => {\r\n  setTimeout(() => {\r\n    throw err\r\n  })\r\n}\r\n```\r\n### 同步错误捕获\r\n- 同步错误可以使用window.onerror和window.addEventListener('error')两种方法捕获。\r\n- addEventListener不像window.onerror会被重新覆盖。\r\n- addEventListener可以处理静态资源错误且触发优先级高于window.onerror。\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## [React Profiler](https://juejin.cn/post/7008337341634854942)\r\n- React Developer Tools提供的Profiler可以直观的帮助我们找出React项目中的性能瓶颈，可以从浏览器扩展中安装使用。\r\n- Profiler主要测量和记录React组件渲染阶段的性能数据，而不是提交阶段的性能数据。\r\n### 面板基本功能\r\n- 顶部按钮：开始/结束、重置并开始、清除信息。\r\n- 图表显示类型：火焰图、排序图、时间线。\r\n- 设置按钮：\r\n  - General: Highlight updates when components render. 高亮发生更新的组件。\r\n  - Profiler: Record each component rendered while profiling. 记录组件更新的原因。\r\n### Commit information\r\n> 点击更新柱状图(不选择某个组件)显示右侧Commit information。\r\n\r\n- Committed at表示相对于本次record的时间，可以忽略。\r\n- Durations中的Render表示本次更新耗时(对应react的Render阶段，生成新的虚拟DOM)，重点关注指标。\r\n![Commit information](./img/Commit%20information.png)\r\n### 在火焰图中选择某个组件时右侧显示的组件信息\r\n- Why did this render? 表示组件渲染的原因，state/props变化、hooks变化等原因。\r\n- Rendered at 表示组件在记录时间段内所有的渲染信息。\r\n![组件信息](./img/组件信息.png)\r\n\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## Redux DevTools\r\n> 浏览器安装对应扩展之后，需要在react应用中配置才能正常使用该扩展。\r\n\r\n### 无侵入性的使用\r\n- 不使用redux中间件的简单形式\r\n```\r\nimport { createStore } from 'redux';\r\n\r\nconst store = createStore(\r\n  rootReducers,\r\n  window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__()\r\n);\r\n```\r\n- 使用redux中间件\r\n```\r\nimport { createStore, applyMiddleware, compose } from 'redux';\r\nimport reduxThunk from 'redux-thunk';\r\n\r\nconst composeEnhancers: any = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose;\r\nconst store = createStore(\r\n  rootReducers,\r\n  composeEnhancers(applyMiddleware(reduxThunk))\r\n);\r\n```\r\n- 只在开发环境使用\r\n```\r\nimport { createStore, applyMiddleware, compose } from 'redux';\r\nimport reduxThunk from 'redux-thunk';\r\n\r\nconst composeEnhancers: any = process.env.NODE_ENV === 'development' ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose : compose;\r\nconst store = createStore(\r\n  rootReducers,\r\n  composeEnhancers(applyMiddleware(reduxThunk))\r\n);\r\n```\r\n### 侵入性使用\r\n- 安装@redux-devtools/extension依赖\r\n```\r\nyarn add @redux-devtools/extension\r\n```\r\n- 不使用redux中间件的简单形式\r\n```\r\nimport { createStore } from 'redux';\r\nimport { composeWithDevTools } from '@redux-devtools/extension';\r\n\r\nconst store = createStore(\r\n  rootReducers,\r\n  composeWithDevTools()\r\n);\r\n```\r\n- 使用redux中间件\r\n```\r\nimport { createStore, applyMiddleware } from 'redux';\r\nimport reduxThunk from 'redux-thunk';\r\nimport { composeWithDevTools } from '@redux-devtools/extension';\r\n\r\nconst store = createStore(\r\n  rootReducers,\r\n  composeWithDevTools(applyMiddleware(reduxThunk))\r\n);\r\n```\r\n- 只在开发环境使用\r\n```\r\nimport { createStore, applyMiddleware } from 'redux';\r\nimport reduxThunk from 'redux-thunk';\r\nimport { composeWithDevTools } from '@redux-devtools/extension/src/developmentOnly';\r\n\r\nconst store = createStore(\r\n  rootReducers,\r\n  composeWithDevTools(applyMiddleware(reduxThunk))\r\n);\r\n```"},function(r,n,e){"use strict";e.r(n),n.default='## inspect调试\r\n1. 手机开启开发者模式，打开USB调试功能，手机通过USB数据线连接电脑。\r\n2. 电脑上打开Chrome浏览器，打开地址[chrome://inspect](chrome://inspect)。\r\n3. 在浏览器中的Devices下方能够找到连接的手机设备。确保已勾选"Discover USB Devices"或"Discover network targets"。（根据连接方式不同，可能有所不同）。\r\n4. 在手机浏览器打开H5页面或者打开APP WebView中加载的H5页面。在浏览器中能够看到手机设备下方出现的网页链接，点击"inspect"来打开开发者工具进行调试。\r\n### 问题记录\r\n- 手机网页需要是在chrome内核的浏览器中打开，只有chrome内核（Android浏览器和Android WebView大多都是chrome内核）打开的H5页面才支持inspect，比如微信的浏览器内核是X5，是不支持inspect的。\r\n- 电脑chrome打开chrome://inspect页面，手机通过USB连接电脑，注意需要是数据线，有的USB只支持充电不支持传输数据。\r\n- 手机打开USB调试，USB连接需要选择传输文件。\r\n- 如果点击inspect显示HTTP/1.1 404 Not Found是因为网络限制，需要使用VPN或者使用edge浏览器调试[edge://inspect/#devices](edge://inspect/#devices)。 \r\n- 如果一切正常，手机会弹出是否允许调试弹窗，选择允许。\r\n- 如果不是常用设备选择始终允许调试可能会导致inspect能够找到连接的手机设备但是显示offline，这是因为手机无法弹出调试弹窗导致的，需要打开终端安装adb并运行以下命令。\r\n```\r\nadb kill-server\r\n\r\nadb start-server\r\n\r\n// 以下命令查看手机设备连接情况\r\nadb devices\r\n```\r\n### Android WebView支持通过chrome://inspect调试H5页面\r\n1. 首先在app/src/main/AndroidManifest.xml设置允许对app debug。\r\n```\r\n\x3c!--添加以下两个属性--\x3e\r\n<application\r\n  android:debuggable="true"\r\n  tools:ignore="HardcodedDebugMode"\r\n>\r\n```\r\n2. 使用setWebContentsDebuggingEnabled方法在WebView中启用调试模式。\r\n'},function(r,n,e){"use strict";e.r(n),n.default="## [whistle](http://wproxy.org/whistle/)\r\n> 跨平台抓包调试代理工具。\r\n\r\n### 安装启动\r\n- 全局安装：npm install whistle -g\r\n- 启动：w2 start\r\n- 关闭：w2 stop\r\n### 移动端配置代理抓包\r\n1. 电脑安装证书，手机也要安装证书。\r\n2. 手机WIFI的代理设置改为手动，设置主机名和端口(whistle的online选项查看即可)。此时就可以正常抓包。\r\n### 设置域名映射，应用本地代码进行实时调试。\r\n1. rules中新建类目。\r\n2. 添加对应映射规则，比如将百度的网址映射为本地，添加https://baidu.com/  http://localhost:3000/即可。\r\n### 设置代理\r\n- 使用w2 proxy命令设置代理。\r\n- 关闭whistle后无法正常访问网站，可以使用w2 proxy off命令关闭，或者电脑设置 => 网络和Internet => 代理 => 手动设置代理 => 关闭代理服务器。"},function(r,n,e){"use strict";e.r(n),n.default="## 微信h5调试\r\n### Android\r\n> x5内核 + chrome://inspect\r\n\r\n1. 手机微信进入[http://debugmm.qq.com/?forcex5=true](http://debugmm.qq.com/?forcex5=true)。\r\n2. 手机微信进入[http://debugx5.qq.com](http://debugx5.qq.com)选择打开，打开TBS内核Inspector调试功能。\r\n3. USB连接手机、电脑，打开开发者模式以及打开USB调试。\r\n4. Chrome中进入chrome://inspect/#devices页面，Devices页面下有对应的Devices Tab，选择对应的网址点击inspect即可开启调试。\r\n5. 想要应用本地的代码，直接在inspect中的location.href指向本地IP的地址即可。"},function(r,n,e){"use strict";e.r(n),n.default="## 修改线上代码调试\r\n> 发布到线上的代码如果存在问题，如果可以直接修改线上的代码进行调试，就可以避免本地修改代码发布到正式环境验证不通过反复发布测试的问题。\r\n\r\n- 在电脑创建一个空的文件夹，用于存储修改后的代码文件。\r\n- 打开Sources面板找到Overrides页签点击+Select folder for overrides选择刚刚创建的空文件夹。选择了文件夹后浏览器上方会有个提示，点击允许。\r\n- 在Sources面板的Page页签中找到要修改的代码文件右键点击选择Override content后，可以编辑文件。\r\n- 编辑文件然后ctrl+s直接保存，修改的文件就会保存到刚刚创建的空文件夹中。保存到本地的代码，在本地修改代码后刷新浏览器也会自动应用本地修改后的代码。\r\n- 刷新页面后会发现刚修改的内容已经生效。\r\n- 在Sources面板的Overrides页签点击Clear configuration会移除Overrides添加的目录，取消使用修改后的代码。"},function(r,n,e){"use strict";e.r(n),n.default="## 断点调试\r\n### 普通代码断点\r\n- Sources面板下搜索对应的文件。\r\n- 在想断住的那一行左侧单击一下就可以添加一个断点，运行到该处就会断住。\r\n### 条件断点\r\n- 右键单击代码所在的行左侧，会出现一个下拉框，点击Add conditional breakpoint可以添加一个条件断点。\r\n- 输入条件表达式，当运行到这一行代码并且表达式的值为真时就会断住。\r\n### DOM断点\r\n- 在Elements面板的对应元素上右键，选择break on可以添加一个DOM断点。\r\n- 当子树有变动、属性有变动、节点移除的时候会断住。\r\n### 异常断点\r\n- 在Debugger面板勾选Pause on uncaught exceptions和Pause on caught exceptions可以添加异常断点，在抛出异常未被捕获或者被捕获时断住。\r\n- 用来调试一些发生异常的代码时很有用。\r\n### 接口打断点\r\n- 在Debugger面板的XHR/fetch Breakpoints中添加想要断点的接口即可。"},function(r,n,e){"use strict";e.r(n),n.default="## 生产环境使用本地sourcemap调试\r\n> 由于生产环境不会上传sourcemap文件，所以当线上项目有错误信息时无法精准定位到源代码，只能定位到打包后混淆的代码。可以通过本地sourcemap调试从而精准定位到源代码。\r\n\r\n- 打开Sources面板找到Workspace页签，点击Add folder可以将本地包含sourcemap的目录添加进去(注意本地生成sourcemap时保证和线上环境代码一致)。\r\n- 在Sources面板的Page页签下打开指定的打包后混淆的代码文件。\r\n- 在打开的打包后混淆的代码文件中右键选择Add source map，将该文件对应的sourcemap文件路径(可以在Workspace页签对应的sourcemap文件右键选择Copy link address复制路径)添加进去即可。\r\n- 添加之后可以根据控制台错误信息精准定位到源代码(浏览器刷新之后需要重新执行Add source map步骤)。"},function(r,n,e){"use strict";e.r(n),n.default="## 线上问题调试\r\n- 本地没问题线上有问题，一部分原因是因为线上接口数据有问题，如果不是接口数据问题，那么可能是前端代码问题。\r\n### Ajax Interceptor\r\n- 一个谷歌插件，可以拦截页面上的Ajax请求，并把返回结果替换成任意文本。可以使用该插件将本地环境调用的接口返回数据改为和线上接口返回数据一致。\r\n- 具体操作：\r\n    1. 下载插件。\r\n    2. 点击插件图标。\r\n    3. 把想要修改的接口URL地址复制到输入框中，然后把返回的内容放到下面的文本框。\r\n### 线上环境 + 本地的source-map文件\r\n- 具体操作参考**生产环境使用本地sourcemap调试**文件内容。\r\n  "},function(r,n,e){"use strict";e.r(n),n.default="## docker部署项目\r\n- 可以备份镜像，实现快速回滚。\r\n### 基本流程\r\n1. 在项目里维护Dockerfile及相关配置文件。\r\n2. 执行docker build构建镜像。\r\n3. push到镜像仓库。\r\n4. 部署的时候pull下来镜像用docker run跑起来。\r\n### 项目根目录添加nginx配置文件\r\n```\r\n// default.conf\r\nserver {\r\n  # 监听端口\r\n  listen       80;\r\n\r\n  # 配置服务ip\r\n  server_name  ip;\r\n\r\n  # nginx默认request header中包含的下划线_的请求头会自动忽略。\r\n  underscores_in_headers on;\r\n\r\n  # 开启gzip压缩功能\r\n  gzip on;\r\n\r\n  # 指定会被压缩的文件类型\r\n  gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/json;\r\n\r\n  # 设置压缩级别，越高资源消耗越大，但压缩效果越好\r\n  gzip_comp_level 5;\r\n\r\n  # 在头部中添加Vary: Accept-Encoding（建议开启）\r\n  gzip_vary on;\r\n  \r\n  # 处理压缩请求的缓冲区数量和大小\r\n  gzip_buffers 16 8k;\r\n\r\n  # 对于不支持压缩功能的客户端请求不开启压缩机制\r\n  gzip_disable \"MSIE [1-6]\\.\"; # 低版本的IE浏览器不支持压缩\r\n\r\n  # 设置压缩响应所支持的HTTP最低版本\r\n  gzip_http_version 1.1;\r\n\r\n  # 设置触发压缩的最小阈值\r\n  gzip_min_length 2k;\r\n\r\n  # 关闭对后端服务器的响应结果进行压缩\r\n  gzip_proxied off;\r\n\r\n  # 配置前端静态资源http缓存\r\n  location / {\r\n    # 指定根目录\r\n    root   /home/admin/build;\r\n    index  index.html index.htm;\r\n    try_files $uri $uri/ /index.html;\r\n\r\n    # index.html使用协商缓存\r\n    add_header Cache-Control 'no-cache';\r\n\r\n    if ($request_uri ~* .*[.](js|css|map|jpg|png|svg|ico)$) {\r\n      # 非html资源强缓存1个月\r\n      add_header Cache-Control \"max-age=2592000\";\r\n    }\r\n\r\n    if ($request_filename ~* ^.*[.](html|htm)$) {\r\n      # html使用协商缓存\r\n      add_header Cache-Control \"no-cache\";\r\n    }\r\n  }\r\n\r\n  # 接口请求代理\r\n  location /api {\r\n    proxy_pass http://ip;\r\n  }\r\n}\r\n```\r\n### 项目根目录添加docker配置文件\r\n> 定义构建镜像的时候基于 Dockerfile 来构建\r\n\r\n```\r\n// Dockerfile\r\n# 该镜像是基于 nginx:latest 镜像而构建的\r\nFROM nginx:latest\r\n\r\n# 将项目根目录下build文件夹下的所有文件复制到镜像中 /home/admin/build/ 目录下\r\nCOPY build/ /home/admin/build/\r\n\r\n# 将项目根目录下default.conf复制到镜像中 etc/nginx/conf.d/default.conf，用本地的 default.conf 配置来替换 Nginx 镜像里的默认配置。\r\nCOPY default.conf /etc/nginx/conf.d/default.conf\r\n```\r\n### 上传打包后的前端静态资源以及相关配置文件\r\n> 将打包后的前端静态资源文件夹build、nginx配置文件default.conf、docker配置文件Dockerfile，使用ftp文件传输工具上传到 /home/admin/ 目录下。\r\n\r\n### 构建镜像(添加镜像tag方便回滚)\r\n```\r\n// 镜像名admin，镜像tag 0.0.1\r\ndocker build -t admin:0.0.1 .\r\n```\r\n### 启动容器\r\n- 将宿主的80端口映射到容器的80端口\r\n- --name admin 容器名为admin\r\n- admin:0.0.1 使用镜像名为admin的 0.0.1 tag版本\r\n```\r\ndocker run -dp 80:80 --name admin admin:0.0.1\r\n```\r\n### 使用node脚本发布\r\n- 安装ssh2-sftp-client ssh2依赖\r\n```\r\nnpm install ssh2-sftp-client ssh2 -D\r\n```\r\n- deploy脚本\r\n```\r\n// deploy.js\r\nconst { Client } = require('ssh2');\r\nconst Sftp = require('ssh2-sftp-client');\r\n\r\nconst conn = new Client();\r\nconst sftp = new Sftp();\r\n\r\n// 根据命令获取部署的版本\r\nconst params = process.argv || [];\r\nconst deployVersion = params[2];\r\nconst romotePath = '/home/admin/';\r\nconst config = {\r\n  name: 'admin',\r\n  ssh: {\r\n    host: '服务ip',\r\n    port: 22,\r\n    username: 'root',\r\n    password: 'password',\r\n  },\r\n  romotePath,\r\n  localPath: './build',\r\n};\r\n\r\n// docker部署\r\nfunction dockerDeploy() {\r\n  conn.on('ready', () => {\r\n    console.log('部署准备');\r\n    conn.shell((err, stream) => {\r\n      if (err) {\r\n        console.log('部署失败');\r\n        conn.end();\r\n        console.log('部署连接断开');\r\n      };\r\n      stream.on('close', () => {\r\n        console.log('部署成功');\r\n        conn.end();\r\n        console.log('部署连接断开');\r\n      }).on('data', (data) => {\r\n        console.log('OUTPUT: ' + data);\r\n      });\r\n      stream.end(`cd /home/admin/\r\n        docker build -t admin:${deployVersion} .\r\n        docker rm -f admin\r\n        docker run -dp 80:80 --name admin admin:${deployVersion}\r\n        exit\r\n      `);\r\n    });\r\n  }).connect(config.ssh);\r\n}\r\n\r\nfunction deploy() {\r\n  console.log(`您选择了上传${config.name}`);\r\n  // 更新前端静态资源以及相关配置文件\r\n  sftp.connect(config.ssh).then(() => {\r\n    console.log('连接成功，上传中..');\r\n    return Promise.all([\r\n      sftp.delete(`${config.romotePath}/default.conf`, true),\r\n      sftp.delete(`${config.romotePath}/Dockerfile`, true),\r\n      sftp.rmdir(`${config.romotePath}/build`, true),\r\n    ]);\r\n  }).then(() => {\r\n    return Promise.all([\r\n      sftp.uploadDir('./build', `${config.romotePath}/build`),\r\n      sftp.fastPut('./default.conf', `${config.romotePath}/default.conf`),\r\n      sftp.fastPut('./Dockerfile', `${config.romotePath}/Dockerfile`),\r\n    ]);\r\n  }).then(() => {\r\n    console.log('上传成功');\r\n    dockerDeploy();\r\n  }).catch(err => {\r\n    console.log(err, '上传失败');\r\n  }).finally(() => {\r\n    sftp.end(); // 断开连接\r\n    console.log('上传连接断开');\r\n  })\r\n}\r\n\r\ndeploy();\r\n```\r\n- 添加npm脚本\r\n```\r\n// package.json\r\n\"scripts\": {\r\n  \"deploy\": \"npm run build && node deploy.js\"\r\n}\r\n```\r\n- 使用部署脚本(添加版本参数)\r\n```\r\nnpm run deploy 0.0.1\r\n```"},function(r,n,e){"use strict";e.r(n),n.default='## gitlab runner部署项目\r\n### 安装gitlab runner\r\n- [windows下载](https://docs.gitlab.com/runner/install/windows.html)\r\n- 下载完成之后，使用管理员运行cmd命令行，然后到刚刚下载的位置中，使用install进行安装，然后start启动。\r\n```\r\ngitlab-runner-windows-amd64.exe install\r\ngitlab-runner-windows-amd64.exe start\r\n```\r\n- 注册gitlab runner\r\n> 服务器上运行gitlab-runner后，runner会轮询的发送带token的http请求给gitlab，如果gitlab有任务了(一般是git push)，那么会把任务信息返回给runner，然后runner就开始调用注册时选的Executor来执行项目根目录下的配置文件.gitlab-ci.yml，执行后把结果反馈给gitlab。\r\n\r\n  1. 在gitlab的项目中打开Settings => CI/CD  => Runners中找到注册的url以及token。\r\n  2. 执行命令register填写上面中对应的url跟token。tags的值很重要要认真填写，executor执行者选择shell。\r\n  3. 注册成功之后可以在Settings => CI/CD  => Runners中看到刚注册的Runner。\r\n```\r\ngitlab-runner-windows-amd64.exe register\r\n```\r\n### gitlab-ci.yml\r\n- 必须指定tags\r\n- cache的设置保证下一阶段任务可以正常使用\r\n```\r\n# 构建阶段：build & deploy 两个 job；按照先后顺序执行\r\nstages:\r\n  - install\r\n  - build\r\n  - deploy\r\n  \r\ncache:\r\n  paths:\r\n    - node_modules\r\n    # 这里将这两个文件缓存，为了在第二个job中使用。其实只要缓存第二个也就够了\r\n    - build/\r\n\r\ninstall:\r\n  tags:\r\n    - deploy test\r\n  stage: install\r\n  only: \r\n    # 只在提交到 deploy/test 分支的时候触发\r\n    - deploy/test\r\n  script:\r\n    # 安装依赖\r\n    - npm install\r\n\r\nbuild:\r\n  tags:\r\n    - deploy test\r\n  stage: build\r\n  only: \r\n    # 只在提交到 deploy/test 分支的时候触发\r\n    - deploy/test\r\n  script:\r\n    # 打包\r\n    - npm run build\r\n\r\ndeploy:\r\n  tags:\r\n    - deploy test\r\n  stage: deploy\r\n  only:\r\n    - deploy/test\r\n  script:\r\n    # 打包\r\n    - npm run deploy test\r\n```\r\n### 报错记录\r\n- ERROR: Job failed (system failure): prepare environment: failed to start process: exec: “pwsh”: executable file not found in %PATH%.\r\n>  因为运行脚本的executor不正确，需要指定一下，打开我们安装gitlab runner的文件夹，有一个config.toml的文件，打开之后吧shell的位置修改为powerShell。然后重启gitlab runner。\r\n\r\n- Treating warnings as errors because process.env.CI = true. Most CI servers set it automati\r\n> build之前设置CI=false\r\n\r\n```\r\n"build": "set \\"CI=false\\" && webpack --config config/webpack.prod.js",\r\n```'},function(r,n,e){"use strict";e.r(n),n.default='## html引用资源部署\r\n### 简单部署流程\r\n- 使用构建工具打包前端代码，生成dist文件夹。\r\n- 使用nginx起一个web服务器，将dist文件夹放到指定的路径下，配置nginx的访问路径。\r\n- 对于请求接口使用proxy_pass进行转发，解决跨域的问题。\r\n- 每次更新部署替换dist文件夹即可。\r\n### html引用资源使用固定文件名\r\n- 当为了节省带宽，提升网页性能给a.css资源添加强缓存时，更新a.css资源内容会导致用户使用本地缓存无法请求到最新的资源。\r\n\r\n```\r\n<link rel="stylesheet" href="a.css" />\r\n```\r\n### 更新html引用资源的资源路径\r\n- 通过更新html中引用的资源路径，让浏览器主动放弃缓存，加载新资源。\r\n- 当页面引用了3个css文件，而某次上线只改了其中的a.css，如果所有链接都更新版本，就会导致另外两个没有更新的css文件的缓存也失效。\r\n```\r\n<link rel="stylesheet" href="a.css?v=1.0.0" />\r\n<link rel="stylesheet" href="b.css?v=1.0.0" />\r\n<link rel="stylesheet" href="c.css?v=1.0.0" />\r\n```\r\n### 使用数据摘要算法更新html引用资源的资源路径\r\n- 让html中引用的资源路径的修改与文件内容关联，只有文件内容变化，才会导致相应资源路径的变更，从而实现文件级别的精确缓存控制。\r\n```\r\n<link rel="stylesheet" href="a.css?v=f23cde" />\r\n<link rel="stylesheet" href="b.css?v=f34cde" />\r\n<link rel="stylesheet" href="c.css?v=f45cde" />\r\n```\r\n### html和html引用资源分别部署\r\n- 为了进一步提升网站性能，html引用资源会被部署到CDN节点上，html中引用的资源路径也会变成对应部署的CDN节点路径。\r\n### 部署应用时先部署html页面还是先部署html引用资源\r\n> 先部署html引用资源，再部署html页面，问题少一些。\r\n\r\n- 先部署html页面，再部署html引用资源。\r\n  1. 在二者部署的时间间隔内，如果有用户访问页面，就会在新的页面结构中加载旧的资源，并且把这个旧版本的资源当做新版本缓存起来。\r\n  2. 用户访问到了一个样式错乱的页面，除非手动刷新，否则在资源缓存过期之前，页面会一直显示错误。\r\n- 先部署html引用资源，再部署html页面。\r\n  1. 在二者部署的时间间隔内，有旧版本资源本地缓存的用户访问网站，由于请求的页面是旧版本的，资源引用没有改变，浏览器将直接使用本地缓存，这种情况下页面展现正常。\r\n  2. 没有本地缓存或者缓存过期的用户访问网站，就会出现旧版本页面加载新版本资源的情况，导致页面执行错误，但当页面完成部署，这部分用户再次访问页面又会恢复正常了。\r\n### 覆盖式发布\r\n- 之所以有部署应用时先部署html页面还是先部署html引用资源的问题是因为html引用资源的覆盖式发布，使用新发布html引用资源覆盖已发布的html引用资源。使用非覆盖式发布会解决该问题。\r\n### 非覆盖式发布\r\n- 用文件的摘要信息对html引用资源文件进行重命名，把摘要信息放到html引用资源文件名中，这样内容有修改的资源就变成了一个新的文件发布到线上，不会覆盖已有的资源文件。\r\n- 部署过程中先部署html引用资源，再部署html页面。\r\n```\r\n<link rel="stylesheet" href="a_f23cde.css" />\r\n```\r\n### html引用资源部署优化方案\r\n- 配置超长时间的本地缓存：节省带宽，提高性能。\r\n- 采用内容摘要作为缓存更新依据：精确的缓存控制。\r\n- html引用资源CDN部署：优化网络请求。\r\n- 更新html引用资源文件名实现非覆盖式发布：平滑升级。\r\n### SPA项目非覆盖式发布的问题解决\r\n> 在已经打开的页面跳转之前从未打开过的页面(之前打开过的页面资源会被缓存在内存中)会因为服务器资源不存在而报错(服务器上该页面原来的资源已被替换成新的资源)。\r\n\r\n- 加入版本校验功能，前后端统一维护一个版本号，每次发版都新增，接口通过判断版本号是否一致来返回相应信息，前端获取到不一致之后主动刷新页面。\r\n- 捕获资源不存在时发生的错误刷新页面。\r\n'},function(r,n,e){"use strict";e.r(n),n.default="## nginx配置前端项目\r\n### 服务器安装nginx，安装后的默认目录假设如下\r\n```\r\n存放前端项目目录  /usr/share/nginx/html \r\n存放配置文件  /etc/nginx/conf.d/default.conf\r\n```\r\n### 上传打包后的前端静态资源\r\n> 将打包后的前端静态资源文件夹build使用ftp文件传输工具上传到 /home/admin 目录下（admin为项目名称）。\r\n\r\n### 配置nginx文件\r\n> 修改 /etc/nginx/conf.d/default.conf 配置文件。\r\n\r\n```\r\nserver {\r\n  # 监听端口\r\n  listen       80;\r\n\r\n  # 配置服务ip\r\n  server_name  ip;\r\n\r\n  # nginx默认request header中包含的下划线_的请求头会自动忽略。\r\n  underscores_in_headers on;\r\n\r\n  # 开启gzip压缩功能\r\n  gzip on;\r\n\r\n  # 指定会被压缩的文件类型\r\n  gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/json;\r\n\r\n  # 设置压缩级别，越高资源消耗越大，但压缩效果越好\r\n  gzip_comp_level 5;\r\n\r\n  # 在头部中添加Vary: Accept-Encoding（建议开启）\r\n  gzip_vary on;\r\n  \r\n  # 处理压缩请求的缓冲区数量和大小\r\n  gzip_buffers 16 8k;\r\n\r\n  # 对于不支持压缩功能的客户端请求不开启压缩机制\r\n  gzip_disable \"MSIE [1-6]\\.\"; # 低版本的IE浏览器不支持压缩\r\n\r\n  # 设置压缩响应所支持的HTTP最低版本\r\n  gzip_http_version 1.1;\r\n\r\n  # 设置触发压缩的最小阈值\r\n  gzip_min_length 2k;\r\n\r\n  # 关闭对后端服务器的响应结果进行压缩\r\n  gzip_proxied off;\r\n\r\n  # 配置前端静态资源http缓存\r\n  location / {\r\n    # 指定根目录\r\n    root   /home/admin/build;\r\n    index  index.html index.htm;\r\n    try_files $uri $uri/ /index.html;\r\n\r\n    # index.html使用协商缓存\r\n    add_header Cache-Control 'no-cache';\r\n\r\n    if ($request_uri ~* .*[.](js|css|map|jpg|png|svg|ico)$) {\r\n      # 非html资源强缓存1个月\r\n      add_header Cache-Control \"max-age=2592000\";\r\n    }\r\n\r\n    if ($request_filename ~* ^.*[.](html|htm)$) {\r\n      # html使用协商缓存\r\n      add_header Cache-Control \"no-cache\";\r\n    }\r\n  }\r\n\r\n  # 接口请求代理\r\n  location /api {\r\n    proxy_pass http://ip;\r\n  }\r\n}\r\n```\r\n### 启动nginx服务\r\n```\r\nservice nginx start\r\n```\r\n### 使用node脚本将打包后的文件夹build上传到服务器\r\n- 安装ssh2-sftp-client依赖\r\n```\r\nnpm install ssh2-sftp-client -D\r\n```\r\n- deploy脚本\r\n```\r\n// deploy.js\r\nconst Sftp = require('ssh2-sftp-client');\r\n\r\nconst sftp = new Sftp();\r\nconst romotePath = '/home/admin/build/';\r\nconst config = {\r\n  name: 'admin',\r\n  ssh: {\r\n    host: '服务ip',\r\n    port: 22,\r\n    username: 'root',\r\n    password: 'password',\r\n  },\r\n  romotePath,\r\n  localPath: './build',\r\n};\r\n\r\nfunction deploy() {\r\n  console.log(`您选择了上传${config.name}`);\r\n  sftp.connect(config.ssh).then(() => {\r\n    console.log('连接成功，上传中..');\r\n    return sftp.rmdir(config.romotePath, true);\r\n  }).then(() => {\r\n    return sftp.uploadDir(config.localPath, config.romotePath);\r\n  }).then(() => {\r\n    console.log('上传成功');\r\n  }).catch(err => {\r\n    console.log(err, '上传失败');\r\n  }).finally(() => {\r\n    sftp.end(); // 断开连接\r\n    console.log('上传连接断开');\r\n  })\r\n}\r\n\r\ndeploy();\r\n```\r\n- 添加npm脚本\r\n```\r\n// package.json\r\n\"scripts\": {\r\n  \"deploy\": \"npm run build && node deploy.js\"\r\n}\r\n```\r\n- 使用部署脚本\r\n```\r\nnpm run deploy\r\n```\r\n\r\n\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## 版本更新提示\r\n- 当前端资源没有及时更新时，可能导致用户无法使用最新的前端功能。\r\n- 服务端有更新时，前端资源没有及时同步更新时可能会导致页面报错。\r\n- 对于那些长时间保持电脑开机且浏览器页面保持打开状态的用户来说，版本更新提示显得尤为重要。\r\n### 监听响应头中Etag的变化\r\n- 定时请求资源的Etag值，并与本地存储的Etag值进行比较。如果Etag值不同，则说明资源有更新，弹出提示弹窗。\r\n- 监听visibilitychange事件，当页面切换为可见状态时，请求资源的Etag值进行比较。防止页面不可见时定时请求的逻辑无法按预期执行。\r\n- 生产环境才开启此功能。\r\n```\r\nimport React, { useEffect, useRef } from 'react';\r\nimport { Modal } from 'antd';\r\nimport { isProd } from '@/utils/common';\r\n\r\n// 获取资源缓存值\r\nconst getETag = async () => {\r\n  const response = await fetch(window.location.origin, {\r\n    cache: 'no-cache',\r\n  });\r\n  return response.headers.get('etag') || response.headers.get('last-modified');\r\n};\r\n\r\nconst useVersionUpdate = () => {\r\n  const timerRef: any = useRef(); // 定时器\r\n  const isConfirmShowRef = useRef(false); // 提示弹窗是否在显示\r\n\r\n  // 刷新页面\r\n  const onRefresh = (newVersion: string) => {\r\n    isConfirmShowRef.current = false;\r\n    // 更新localStorage版本号信息\r\n    window.localStorage.setItem('platformVersion', newVersion);\r\n    // 刷新页面\r\n    window.location.reload();\r\n  }\r\n\r\n  // 弹出提示弹窗\r\n  const openConfirm = (newVersion: string) => {\r\n    isConfirmShowRef.current = true;\r\n    Modal.confirm({\r\n      title: '版本更新提示',\r\n      content: '检测到系统当前版本已更新，请刷新后使用。',\r\n      okText: '确认更新',\r\n      centered: true,\r\n      onOk: () => {\r\n        onRefresh(newVersion);\r\n      },\r\n      onCancel: () => isConfirmShowRef.current = false,\r\n    })\r\n  }\r\n\r\n  // 比较版本号\r\n  const compareVersion = async() => {\r\n    try {\r\n      clearInterval(timerRef.current);\r\n      if (!isConfirmShowRef.current) {\r\n        const newVersion = await getETag();\r\n        const oldVersion = localStorage.getItem('platformVersion');\r\n        if (newVersion && !oldVersion) {\r\n          // 如果本地没有，则存储版本信息\r\n          window.localStorage.setItem('platformVersion', newVersion);\r\n        } else if (newVersion && newVersion !== oldVersion) {\r\n          // 本地已有版本信息，但是和新版本不同，弹出提示\r\n          openConfirm(newVersion);\r\n        }\r\n      }\r\n    } catch (error) {\r\n      console.log(error)\r\n    } finally {\r\n      timerRef.current = setTimeout(compareVersion, 60 * 60 * 1000);\r\n    }\r\n  }\r\n\r\n  /* 初始时检查，之后1h时检查一次 */\r\n  useEffect(() => {\r\n    if (isProd) {\r\n      compareVersion();\r\n      // 页面切换为可见状态时检查版本是否更新\r\n      document.addEventListener('visibilitychange', () => {\r\n        if (document.visibilityState === 'visible') {\r\n          compareVersion();\r\n        }\r\n      });\r\n      return () => {\r\n        clearInterval(timerRef.current);\r\n      };\r\n    }\r\n  }, []);\r\n};\r\n\r\nexport default useVersionUpdate;\r\n```\r\n### [监听git commit hash的变化](https://mp.weixin.qq.com/s/Kc8rAiOylCfePuHcEvWCKA)"},function(r,n,e){"use strict";e.r(n),n.default="## api\r\n### instanceof\r\n- instanceof操作符左侧是一个普通对象，右侧是一个构造函数，用于检测构造函数的prototype是否出现在某个实例对象的原型链上。\r\n```\r\nfunction Car(make, model, year) {\r\n  this.make = make;\r\n  this.model = model;\r\n  this.year = year;\r\n}\r\nconst auto = new Car('Honda', 'Accord', 1998);\r\n\r\nconsole.log(auto instanceof Car); // true\r\nconsole.log(auto instanceof Object); // true\r\n```\r\n### isPrototypeOf()\r\n- isPrototypeOf()不关心构造函数，用于检查一个对象是否存在于另一个对象的原型链上。\r\n```\r\nfunction Foo() {}\r\nfunction Bar() {}\r\n\r\nBar.prototype = Object.create(Foo.prototype);\r\n\r\nconst bar = new Bar();\r\n\r\nconsole.log(Foo.prototype.isPrototypeOf(bar)); // true\r\nconsole.log(Bar.prototype.isPrototypeOf(bar)); // true\r\n```\r\n### instanceof VS isPrototypeOf()\r\n- instanceOf运算符侧重于检查构造函数的原型是否在对象的原型链上。\r\n- isPrototypeOf()方法侧重于检查一个对象是否在另一个对象的原型链上。\r\n### Object.getPrototypeOf\r\n- 获取实例对象的原型。\r\n```\r\n// Person构造函数\r\nfunction Person() {}\r\n\r\n// 在Person的原型对象上挂载属性和方法\r\nPerson.prototype.name = 'dyx';\r\nPerson.prototype.age = 26;\r\nPerson.prototype.getName = function() {\r\n  return this.name;\r\n}\r\n \r\nconst dyx = new Person();\r\nObject.getPrototypeOf(dyx) === Person.prototype // true\r\n```\r\n### hasOwnProperty\r\n- for in循环将循环遍历对象本身以及它所委托的原型的所有可枚举属性，添加到原型的任何属性都是可枚举的(使用 in 操作符检查对象中是否含有某个属性时同理)。\r\n- hasOwnProperty返回一个布尔值，表示对象是否具有指定的属性作为其自身的属性，而不是对象所委托的原型上的属性。\r\n```\r\nfunction Animal(name, energy) {\r\n  this.name = name;\r\n  this.energy = energy;\r\n}\r\nAnimal.prototype.eat = function(amount) {\r\n  console.log(`${this.name} is eating.`);\r\n  this.energy += amount;\r\n}\r\n \r\nconst leo = new Animal('Leo', 7);\r\nfor (let key in leo) {\r\n  console.log(key); // name、energy、eat\r\n}\r\n\r\nfor (let key in leo) {\r\n  if (leo.hasOwnProperty(key)) {\r\n    console.log(key); // name、energy\r\n  }\r\n}\r\n```\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## 原型原型链\r\n### 普通对象与函数对象\r\n- JavaScript中对象分为普通对象和函数对象。通过new Function()创建的对象都是函数对象，其它的都是普通对象。\r\n- 每个对象都有`__proto__`属性，但只有函数对象才有prototype属性。\r\n- 所有函数对象的`__proto__`都指向Function.prototype，它是一个空函数。所有函数对象都继承了Function.prototype的属性及方法，如length、call、apply、bind。\r\n### 原型对象 prototype\r\n- 每个函数对象都会有一个prototype属性，这个属性值是一个对象，这个对象就是通过调用构造函数创建的对象实例的原型。\r\n- 使用原型对象的好处是，在它上面定义的属性和方法都可以被实例共享。\r\n\r\n![原型](./img/原型.png)\r\n### 原型 `__proto__`\r\n- 所有非内置对象都拥有独有属性`__proto__`，对象的`__proto__`属性指向创建它的构造函数的原型对象。\r\n- 例如对象dyx有一个`__proto__`属性，创建它的构造函数是Person，构造函数的原型对象是Person.prototype，所以`dyx.__proto__ === Person.prototype`。\r\n- 内置对象如：Function、Date、Array、Object、Math、JSON等。\r\n### 原型链\r\n- 如果实例的原型是另一个构造函数的实例，于是该实例的原型本身又有一个内部指针(`__proto__`)指向另一个原型，相应的另一个原型也有一个内部指针(`__proto__`)指向另一个原型。这样实例和原型之间形成了一条长长的链条，这就是原型链。\r\n- 所有函数对象的原型对象的`__proto__`都会指向内置的Object.prototype，而Object的原型对象的`__proto__`指向null。也就是说所有的普通对象都源于Object.prototype，它包含javascript中许多通用的功能。\r\n- 每个对象都有一个私有属性`__proto__`指向另一个名为原型的对象。原型对象也有一个自己的原型，层层向上直到一个对象的原型为null。根据定义null没有原型，并作为这个原型链中的最后一个环节。\r\n- 对象通过`__proto__`属性指向其构造函数的原型对象，进而通过原型对象的`__proto__`属性指向更高层级的原型对象，最终指向null而停止所形成的链条称为原型链。\r\n\r\n![原型链](./img/原型链.png)\r\n\r\n### [构造函数](https://mp.weixin.qq.com/s/BtA5C_1DKpaztM6GYRakPg)\r\n- 所有函数对象的原型对象的构造函数均指向其自身。\r\n- 由于所有函数对象的原型对象的构造函数均为其自身，则如若`Foo.prototype.__proto__`指向其构造函数的prototype，即`Foo.prototype.__proto__`指向Foo.prototype，那么原型链的查找将进入无限循环。为了避免这个问题，则将所有函数对象的原型对象的`__proto__`均指向Object.prototype。\r\n```\r\nfunction Foo() {};\r\nconst o1 = new Foo();\r\n\r\no1.constructor === Foo // true\r\nFoo.constructor === Function // true\r\nFunction.constructor === Function // true\r\n```\r\n![构造函数](./img/构造函数.png)\r\n### 原型对象、原型、构造函数的关系\r\n- 每个构造函数都有一个原型对象(实例的原型)，原型对象有一个constructor属性指向构造函数。\r\n- 构造函数构造出来的实例有一个内部指针即原型(在chrome、firefox、safari浏览器环境中这个指针就是`__proto__`)指向该构造函数的原型对象。\r\n- 构造函数构造出来的实例的constructor属性指向该构造函数。\r\n```\r\n1. 创建一个空的构造函数Person。\r\n2. 创建一个Person的实例dyx，dyx实例本身是没有挂载任何属性和方法的，但是它有一个`__proto__`内置属性，这个属性是个对象，里面有name、age属性和getName函数。\r\n3. Person.prototype和dyx的`__proto__`都指向同一个对象，这个对象对于Person构造函数而言叫做原型对象，对于dyx实例而言叫做原型。\r\n4. 实例dyx的constructor属性指向Person构造函数。\r\n\r\n\r\n// Person构造函数\r\nfunction Person() {}\r\n\r\n// 在Person的原型对象上挂载属性和方法\r\nPerson.prototype.name = 'dyx';\r\nPerson.prototype.age = 26;\r\nPerson.prototype.getName = function() {\r\n  return this.name;\r\n}\r\n\r\nconst dyx = new Person();\r\nconsole.log(dyx.name) // 'dyx'\r\nconsole.log(dyx.getName()); // 'dyx'\r\n\r\nconsole.log(Person.prototype.constructor === Person); // true\r\nconsole.log(dyx.__proto__ === Person.prototype); // true\r\nconsole.log(dyx.constructor === Person); // true\r\n```\r\n![相互关系](./img/相互关系.png)\r\n\r\n\r\n\r\n\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## 原型对象值修改\r\n### prototype对象重新赋值\r\n- 实例化对象时，该对象的`__proto__`指向当前的构造函数的prototype，如果实例化后构造函数的prototype重新赋值，不会影响已经创建的实例。\r\n```\r\n// Person构造函数\r\nfunction Person() {}\r\n\r\n// 在Person的原型对象上挂载属性和方法\r\nPerson.prototype.name = 'dyx';\r\nPerson.prototype.age = 26;\r\nPerson.prototype.getName = function() {\r\n  return this.name;\r\n}\r\n\r\nconst dyx = new Person();\r\nconsole.log(dyx.name); // 'dyx'\r\nPerson.prototype = {\r\n  name: 'douyaxing'\r\n}\r\nconsole.log(dyx.name); // 'dyx'\r\n```\r\n### prototype对象修改属性值或添加属性\r\n- 原型对象的属性值被修改后，或者添加了新的属性，实例化对象的原型值也会发生变化。\r\n```\r\n// Person构造函数\r\nfunction Person() {}\r\n\r\n// 在Person的原型对象上挂载属性和方法\r\nPerson.prototype.name = 'dyx';\r\nPerson.prototype.age = 26;\r\nPerson.prototype.getName = function() {\r\n  return this.name;\r\n}\r\n\r\nconst dyx = new Person();\r\nconsole.log(dyx.name); // 'dyx'\r\nconsole.log(dyx.sex); // undefined\r\nPerson.prototype.name = 'douyaxing';\r\nPerson.prototype.sex = '男';\r\nconsole.log(dyx.name); // 'douyaxing'\r\nconsole.log(dyx.sex); // '男'\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## 对象的属性和方法查找\r\n1. 查找对象自己声明的。\r\n2. 去原型链上查找，在`__proto__`指向的原型上查找，如果在后者也没有找到需要的东西，引擎就会继续查找它的`__proto__`指向的原型。\r\n3. 去Object.prototype上查找(所有的普通对象都源于Object.prototype，它包含javascript中许多通用的功能)。"},function(r,n,e){"use strict";e.r(n),n.default="## react-intl国际化\r\n### 安装依赖\r\n```\r\nyarn add react-intl\r\n```\r\n### 添加国际化语言配置\r\n- en_US.js\r\n```\r\nconst en_US = {\r\n  search: 'Search'\r\n};\r\n\r\nexport { en_US };\r\n```\r\n- zh_CN.js\r\n```\r\nconst zh_CN = {\r\n  search: '搜索'\r\n};\r\n\r\nexport { zh_CN };\r\n```\r\n- index.ts\r\n```\r\nimport zhCN from 'antd/lib/locale/zh_CN';\r\nimport enUS from 'antd/lib/locale/en_US';\r\nimport { zh_CN } from './zh_CN';\r\nimport { en_US } from './en_US';\r\n\r\nexport const getLocale = (lang: string) => {\r\n  let locale = null;\r\n  let antLocale = null;\r\n  let messages = null;\r\n  switch (lang) {\r\n    case 'en-US':\r\n      locale = 'en-US';\r\n      antLocale = enUS;\r\n      messages = en_US;\r\n      break;\r\n    case 'zh-CN':\r\n      locale = 'zh-CN';\r\n      antLocale = zhCN;\r\n      messages = zh_CN;\r\n      break;\r\n    default:\r\n      locale = 'zh-CN';\r\n      antLocale = zhCN;\r\n      messages = zh_CN;\r\n      break;\r\n  }\r\n  // 语言环境、Ant Design组件库的语言环境、国际化语言内容\r\n  return { locale, antLocale, messages };\r\n};\r\n```\r\n### redux中存储当前的语言环境\r\n```\r\n// reducer.ts\r\ninterface PayloadDataType {\r\n  locale: string;\r\n}\r\n\r\ninterface ActionType {\r\n  type: string;\r\n  payload?: PayloadDataType;\r\n}\r\nconst initState = {\r\n  locale: localStorageUtil.getItem('locale') || 'zh-CN' // locale\r\n};\r\n\r\nexport const configStore = (state = initState, action: ActionType) => {\r\n  const { type, payload } = action;\r\n  switch (type) {\r\n    case 'changeLocale':\r\n      localStorageUtil.setItem('locale', payload?.locale);\r\n      return {\r\n        locale: payload?.locale\r\n      };\r\n    default:\r\n      return state;\r\n  }\r\n};\r\n```\r\n### 入口文件配置\r\n```\r\nimport React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport { Provider } from 'react-redux';\r\nimport { IntlProvider } from 'react-intl';\r\nimport { ConfigProvider } from 'antd';\r\nimport 'antd/dist/antd.css';\r\nimport Routes from './routes';\r\nimport store from './store';\r\nimport { getLocale } from '@/assets/locale';\r\nimport './index.css';\r\n\r\nconst App = () => {\r\n  // 获取语言信息\r\n  const currentLocale = store.getState().configStore.locale;\r\n  const { locale, antLocale, messages } = getLocale(currentLocale);\r\n\r\n  return (\r\n    <Provider store={store}>\r\n      <IntlProvider locale={locale} messages={messages}>\r\n        <ConfigProvider locale={antLocale}>\r\n          <Routes />\r\n        </ConfigProvider>\r\n      </IntlProvider>\r\n    </Provider>\r\n  );\r\n};\r\n\r\nReactDOM.render(<App />, document.getElementById('root'));\r\n```\r\n### 组件中使用\r\n```\r\nimport { FormattedMessage } from 'react-intl';\r\n\r\n<FormattedMessage id=\"search\" />\r\n```\r\n### 切换语言\r\n```\r\n// 修改语言\r\nconst onChangeLocale = () => {\r\n  dispatch({\r\n    type: 'changeLocale',\r\n    payload: { locale: locale === 'zh-CN' ? 'en-US' : 'zh-CN' }\r\n  });\r\n  window.location.reload();\r\n};\r\n```\r\n### 非组件中使用国际化\r\n- 使用createIntl创建intl实例导出。\r\n```\r\nimport { createIntl, createIntlCache } from 'react-intl';\r\nimport zhCN from 'antd/lib/locale/zh_CN';\r\nimport enUS from 'antd/lib/locale/en_US';\r\nimport { zh_CN } from './zh_CN';\r\nimport { en_US } from './en_US';\r\n\r\nexport const getLocale = (lang: string) => {\r\n  let locale = null;\r\n  let antLocale = null;\r\n  let messages = null;\r\n  switch (lang) {\r\n    case 'en-US':\r\n      locale = 'en-US';\r\n      antLocale = enUS;\r\n      messages = en_US;\r\n      break;\r\n    case 'zh-CN':\r\n      locale = 'zh-CN';\r\n      antLocale = zhCN;\r\n      messages = zh_CN;\r\n      break;\r\n    default:\r\n      locale = 'zh-CN';\r\n      antLocale = zhCN;\r\n      messages = zh_CN;\r\n      break;\r\n  }\r\n  return { locale, antLocale, messages };\r\n};\r\n\r\n// 导出intl实例\r\nexport const getIntl = (lang: string) => {\r\n  const cache = createIntlCache();\r\n  const { locale, messages } = getLocale(lang);\r\n\r\n  return createIntl(\r\n    {\r\n      locale,\r\n      messages\r\n    },\r\n    cache\r\n  );\r\n};\r\n```\r\n- 非组件中使用\r\n```\r\nimport { getIntl } from '@/assets/locale';\r\n\r\nmessage.success(\r\n  getIntl(store.getState().configStore.locale).formatMessage({\r\n    id: 'search'\r\n  })\r\n);\r\n```\r\n### 国际化支持参数传递\r\n- en_US.js\r\n```\r\nconst en_US = {\r\n  search: 'Search {content}'\r\n};\r\n\r\nexport { en_US };\r\n```\r\n- zh_CN.js\r\n```\r\nconst zh_CN = {\r\n  search: '搜索 {content}'\r\n};\r\n\r\nexport { zh_CN };\r\n```\r\n- 组件中使用\r\n```\r\nimport { FormattedMessage } from 'react-intl';\r\n\r\n<FormattedMessage id=\"search\" values={{ content: 'dyx' }} />\r\n```\r\n- 非组件中使用\r\n```\r\nimport { getIntl } from '@/assets/locale';\r\n\r\nmessage.success(\r\n  getIntl(store.getState().configStore.locale).formatMessage(\r\n    { id: 'search' },\r\n    { content: 'dyx' }\r\n  )\r\n);\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## 项目国际化工作项\r\n### 前端词条相关工作\r\n- 提取待翻译词条到文件。\r\n- 翻译并更新词条文件。\r\n- 词条翻译相关工具函数开发。\r\n### 接口支持国际化\r\n- 前端通过请求头传递当前语言环境。\r\n- 服务端解析请求头返回对应语言环境信息。\r\n### 前端支持切换语言环境\r\n### 三方库适配多语言环境\r\n- UI组件库多语言适配。\r\n- 其它有词条场景的三方库多语言适配。\r\n### 静态资源词条适配多语言环境\r\n- 有词条场景的图片多语言适配。\r\n- 有词条场景的文件多语言适配。\r\n### 前端样式走查及适配\r\n- 国际化后的文本可能会出现显示溢出、截断、乱换行、排版错乱、未对齐等场景，需要针对不同语言处理不同样式，互不影响。\r\n\r\n\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## [react-markdown渲染markdown文件](https://blog.csdn.net/Sakuraaaa_/article/details/128400497)\r\n### 安装依赖\r\n```\r\nyarn add react-markdown\r\n \r\n// 其余样式插件\r\nyarn add remark-gfm   \r\nyarn add rehype-raw   \r\nyarn add react-syntax-highlighter   \r\nyarn add github-markdown-css\r\n```\r\n### 渲染markdown文件\r\n```\r\nimport ReactMarkdown from 'react-markdown';\r\n\r\nconst App = () => {\r\n  return (\r\n    <ReactMarkdown>\r\n      {/* markdown文件文件内容 */}\r\n      {mdContent}\r\n    </ReactMarkdown>\r\n  )\r\n}\r\n```\r\n### 优化样式\r\n```\r\nimport ReactMarkdown from 'react-markdown';\r\nimport remarkGfm from 'remark-gfm'; // 划线、表、任务列表和直接url等的语法扩展\r\nimport rehypeRaw from 'rehype-raw'; // 解析标签，支持html语法\r\nimport { Prism as SyntaxHighlighter } from 'react-syntax-highlighter'; // 代码高亮\r\nimport { vscDarkPlus } from 'react-syntax-highlighter/dist/esm/styles/prism'; // 代码高亮的主题\r\nimport 'github-markdown-css'; // 样式文件\r\n\r\nconst App = () => {\r\n  return (\r\n    <ReactMarkdown\r\n      // 类名必须有才会有样式\r\n      className=\"markdown-body\"\r\n      remarkPlugins={[remarkGfm]}\r\n      rehypePlugins={[rehypeRaw]}\r\n      components={{\r\n        // 渲染代码块\r\n        code(props: any) {\r\n          const { children, ...rest } = props;\r\n          return (\r\n            <SyntaxHighlighter\r\n              {...rest}\r\n              style={vscDarkPlus}\r\n              PreTag=\"div\"\r\n              language=\"javascript\"\r\n            >\r\n              {String(children).replace(/\\n$/, '')}\r\n            </SyntaxHighlighter>\r\n          );\r\n        }\r\n      }}\r\n    >\r\n      \r\n      {mdContent}\r\n    </ReactMarkdown>\r\n  )\r\n}\r\n```\r\n### 生成导航目录\r\n- 如果借用相关插件实现目录对我们markdown的书写格式规范要求较高，可能会出现解析目录失败的问题。\r\n- 手动实现导航目录\r\n  1. 对markdown渲染后的DOM进行遍历，取出所有的h1-h6标签以及标签中的文本进行目录展示，同时给所有的h1-h6标签添加a标签作为锚点，方便点击目录进行定位。\r\n  ```\r\n  // 根据H标签获取目录数据以及为H标签添加锚点\r\n  const getNavs = () => {\r\n    const blogDom = document.getElementsByClassName('markdown-body')[0];\r\n    let eid = 0;\r\n    const titles: any = [];\r\n    for (const item of blogDom.childNodes as any) {\r\n      const { nodeName, innerText } = item;\r\n      if (['H1', 'H2', 'H3', 'H4', 'H5', 'H6'].includes(nodeName)) {\r\n        const a = document.createElement('a');\r\n        a.setAttribute('id', '#' + eid);\r\n        a.innerText = ' ';\r\n        const title = {\r\n          type: nodeName,\r\n          id: eid,\r\n          name: innerText\r\n        };\r\n        titles.push(title);\r\n        item.appendChild(a);\r\n        eid++;\r\n      }\r\n    }\r\n    setNavs(titles);\r\n  };\r\n  ```\r\n  2. 点击生成的目录，跳转到对应的位置\r\n  ```\r\n  // 点击目录移动到对应内容\r\n  const onNavClick = (e: any, id: number) => {\r\n    e.preventDefault();\r\n    if (id) {\r\n      // 找到锚点对应得的节点\r\n      const element = document.getElementById(`#${id}`);\r\n      // 如果对应id的锚点存在，就跳滚动到锚点顶部\r\n      element && element.scrollIntoView({ block: 'start', behavior: 'smooth' });\r\n      onClose();\r\n    }\r\n  };\r\n  ```"},function(r,n,e){"use strict";e.r(n),n.default="## 复制粘贴功能\r\n### document.execCommand\r\n- 不支持异步操作\r\n- 只能在真正的用户操作之后才能被触发，是为了安全考虑。当用户操作之后，chrome会将当前作用域下的userAction变量置为true，然后执行execCommand时会去读取这个变量，当为true的时候才可以执行。\r\n- ajax基本都是异步请求，而异步请求不同于同步请求的地方就在于重新创建了一个作用域去执行回调函数。所以在重新创建一个作用域之后，之前作用域内的userAction就失效了，当前作用域下的userAction为false，所以复制不成功。\r\n```\r\nconst copyText = (text) => {\r\n  // 创建一个临时的 textarea 元素\r\n  const textarea = document.createElement('textarea');\r\n\r\n  // 设置 textarea 的内容\r\n  textarea.value = text;\r\n\r\n  // 防止在页面上显示 textarea\r\n  textarea.setAttribute('readonly', '');\r\n  textarea.style.position = 'absolute';\r\n  textarea.style.left = '-9999px';\r\n\r\n  // 将 textarea 添加到页面中\r\n  document.body.appendChild(textarea);\r\n\r\n  // 选中 textarea 的内容\r\n  textarea.select();\r\n\r\n  // 尝试执行复制操作\r\n  const success = document.execCommand('copy');\r\n\r\n  // 移除 textarea 元素\r\n  document.body.removeChild(textarea);\r\n\r\n  // 根据复制操作的成功与否给出提示\r\n  if (success) {\r\n    console.log('复制成功！');\r\n  } else {\r\n    console.log('复制失败，请手动复制。');\r\n  }\r\n}\r\n```\r\n### navigator.clipboard\r\n- 支持异步操作\r\n- 复制功能\r\n```\r\nconst copyText = async (text) => {\r\n  try {\r\n    await navigator.clipboard.writeText(text);\r\n    console.log('复制成功！');\r\n  } catch (err) {\r\n    console.error('无法复制: ', err);\r\n  }\r\n};\r\n```\r\n- 粘贴功能\r\n```\r\nconst pasteText = async () => {\r\n  try {\r\n    const text = await navigator.clipboard.readText();\r\n    console.log('粘贴成功！');\r\n  } catch (err) {\r\n    console.error('无法粘贴: ', err);\r\n  }\r\n};\r\n```\r\n- 兼容性\r\n> Navigator这种新API是需要事先授予权限的，而权限是通过Permissions API获取的。我们需要用户明确授权，但在某些环境下比如安卓的WebView，可能会遇到兼容性问题。\r\n\r\n```\r\nif (navigator.clipboard && navigator.permissions) { \r\n  await navigator.clipboard.writeText(text);\r\n}\r\n```\r\n### 考虑兼容性的复制功能实现\r\n```\r\nconst copyText = async (text) => {\r\n  try {\r\n    // 使用现代 API 尝试复制\r\n    if (navigator.clipboard && navigator.permissions) {\r\n      await navigator.clipboard.writeText(text);\r\n      console.log('复制成功！');\r\n      return; // 如果成功，直接返回\r\n    }\r\n\r\n    // 降级方案\r\n    const textArea = document.createElement('textArea');\r\n    textArea.value = text;\r\n    textArea.style.width = 0;\r\n    textArea.style.position = 'fixed';\r\n    textArea.style.left = '-999px';\r\n    textArea.style.top = '10px';\r\n    textArea.setAttribute('readonly', 'readonly');\r\n    document.body.appendChild(textArea);\r\n    textArea.select();\r\n\r\n    // 尝试执行复制操作\r\n    const success = document.execCommand('copy');\r\n    if (!success) {\r\n      throw new Error('无法复制文本');\r\n    }\r\n\r\n    // 清理\r\n    document.body.removeChild(textArea);\r\n    console.log('复制成功！');\r\n  } catch (err) {\r\n    console.error('复制失败:', err);\r\n  }\r\n};\r\n```"},function(r,n,e){"use strict";e.r(n),n.default='## 复制网页内容为图片\r\n1. 获取复制内容所属的DOM。\r\n2. 复制内容所属的DOM转换成canvas。\r\n3. 转换canvas为二进制图像。\r\n4. 复制二进制图像到剪贴板。\r\n### DOM转换为canvas\r\n- 使用html2canvas库将DOM转化为canvas。\r\n```\r\nnpm install --save html2canvas\r\n\r\nhtml2canvas(element).then(canvas => {\r\n  // 获取到canvas\r\n}\r\n```\r\n### canvas转换为二进制图像\r\n- 使用canvas.toBlob将canvas转换为二进制图像。\r\n```\r\ncanvas.toBlob(\r\n  (blob) => {\r\n    // 获取到二进制图像\r\n  }, \r\n  "image/png", // 文件的格式\r\n  1 // 图像压缩质量 0-1\r\n);\r\n```\r\n### 复制二进制图像到剪贴板\r\n- 使用navigator.clipboard的ClipboardItem复制二进制图像，依赖HTTPS。\r\n```\r\ntry {\r\n  await navigator.clipboard.write([\r\n    new ClipboardItem({\r\n      [blob.type]: blob\r\n    })\r\n  ]);\r\n  console.log("图像已成功复制到剪贴板");\r\n} catch (err) {\r\n  console.error("无法复制图像到剪贴板", err);\r\n}\r\n```\r\n### 完整功能\r\n```\r\nconst copyDomToImage = () => {\r\n  const element = document.getElementById("target");\r\n\r\n  html2canvas(element).then(canvas => {\r\n    canvas.toBlob(\r\n      async (blob) => {\r\n        // 复制文件到剪贴板  \r\n        try {\r\n          await navigator.clipboard.write([\r\n            new ClipboardItem({\r\n              [blob.type]: blob\r\n            })\r\n          ]);\r\n          console.log("图像已成功复制到剪贴板");\r\n        } catch (err) {\r\n          console.error("无法复制图像到剪贴板", err);\r\n        }\r\n      }, \r\n      "image/png", // 文件的格式\r\n      1 // 图像压缩质量 0-1\r\n    );\r\n  });\r\n}\r\n```'},function(r,n,e){"use strict";e.r(n),n.default="## qiankun微应用\r\n### 应用的请求代理proxy配置\r\n> 子应用配置的请求代理，在独立运行是没问题的。但是通过主应用去加载的子应用，子应用发出的请求实际已经被主应用劫持了，不会运行到子应用的请求代理。所以主应用也需要配置子应用需要的请求代理。\r\n\r\n### react子应用使用react-refresh，主应用不响应热更新的问题\r\n> 当React Refresh的多个实例同时运行时，需要使用library属性为React Refresh设置命名空间，类似于webpack中的output.library选项。\r\n\r\n- [react-refresh API](https://github.com/pmmmwh/react-refresh-webpack-plugin/blob/main/docs/API.md)\r\n```\r\n// webpack.dev.js\r\nconst ReactRefreshWebpackPlugin = require('@pmmmwh/react-refresh-webpack-plugin');\r\nconst { name } = require('../package.json');\r\n\r\nmodule.exports = {\r\n  mode: 'development',\r\n  devServer: {\r\n    headers: {\r\n      'Access-Control-Allow-Origin': '*',\r\n    },\r\n    hot: true,\r\n    open: true,\r\n    port: 3000,\r\n  },\r\n  plugins: [\r\n    new ReactRefreshWebpackPlugin({\r\n      library: `${name}-[name]`\r\n    }),\r\n  ]\r\n}\r\n```\r\n### 使用react-refresh，报错出现浮层影响本地开发\r\n> 将overlay属性值设置为false，关闭浮层报错。\r\n\r\n```\r\n// webpack.dev.js\r\nconst ReactRefreshWebpackPlugin = require('@pmmmwh/react-refresh-webpack-plugin');\r\nconst { name } = require('../package.json');\r\n\r\nmodule.exports = {\r\n  mode: 'development',\r\n  devServer: {\r\n    headers: {\r\n      'Access-Control-Allow-Origin': '*',\r\n    },\r\n    hot: true,\r\n    open: true,\r\n    port: 3000,\r\n  },\r\n  plugins: [\r\n    new ReactRefreshWebpackPlugin({\r\n      library: `${name}-[name]`,\r\n      overlay: false,\r\n    }),\r\n  ]\r\n}\r\n```\r\n### 应用样式隔离\r\n> 默认情况下沙箱可以确保单实例场景子应用之间的样式隔离，但是无法确保主应用跟子应用、或者多实例场景的子应用样式隔离。当配置为{ strictStyleIsolation: true }时表示开启严格的样式隔离模式。这种模式下qiankun会为每个微应用的容器包裹上一个shadow dom节点，从而确保微应用的样式不会对全局造成影响。\r\n\r\n- 使用{ strictStyleIsolation: true }有时候导致vue3的组件样式丢失，可以使用{ experimentalStyleIsolation: true }\r\n> 使用{ experimentalStyleIsolation: true }qiankun会改写子应用所添加的样式为所有样式规则增加一个特殊的选择器规则来限定其影响范围。\r\n\r\n```\r\n// 假设应用名是 react16\r\n.app-main {\r\n  font-size: 14px;\r\n}\r\n\r\ndiv[data-qiankun-react16] .app-main {\r\n  font-size: 14px;\r\n}\r\n```\r\n### 子应用之间跳转\r\n- 主应用和微应用都是hash模式，主应用根据hash来判断微应用，则不用考虑这个问题。\r\n- 主应用根据path来判断微应用，history模式的微应用之间的跳转，或者微应用跳主应用页面，直接使用微应用的路由实例是不行的，原因是微应用的路由实例跳转都基于子应用路由的base。有两种办法可以跳转：\r\n  1. history.pushState()。\r\n  2. 将主应用的路由实例通过props传给微应用，微应用这个路由实例跳转。"},function(r,n,e){"use strict";e.r(n),n.default="#### qiankun微前端各应用分别部署\r\n> 主应用和微应用分别部署（不同ip或不同端口）。\r\n\r\n```\r\n1. 主应用访问路径 http://ip\r\n2. react子应用访问路径 http://ip:8001\r\n3. vue子应用访问路径 http://ip:8002\r\n\r\n/home/micro  // 资源目录\r\n    ├── main\r\n        ├── build  // 主应用静态资源\r\n    ├── microReact     \r\n        ├── build       // react微应用静态资源\r\n    ├── microVue      \r\n        ├── build       // vue微应用静态资源\r\n```\r\n### 子应用配置webpack构建时的publicPath。\r\n```\r\npublicPath: process.env.NODE_ENV === 'development' ? '/' : '/microVue/',\r\n```\r\n### 主应用中注册微应用的entry设置成微应用的部署路径，可以使用相对路径。\r\n> entry路径最后面的 / 不可省略，否则 publicPath 会设置错误。注册微应用的activeRule不能和微应用的部署路径一样，否则在主应用页面刷新会直接变成微应用页面。\r\n\r\n```\r\n// 注册子应用\r\nregisterMicroApps([\r\n  {\r\n    name: 'micro-react',\r\n    entry: process.env.NODE_ENV === 'development' ? '//localhost:8001' : '/microReact/',\r\n    container: '#microContainer',\r\n    activeRule: '/micro-react',\r\n  },\r\n  {\r\n    name: 'micro-vue',\r\n    entry: process.env.NODE_ENV === 'development' ? '//localhost:8002' : '/microVue/',\r\n    container: '#microContainer',\r\n    activeRule: '/micro-vue',\r\n  },\r\n]);\r\n```\r\n### nginx配置\r\n```\r\n# 主应用\r\nserver {\r\n  # 监听端口\r\n  listen       80;\r\n\r\n  # 服务ip\r\n  server_name  ip;\r\n\r\n  # 开启gzip压缩功能\r\n  gzip on;\r\n\r\n  # 指定会被压缩的文件类型\r\n  gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/json;\r\n\r\n  # 设置压缩级别，越高资源消耗越大，但压缩效果越好\r\n  gzip_comp_level 5;\r\n\r\n  # 在头部中添加Vary: Accept-Encoding（建议开启）\r\n  gzip_vary on;\r\n  \r\n  # 处理压缩请求的缓冲区数量和大小\r\n  gzip_buffers 16 8k;\r\n\r\n  # 对于不支持压缩功能的客户端请求不开启压缩机制\r\n  gzip_disable \"MSIE [1-6]\\.\"; # 低版本的IE浏览器不支持压缩\r\n\r\n  # 设置压缩响应所支持的HTTP最低版本\r\n  gzip_http_version 1.1;\r\n\r\n  # 设置触发压缩的最小阈值\r\n  gzip_min_length 2k;\r\n\r\n  # 关闭对后端服务器的响应结果进行压缩\r\n  gzip_proxied off;\r\n\r\n  # 配置前端静态资源\r\n  location / {\r\n    root   /home/micro/main/build;\r\n    index  index.html index.htm;\r\n    try_files $uri $uri/ /index.html;\r\n\r\n    # index.html使用协商缓存\r\n    add_header Cache-Control 'no-cache';\r\n\r\n    if ($request_uri ~* .*[.](js|css|map|jpg|png|svg|ico)$) {\r\n      # 非html资源强缓存1个月\r\n      add_header Cache-Control \"max-age=2592000\";\r\n    }\r\n\r\n    if ($request_filename ~* ^.*[.](html|htm)$) {\r\n      # html使用协商缓存\r\n      add_header Cache-Control \"no-cache\";\r\n    }\r\n  }\r\n\r\n  # react子应用的转发\r\n  location /microReact {\r\n    proxy_pass http://ip:8001/;\r\n    proxy_set_header Host $host:$server_port;\r\n  }\r\n\r\n  # vue子应用的转发\r\n  location /microVue {\r\n    proxy_pass http://ip:8002/;\r\n    proxy_set_header Host $host:$server_port;\r\n  }\r\n}\r\n\r\n# react子应用\r\nserver {\r\n  # 监听端口\r\n  listen       8001;\r\n\r\n  # 服务ip\r\n  server_name  ip;\r\n\r\n  # 开启gzip压缩功能\r\n  gzip on;\r\n\r\n  # 指定会被压缩的文件类型\r\n  gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/json;\r\n\r\n  # 设置压缩级别，越高资源消耗越大，但压缩效果越好\r\n  gzip_comp_level 5;\r\n\r\n  # 在头部中添加Vary: Accept-Encoding（建议开启）\r\n  gzip_vary on;\r\n  \r\n  # 处理压缩请求的缓冲区数量和大小\r\n  gzip_buffers 16 8k;\r\n\r\n  # 对于不支持压缩功能的客户端请求不开启压缩机制\r\n  gzip_disable \"MSIE [1-6]\\.\"; # 低版本的IE浏览器不支持压缩\r\n\r\n  # 设置压缩响应所支持的HTTP最低版本\r\n  gzip_http_version 1.1;\r\n\r\n  # 设置触发压缩的最小阈值\r\n  gzip_min_length 2k;\r\n\r\n  # 关闭对后端服务器的响应结果进行压缩\r\n  gzip_proxied off;\r\n\r\n  # 配置前端静态资源\r\n  location / {\r\n    root   /home/micro/microReact/build;\r\n    index  index.html index.htm;\r\n    try_files $uri $uri/ /index.html;\r\n\r\n    # # index.html使用协商缓存\r\n    add_header Cache-Control 'no-cache';\r\n\r\n    if ($request_uri ~* .*[.](js|css|map|jpg|png|svg|ico)$) {\r\n      # 非html资源强缓存1个月\r\n      add_header Cache-Control \"max-age=2592000\";\r\n    }\r\n\r\n    if ($request_filename ~* ^.*[.](html|htm)$) {\r\n      # html使用协商缓存\r\n      add_header Cache-Control \"no-cache\";\r\n    }\r\n  }\r\n\r\n  # 兼容子应用独立访问\r\n  location /microReact {\r\n    proxy_pass http://ip:8001/;\r\n  }\r\n}\r\n\r\n# vue子应用\r\nserver {\r\n  # 监听端口\r\n  listen       8002;\r\n\r\n  # 服务ip\r\n  server_name  ip;\r\n\r\n  # 开启gzip压缩功能\r\n  gzip on;\r\n\r\n  # 指定会被压缩的文件类型\r\n  gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/json;\r\n\r\n  # 设置压缩级别，越高资源消耗越大，但压缩效果越好\r\n  gzip_comp_level 5;\r\n\r\n  # 在头部中添加Vary: Accept-Encoding（建议开启）\r\n  gzip_vary on;\r\n  \r\n  # 处理压缩请求的缓冲区数量和大小\r\n  gzip_buffers 16 8k;\r\n\r\n  # 对于不支持压缩功能的客户端请求不开启压缩机制\r\n  gzip_disable \"MSIE [1-6]\\.\"; # 低版本的IE浏览器不支持压缩\r\n\r\n  # 设置压缩响应所支持的HTTP最低版本\r\n  gzip_http_version 1.1;\r\n\r\n  # 设置触发压缩的最小阈值\r\n  gzip_min_length 2k;\r\n\r\n  # 关闭对后端服务器的响应结果进行压缩\r\n  gzip_proxied off;\r\n\r\n  # 配置前端静态资源\r\n  location / {\r\n    root   /home/micro/microVue/build;\r\n    index  index.html index.htm;\r\n    try_files $uri $uri/ /index.html;\r\n\r\n    # index.html使用协商缓存\r\n    add_header Cache-Control 'no-cache';\r\n\r\n    if ($request_uri ~* .*[.](js|css|map|jpg|png|svg|ico)$) {\r\n      # 非html资源强缓存1个月\r\n      add_header Cache-Control \"max-age=2592000\";\r\n    }\r\n\r\n    if ($request_filename ~* ^.*[.](html|htm)$) {\r\n      # html使用协商缓存\r\n      add_header Cache-Control \"no-cache\";\r\n    }\r\n  }\r\n\r\n  # 兼容子应用独立访问\r\n  location /microVue {\r\n    proxy_pass http://ip:8002/;\r\n  }\r\n}\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## qiankun微前端部署同级目录\r\n> 主应用和微应用部署到同一个服务器（同一个IP和端口）。微应用和主应用放在同一级目录下。\r\n\r\n```\r\n1. 主应用访问路径 http://ip\r\n2. react子应用访问路径 http://ip/microReact\r\n3. vue子应用访问路径 http://ip/microVue\r\n\r\n/home/micro  // 资源目录\r\n    ├── main\r\n        ├── build  // 主应用静态资源\r\n    ├── microReact     \r\n        ├── build       // react微应用静态资源\r\n    ├── microVue      \r\n        ├── build       // vue微应用静态资源\r\n```\r\n### 子应用配置webpack构建时的publicPath。\r\n```\r\npublicPath: process.env.NODE_ENV === 'development' ? '/' : '/microVue/build/',\r\n```\r\n### 子应用设置history路由base，用于微应用独立访问时使用。\r\n> 独立访问时的base设置成/microVue/而不是/microVue/build/，是因为nginx的location配置成/microVue/，具体可见下方nginx配置。同时保证和主应用配置的activeRule不一样\r\n\r\n```\r\nbase: window.__POWERED_BY_QIANKUN__ ? '/micro-vue/' : '/microVue/',\r\n```\r\n### 主应用中注册微应用的entry设置成微应用的部署路径，可以使用相对路径。\r\n> entry路径最后面的 / 不可省略，否则 publicPath 会设置错误。注册微应用的activeRule不能和微应用的部署路径一样，否则在主应用页面刷新会直接变成微应用页面。\r\n\r\n```\r\n// 注册子应用\r\nregisterMicroApps([\r\n  {\r\n    name: 'micro-react',\r\n    entry: process.env.NODE_ENV === 'development' ? '//localhost:8001' : '/microReact/',\r\n    container: '#microContainer',\r\n    activeRule: '/micro-react',\r\n  },\r\n  {\r\n    name: 'micro-vue',\r\n    entry: process.env.NODE_ENV === 'development' ? '//localhost:8002' : '/microVue/',\r\n    container: '#microContainer',\r\n    activeRule: '/micro-vue',\r\n  },\r\n]);\r\n```\r\n### nginx配置\r\n```\r\nserver {\r\n  # 监听端口\r\n  listen       80;\r\n\r\n  # 服务ip\r\n  server_name  ip;\r\n\r\n  # 开启gzip压缩功能\r\n  gzip on;\r\n\r\n  # 指定会被压缩的文件类型\r\n  gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/json;\r\n\r\n  # 设置压缩级别，越高资源消耗越大，但压缩效果越好\r\n  gzip_comp_level 5;\r\n\r\n  # 在头部中添加Vary: Accept-Encoding（建议开启）\r\n  gzip_vary on;\r\n  \r\n  # 处理压缩请求的缓冲区数量和大小\r\n  gzip_buffers 16 8k;\r\n\r\n  # 对于不支持压缩功能的客户端请求不开启压缩机制\r\n  gzip_disable \"MSIE [1-6]\\.\"; # 低版本的IE浏览器不支持压缩\r\n\r\n  # 设置压缩响应所支持的HTTP最低版本\r\n  gzip_http_version 1.1;\r\n\r\n  # 设置触发压缩的最小阈值\r\n  gzip_min_length 2k;\r\n\r\n  # 关闭对后端服务器的响应结果进行压缩\r\n  gzip_proxied off;\r\n\r\n  # 配置前端静态资源\r\n  # 主应用\r\n  location / {\r\n    root   /home/micro/main/build;\r\n    index  index.html index.htm;\r\n    try_files $uri $uri/ /index.html;\r\n\r\n    # index.html使用协商缓存\r\n    add_header Cache-Control 'no-cache';\r\n\r\n    if ($request_uri ~* .*[.](js|css|map|jpg|png|svg|ico)$) {\r\n      # 非html资源强缓存1个月\r\n      add_header Cache-Control \"max-age=2592000\";\r\n    }\r\n\r\n    if ($request_filename ~* ^.*[.](html|htm)$) {\r\n      # html使用协商缓存\r\n      add_header Cache-Control \"no-cache\";\r\n    }\r\n  }\r\n\r\n  # react子应用\r\n  location /microReact {\r\n    root   /home/micro;\r\n    index  build/index.html build/index.htm;\r\n    try_files $uri $uri/ /microReact/build/index.html;\r\n\r\n    # index.html使用协商缓存\r\n    add_header Cache-Control 'no-cache';\r\n\r\n    if ($request_uri ~* .*[.](js|css|map|jpg|png|svg|ico)$) {\r\n      # 非html资源强缓存1个月\r\n      add_header Cache-Control \"max-age=2592000\";\r\n    }\r\n\r\n    if ($request_filename ~* ^.*[.](html|htm)$) {\r\n      # html使用协商缓存\r\n      add_header Cache-Control \"no-cache\";\r\n    }\r\n  }\r\n\r\n  # vue子应用\r\n  location /microVue {\r\n    root   /home/micro;\r\n    index  build/index.html build/index.htm;\r\n    try_files $uri $uri/ /microVue/build/index.html;\r\n\r\n    # index.html使用协商缓存\r\n    add_header Cache-Control 'no-cache';\r\n\r\n    if ($request_uri ~* .*[.](js|css|map|jpg|png|svg|ico)$) {\r\n      # 非html资源强缓存1个月\r\n      add_header Cache-Control \"max-age=2592000\";\r\n    }\r\n\r\n    if ($request_filename ~* ^.*[.](html|htm)$) {\r\n      # html使用协商缓存\r\n      add_header Cache-Control \"no-cache\";\r\n    }\r\n  }\r\n}\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## qiankun微前端部署非同级目录\r\n> 主应用和微应用部署到同一个服务器（同一个 IP 和端口）。微应用都放在一个特殊名称的文件夹下，下面案例的文件夹名为child。\r\n\r\n```\r\n1. 主应用访问路径 http://ip\r\n2. react子应用访问路径 http://ip/child/micro-react\r\n3. vue子应用访问路径 http://ip/child/micro-vue\r\n\r\n/home/micro  // 资源目录\r\n    ├── main\r\n        ├── build  // 主应用静态资源\r\n    ├── child  // 微应用存放的文件夹\r\n        ├── micro-react      \r\n            ├── build       // react微应用静态资源\r\n        ├── micro-vue      \r\n            ├── build       // vue微应用静态资源\r\n```\r\n### 子应用配置webpack构建时的publicPath。\r\n```\r\npublicPath: process.env.NODE_ENV === 'development' ? '/' : '/child/micro-vue/build/',\r\n```\r\n### 子应用设置history路由base，用于微应用独立访问时使用。\r\n> 独立访问时的base设置成/child/micro-vue/而不是/child/micro-vue/build/，是因为nginx的location配置成/child/micro-vue/，具体可见下方nginx配置。\r\n\r\n```\r\nbase: window.__POWERED_BY_QIANKUN__ ? '/micro-vue/' : '/child/micro-vue/',\r\n```\r\n### 主应用中注册微应用的entry设置成微应用的部署路径，可以使用相对路径。\r\n> entry路径最后面的 / 不可省略，否则 publicPath 会设置错误。注册微应用的activeRule不能和微应用的部署路径一样，否则在主应用页面刷新会直接变成微应用页面。\r\n\r\n```\r\n// 注册子应用\r\nregisterMicroApps([\r\n  {\r\n    name: 'micro-react',\r\n    entry: process.env.NODE_ENV === 'development' ? '//localhost:8001' : '/child/micro-react/',\r\n    container: '#microContainer',\r\n    activeRule: '/micro-react',\r\n  },\r\n  {\r\n    name: 'micro-vue',\r\n    entry: process.env.NODE_ENV === 'development' ? '//localhost:8002' : '/child/micro-vue/',\r\n    container: '#microContainer',\r\n    activeRule: '/micro-vue',\r\n  },\r\n]);\r\n```\r\n### nginx配置\r\n```\r\nserver {\r\n  # 监听端口\r\n  listen       80;\r\n\r\n  # 服务ip\r\n  server_name  ip;\r\n\r\n  # 开启gzip压缩功能\r\n  gzip on;\r\n\r\n  # 指定会被压缩的文件类型\r\n  gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/json;\r\n\r\n  # 设置压缩级别，越高资源消耗越大，但压缩效果越好\r\n  gzip_comp_level 5;\r\n\r\n  # 在头部中添加Vary: Accept-Encoding（建议开启）\r\n  gzip_vary on;\r\n  \r\n  # 处理压缩请求的缓冲区数量和大小\r\n  gzip_buffers 16 8k;\r\n\r\n  # 对于不支持压缩功能的客户端请求不开启压缩机制\r\n  gzip_disable \"MSIE [1-6]\\.\"; # 低版本的IE浏览器不支持压缩\r\n\r\n  # 设置压缩响应所支持的HTTP最低版本\r\n  gzip_http_version 1.1;\r\n\r\n  # 设置触发压缩的最小阈值\r\n  gzip_min_length 2k;\r\n\r\n  # 关闭对后端服务器的响应结果进行压缩\r\n  gzip_proxied off;\r\n\r\n  # 配置前端静态资源\r\n  # 主应用\r\n  location / {\r\n    root   /home/micro/main/build;\r\n    index  index.html index.htm;\r\n    try_files $uri $uri/ /index.html;\r\n\r\n    # index.html使用协商缓存\r\n    add_header Cache-Control 'no-cache';\r\n\r\n    if ($request_uri ~* .*[.](js|css|map|jpg|png|svg|ico)$) {\r\n      # 非html资源强缓存1个月\r\n      add_header Cache-Control \"max-age=2592000\";\r\n    }\r\n\r\n    if ($request_filename ~* ^.*[.](html|htm)$) {\r\n      # html使用协商缓存\r\n      add_header Cache-Control \"no-cache\";\r\n    }\r\n  }\r\n\r\n  # react子应用\r\n  location /child/micro-react {\r\n    root   /home/micro;\r\n    index  build/index.html build/index.htm;\r\n    try_files $uri $uri/ /child/micro-react/build/index.html;\r\n\r\n    # index.html使用协商缓存\r\n    add_header Cache-Control 'no-cache';\r\n\r\n    if ($request_uri ~* .*[.](js|css|map|jpg|png|svg|ico)$) {\r\n      # 非html资源强缓存1个月\r\n      add_header Cache-Control \"max-age=2592000\";\r\n    }\r\n\r\n    if ($request_filename ~* ^.*[.](html|htm)$) {\r\n      # html使用协商缓存\r\n      add_header Cache-Control \"no-cache\";\r\n    }\r\n  }\r\n\r\n  # vue子应用\r\n  location /child/micro-vue {\r\n    root   /home/micro;\r\n    index  build/index.html build/index.htm;\r\n    try_files $uri $uri/ /child/micro-vue/build/index.html;\r\n\r\n    # index.html使用协商缓存\r\n    add_header Cache-Control 'no-cache';\r\n\r\n    if ($request_uri ~* .*[.](js|css|map|jpg|png|svg|ico)$) {\r\n      # 非html资源强缓存1个月\r\n      add_header Cache-Control \"max-age=2592000\";\r\n    }\r\n\r\n    if ($request_filename ~* ^.*[.](html|htm)$) {\r\n      # html使用协商缓存\r\n      add_header Cache-Control \"no-cache\";\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## 微前端\r\n### 使用微前端的场景\r\n- 项目功能逐渐增多，代码规模庞大，导致代码维护和开发效率低下。\r\n- 项目需要集成多个不同技术栈的模块或服务。\r\n- 团队成员分散，各自负责开发不同的模块或服务，需要实现独立开发和部署。\r\n- 项目需要支持独立的生命周期管理和版本控制。\r\n- 需要实现动态加载和卸载子应用等场景。\r\n### iframe\r\n#### iframe优点\r\n- iframe提供了浏览器原生的硬隔离方案，不论是样式隔离、js隔离这类问题统统都能被完美解决。\r\n#### iframe缺点\r\n1. 隔离性和通信复杂性：iframe本身提供了一种隔离的环境，但这也带来了通信和数据交互的复杂性。由于每个子应用都在独立的iframe中运行，它们之间的通信需要通过特定的机制，而这增加了开发和维护的复杂性。\r\n2. 性能和加载时间：每个iframe都需要加载和渲染独立的HTML、CSS和JavaScript。这意味着在加载微前端应用时，需要同时加载多个iframe，导致额外的网络请求和页面资源占用，可能会影响性能和加载时间。\r\n3. 样式和布局限制：iframe的内容在页面中是独立的，它们具有自己的CSS样式和布局上下文。这导致在微前端架构中难以实现全局样式的一致性，以及子应用之间的布局和交互的协调问题。例如带遮罩层的弹框居中显示的问题。\r\n4. url不同步：浏览器刷新iframe的url状态丢失、后退前进按钮无法使用。\r\n5. 浏览器安全性限制：由于安全策略的限制，iframe之间的跨域通信可能受到限制，特别是在涉及跨域资源访问和共享数据时。这可能导致在微前端架构中需要处理复杂的安全性问题。\r\n### 微前端运行原理\r\n#### 监听路由变化\r\n- 监听hash路由：window.onhashchange。\r\n- 监听history路由：window.onpopstate，重写pushState、replaceState通过函数重写的方式进行劫持。\r\n#### 匹配子应用\r\n> 监听路由的变化后拿到当前路由的路径window.location.pathname，然后根据registerMicroApps注册的子应用的activeRule获取匹配的子应用。\r\n\r\n#### 加载子应用\r\n> 找到当前路由匹配的子应用后可以加载这个子应用的html资源。不能给直接通过container.innerHTML = html将文本放到容器内，这样是无法显示的。浏览器处于安全考虑，放到页面上的html如果包含了js脚本，它是不会去执行js的，需要手动处理script脚本。\r\n\r\n- 将获取到的html文本放到template DOM节点中。\r\n- 获取所有的script脚本，script脚本分为内联脚本和外链脚本，拿到内联脚本后获取内容可以通过eval直接处理。如果是含有scr的script脚本，还需要拿到src的值，通过fetch去获取脚本。\r\n- 执行所有的script脚本，通过eval执行脚本。\r\n#### 渲染子应用\r\n\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## PureComponent比较逻辑\r\n- PrueComponent继承了Component将shouldComponentUpdate重写成了shallowCompare。\r\n- 在shallowCompare中使用shallowEqual方法对新旧Props和新旧State进行浅比较。\r\n```\r\nexport defualut function PureComponent(props, context) {\r\n  Component.call(this, props, context);\r\n}\r\nPureComponent.prototype = Object.create(Component.prototye);\r\nPureComponent.prototype.contructor = PureComponent;\r\nPureComponent.prototype.shouldComponentUpdate = shallowCompare;\r\n \r\nfunction shallowCompare(nextProps, nextState) {\r\n  return !shallowEqual(this.props, nextProps) || !shallowEqual(this.state, nextState);\r\n}\r\n```\r\n### shallowEqual的比较步骤\r\n1. 首先会直接比较新老Props和新老State两个对象的地址是否相同，如果地址相同，就直接返回true，如果地址不相同就继续判断。\r\n2. 判断新老Props和新老State，有不是对象或者为null的，返回false。\r\n3. 判断新老Props和新老State的属性个数(Object.keys)是否相同，如果不同证明有属性增加或者减少，返回false。\r\n4. 遍历老Props和老State的每一项，如果对应的新Props或新State中有没有与之对应的属性或对应的属性值不相等(浅比较)，返回false。\r\n```\r\nfunction shallowEqual(objA, objB) {\r\n  if (is(objA, objB)) {\r\n    return true;\r\n  }\r\n \r\n  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {\r\n    return false;\r\n  }\r\n \r\n  const keysA = Object.keys(objA);\r\n  const keysB = Object.keys(objB);\r\n \r\n  if (keysA.length !== keysB.length) {\r\n    return false;\r\n  }\r\n \r\n  for (let i = 0; i < keysA.length; i++) {\r\n    if (!hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {\r\n      return false;\r\n    }\r\n  }\r\n \r\n  return true;\r\n}\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## React性能优化\r\n> ‌React的更新机制是从状态变化的组件开始更新(不会从根组件开始触发更新)，然后递归更新整个组件树。\r\n\r\n### react工作流\r\n- React是声明式UI库，负责将数据转换为页面结构(虚拟DOM结构)后，再转换成真实DOM结构交给浏览器渲染。\r\n- 当数据发生改变时，React会先进行调和(Reconciliation)阶段，调和阶段结束后立刻进入提交(Commit)阶段，提交阶段结束后新数据对应的页面才被展示出来。\r\n#### 调和阶段\r\n1. 计算目标虚拟DOM结构：计算出目标数据对应的虚拟DOM结构(类组件的render方法或函数组件自身)。\r\n2. Diff过程：寻找将当前虚拟DOM结构修改为目标虚拟DOM结构的最优更新方案(Diff算法，会记录虚拟DOM的更新方式如Update、Mount、Unmount，为提交阶段做准备)。\r\n#### 提交阶段\r\n1. 更新真实DOM：将调和阶段记录的更新方式应用到真实DOM中。\r\n2. 调用暴露给开发者的生命周期钩子方法。 \r\n### Render过程\r\n- 调和阶段中计算目标虚拟DOM结构的过程称为Render过程。\r\n- 触发React组件的Render过程的方式\r\n    1. State更新\r\n    2. Props更新\r\n    3. 父组件Render触发子组件Render过程。\r\n    4. 组件依赖的上下文(context)发生变化\r\n    5. forceUpdate强制更新\r\n    6. 组件依赖的自定义hooks发生变化\r\n### react底层优化机制\r\n- 虚拟DOM + Diff算法高效的更新真实DOM。\r\n- 升级fiber架构使得Diff过程可以被中断且恢复，fiber架构把Diff的工作过程时间分片，避免JS脚本执行时间过长导致页面掉帧、页面卡顿。\r\n- 设计任务调度优先级更高效的更新，及时响应用户的操作。\r\n### 优化策略\r\n- 由于调和阶段的Diff过程和提交阶段的更新真实DOM都属于React的内部实现，开发者能提供的优化能力有限，仅有列表项使用key属性等少量优化技巧。\r\n- 实际项目中大部分优化方式都集中在调和阶段计算目标虚拟DOM的过程。\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## 优化场景\r\n### 点击显示弹窗，弹窗显示比较慢。\r\n- 页面内容过多(比如有表格)，弹窗显示时页面内容重新render导致弹窗显示比较慢。\r\n- 可以将控制弹窗显示的状态下放，当状态变化时不会导致页面重新render，可以提升弹窗显示的速度。\r\n### 耗时任务执行前后通过状态控制显示loading\r\n- 将耗时任务移动到下一个宏任务中执行，优先显示loading效果。\r\n```\r\nsetLoading(true);\r\nconst expandData: any = [];\r\nsetTimeout(() => {\r\n  const filterData = filterTreeData(\r\n    allCarData,\r\n    { title: value },\r\n    (item: any) => expandData.push(item.key)\r\n  );\r\n  setCarData(filterData);\r\n  setExpandedKeys(expandData);\r\n  setLoading(false);\r\n}, 100);\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## 更快的完成Diff比较\r\n### 列表项使用稳定唯一的key属性。\r\n- 在渲染元素列表时，尽量避免将数组索引作为组件的key。如果列表项有添加、删除及重新排序的操作，使用索引作为key可能会使节点复用率变低而影响性能。\r\n### 尽量保持更新前后节点类型一致。\r\n- 如果更新前后节点类型不一致的话无论有多少子组件将全部卸载重新创建。\r\n### 条件渲染时不要去破坏结构。\r\n- 尽量使用空节点来保持前后结构顺序的统一。"},function(r,n,e){"use strict";e.r(n),n.default="## 跳过不必要的组件更新\r\n### PureComponent、React.memo\r\n- 当父组件重新渲染时，即使父组件传给子组件的所有Props都没有变化，子组件也会重新渲染。\r\n- PureComponent会对类组件的State和Props进行浅比较，只有当State和Props发生变化时组件才会重新渲染。\r\n- React.memo会对函数组件的Props进行浅比较，只有当Props发生变化时组件才会重新渲染。支持第二个参数传入一个函数，如果组件需要更新就返回false，不需要更新就返回true。和shouldComponentUpdate正好相反。\r\n### shouldComponentUpdate\r\n- shouldComponentUpdate是class组件主要的优化方式。\r\n- 支持对this.props与nextProps以及this.state与nextState以及this.context和nextContext进行比较，如果组件需要更新就返回true，不需要更新就返回false。\r\n### useMemo、useCallback生成稳定的Props值\r\n- 如果传给子组件的Props每次都是新的引用(例如传递函数作为子组件Props时，父组件每次重新渲染，作为Props的函数都会生成新的引用)，那么React.memo的优化就会失效。\r\n- 可以借助useMemo或useCallback来生成稳定的Props值，并结合React.memo避免子组件重新渲染。\r\n### Immutable Data + PureComponent(React.memo)\r\n- 使用Immutable Data凡是有节点被改变，那么它和与它相关的所有上级节点都更新，并且更新后返回了一个全新的引用，即使是浅比对也能感知到数据的改变。\r\n- 使用Immutable Data + PureComponent(React.memo)可以更高效的识别出State和Props是否变化(引用类型数据变化无需深比较就可以高效识别)，从而通过PureComponent(React.memo)可以更高效的判断组件是否需要更新。\r\n### 发布者订阅者跳过中间组件的渲染\r\n- React推荐将公共数据放在所有需要该状态的组件的公共祖先上，但将状态放在公共祖先上后，该状态就需要层层向下传递，直到传递给使用该状态的组件为止。每次状态的更新都会涉及中间组件的渲染，但中间组件并不关心该状态，中间组件只负责将该状态再传给子组件。\r\n- 这种场景下可以将状态用发布者订阅者模式维护，只有关心该状态的组件才去订阅该状态，不再需要中间组件传递该状态。当状态更新时发布者发布数据更新消息，只有订阅者组件才会重新渲染，中间组件不再需要重新渲染。\r\n- 只要是发布者订阅者模式的库，都可以进行该优化。比如redux、React.createContext等。\r\n### 合理使用Context\r\n- Context能够在组件树间跨层级传递数据。\r\n- Context可以绕过React.memo或shouldComponentUpdate设定的比较过程，一旦Context的Value变动，所有使用useContext获取该Context的组件会全部forceUpdate，即使Context更新的部分value与当前组件无关。\r\n- 为了使组件仅在Context与其相关的value发生更改时重新渲染，将组件分为两个部分。在外层组件中从Context中读取所需内容，并将其作为props传递给使用memo优化的子组件。\r\n### 状态下放，缩小状态影响范围\r\n- 如果一个状态只在某部分子树中使用，那么可以将这部分子树提取为组件，并将该状态移动到该组件内部。\r\n### useMemo返回稳定的虚拟DOM\r\n- 相较于React.memo需要对组件进行一次包装生成新的组件，useMemo返回稳定的虚拟DOM形式只需在存在性能瓶颈的地方使用，不用修改组件，使用更方便。\r\n- useMemo返回稳定的虚拟DOM形式不用判断组件的所有Props，而只需考虑当前场景中用到的值，使用更灵活。\r\n- 父组件\r\n```\r\n// 子组件只关心count数据，当更新name数据的时候，Children子组件不会重新渲染，实现对组件的缓存控制。\r\nimport React, { useState, useMemo } from 'react';\r\nimport Children from './children';\r\n\r\nconst Parent = () => {\r\n  const [count, setCount] = useState(0);\r\n  const [name, setName] = useState(0);\r\n\r\n  const memoChildren = useMemo(() => <Children count = {count} />, [count]);\r\n  return (\r\n    <div>\r\n      <div>count：{count}；name：{name}</div>\r\n      <button onClick={() => setCount(count + 1)}>点击更新count</button>\r\n      <button onClick={() => setName(name + 1)}>点击更新name</button>\r\n      {memoChildren}\r\n    </div>\r\n  )\r\n}\r\n\r\nexport default Parent;\r\n```\r\n- 子组件\r\n```\r\nimport React from 'react';\r\n\r\nconst Children = (props) => {\r\n  console.log('render');\r\n  return (\r\n    <div>\r\n      子组件只关心count数据\r\n      {props.count}\r\n    </div>\r\n  )\r\n}\r\n\r\nexport default Children;\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## 通用优化\r\n### 减少波及范围，无关页面更新数据不存入State中\r\n- 在class组件可以使用类组件的实例属性存储无关页面更新的数据。\r\n- 在函数组件中可以通过useRef来存储无关页面更新的数据。\r\n### 使用useMemo缓存计算结果，减少不必要的计算逻辑\r\n- 当useMemo的依赖未发生改变时，就不会触发重新计算。一般用在有非常耗时的计算场景中。\r\n### 控制更新优先级\r\n- 使用useTransition提供的startTransition来标记一个更新为不紧急的更新。这段任务可以接受延迟或被打断渲染，进而去优先考虑更重要的任务执行。\r\n- 将耗时任务移动到下一个宏任务中执行，优先响应用户行为。\r\n### 在组件卸载时清除全局监听器、定时器等。防止内存泄漏影响性能。\r\n### Fragment\r\n- 当渲染多个元素而不需要额外的容器元素时，使用Fragment减少DOM节点的数量，从而提高渲染性能。\r\n### 批量更新State，减少setState的重复操作\r\n- 在React18之前的版本中，在生命周期钩子函数和React合成事件中会自动应用批量更新，在异步函数(setTimeout、 Promise的then回调)和原生事件中(addEventListener)不会应用批量更新，可以使用unstable_batchedUpdates方法实现批量更新。\r\n- React18中的任何场景都会自动应用批量更新。\r\n#### React合成事件中多次调整state，只会重新渲染一次，批量更新。\r\n```\r\nimport React, { Component } from 'react';\r\n\r\nexport default class Home extends Component {\r\n  state = {\r\n    count: 0\r\n  }\r\n\r\n  buttonClick = () => {\r\n    this.setState({\r\n      count: this.state.count + 1\r\n    });\r\n    console.log(this.state.count); // 0\r\n    this.setState({\r\n      count: this.state.count + 1\r\n    });\r\n    console.log(this.state.count); // 0\r\n    this.setState({\r\n      count: this.state.count + 1\r\n    });\r\n    console.log(this.state.count); // 0\r\n  }\r\n\r\n  render() {\r\n    console.log('render', this.state.count); // 1\r\n    return (\r\n      <div>\r\n        <div>{this.state.count}</div>\r\n        <button onClick={this.buttonClick}>click</button>\r\n      </div>\r\n    )\r\n  }\r\n}\r\n```\r\n#### 原生事件中多次调整state，会重新渲染多次，react18之前为非批量更新，react18之后为批量更新。\r\n```\r\nimport React, { Component } from 'react';\r\n\r\nexport default class Home extends Component {\r\n  state = {\r\n    count: 0\r\n  }\r\n\r\n  componentDidMount() {\r\n    document.getElementById('dyx')?.addEventListener('click', this.buttonClick)\r\n  }\r\n\r\n  componentWillUnmount() {\r\n    document.getElementById('dyx')?.removeEventListener('click', this.buttonClick)\r\n  }\r\n\r\n  buttonClick = () => {\r\n    this.setState({\r\n      count: this.state.count + 1\r\n    });\r\n    console.log(this.state.count); // 1\r\n    this.setState({\r\n      count: this.state.count + 1\r\n    });\r\n    console.log(this.state.count); // 2\r\n    this.setState({\r\n      count: this.state.count + 1\r\n    });\r\n    console.log(this.state.count); // 3\r\n  }\r\n\r\n  render() {\r\n    console.log('render', this.state.count); // 1、2、3\r\n    return (\r\n      <div>\r\n        <div>{this.state.count}</div>\r\n        <button id=\"dyx\">click</button>\r\n      </div>\r\n    )\r\n  }\r\n}\r\n```\r\n#### 使用unstable_batchedUpdates将非批量更新的场景调整为批量更新(react18之前使用)。\r\n```\r\nimport React, { Component } from 'react';\r\nimport { unstable_batchedUpdates } from 'react-dom';\r\n\r\nexport default class Home extends Component {\r\n  state = {\r\n    count: 0\r\n  }\r\n\r\n  componentDidMount() {\r\n    document.getElementById('dyx')?.addEventListener('click', this.buttonClick)\r\n  }\r\n\r\n  componentWillUnmount() {\r\n    document.getElementById('dyx')?.removeEventListener('click', this.buttonClick)\r\n  }\r\n\r\n  buttonClick = () => {\r\n    unstable_batchedUpdates(() => {\r\n      this.setState({\r\n        count: this.state.count + 1\r\n      });\r\n      console.log(this.state.count); // 0\r\n      this.setState({\r\n        count: this.state.count + 1\r\n      });\r\n      console.log(this.state.count); // 0\r\n      this.setState({\r\n        count: this.state.count + 1\r\n      });\r\n      console.log(this.state.count); // 0\r\n    })\r\n  }\r\n\r\n  render() {\r\n    console.log('render', this.state.count); // 1\r\n    return (\r\n      <div>\r\n        <div>{this.state.count}</div>\r\n        <button id=\"dyx\">click</button>\r\n      </div>\r\n    )\r\n  }\r\n}\r\n```\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## 前端处理高并发\r\n### 使用配置更高的服务器\r\n### 前端缓存\r\n> 通过将静态资源或经常使用的数据缓存至浏览器或CDN节点，可以减少服务器压力和网络传输时间，提高页面的加载速度和响应速度。\r\n\r\n### 负载均衡\r\n> 通过负载均衡技术，将请求分配到多个服务器上处理，充分利用服务器资源提高整体处理能力，可以提高系统的可用性和稳定性，避免单一服务器过载导致系统崩溃的情况发生。"},function(r,n,e){"use strict";e.r(n),n.default="## 图片资源优化\r\n### 图片懒加载\r\n- 当图片出现在可视区域或者即将出现在可视区域时再加载图片，避免一次性加载全部图片。\r\n- JS实现：先将图片路径设置给original-src，当页面不可见时图片不会加载，通过监听页面滚动，等页面可见时设置图片src。\r\n- CSS实现：使用background-url的样式规则如果不应用到具体的元素，浏览器不会去下载该图片。可以通过切换className的方式进行CSS中图片的懒加载。\r\n### 图片压缩\r\n- 一些图片适当降低图片质量时，通常是看不出来区别的，可以使用[tinypng](https://tinypng.com/)、image-webpack-loader进行图片压缩。\r\n\r\n### 尽量使用CSS代替图片\r\n- 一些简单的图片效果如果可以通过CSS效果实现则进行用CSS来实现，可以减小请求次数或者打包体积大小。\r\n### 使用webp图片\r\n- webp的优势体现在它具有更优的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量。\r\n- 同时具备了无损和有损的压缩模式、Alpha透明以及动画的特性，在JPEG和PNG上的转化效果都相当优秀、稳定和统一。\r\n### 图片转base64格式\r\n- 将小图片转换为base64编码格式，减少http请求。\r\n### 雪碧图\r\n- 将多个小图标保存为一个独立的图片文件，然后通过CSS将对应元素的背景图片设置为对应的图标图片。\r\n- 当页面加载时同时请求非常多的小图标图片，不会受到浏览器并发HTTP请求数的限制。"},function(r,n,e){"use strict";e.r(n),n.default="## 客户端优化H5加载速度\r\n### 容器预建\r\n- 与浏览器不同，App打开H5页面的第一步并不是建立页面请求连接，而是初始化Webview。\r\n- 初始化Webview包括创建Webview实例，对于App冷启动后的首次Webview初始化，还需要初始化浏览器内核。\r\n- 对于冷启动或者全新安装的App，首次初始化Webview耗时相对较长，大概在数百ms；而二次打开就较快了，大概在数十ms。\r\n### 资源离线化\r\n- 将H5资源提前下载或内置到App中。这样加载资源时就可以通过App内部的请求拦截机制转发本地资源，避免网络请求。\r\n- 优化后可以显著降低资源加载的耗时，减少白屏时间，一般不超过100ms（仅剩资源解析和本地 I/O 耗时），不再受弱网限制。"},function(r,n,e){"use strict";e.r(n),n.default="## 性能优化\r\n- 加载时优化：让一个网站加载过程更快，比如压缩文件大小、使用CDN加速等方式可以优化加载性能。\r\n- 运行时优化：资源加载完毕后，在页面开始运行的时候进行优化。\r\n### 加载时性能\r\n> 检查加载性能的指标一般看：白屏时间和首屏时间。\r\n\r\n- 白屏时间：指的是从输入网址到页面开始显示内容的时间。\r\n```\r\n// 将代码脚本放在</head>前面就能获取白屏时间\r\n<script>\r\n  new Date().getTime() - performance.timing.navigationStart\r\n<\/script>\r\n```\r\n- 首屏时间：指的是从输入网址到首屏页面内容渲染完毕的时间。\r\n```\r\n// 在window.onload事件中执行以下代码，可以获取首屏时间：\r\nnew Date().getTime() - performance.timing.navigationStart\r\n```\r\n### 运行时性能\r\n> 运行时性能是指页面运行时的性能表现，可以通过chrome开发者工具中的Performance面板来分析页面的运行时性能。"},function(r,n,e){"use strict";e.r(n),n.default='## [性能指标](https://juejin.cn/post/6850037270729359367)\r\n### 性能检测网站\r\n- [https://gtmetrix.com/](https://gtmetrix.com/)\r\n- [https://www.debugbear.com/test](https://www.debugbear.com/test)\r\n- [https://www.webpagetest.org](https://www.webpagetest.org)\r\n### First Paint(FP) 首次绘制\r\n> 首次渲染的时间点，可以视为白屏时间，比如完成背景色渲染的时间点。通常作为时间点最早的一个性能指标。\r\n\r\n### First Contentful Paint(FCP) 首次内容绘制\r\n> 首次有内容渲染的时间点，指标测量页面从开始加载到页面内容的任何部分在屏幕上完成渲染的时间。对于该指标，"内容"指的是文本、图像、`<svg>`元素或非白色的`<canvas>`元素，可以作为首屏时间。\r\n\r\n### Largest Contentful Paint(LCP) 最大内容绘制\r\n> 页面的最大内容（通常是比较核心的内容）加载完成的时间，这个最大内容可以是图片/文本块。它是一个SEO相关的指标。LCP其实能比前两个指标更能体现一个页面的性能好坏程度，当页面出现骨架屏或者Loading动画时FCP其实已经被记录下来了，但是此时用户希望看到的内容其实并未呈现，我们更想知道的是页面主要的内容是何时呈现出来的。\r\n\r\n### Time to Interactive(TTI) 可交互时间\r\n> Long Task：如果浏览器JS引擎线程执行的一个task耗时大于50ms，那么这个task称为long task。GUI渲染线程与JS引擎线程是互斥的，所以当发生Long Task时，用户的交互操作很可能无法及时执行，这时用户就会体验到卡顿（当页面响应时间超过100ms时，用户可以体验到卡顿），进而影响用户体验。从页面加载开始到页面处于完全可交互状态所花费的时间。通常是发生在页面依赖的资源已经加载完成，此时浏览器可以快速响应用户交互的时间。\r\n\r\n**满足条件**\r\n- 从FCP指标后开始计算\r\n- 持续5秒内无长任务（执行时间超过50ms）且无两个以上正在进行中的GET请求\r\n- 往前回溯至5秒前的最后一个长任务结束的时间\r\n### First Input Delay(FID) 首次输入延迟\r\n> 记录在FCP和TTI之间用户首次与页面交互时响应的延迟。这个指标的触发是在用户第一次与页面交互的的时候，记录的是是用户第一次与页面交互到浏览器真正能够开始处理事件处理程序以响应该交互的时间，即交互延迟时间。比如发生在用户第一次在页面进行click，keydown等交互。发生输入延迟是因为浏览器的主线程正忙着执行其它工作（比如解析和执行大型JS文件），还不能响应用户。\r\n\r\n### Cumulative Layout Shift(CLS) 累积布局偏移\r\n> 在一个页面的生命周期中，会不断的发生布局变化（layout shift），对每一次布局变化做一个累积的记分，其中得分最大布局变化即为CLS。是衡量页面稳定性的重要指标（visual stability）。\r\n\r\n### Total Blocking Time(TBT) 阻塞总时间\r\n> 记录在FCP到TTI之间所有长任务的阻塞时间总和。\r\n\r\n### First Meaningful Paint(FMP) 首次有效绘制\r\n> 首次绘制有意义内容的时间。业界比较认可的方式是在加载和渲染过程中最大布局变动之后的那个绘制时间即为当前页面的FMP。因为它计算相对复杂，且存在准确性等问题，Lighthouse 6.0中被废弃。更多的使用LCP指标。\r\n\r\n### Core Web Vitals\r\n> Google提出的衡量网站用户体验的核心数据指标，涵盖了页面的加载速度、可交互性和稳定性。是近期生效的会影响SEO的重要指标，包含一下三项：LCP、FID、CLS。\r\n\r\n### DOMContentLoaded(DCL)\r\n> DOM加载完成即触发，不用等页面资源加载。\r\n\r\n### Load(L)\r\n> 页面及其依赖的资源全部加载完成的时间，包括所有的资源文件，如样式表和图片等。\r\n\r\n### FP vs FCP\r\n> 可以把这两个指标认为是和白屏时间相关的指标。\r\n\r\n- FP：从开始加载到第一次渲染，FCP：从开始加载到第一次内容渲染。\r\n- FCP是FP的增强版，对用户来说更关键。因为FCP带着图像和文字这些内容信息，是用户更关心的。\r\n- FP时间小于等于FCP。\r\n### LCP vs FCP\r\n- FCP：页面加载过程中，比较早期的一个指标，如果一个页面有loading态，这个指标表现可能很好，但是实际内容什么时候呈现给用户，这个指标没办法衡量。\r\n- LCP：关注页面核心内容呈现时间，这个内容是用户更感兴趣的，更加和用户相关。'},function(r,n,e){"use strict";e.r(n),n.default='## 网络层面优化\r\n### 减少http请求\r\n### http2\r\n- 解析速度快。\r\n- 多路复用，多个请求可以共用一个TCP连接。\r\n- 头部压缩，更小的负载体积。\r\n### 静态资源上传到CDN(内容分发网络)\r\n- 将静态资源上传到CDN，用户请求资源时返回就近节点上缓存的资源，不需要每个用户的请求都回源站获取，避免网络拥塞、缓解源站压力，保证用户访问资源的速度和体验。\r\n### 充分利用http缓存\r\n- HTML：使用协商缓存。\r\n- CSS&JS&图片：使用强缓存，将打包的文件名加上contenthash。\r\n### 自托管第三方资源\r\n- 第三方资源官方的cdn比较慢的情况下可以考虑自托管三方资源，根据项目实际情况进行使用。\r\n### DNS优化\r\n#### 减少DNS请求次数\r\n#### 缩短DNS解析时间dns-prefetch(DNS预解析)\r\n- 提前解析之后可能会用到的域名，使解析结果缓存到系统缓存中，缩短DNS解析时间，进而提高网站的访问速度。适用于网页引用了大量其他域名的资源。\r\n- dns-prefetch需慎用，多页面应用重复DNS预解析会增加重复DNS查询次数导致过量的DNS解析，对网络是一种负担。\r\n```\r\n// 用meta标签来告知浏览器当前页面要做DNS预解析。\r\n<meta http-equiv="x-dns-prefetch-control" content="on" />\r\n\r\n// 用link标签对指定域名做DNS预解析。\r\n<link rel="dns-prefetch" href="https://www.baidu.com/" />\r\n```\r\n#### dns-prefetch原理\r\n> 当浏览器访问一个域名的时候，需要解析一次DNS获得对应域名的ip地址。解析过程按照如下顺序逐步读取缓存直到拿到IP地址。dns-prefetch就是将解析后的IP缓存在系统中。因为dns-prefetch在本地操作系统做了DNS缓存，使得DNS在解析的过程中，提前在系统缓存中找到了对应IP，后续的解析步骤就不用执行了，有效地缩短了DNS解析时间。\r\n\r\n- 浏览器缓存\r\n- 系统缓存\r\n- 路由器缓存\r\n- ISP(运营商)DNS缓存\r\n- 根域名服务器\r\n- 顶级域名服务器\r\n- 主域名服务器\r\n#### DNS解析耗时\r\n> dns-prefetch可以给DNS解析过程带来15-300ms的提升，尤其是一些大量引用很多其他域名资源的网站，提升效果就更加明显了。\r\n\r\n- 假如浏览器首次将一个域名解析为IP地址，并缓存至操作系统，那么下一次DNS解析时间可以低至0-1ms。\r\n- 假如解析结果不缓存在系统，那么就需要读取路由器的缓存，进而后续的解析时间最小也要约15ms。\r\n- 如果路由器缓存也不存在，则需要读取ISP(运营商)DNS缓存，一般像taobao.com、baidu.com这些常见的域名，读取ISP(运营商)DNS缓存需要的时间在80-120ms，如果是不常见的域名，平均需要200-300ms。大部分的网站到运营商这块都能找到IP。\r\n#### 浏览器DNS缓存\r\n- 现代浏览器为了优化DNS解析，也设有了浏览器DNS缓存。\r\n- 每当在首次DNS解析后会对其IP进行缓存。缓存时长每种浏览器都不一样，比如Chrome的过期时间是1分钟，在这个期限内不会重新请求DNS。\r\n- 每当Chrome浏览器启动的时候，就会自动的快速解析浏览器最近一次启动时记录的前10个域名。所以经常访问的网址就不存在DNS解析的延迟，进而打开速度更快。\r\n- 而dns-prefetch相当于在浏览器缓存之后，在本地操作系统中做了DNS缓存，为的是给浏览器缓存做保障，尽量让DNS解析存储在本地，以此做了又一层的DNS解析优化。\r\n- DNS在系统的缓存时间是大于浏览器的。\r\n#### 浏览器与系统DNS缓存时间\r\n> TTL(Time-To-Live)就是一条域名解析记录在DNS服务器中的存留时间，国内和国际上很多平台的TTL值都是以秒为单位的，很多的默认值都是3600，也就是默认缓存1小时。\r\n\r\n- 浏览器DNS缓存的时间跟DNS服务器返回的TTL值无关, 它的缓存时间取决于浏览器自身设置。\r\n- 系统缓存会参考DNS服务器响应的TTL值，但是不完全等于TTL值。\r\n#### dns-prefetch最佳实践\r\n- dns-prefetch仅对跨域域上的DNS查找有效，因此请避免使用它来指向相同域。这是因为到浏览器看到提示时站点域背后的IP已经被解析。\r\n- 考虑将dns-prefetch与preconnect(预连接)搭配使用。\r\n    - 由于dns-prefetch仅执行DNS查找，不像preconnect会建立与服务器的连接。如果站点是通过HTTPS服务的，两者的组合会涵盖DNS解析，建立TCP连接以及执行TLS握手。将两者结合起来可提供进一步减少跨域请求的感知延迟的机会。\r\n    - 如果页面需要建立与许多第三方域的连接，则将它们预先连接会适得其反。preconnect提示最好仅用于最关键的连接，对于其它的连接使用dns-prefetch节省第一步的DNS查找时间即可。\r\n```\r\n<link rel="preconnect" href="https://www.baidu.com/" crossorigin>\r\n<link rel="dns-prefetch" href="https://www.baidu.com/" />\r\n```'},function(r,n,e){"use strict";e.r(n),n.default="## 资源体积优化\r\n### 文件传输名词\r\n- 传输时间：资源网络传输耗时。\r\n- transferSize：资源大小。\r\n- encodedBodySize：压缩过的资源大小。\r\n- decodedBodySize：解压后的资源大小。\r\n### 代码压缩\r\n- 删除不必要的字符、空白和注释。\r\n- 如果使用的是webpack v5或更高版本时代码压缩是自带的功能，如果是v5以下或者希望自定义配置，可使用terser-webpack-plugin实现压缩。\r\n### 单独打包css及压缩css代码\r\n- webpack默认将js代码和css代码打包到一个文件，可使用mini-css-extract-plugin单独打包css会减少整包的体积。\r\n- 使用css-minimizer-webpack-plugin压缩css代码。\r\n### 开启gzip压缩\r\n### 路由懒加载Suspense + React.lazy\r\n- 按需加载，将每个路由页面单独打包为一个文件。\r\n- 路由懒加载修改一个页面代码之后，这个页面的文件会被修改，其它页面的文件不会被修改，main.js文件也会被修改，因为main.js文件有引用这个文件的逻辑。\r\n### 代码分割optimization.splitChunks\r\n- webpack默认会将所有模块代码打包在一起，这种规则的优点是能减少页面的HTTP请求数，缺点是页面初始代码包过大影响首屏渲染性能。\r\n- 无法有效使用http缓存，分包可避免代码修改整个bundle缓存失效。\r\n### 三方依赖单独使用cdn引入，使用externals属性单独配置。\r\n### 三方依赖的按需引入\r\n- 如果直接引入整个依赖，会导致项目的体积过大，可以只引入需要使用的内容，以达到减小项目体积的目的。\r\n```\r\nimport lodash -> import lodash/get\r\n```\r\n### 使用支持Tree Shaking的三方依赖\r\n```\r\nimport lodash -> import lodash-es\r\n```\r\n### 替换使用更小的库\r\n- 使用dayjs替换moment。\r\n### 语言包按需加载\r\n- 使用moment只保留en-gb、zh-cn两个语言包时gzip体积小53kb。\r\n```\r\n// 只引入中文和英文两个语言包\r\nnew webpack.ContextReplacementPlugin(/moment[/\\\\]locale$/, /en-gb|zh-cn/)\r\n```\r\n### 减少不必要的三方依赖的使用\r\n- yarn why查看依赖被引用的情况。可根据项目实际情况减少三方依赖的使用。\r\n### polyfill按需加载\r\n- polyfill是为了浏览器兼容性而生，是否需要polyfill应该由客户端的浏览器自己决定，而不是开发者决定，可以通过设置应用要运行的目标浏览器环境实现polyfill的按需加载。\r\n### 复用babel的辅助函数\r\n- @babel/plugin-transform-runtime会将我们用到的辅助函数，从@babel/runtime中以require的方式引入到我们的文件中实现复用。\r\n### 模块懒加载(使用时动态导入模块，不在首页就加载)\r\n- xlsx下载文件，在使用的时候再加载xlsx依赖。使用动态import引入的依赖可以单独打包出来。\r\n```\r\nconst buttonClick = async() => {\r\n  // 使用时异步引入xlsx模块\r\n  const xlsx = await import('xlsx');\r\n  xlsx.writeFile(wb, filename)\r\n}\r\n```\r\n```\r\nconst srcSuccess = []\r\n\r\nfunction stdOnEnd(script, cb) {\r\n  script.onload = function () {\r\n    this.onerror = this.onload = null\r\n    cb(null, script)\r\n  }\r\n  script.onerror = function () {\r\n    // this.onload = null here is necessary\r\n    // because even IE9 works not like others\r\n    this.onerror = this.onload = null\r\n    cb(new Error('Failed to load ' + this.src), script)\r\n  }\r\n}\r\n\r\nfunction ieOnEnd(script, cb) {\r\n  script.onreadystatechange = function () {\r\n    if (this.readyState !== 'complete' && this.readyState !== 'loaded') return\r\n    this.onreadystatechange = null\r\n    cb(null, script) // there is no way to catch loading errors in IE8\r\n  }\r\n}\r\n\r\nfunction load(src, opts, cb) {\r\n  var head = document.head || document.getElementsByTagName('head')[0]\r\n  var script = document.createElement('script')\r\n\r\n  if (typeof opts === 'function') {\r\n    cb = opts\r\n    opts = {}\r\n  }\r\n\r\n  opts = opts || {}\r\n  cb = cb || function () {}\r\n\r\n  script.type = opts.type || 'text/javascript'\r\n  script.charset = opts.charset || 'utf8'\r\n  script.async = 'async' in opts ? !!opts.async : true\r\n  script.src = src\r\n\r\n  if (opts.attrs) {\r\n    for (var attr in opts.attrs) {\r\n      script.setAttribute(attr, opts.attrs[attr])\r\n    }\r\n  }\r\n\r\n  if (opts.text) {\r\n    script.text = '' + opts.text\r\n  }\r\n\r\n  const callback = (error, script) => {\r\n    cb(error, script)\r\n    error && head.removeChild(script)\r\n  }\r\n\r\n  var onend = 'onload' in script ? stdOnEnd : ieOnEnd\r\n  onend(script, callback)\r\n\r\n  // some good legacy browsers (firefox) fail the 'in' detection above\r\n  // so as a fallback we always set onload\r\n  // old IE will ignore this and new IE will set onload\r\n  if (!script.onload) {\r\n    stdOnEnd(script, callback)\r\n  }\r\n\r\n  head.appendChild(script)\r\n}\r\n\r\n\r\nconst importScript = (src, opts) => {\r\n  if (srcSuccess.indexOf(src) !== -1) {\r\n    return Promise.resolve()\r\n  }\r\n  return new Promise((resolve, reject) => {\r\n    load(src, opts, (error, script) => {\r\n      if (error) {\r\n        reject(error)\r\n      } else {\r\n        srcSuccess.push(src)\r\n        resolve()\r\n      }\r\n    })\r\n  })\r\n}\r\n\r\nexport default importScript\r\n\r\n// 使用\r\nconst onExport = async () => {\r\n  const isSuccess = await importScript(\"https://cdn.bootcdn.net/ajax/libs/xlsx/0.18.5/xlsx.full.min.js\", { async: false });\r\n  if (isSuccess) {\r\n    // 下载逻辑\r\n    ...\r\n  } else {\r\n    message.error('资源加载失败');\r\n  }\r\n}\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## 项目细节优化\r\n### JavaScript异步和延迟加载\r\n- JavaScript文件默认为同步加载，这意味着在脚本完全加载和执行之前，它们会阻止网页的渲染。\r\n- 异步加载和延迟加载技术允许JavaScript文件独立于页面渲染过程进行加载，从而最大限度地减少对加载时间的影响。\r\n- 异步加载可确保脚本在可用时立即加载和执行，而延迟加载则会延迟脚本的执行，直到HTML解析完成。\r\n### 长时间任务优化(避免卡顿)\r\n> 浏览器单线程的运行方式决定了JavaScript长时间运行的任务会阻塞UI渲染和用户交互，从而影响性能。\r\n\r\n- 使用Web Worker执行长时间任务避免阻塞UI。\r\n- 对于长时间任务可以将其分解为一系列较小的任务并在空闲时执行，使用时间切片的策略。\r\n```\r\nfunction chunk(taskList, iteration, context) {\r\n  requestIdleCallback((deadline) => {\r\n    while (deadline.timeRemaining() > 0 && taskList.length > 0) {\r\n      iteration.call(context, taskList.shift());\r\n    }\r\n\r\n    if (taskList.length > 0) {\r\n      chunk(taskList, iteration, context);\r\n    }\r\n  });\r\n}\r\n\r\nchunk(longTasks, (task) => {\r\n  task.execute();\r\n}, this);\r\n```\r\n- 当使用js做了些逻辑，还触发了样式变化，style把应用的样式规则计算好之后，把影响到的页面元素进行重新布局，叫做layout，再把它画到内存的一个画布里面，paint成了像素，最后把这个画布刷到屏幕上去，叫做composite，形成一帧。\r\n![浏览器](./img/%E6%B5%8F%E8%A7%88%E5%99%A8.webp)\r\n  1. 当js只是做一些运算，并没有增删DOM或改变CSS，那么后续几步就不会执行。\r\n  2. style只改了颜色等不需要重新layout的属性就不用执行layout这一步。\r\n  3. style改了transform属性，在blink和edge浏览器里面不需要layout和paint。\r\n### 交互形式优化\r\n- 合理使用防抖和节流(滚动等触发频繁的事件)。\r\n- 骨架屏优化白屏时长。\r\n- 长列表优化。\r\n    - 滚动加载更多。\r\n    - 分页实现。\r\n    - 虚拟列表。\r\n### 动画优化\r\n- 使用CSS3动画替代JavaScript动画。\r\n- 使用requestAnimationFrame进行动画处理。\r\n### 布局优化\r\n- 避免重排和重绘。\r\n> 重排和重绘是浏览器渲染过程中的两个步骤，它们对性能影响很大。优化的关键在于尽可能减少触发重排和重绘的操作，\r\n  \r\n  1. 避免table布局\r\n  2. 样式集中改变\r\n  ```\r\n  // 三次重排\r\n  div.style.left = '10px';\r\n  div.style.top = '10px';\r\n  div.style.width = '20px';\r\n\r\n  // 一次重排\r\n  div.style.cssText = 'left: 10px;top: 10px; width: 20px';\r\n  ```\r\n  3. 分离读写操作：DOM的多个读操作或多个写操作，应该放在一起。不要两个读操作之间，加入一个写操作。\r\n  ```\r\n  // bad 强制刷新 触发四次重排+重绘\r\n  div.style.left = div.offsetLeft + 1 + 'px';\r\n  div.style.top = div.offsetTop + 1 + 'px';\r\n  div.style.right = div.offsetRight + 1 + 'px';\r\n  div.style.bottom = div.offsetBottom + 1 + 'px';\r\n\r\n\r\n  // good 缓存布局信息 相当于读写分离 触发一次重排+重绘\r\n  var curLeft = div.offsetLeft;\r\n  var curTop = div.offsetTop;\r\n  var curRight = div.offsetRight;\r\n  var curBottom = div.offsetBottom;\r\n\r\n  div.style.left = curLeft + 1 + 'px';\r\n  div.style.top = curTop + 1 + 'px';\r\n  div.style.right = curRight + 1 + 'px';\r\n  div.style.bottom = curBottom + 1 + 'px';\r\n  ```\r\n  4. position属性为absolute或fixed：使用绝对定位会使的该元素单独成为渲染树中body的一个子元素，重排开销比较小，不会对其它节点造成太多影响。当你在这些节点上放置这个元素时，一些其它在这个区域内的节点可能需要重绘，但是不需要重排。\r\n\r\n- 将CSS放在html头部，JavaScript文件放在html底部。\r\n> css文件链接尽量放在html头部，css加载不会阻塞DOM Tree解析，但是会阻塞DOM Tree渲染，也会阻塞后面js执行。也就是说DOM Tree在渲染前就要解析好CSS，从而减少浏览器重排文档的次数。而且css放在页面底部会导致页面初始时是没有样式的。js文件一般放在页面底部，这是防止js的加载和解析阻塞页面元素的正常渲染(JS放在头部加defer属性也可以)。\r\n\r\n- 避免使用同步布局。\r\n> 同步布局(或强制布局)是指浏览器强制在DOM修改和计算样式之后，立即进行布局。这会中断浏览器的优化过程导致性能下降。一般出现在连续的样式修改和读取操作之间。\r\n\r\n```\r\nlet div = document.querySelector('div');\r\n\r\n// 写样式\r\ndiv.style.width = '100px';\r\n// 读样式，导致同步布局\r\nlet width = div.offsetWidth;\r\n// 再写样式\r\ndiv.style.height = width + 'px';  // 强制布局\r\n\r\n\r\n// 为避免这个问题，可以将读操作移到所有写操作之后：\r\nlet div = document.querySelector('div');\r\n\r\n// 写样式\r\ndiv.style.width = '100px';\r\n// 写样式\r\ndiv.style.height = '100px';\r\n// 读样式\r\nlet width = div.offsetWidth;\r\n```\r\n### 字体图标优化\r\n- 使用字体图标或svg图片代替图片图标，字体图标使用方便灵活、矢量方式设计不会失真、资源体积小。\r\n### 代码编写优化\r\n- 优化循环。\r\n```\r\n// 不好的写法\r\nfor (let i = 0; i < arr.length; i++) {\r\n  console.log(arr[i]);\r\n}\r\n\r\n// 好的写法\r\nlet length = arr.length;\r\nfor (let i = 0; i < length; i++) {\r\n  console.log(arr[i]);\r\n}\r\n\r\n// 更好的写法\r\narr.forEach((item) => {\r\n  console.log(item);\r\n});\r\n```\r\n- 使用switch代替if-else。\r\n```\r\n// 假设state为4，if-else语句就要进行4次判断，switch只要进行一次即可。\r\nif (state === 0) {\r\n  console.log(\"待开通\")\r\n} else if (state === 1) {\r\n  console.log(\"学习中\")\r\n} else if (state === 2) {\r\n  console.log(\"休学中\")\r\n} else if (state === 3) {\r\n  console.log(\"已过期\")\r\n} esle if (state === 4) {\r\n  console.log(\"未购买\")\r\n}\r\n\r\nswitch (state) {\r\n  case 0:\r\n    break\r\n  case 1:\r\n    break\r\n  case 2:\r\n    break\r\n  case 3:\r\n    break\r\n  case 4:\r\n    break\r\n}\r\n```\r\n- 减少DOM的操作，尽可能的合并DOM操作。\r\n- 使用事件委托减少事件处理器的数量。\r\n- 使用flex布局，性能更好。\r\n- 避免过度使用全局变量，全局变量会占用更多的内存，从而降低程序的运行效率。\r\n- 高效错误处理，避免过度使用try-catch，因为它们会影响性能。\r\n- 避免不必要的闭包。\r\n- 利用浏览器缓存，将一些经常用到的、变化不大的数据存储在本地，以减少对服务器的请求。可以使用localStorage或sessionStorage来存储这些数据。\r\n- 减少cookie大小，消除不必要的cookie。cookie传输会造成带宽浪费，影响响应时间。\r\n- 使用WeakMap和WeakSet进行高效的内存管理。\r\n- 通过Intersection Observer API可以知道一个元素何时进入或离开视口，实现图片或者其他资源的懒加载时可以使用。\r\n- 使用Web Socket进行数据通信，当需要频繁地与服务器进行数据交换可以使用Web Socket，比HTTP有更低的开销。\r\n- 避免使用with语句，with语句会改变代码的作用域，这可能会导致性能问题。\r\n- 使用位操作进行整数运算，比传统的算术运算符更快。\r\n- 使用双缓冲技术进行绘图。\r\n> 当需要进行频繁的绘图操作时，可以使用双缓冲技术，即先在离屏画布上进行绘图，然后一次性将离屏画布的内容复制到屏幕上，这样可以避免屏幕闪烁，并且提升绘图性能。\r\n\r\n```\r\nvar offscreenCanvas = document.createElement('canvas');\r\nvar offscreenContext = offscreenCanvas.getContext('2d');\r\n\r\n// 在离屏画布上进行绘图...\r\noffscreenContext.fillRect(0, 0, 100, 100);\r\n\r\n// 将离屏画布的内容复制到屏幕上\r\ncontext.drawImage(offscreenCanvas, 0, 0);\r\n```\r\n### 使用新技术优化\r\n- 通过服务器端渲染(SSR)改善首次页面加载性能。\r\n> 服务器端渲染意味着在服务器上生成HTML，然后将其发送到客户端。这可以加快首次页面加载速度，因为用户可以直接看到渲染好的页面，而不必等待JavaScript下载并执行。这对于性能要求很高的应用来说，是一种有效的优化手段。\r\n\r\n- 使用IndexedDB存储大量数据\r\n> 如果需要在客户端存储大量数据，可以使用IndexedDB。与localStorage相比IndexedDB可以存储更大量的数据，并且支持事务和索引。\r\n\r\n- 使用WebRTC进行实时通信\r\n> WebRTC是一种提供实时通信能力的技术，允许数据直接在浏览器之间传输，对于需要实时交互的应用，如视频聊天、实时游戏等可以使用WebRTC来提高性能。\r\n\r\n- 使用WebGL进行3D渲染\r\n> WebGL是一种用于进行3D渲染的Web标准，它提供了底层的图形API，并且能够利用GPU进行加速，非常适合于进行复杂的3D渲染。\r\n\r\n- 使用Service Worker进行资源缓存\r\n> Service Workers可以让你控制网页的缓存策略，进一步减少HTTP请求，提升网页的加载速度，可以将一些不常变化的资源文件预先缓存起来。\r\n\r\n- 使用Progressive Web Apps(PWA)技术\r\n> PWA可以让网站在离线时仍然可用，并且可以被添加到用户的主屏幕，提供类似于原生应用的体验。PWA需要使用Service Workers和Manifest等技术。\r\n\r\n- 使用WebAssembly进行性能关键部分的开发\r\n> WebAssembly是一种新的编程语言，它的代码运行速度接近原生代码，非常适合进行性能关键部分的开发。例如可以用WebAssembly来开发图形渲染、物理模拟等复杂任务。"},function(r,n,e){"use strict";e.r(n),n.default="## 手写ES6数组方法\r\n### forEach\r\n```\r\nArray.prototype.myForEach = function(callback, thisArg) {\r\n  if (!((typeof callback === 'Function' || typeof callback === 'function') && this)) {\r\n    throw new TypeError();\r\n  }\r\n  const arr = Object(this);  // this是调用当前方法的数组\r\n  const len = arr.length >>> 0;  // 转换为正整数\r\n  let i = 0;\r\n  while (i < len) {\r\n    if (i in arr) {\r\n      callback.call(thisArg, arr[i], i, arr);\r\n    }\r\n    i++;\r\n  }\r\n}\r\n\r\n// 使用\r\nconst arr = new Array(1, 2, 3)\r\narr.myForEach((item, index, arr) => {\r\n  console.log(item, index, arr)\r\n})\r\nconsole.log(arr)\r\n```\r\n### map\r\n```\r\nArray.prototype.myMap = function(callback, thisArg) {\r\n  if (!((typeof callback === 'Function' || typeof callback === 'function') && this)) {\r\n    throw new TypeError();\r\n  }\r\n  const arr = Object(this)  // this是调用当前方法的数组\r\n  const len = arr.length >>> 0  // 转换为正整数\r\n  let i = 0\r\n  let res = []\r\n  while (i < len) {\r\n    if (i in arr) {\r\n      res[i] = callback.call(thisArg, arr[i], i, arr);\r\n    }\r\n    i++;\r\n  }\r\n  return res\r\n}\r\n\r\nconst arr = new Array(1, 2, 3)\r\nconst arr1 = arr.myMap((item, index, arr) => item + 1)\r\nconsole.log(arr)\r\nconsole.log(arr1)\r\n```\r\n### filter\r\n```\r\nArray.prototype.myFilter = function(callback, thisArg) {\r\n  if (!((typeof callback === 'Function' || typeof callback === 'function') && this)) {\r\n    throw new TypeError();\r\n  }\r\n  const arr = Object(this)  // this是调用当前方法的数组\r\n  const len = arr.length >>> 0  // 转换为正整数\r\n  let i = 0\r\n  let res = [] // 返回值\r\n  while (i < len) {\r\n    if (i in arr) {\r\n      if (callback.call(thisArg, arr[i], i, arr)) {\r\n        res.push(arr[i])\r\n      }\r\n    }\r\n    i++;\r\n  }\r\n  return res\r\n}\r\n\r\nconst arr = new Array(1, 2, 3)\r\nconst arr1 = arr.myFilter((item, index, arr) => item > 1)\r\nconsole.log(arr)\r\nconsole.log(arr1)\r\n```\r\n### some\r\n```\r\nArray.prototype.mySome = function(callback, thisArg) {\r\n  if (!((typeof callback === 'Function' || typeof callback === 'function') && this)) {\r\n    throw new TypeError();\r\n  }\r\n  const arr = Object(this)  // this是调用当前方法的数组\r\n  const len = arr.length >>> 0  // 转换为正整数\r\n  let i = 0\r\n  while (i < len) {\r\n    if (i in arr) {\r\n      if (callback.call(thisArg, arr[i], i, arr)) {\r\n        return true\r\n      }\r\n    }\r\n    i++;\r\n  }\r\n  return false\r\n}\r\n\r\n// 使用\r\nconst arr = new Array(1, 2, 3)\r\nconst res = arr.mySome((item, index, arr) => item > 1)\r\nconst res1 = [].mySome((item, index, arr) => item > 1)\r\nconsole.log(arr)\r\nconsole.log(res)\r\nconsole.log(res1) // 空数组使用返回false\r\n```\r\n### every\r\n```\r\nArray.prototype.myEvery = function(callback, thisArg) {\r\n  if (!((typeof callback === 'Function' || typeof callback === 'function') && this)) {\r\n    throw new TypeError();\r\n  }\r\n  const arr = Object(this)  // this 就是调用当前方法的数组\r\n  const len = arr.length >>> 0  // 转换为正整数\r\n  let i = 0\r\n  while (i < len) {\r\n    if (i in arr) {\r\n      if (!callback.call(thisArg, arr[i], i, arr)) {\r\n        return false\r\n      }\r\n    }\r\n    i++;\r\n  }\r\n  return true\r\n}\r\n\r\n// 使用\r\nconst arr = new Array(1, 2, 3)\r\nconst res = arr.myEvery((item, index, arr) => item > 1)\r\nconst res1 = [].myEvery((item, index, arr) => item > 1)\r\nconsole.log(arr)\r\nconsole.log(res)\r\nconsole.log(res1) // 空数组使用返回true\r\n```\r\n### reduce\r\n```\r\nArray.prototype.myReduce = function(callback, initialValue) {\r\n  if (!((typeof callback === 'Function' || typeof callback === 'function') && this)) {\r\n    throw new TypeError();\r\n  }\r\n  const arr = Object(this)  // this是调用当前方法的数组\r\n  const len = arr.length >>> 0  // 转换为正整数\r\n  let i = 0, res\r\n  \r\n  if (arguments.length > 1) {\r\n    res = initialValue\r\n  } else {\r\n    // 没传入初始值的时候，取数组中第一个非 empty 的值为初始值\r\n    while (i < len && !(i in arr)) {\r\n      i++\r\n    }\r\n    // 空数组必须有初始值否则抛错\r\n    if (i >= len) {\r\n      throw new TypeError( 'Reduce of empty array with no initial value' );\r\n    }\r\n    res = arr[i++]\r\n  }\r\n  while (i < len) {\r\n    if (i in arr) {\r\n      res = callback(res, arr[i], i, arr)\r\n    }\r\n    i++\r\n  }\r\n  return res\r\n}\r\n\r\n// 使用\r\nconst arr = new Array(1, 2, 3)\r\nconst emptyArr = new Array()\r\nconst res = arr.myReduce((prev, curr) => console.log(prev, curr))\r\nconst res1 = emptyArr.myReduce((prev, curr) => console.log(prev, curr))\r\nconsole.log(arr)\r\nconsole.log(res)\r\nconsole.log(res1)\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## 手写bind、call、apply\r\n### bind\r\n- 形式一\r\n```\r\nFunction.prototype.myBind = function(context) {\r\n  var self = this;\r\n  var args = Array.prototype.slice.call(arguments, 1);\r\n  var fNOP = function () {};\r\n  var fBound = function () {\r\n    var bindArgs = Array.prototype.slice.call(arguments);\r\n    var finalArgs = args.concat(bindArgs);\r\n    return self.apply(this instanceof fNOP ? this : context, finalArgs);\r\n  }\r\n\r\n  fNOP.prototype = this.prototype;\r\n  fBound.prototype = new fNOP();\r\n  return fBound;\r\n}\r\n```\r\n- 使用\r\n```\r\nconst obj = { name: 'douyaxing' };\r\nvar name = 'dyx';\r\nfunction exer(age, sex) {\r\n  console.log(this.name, age, sex);\r\n}\r\nexer(18, 'man');\r\nconst newExer = exer.myBind(obj, 23);\r\nnewExer('man');\r\n```\r\n### call\r\n- 形式一\r\n```\r\nFunction.prototype.myCall = function(context) {\r\n  var context = context || window;\r\n  context.fn = this;\r\n  var args = [];\r\n\r\n  for(var i = 1, len = arguments.length; i < len; i++) {\r\n    args.push('arguments[' + i + ']');\r\n  }\r\n  var result = eval('context.fn(' + args +')');\r\n\r\n  delete context.fn;\r\n  return result;\r\n}\r\n```\r\n- 形式二\r\n```\r\nFunction.prototype.myCall = function(context, ...args) {\r\n  context = context || window;\r\n  context.fn = this;\r\n  let result = context.fn(...args);\r\n  delete context.fn;\r\n  return result;\r\n}\r\n```\r\n- 使用\r\n```\r\nconst obj = { name: 'douyaxing' };\r\nconst obj1 = { name: 'douyaxing23' };\r\nvar name = 'dyx';\r\nfunction exer(age, sex) {\r\n  console.log(this.name, age, sex);\r\n}\r\nexer(18, 'man');\r\nexer.myCall(obj, '23', 'women');\r\nexer.myCall(obj1, '2', 'women');\r\n```\r\n### apply\r\n- 形式1\r\n```\r\nFunction.prototype.myApply = function(context, arr) {\r\n  var context = context || window;\r\n  context.fn = this;\r\n\r\n  var result;\r\n  if (!arr) {\r\n    result = context.fn();\r\n  } else {\r\n    var args = [];\r\n    for (var i = 0, len = arr.length; i < len; i++) {\r\n      args.push('arr[' + i + ']');\r\n    }\r\n    result = eval('context.fn(' + args + ')');\r\n  }\r\n  delete context.fn;\r\n  return result;\r\n}\r\n```\r\n- 形式2\r\n```\r\nFunction.prototype.myApply = function(context) {\r\n  context = context || window;\r\n  context.fn = this;\r\n  let result;\r\n  if (arguments[1]) {\r\n    result = context.fn(...arguments[1]);\r\n  } else {\r\n    result = context.fn();\r\n  }\r\n  delete context.fn;\r\n  return result;\r\n}\r\n```\r\n- 使用\r\n```\r\nconst obj = { name: 'douyaxing' };\r\nconst obj1 = { name: 'douyaxing23' };\r\nvar name = 'dyx';\r\nfunction exer(age, sex) {\r\n  console.log(this.name, age, sex);\r\n}\r\nexer(18, 'man');\r\nexer.myApply(obj, ['23', 'women']);\r\nexer.myApply(obj1, ['2', 'women']);\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## 手写instanceof\r\n> 递归获取实例的原型，判断其是否和构造函数的原型对象相等。\r\n\r\n```\r\nconst myInstanceof = (left, right) => {\r\n  // 边界判断\r\n  if (typeof left !== 'object' && typeof left !== 'function' || left === null) return false;\r\n  let proto = Object.getPrototypeOf(left);   // 获取左侧对象实例的原型\r\n  while (proto !== right.prototype) {  // 找到了就终止循环\r\n    if (proto === null) return false;    // 找不到返回false\r\n    proto = Object.getPrototypeOf(proto);   // 沿着原型链继续获取原型\r\n  }\r\n  return true;\r\n}\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## [手写Promise](https://juejin.cn/post/6945319439772434469)\r\n### 基本功能\r\n1. Promise是一个类，在执行这个类的时候会传入一个执行器，这个执行器会立即执行，执行器会传入内部的resolve和reject方法供调用的时候使用。\r\n```\r\nclass MyPromise {\r\n  constructor(executor){\r\n    // 立即执行并传入resolve和reject方法\r\n    executor(this.resolve, this.reject);\r\n  }\r\n\r\n  // 用箭头函数就可以让this指向当前实例对象\r\n  // 更改成功后的状态\r\n  resolve = () => {}\r\n\r\n  // 更改失败后的状态\r\n  reject = () => {}\r\n}\r\n```\r\n2. Promise会有三种状态Pending 等待, Fulfilled 完成, Rejected 失败，状态只能由 Pending --\x3e Fulfilled 或者 Pending --\x3e Rejected，且一但发生改变便不可二次修改。\r\n3. Promise中使用resolve和reject两个函数来更改状态。\r\n```\r\n// 先定义三个常量表示状态\r\nconst PENDING = 'pending';\r\nconst FULFILLED = 'fulfilled';\r\nconst REJECTED = 'rejected';\r\n\r\nclass MyPromise {\r\n  constructor(executor){\r\n    // 立即执行并传入resolve和reject方法\r\n    executor(this.resolve, this.reject)\r\n  }\r\n\r\n  // 储存状态的变量，初始值是 pending\r\n  status = PENDING;\r\n\r\n  // 成功之后的值\r\n  value = null;\r\n\r\n  // 失败之后的原因\r\n  reason = null;\r\n\r\n  // 用箭头函数就可以让this指向当前实例对象\r\n  // 更改成功后的状态\r\n  resolve = (value) => {\r\n    // 只有状态是等待，才执行状态修改\r\n    if (this.status === PENDING) {\r\n      // 状态修改为成功\r\n      this.status = FULFILLED;\r\n      // 保存成功之后的值\r\n      this.value = value;\r\n    }\r\n  }\r\n\r\n  // 更改失败后的状态\r\n  reject = (reason) => {\r\n    // 只有状态是等待，才执行状态修改\r\n    if (this.status === PENDING) {\r\n      // 状态成功为失败\r\n      this.status = REJECTED;\r\n      // 保存失败后的原因\r\n      this.reason = reason;\r\n    }\r\n  }\r\n}\r\n```\r\n4. then方法内部做的事情就是状态判断，如果状态是成功，调用成功回调函数，如果状态是失败，调用失败回调函数。\r\n```\r\nthen(onFulfilled, onRejected) {\r\n  // 判断状态\r\n  if (this.status === FULFILLED) {\r\n    // 调用成功回调，并且把值返回\r\n    onFulfilled(this.value);\r\n  } else if (this.status === REJECTED) {\r\n    // 调用失败回调，并且把原因返回\r\n    onRejected(this.reason);\r\n  }\r\n}\r\n```\r\n\r\n### Promise处理异步，保证.then的执行等待异步执行完\r\n> then方法中判断当前的状态，如果是Pending 则缓存成功和失败的回调函数，待状态改变之后在对应的reject或resolve方法中调用对应的回调函数。\r\n\r\n```\r\n// 存储成功回调函数\r\nonFulfilledCallback = null;\r\n\r\n// 存储失败回调函数\r\nonRejectedCallback = null;\r\n\r\nthen(onFulfilled, onRejected) {\r\n  // 判断状态\r\n  if (this.status === FULFILLED) {\r\n    // 调用成功回调，并且把值返回\r\n    onFulfilled(this.value);\r\n  } else if (this.status === REJECTED) {\r\n    // 调用失败回调，并且把原因返回\r\n    onRejected(this.reason);\r\n  } else if (this.status === PENDING) {\r\n    // 将成功回调和失败回调存储起来，等到执行成功失败函数的时候再传递\r\n    this.onFulfilledCallback = onFulfilled;\r\n    this.onRejectedCallback = onRejected;\r\n  }\r\n}\r\n\r\n// 用箭头函数就可以让this指向当前实例对象\r\n// 更改成功后的状态\r\nresolve = (value) => {\r\n  // 只有状态是等待，才执行状态修改\r\n  if (this.status === PENDING) {\r\n    // 状态修改为成功\r\n    this.status = FULFILLED;\r\n    // 保存成功之后的值\r\n    this.value = value;\r\n    // 判断成功回调是否存在，如果存在就调用\r\n    this.onFulfilledCallback && this.onFulfilledCallback(value);\r\n  }\r\n}\r\n\r\n// 更改失败后的状态\r\nreject = (reason) => {\r\n  // 只有状态是等待，才执行状态修改\r\n  if (this.status === PENDING) {\r\n    // 状态成功为失败\r\n    this.status = REJECTED;\r\n    // 保存失败后的原因\r\n    this.reason = reason;\r\n    // 判断失败回调是否存在，如果存在就调用\r\n    this.onRejectedCallback && this.onRejectedCallback(reason)\r\n  }\r\n}\r\n```\r\n### then方法的多次调用实现\r\n> 由于then方法可以多次调用，所以缓存时应该缓存所有的回调函数(数组存储)，状态改变之后调用的时候循环调用存储的回调函数。\r\n\r\n```\r\n// 存储成功回调函数\r\nonFulfilledCallbacks = [];\r\n\r\n// 存储失败回调函数\r\nonRejectedCallbacks = [];\r\n\r\nthen(onFulfilled, onRejected) {\r\n  // 判断状态\r\n  if (this.status === FULFILLED) {\r\n    // 调用成功回调，并且把值返回\r\n    onFulfilled(this.value);\r\n  } else if (this.status === REJECTED) {\r\n    // 调用失败回调，并且把原因返回\r\n    onRejected(this.reason);\r\n  } else if (this.status === PENDING) {\r\n    // 将成功回调和失败回调存储起来，等到执行成功失败函数的时候再传递\r\n    this.onFulfilledCallbacks.push(onFulfilled);\r\n    this.onRejectedCallbacks.push(onRejected);\r\n  }\r\n}\r\n\r\n// 更改成功后的状态\r\nresolve = (value) => {\r\n  // 只有状态是等待，才执行状态修改\r\n  if (this.status === PENDING) {\r\n    // 状态修改为成功\r\n    this.status = FULFILLED;\r\n    // 保存成功之后的值\r\n    this.value = value;\r\n    // resolve里面将所有成功的回调拿出来执行\r\n    while (this.onFulfilledCallbacks.length) {\r\n      // Array.shift() 取出数组第一个元素，然后（）调用，shift不是纯函数，取出后，数组将失去该元素，直到数组为空\r\n      this.onFulfilledCallbacks.shift()(value)\r\n    }\r\n  }\r\n}\r\n\r\n// 更改失败后的状态\r\nreject = (reason) => {\r\n  // 只有状态是等待，才执行状态修改\r\n  if (this.status === PENDING) {\r\n    // 状态成功为失败\r\n    this.status = REJECTED;\r\n    // 保存失败后的原因\r\n    this.reason = reason;\r\n    // reject里面将所有失败的回调拿出来执行\r\n    while (this.onRejectedCallbacks.length) {\r\n      this.onRejectedCallbacks.shift()(reason)\r\n    }\r\n  }\r\n}\r\n```\r\n### then方法的链式调用\r\n> then方法要链式调用就需要返回一个Promise对象。then方法里面return一个返回值作为下一个then方法的参数，如果是return一个Promise对象，那么就需要判断它的状态。\r\n\r\n```\r\nclass MyPromise {\r\n  // ......\r\n  then(onFulfilled, onRejected) {\r\n    // 为了链式调用这里直接创建一个 MyPromise，并在后面 return 出去\r\n    const promise2 = new MyPromise((resolve, reject) => {\r\n      // 这里的内容在执行器中，会立即执行\r\n      if (this.status === FULFILLED) {\r\n        // 获取成功回调函数的执行结果\r\n        const x = onFulfilled(this.value);\r\n        // 传入 resolvePromise 集中处理\r\n        resolvePromise(x, resolve, reject);\r\n      } else if (this.status === REJECTED) {\r\n        onRejected(this.reason);\r\n      } else if (this.status === PENDING) {\r\n        this.onFulfilledCallbacks.push(onFulfilled);\r\n        this.onRejectedCallbacks.push(onRejected);\r\n      }\r\n    }) \r\n    return promise2;\r\n  }\r\n}\r\n\r\nfunction resolvePromise(x, resolve, reject) {\r\n  // 判断x是不是 MyPromise 实例对象\r\n  if(x instanceof MyPromise) {\r\n    // 执行 x，调用 then 方法，目的是将其状态变为 fulfilled 或者 rejected\r\n    // x.then(value => resolve(value), reason => reject(reason))\r\n    // 简化之后\r\n    x.then(resolve, reject)\r\n  } else {\r\n    // 普通值\r\n    resolve(x)\r\n  }\r\n}\r\n```\r\n### then方法判断是否返回自己\r\n> 如果then方法返回的是自己的Promise对象，则会发生循环调用，这个时候程序会报错\r\n\r\n1. 判断返回的Promise是否等于自己，如果等于自己抛错。\r\n2. 判断的过程在Promise的运行过程中，此时无法获取到返回的Promise，所以判断的过程需要创建微任务queueMicrotask(可以使用setTimeout来代替)来处理，保证可以获取到返回的Promise。\r\n```\r\nclass MyPromise {\r\n  // ......\r\n  then(onFulfilled, onRejected) {\r\n    const promise2 = new MyPromise((resolve, reject) => {\r\n      if (this.status === FULFILLED) {\r\n        // 创建一个微任务等待 promise2 完成初始化\r\n        queueMicrotask(() => {\r\n          // 获取成功回调函数的执行结果\r\n          const x = onFulfilled(this.value);\r\n          // 传入 resolvePromise 集中处理\r\n          resolvePromise(promise2, x, resolve, reject);\r\n        })  \r\n      } else if (this.status === REJECTED) {\r\n        onRejected(this.reason);\r\n      } else if (this.status === PENDING) {\r\n        this.onFulfilledCallbacks.push(onFulfilled);\r\n        this.onRejectedCallbacks.push(onRejected);\r\n      }\r\n    }) \r\n    \r\n    return promise2;\r\n  }\r\n}\r\n\r\nfunction resolvePromise(promise2, x, resolve, reject) {\r\n  // 如果相等了，说明return的是自己，抛出类型错误并返回\r\n  if (promise2 === x) {\r\n    return reject(new TypeError('Chaining cycle detected for promise #<Promise>'))\r\n  }\r\n  if (x instanceof MyPromise) {\r\n    x.then(resolve, reject)\r\n  } else {\r\n    resolve(x)\r\n  }\r\n}\r\n```\r\n### 参考fulfilled状态下的处理方式，对rejected和pending状态进行改造\r\n```\r\nthen(onFulfilled, onRejected) {\r\n  // 为了链式调用这里直接创建一个 MyPromise，并在后面 return 出去\r\n  const promise2 = new MyPromise((resolve, reject) => {\r\n    // 判断状态\r\n    if (this.status === FULFILLED) {\r\n      // 创建一个微任务等待 promise2 完成初始化\r\n      queueMicrotask(() => {\r\n        try {\r\n          // 获取成功回调函数的执行结果\r\n          const x = onFulfilled(this.value);\r\n          // 传入 resolvePromise 集中处理\r\n          resolvePromise(promise2, x, resolve, reject);\r\n        } catch (error) {\r\n          reject(error)\r\n        } \r\n      })  \r\n    } else if (this.status === REJECTED) { \r\n      // 创建一个微任务等待 promise2 完成初始化\r\n      queueMicrotask(() => {\r\n        try {\r\n          // 调用失败回调，并且把原因返回\r\n          const x = onRejected(this.reason);\r\n          // 传入 resolvePromise 集中处理\r\n          resolvePromise(promise2, x, resolve, reject);\r\n        } catch (error) {\r\n          reject(error)\r\n        } \r\n      }) \r\n    } else if (this.status === PENDING) {\r\n      // 将成功回调和失败回调存储起来，等到执行成功失败函数的时候再传递\r\n      this.onFulfilledCallbacks.push(() => {\r\n        queueMicrotask(() => {\r\n          try {\r\n            // 获取成功回调函数的执行结果\r\n            const x = onFulfilled(this.value);\r\n            // 传入 resolvePromise 集中处理\r\n            resolvePromise(promise2, x, resolve, reject);\r\n          } catch (error) {\r\n            reject(error)\r\n          } \r\n        }) \r\n      });\r\n      this.onRejectedCallbacks.push(() => {\r\n        queueMicrotask(() => {\r\n          try {\r\n            // 调用失败回调，并且把原因返回\r\n            const x = onRejected(this.reason);\r\n            // 传入 resolvePromise 集中处理\r\n            resolvePromise(promise2, x, resolve, reject);\r\n          } catch (error) {\r\n            reject(error)\r\n          } \r\n        }) \r\n      });\r\n    }\r\n  }) \r\n  \r\n  return promise2;\r\n}\r\n```\r\n### then方法的参数可选\r\n> then方法的参数可以不传或者单传都不影响执行，then方法的参数进行判断，没有传入参数时执行默认的方法。\r\n\r\n```\r\nthen(onFulfilled, onRejected) {\r\n  // 如果不传，就使用默认函数\r\n  onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value => value;\r\n  onRejected = typeof onRejected === 'function' ? onRejected : reason => { throw reason };\r\n\r\n  // ......\r\n}\r\n```\r\n### 捕获错误\r\n1. 捕获执行器中的代码，如果执行器中有代码错误(外部调用的语法)，那么Promise的状态要变为失败。\r\n2. then方法执行时捕获错误。\r\n```\r\n// 执行器捕获错误\r\nconstructor(executor) {\r\n  // 立即执行并传入resolve和reject方法\r\n  try {\r\n    executor(this.resolve, this.reject)\r\n  } catch (error) {\r\n    // 如果有错误，就直接执行 reject\r\n    this.reject(error)\r\n  }\r\n}\r\n\r\n// then方法执行捕获错误\r\nthen(onFulfilled, onRejected) {\r\n  // 为了链式调用这里直接创建一个 MyPromise，并在后面 return 出去\r\n  const promise2 = new MyPromise((resolve, reject) => {\r\n    // 判断状态\r\n    if (this.status === FULFILLED) {\r\n      // 创建一个微任务等待 promise2 完成初始化\r\n      queueMicrotask(() => {\r\n        try {\r\n          // 获取成功回调函数的执行结果\r\n          const x = onFulfilled(this.value);\r\n          // 传入 resolvePromise 集中处理\r\n          resolvePromise(promise2, x, resolve, reject);\r\n        } catch (error) {\r\n          reject(error)\r\n        }  \r\n      })  \r\n    } else if (this.status === REJECTED) {\r\n      // 调用失败回调，并且把原因返回\r\n      onRejected(this.reason);\r\n    } else if (this.status === PENDING) {\r\n      // 将成功回调和失败回调存储起来，等到执行成功失败函数的时候再传递\r\n      this.onFulfilledCallbacks.push(onFulfilled);\r\n      this.onRejectedCallbacks.push(onRejected);\r\n    }\r\n  }) \r\n  return promise2;\r\n}\r\n```\r\n### resolve和reject的静态调用\r\n> 在Promise类中使用static关键字实现resolve和reject方法，方法的内部就是调用new Promise((resolve, reject) => {})。\r\n\r\n```\r\n// resolve 静态方法\r\nstatic resolve (parameter) {\r\n  // 如果传入 MyPromise 就直接返回\r\n  if (parameter instanceof MyPromise) {\r\n    return parameter;\r\n  }\r\n\r\n  // 转成常规方式\r\n  return new MyPromise(resolve =>  {\r\n    resolve(parameter);\r\n  });\r\n}\r\n\r\n// reject 静态方法\r\nstatic reject (reason) {\r\n  return new MyPromise((resolve, reject) => {\r\n    reject(reason);\r\n  });\r\n}\r\n```\r\n### 全量实现\r\n```\r\n// 先定义三个常量表示状态\r\nconst PENDING = 'pending';\r\nconst FULFILLED = 'fulfilled';\r\nconst REJECTED = 'rejected';\r\n\r\n// 新建 MyPromise 类\r\nclass MyPromise {\r\n  constructor(executor) {\r\n    // 会立即执行并传入resolve和reject方法\r\n    try {\r\n      executor(this.resolve, this.reject)\r\n    } catch (error) {\r\n      this.reject(error)\r\n    }\r\n  }\r\n\r\n  // 储存状态的变量，初始值是 pending\r\n  status = PENDING;\r\n  // 成功之后的值\r\n  value = null;\r\n  // 失败之后的原因\r\n  reason = null;\r\n\r\n  // 存储成功回调函数\r\n  onFulfilledCallbacks = [];\r\n  // 存储失败回调函数\r\n  onRejectedCallbacks = [];\r\n\r\n  // 更改成功后的状态\r\n  resolve = (value) => {\r\n    // 只有状态是等待，才执行状态修改\r\n    if (this.status === PENDING) {\r\n      // 状态修改为成功\r\n      this.status = FULFILLED;\r\n      // 保存成功之后的值\r\n      this.value = value;\r\n      // resolve里面将所有成功的回调拿出来执行\r\n      while (this.onFulfilledCallbacks.length) {\r\n        // Array.shift() 取出数组第一个元素，然后（）调用，shift不是纯函数，取出后，数组将失去该元素，直到数组为空\r\n        this.onFulfilledCallbacks.shift()(value)\r\n      }\r\n    }\r\n  }\r\n\r\n  // 更改失败后的状态\r\n  reject = (reason) => {\r\n    // 只有状态是等待，才执行状态修改\r\n    if (this.status === PENDING) {\r\n      // 状态成功为失败\r\n      this.status = REJECTED;\r\n      // 保存失败后的原因\r\n      this.reason = reason;\r\n      // resolve里面将所有失败的回调拿出来执行\r\n      while (this.onRejectedCallbacks.length) {\r\n        this.onRejectedCallbacks.shift()(reason)\r\n      }\r\n    }\r\n  }\r\n\r\n  then(onFulfilled, onRejected) {\r\n    const realOnFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value => value;\r\n    const realOnRejected = typeof onRejected === 'function' ? onRejected : reason => { throw reason };\r\n\r\n    // 为了链式调用这里直接创建一个 MyPromise，并在后面 return 出去\r\n    const promise2 = new MyPromise((resolve, reject) => {\r\n      const fulfilledMicrotask = () =>  {\r\n        // 创建一个微任务等待 promise2 完成初始化\r\n        queueMicrotask(() => {\r\n          try {\r\n            // 获取成功回调函数的执行结果\r\n            const x = realOnFulfilled(this.value);\r\n            // 传入 resolvePromise 集中处理\r\n            resolvePromise(promise2, x, resolve, reject);\r\n          } catch (error) {\r\n            reject(error)\r\n          } \r\n        })  \r\n      }\r\n\r\n      const rejectedMicrotask = () => { \r\n        // 创建一个微任务等待 promise2 完成初始化\r\n        queueMicrotask(() => {\r\n          try {\r\n            // 调用失败回调，并且把原因返回\r\n            const x = realOnRejected(this.reason);\r\n            // 传入 resolvePromise 集中处理\r\n            resolvePromise(promise2, x, resolve, reject);\r\n          } catch (error) {\r\n            reject(error)\r\n          } \r\n        }) \r\n      }\r\n\r\n      // 判断状态\r\n      if (this.status === FULFILLED) {\r\n        fulfilledMicrotask() \r\n        // 可以使用setTimeout实现\r\n        setTimeout(() => {\r\n          try {\r\n            let x = realOnFulfilled(this.value);\r\n            x instanceof MyPromise ? x.then(resolve, reject) : resolve(x)\r\n          } catch (err) {\r\n            reject(err)\r\n          }\r\n        })\r\n      } else if (this.status === REJECTED) { \r\n        rejectedMicrotask()\r\n      } else if (this.status === PENDING) {\r\n        // 将成功回调和失败回调存储起来，等到执行成功失败函数的时候再传递\r\n        this.onFulfilledCallbacks.push(fulfilledMicrotask);\r\n        this.onRejectedCallbacks.push(rejectedMicrotask);\r\n      }\r\n    }) \r\n    \r\n    return promise2;\r\n  }\r\n\r\n  // resolve 静态方法\r\n  static resolve(parameter) {\r\n    // 如果传入 MyPromise 就直接返回\r\n    if (parameter instanceof MyPromise) {\r\n      return parameter;\r\n    }\r\n\r\n    // 转成常规方式\r\n    return new MyPromise(resolve =>  {\r\n      resolve(parameter);\r\n    });\r\n  }\r\n\r\n  // reject 静态方法\r\n  static reject(reason) {\r\n    return new MyPromise((resolve, reject) => {\r\n      reject(reason);\r\n    });\r\n  }\r\n}\r\n\r\nfunction resolvePromise (promise2, x, resolve, reject) {\r\n  // 如果相等了，说明return的是自己，抛出类型错误并返回\r\n  if (promise2 === x) {\r\n    return reject(new TypeError('Chaining cycle detected for promise #<Promise>'))\r\n  }\r\n  // 判断x是不是 MyPromise 实例对象\r\n  if(x instanceof MyPromise) {\r\n    // 执行 x，调用 then 方法，目的是将其状态变为 fulfilled 或者 rejected\r\n    // x.then(value => resolve(value), reason => reject(reason))\r\n    // 简化之后\r\n    x.then(resolve, reject)\r\n  } else{\r\n    // 普通值\r\n    resolve(x)\r\n  }\r\n}\r\n\r\nmodule.exports = MyPromise;\r\n```\r\n### Promise.resolve\r\n- Promise.resolve最终结果还是一个Promise，并且与Promise.resolve(该值)传入的值息息相关。\r\n- 传入的参数可以是一个Promise实例，那么该函数执行的结果是直接将实例返回。\r\n- 如果这个值是thenable（即带有\"then\" 方法），返回的promise会“跟随”这个thenable的对象，采用它的最终状态；否则返回的promise将以此值完成。\r\n```\r\nPromise.resolve = function(value) {\r\n  // 如果是 Promsie，则直接返回\r\n  if (value && typeof value === 'object' && value instanceof Promise) {\r\n    return value;\r\n  }\r\n  return new Promise(resolve => resolve(value))\r\n}\r\n```\r\n### Promise.reject\r\n> Promise.reject() 方法返回一个带有拒绝原因的Promise对象。\r\n\r\n```\r\nPromise.reject = function(reason) {\r\n  return new Promise((resolve, reject) => reject(reason))\r\n}\r\n```\r\n### Promise.all\r\n```\r\nPromise.all = function(promiseArr) {\r\n  let count = 0, result = [];\r\n  const len = promiseArr.length;\r\n  return new Promise((resolve, reject) => {\r\n    if (len === 0) {\r\n      return resolve([]);\r\n    }\r\n    promiseArr.forEach((p, i) => {\r\n      Promise.resolve(p).then(val => {\r\n        count++\r\n        result[i] = val\r\n        // 全部resolve之后才返回最终的值\r\n        if (count === promiseArr.length) {\r\n          resolve(result)\r\n        }\r\n      }, err => {\r\n        reject(err)\r\n      })\r\n    })\r\n  })\r\n}\r\n```\r\n### Promise.allSettled\r\n```\r\nPromise.allSettled = (promiseArr) => {\r\n  let count = 0, result = [];\r\n  const len = promiseArr.length\r\n  return new Promise((resolve, reject) => {\r\n    // 数组是空的话，直接返回空数据\r\n    if (len === 0) {\r\n      return resolve([]);\r\n    }\r\n    promiseArr.forEach((p, i) => {\r\n      Promise.resolve(p).then((res) => {\r\n        count += 1\r\n        // 成功属性设置 \r\n        result[ i ] = {\r\n          status: 'fulfilled',\r\n          value: res\r\n        }\r\n        \r\n        if (count === len) {\r\n          rs(result)\r\n        }\r\n      }).catch((err) => {\r\n        count += 1\r\n        // 失败属性设置 \r\n        result[i] = { \r\n          status: 'rejected', \r\n          reason: err \r\n        }\r\n        if (count === len) {\r\n          rs(result)\r\n        }\r\n      })\r\n    })\r\n  })\r\n}\r\n```\r\n### Promise.race\r\n```\r\nPromise.race = function(promiseArr) {\r\n  return new Promise((resolve, reject) => {\r\n    promiseArr.forEach(p => {\r\n      Promise.resolve(p).then(val => {\r\n        // 有一个resolve之后就返回最终的值\r\n        resolve(val)\r\n      }, err => {\r\n        reject(err)\r\n      })\r\n    })\r\n  })\r\n}\r\n```\r\n### Promise并行限制\r\n```\r\nclass Scheduler {\r\n  constructor() {\r\n    this.queue = [];\r\n    this.maxCount = 2;\r\n    this.runCounts = 0;\r\n  }\r\n  add(promiseCreator) {\r\n    this.queue.push(promiseCreator);\r\n  }\r\n  taskStart() {\r\n    for (let i = 0; i < this.maxCount; i++) {\r\n      this.request();\r\n    }\r\n  }\r\n  request() {\r\n    if (!this.queue || !this.queue.length || this.runCounts >= this.maxCount) {\r\n      return;\r\n    }\r\n    this.runCounts++;\r\n\r\n    this.queue.shift()().then(() => {\r\n      this.runCounts--;\r\n      this.request();\r\n    });\r\n  }\r\n}\r\n   \r\nconst timeout = time => new Promise(resolve => {\r\n  setTimeout(resolve, time);\r\n})\r\n  \r\nconst scheduler = new Scheduler();\r\n  \r\nconst addTask = (time,order) => {\r\n  scheduler.add(() => timeout(time).then(()=>console.log(order)))\r\n}\r\n  \r\n  \r\naddTask(1000, '1');\r\naddTask(500, '2');\r\naddTask(300, '3');\r\naddTask(400, '4');\r\nscheduler.taskStart()\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## 字典\r\n- 一个存储唯一值的结构，以键值对的形式存储。\r\n- js中的字典数据类型是Map。"},function(r,n,e){"use strict";e.r(n),n.default="## 栈\r\n- 栈是一种特殊的线性表，特点是只能在表的一端操作。可以操作的端称为栈顶，不可以操作的另一端称为栈底。\r\n- 栈的特性是先进后出，比如蒸馒头的笼屉、羽毛球筒。\r\n- js中没有栈这种数据类型。\r\n### js实现\r\n```\r\nclass Stack {\r\n  constructor() {\r\n    // 存储数据\r\n    this.items = [];\r\n  }\r\n\r\n  push(item) {\r\n    // 入栈\r\n    this.items.push(item);\r\n  }\r\n\r\n  pop() {\r\n    // 出栈\r\n    return this.items.pop();\r\n  }\r\n\r\n  top() {\r\n    // 获取栈顶元素\r\n    return this.items[this.items.length - 1];\r\n  }\r\n\r\n  clear() {\r\n    // 清空栈\r\n    this.items = [];\r\n  }\r\n\r\n  size() {\r\n    // 获取栈的大小\r\n    return this.items.length;\r\n  }\r\n\r\n  isEmpty() {\r\n    // 判断栈是否为空\r\n    return this.items.length === 0;\r\n  }\r\n}\r\n```\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## 树\r\n> 树是一种数据结构，它是由n(n>=1)个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。\r\n\r\n- 无序树：树中任意节点的子结点之间没有顺序关系，这种树称为无序树，也称为自由树。\r\n- 有序树：树中任意节点的子结点之间有顺序关系，这种树称为有序树。\r\n- 二叉树：每个节点最多含有两个子树的树称为二叉树。\r\n- 满二叉树：叶节点除外的所有节点均含有两个子树的树被称为满二叉树。\r\n- 完全二叉树：除最后一层外，所有层都是满节点，且最后一层缺右边连续节点的二叉树称为完全二叉树（堆就是一个完全二叉树）。\r\n- 哈夫曼树（最优二叉树）：带权路径最短的二叉树称为哈夫曼树或最优二叉树。\r\n### 二叉树\r\n![二叉树](./img/二叉树.png)\r\n\r\n```\r\nfunction Node(data) {\r\n  this.data = data;\r\n  this.left = null;\r\n  this.right = null;\r\n}\r\n\r\nconst nodeA = new Node('A');\r\nconst nodeB = new Node('B');\r\nconst nodeC = new Node('C');\r\nconst nodeD = new Node('D');\r\nconst nodeE = new Node('E');\r\nconst nodeF = new Node('F');\r\nconst nodeG = new Node('G');\r\n\r\nnodeA.left = nodeB;\r\nnodeA.right = nodeC;\r\nnodeB.left = nodeD;\r\nnodeB.right = nodeE;\r\nnodeC.left = nodeF;\r\nnodeC.right = nodeG;\r\n```\r\n### 深度优先遍历\r\n> 尽可能深的搜索树的分支，就比如遇到一个节点就会直接去遍历它的子节点，不会立刻去遍历它的兄弟节点。\r\n\r\n- 访问根节点\r\n- 对根节点的children挨个进行深度优先遍历\r\n```\r\nconst dfs = (tree) => {\r\n  tree.children.forEach(dfs)\r\n};\r\n```\r\n### 广度优先遍历\r\n> 先访问离根节点最近的节点, 如果有兄弟节点就会先遍历兄弟节点，再去遍历自己的子节点。\r\n\r\n- 新建一个队列，并把根节点入队\r\n- 把队头出队并访问\r\n- 把队头的children挨个入队\r\n- 重复第二 、三步直到队列为空\r\n```\r\nconst bfs = (tree) => {\r\n  const q = [tree];\r\n  while (q.length > 0) {\r\n    const n = q.shift()\r\n    console.log(n.val);\r\n    n.children.forEach(c => q.push(c))\r\n  }\r\n};\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## 链表\r\n- 由若干个结点链结成一个链表，称之为链式存储结构。\r\n- 通过next指针来链接, 最底层为null。\r\n```\r\nconst Node = function(data) {\r\n  this.data = data;\r\n  this.next = null;\r\n}\r\n\r\nconst node1 = new Node(1);\r\nconst node2 = new Node(2);\r\nconst node3 = new Node(3);\r\n\r\nnode1.next = node2;\r\nnode2.next = node3;\r\n```\r\n### 链表和数组的区别\r\n- 链表和数组都可以存储多个数据。数组需要一块连续的内存空间来存储数据，对内存的要求比较高。而链表却相反，它并不需要一块连续的内存空间。\r\n- 链表是通过指针将一组零散的内存块串联在一起。相比数组链表是一种稍微复杂一点的数据结构。两者没有好坏之分各有各的优缺点。\r\n- 由于内存存储特性，数组可以实现快速的查找元素，但是在插入和删除时就需要移动大量的元素。原因就在于相邻元素在内存中的位置也是紧挨着的，中间没有空隙，因此就无法快速添加元素。而当删除后，内存空间中就会留出空隙，自然需要弥补。\r\n### 链表分类\r\n- 单向链表\r\n\r\n![单向链表](./img/单向.png)\r\n- 双向链表\r\n\r\n![双向链表](./img/双向.png)\r\n- 单向循环链表\r\n\r\n![单向循环链表](./img/单向循环.png)\r\n- 双向循环链表\r\n\r\n![双向循环链表](./img/双向循环.png)\r\n- 环形链表\r\n\r\n![环形链表](./img/环形.png)\r\n- 相交链表\r\n\r\n![环形链表](./img/相交.png)\r\n- 回文链表\r\n\r\n![回文链表](./img/回文.png)\r\n\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## 队列\r\n- 队列一种特殊的线性表，可以进行删除操作的端称为队首，而可以进行插入操作的端称为队尾。删除一个元素称为出队，插入一个元素称为入队。\r\n- 队列的特性是先进先出，比如排队。\r\n- js中没有队列这种数据类型。\r\n\r\n```\r\nclass Queue {\r\n  constructor() {\r\n    // 存储数据\r\n    this.items = [];\r\n  }\r\n\r\n  enqueue(item) {\r\n    // 入队\r\n    this.items.push(item);\r\n  }\r\n\r\n  dequeue() {\r\n    // 出队\r\n    return this.items.shift();\r\n  }\r\n\r\n  head() {\r\n    // 获取队首的元素\r\n    return this.items[0];\r\n  }\r\n\r\n  tail() {\r\n    // 获取队尾的元素\r\n    return this.items[this.items.length - 1];\r\n  }\r\n\r\n  clear() {\r\n    // 清空队列\r\n    this.items = [];\r\n  }\r\n\r\n  size() {\r\n    // 获取队列的长度\r\n    return this.items.length;\r\n  }\r\n\r\n  isEmpty() {\r\n    // 判断队列是否为空\r\n    return this.items.length === 0;\r\n  }\r\n}\r\n```\r\n\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## 集合\r\n- 一种无序且唯一的数据结构。\r\n- js中的集合数据类型是Set。"},function(r,n,e){"use strict";e.r(n),n.default="## refreshToken\r\n> 用户携带的accessToken过期时，用户需要重新获取新的accessToken，而refreshToken就是用来重新获取新accessToken的凭证。\r\n\r\n### 使用refreshToken可以提高安全性\r\n> 有了refreshToken可以降低accessToken被盗的风险。\r\n\r\n- 用户在访问网站时accessToken被盗取了，此时攻击者就可以拿这个accessToke访问权限以内的功能了。如果accessToken设置一个短暂的有效期2小时，攻击者能使用被盗取的accessToken的时间最多也就2个小时，除非再通过refreshToken刷新accessToken才能正常访问。\r\n- 设置accessToken有效期是永久的，用户在更改密码之后，之前的accessToken也是有效的。\r\n### 请求前判断token是否过期\r\n> 在请求前利用最初请求返回的字段expires_in字段来判断access_token是否已经过期，若已过期则将请求挂起，先刷新access_token后再继续请求。\r\n\r\n- 优点\r\n  1. 能节省http请求。\r\n- 缺点\r\n  1. 因为使用了本地时间判断，若本地时间被篡改，有校验失败的风险。\r\n### 响应拦截器里判断是否过期刷新token\r\n> 响应拦截器里拦截返回后的数据。先发起请求，如果接口返回access_token过期，刷新access_token再进行一次重试。\r\n\r\n- 优点\r\n  1. 无需判断时间。\r\n- 缺点\r\n  1. 会消耗多一次http请求。\r\n### 响应拦截器里判断是否过期刷新token代码实现\r\n1. 创建isRefreshing = false变量存储否正在刷新token，创建requests = []变量存储待重发请求。\r\n2. 当请求返回401(约定好为token过期)且不是请求刷新token的接口时特殊处理。\r\n3. 如果正在刷新token(isRefreshing为true)\r\n  - 返回未执行resolve的Promise。\r\n  - requests变量存储当前的请求(用函数形式将resolve存入，等待token刷新后重新请求再执行)。\r\n4. 如果没有正在刷新token(isRefreshing为false)，请求刷新token的接口(开始请求时isRefreshing改为true，请求结束之后isRefreshing改为false)\r\n  - 请求成功时\r\n    1. 存储新的token。\r\n    2. 使用新的token将requests数组中的请求重新执行并清空requests变量。\r\n    3. 并重新发起原来的请求。\r\n  - 请求失败时\r\n    1. 需跳转到登录页重新登录。\r\n```\r\n/**\r\n * axios请求方法\r\n */\r\nimport axios from 'axios';\r\nimport { message } from 'antd';\r\nimport history from './history';\r\n\r\n// 刷新access_token的接口\r\nconst refreshToken = () => {\r\n  return request.post('http://localhost:7001/refreshToken', { refresh_token: localStorage.getItem('refresh_token') });\r\n}\r\n\r\nlet isRefreshing = false;// 标记是否正在刷新token\r\nlet requests: any = []; // 存储待重发请求的数组\r\n\r\nconst request = axios.create({\r\n  baseURL: '',\r\n  timeout: 30000,\r\n});\r\n\r\n// 请求头添加access_token\r\nrequest.interceptors.request.use((config: any) => {\r\n  const accessToken = localStorage.getItem('access_token');\r\n  if (accessToken && config.headers) {\r\n    config.headers.access_token = accessToken;\r\n  }\r\n  return config;\r\n});\r\n\r\nrequest.interceptors.response.use(\r\n  response => response,\r\n  error => {\r\n    // 请求返回401且不是请求刷新token的接口\r\n    if (error.response?.status === 401 && !error.config.url.endsWith('/refreshToken')) {\r\n      const { config } = error;\r\n      if (isRefreshing) {\r\n        // 正在刷新token时存储请求方法\r\n        return new Promise(resolve => {\r\n          // 存储未执行resolve方法的Promise，等待刷新后再执行\r\n          requests.push(() => {\r\n            resolve(request(config))\r\n          });\r\n        })\r\n      } else {\r\n        isRefreshing = true;\r\n        // 刷新token\r\n        return refreshToken().then(res => {\r\n          const { access_token, refresh_token } = res.data.data || {};\r\n          // 存储新的token\r\n          localStorage.setItem('access_token', access_token);\r\n          localStorage.setItem('refresh_token', refresh_token);\r\n          // token刷新后将数组中的请求重新执行\r\n          requests.forEach((cb: any) => cb());\r\n          requests = []; // 重新请求完清空\r\n          return request(config); // 重新发起当前请求\r\n        }).catch(err => {\r\n          // 刷新token的接口请求失败时需重新登录\r\n          message.error('抱歉，您的登录状态已失效，请重新登录');\r\n          history.push('/login');\r\n          return Promise.reject(err);\r\n        }).finally(() => {\r\n          isRefreshing = false;\r\n        })\r\n      }\r\n    }\r\n    return Promise.reject(error);\r\n  }\r\n);\r\n\r\nexport default request;\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## sendBeacon\r\n> navigator.sendBeacon()方法可用于通过HTTP POST将少量数据异步传输到Web服务器。\r\n\r\n- url：data将要被发送到的网络地址。\r\n- data：将要发送的ArrayBuffer、ArrayBufferView、Blob、DOMString、FormData或URLSearchParams类型的数据。\r\n- 返回值：当用户代理成功把数据加入传输队列时，sendBeacon()方法将会返回true，否则返回false。\r\n```\r\nnavigator.sendBeacon(url, data);\r\n```\r\n- sendBeacon默认credentials的值为'include'，当使用cors跨域请求时注意Access-Control-Allow-Credentials的使用。\r\n### 优点\r\n- 异步和非阻塞：navigator.sendBeacon是异步的，它不会阻塞浏览器的其他操作，不会影响到页面的性能。\r\n- 数据发送可靠：在页面卸载时仍然可以发送数据，当用户离开页面(例如关闭页面或者导航到其他页面)时，navigator.sendBeacon仍然可以发送数据。\r\n- 低优先级：navigator.sendBeacon发送的请求是低优先级的，它不会影响到页面的其他网络请求。\r\n- 简单易用：navigator.sendBeacon的API非常简单，只需要提供上报的URL和数据，就可以发送请求。\r\n- 支持跨域请求。\r\n- 不影响下一导航的载入。\r\n### 缺点\r\n- 只能发送POST请求，不能发送GET请求。\r\n- 发送的请求不能接收服务器的响应。\r\n- 一些旧的浏览器可能不支持navigator.sendBeacon。在使用navigator.sendBeacon时需要根据实际情况进行兼容性处理。\r\n- 不支持自定义headers请求头。\r\n### 文档卸载期间发送数据\r\n> 保证在文档卸载期间发送数据一直是一个困难。因为用户代理通常会忽略在unload事件处理器中产生的异步XMLHttpRequest。下述方法都会迫使用户代理延迟卸载文档，并使得下一个导航出现的更晚。下一个页面对于这种较差的载入表现无能为力。\r\n\r\n- 发起一个同步XMLHttpRequest来发送数据。\r\n- fetch + keepalive。\r\n- 创建一个`<img>`元素并设置src，大部分用户代理会延迟卸载（unload）文档以加载图像。\r\n- 创建一个几秒的 no-op 循环。\r\n### 在visibilitychange事件发生时发送数据\r\n- 避免使用unload和beforeunload，在许多情况下（尤其是移动设备）浏览器不会产生unload、beforeunload或pagehide事件。\r\n```\r\nwindow.addEventListener('beforeunload', (event) => {\r\n  // 执行API请求\r\n});\r\n```\r\n- unload事件与现代浏览器实现的往返缓存（bfcache）不兼容。\r\n- 可使用pagehide事件来代替部分浏览器未实现的visibilitychange事件。和beforeunload与unload事件类似，这一事件不会被可靠地触发（特别是在移动设备上），但它与bfcache兼容。\r\n```\r\ndocument.addEventListener(\"visibilitychange\", () => {\r\n  if (document.visibilityState === \"hidden\") {\r\n    // sendBeacon发送json格式数据\r\n    const blob = new Blob([JSON.stringify(data)], {\r\n      type: 'application/json; charset=UTF-8'\r\n    });\r\n    window.navigator.sendBeacon(url, blob);\r\n  }\r\n});\r\n```\r\n"},function(r,n,e){"use strict";e.r(n),n.default='## 数据请求\r\n### XMLHttpRequest\r\n> XMLHttpRequest通常简称为XHR。通过XMLHttpRequest可以在不刷新页面的情况下请求特定URL获取数据。\r\n\r\n- 异步请求：XHR允许进行异步请求，它可以在后台执行，而不会阻止页面的其它操作。\r\n- 支持跨域请求：通过服务器端设置允许跨域请求，从不同域的服务器获取数据。\r\n- 事件驱动：提供了onload、onerror、onprogress等一系列事件来监听请求的状态变化。\r\n- 灵活性：提供了对请求头、响应头以及请求方法的完全控制，使其非常灵活。\r\n```\r\n// 创建一个新的XHR对象\r\nconst xhr = window.XMLHttpRequest ? new XMLHttpRequest(): new ActiveXObject(\'Microsoft.XMLHTTP\'); // 兼容IE6及以下版本\r\n\r\n// 配置请求\r\nxhr.open(\'GET\', "https://baidu.com/test", true);\r\n\r\n// 设置响应处理函数\r\nxhr.onreadysatechange = function() {\r\n  if (xhr.readySate == 4 && xhr.status == 200) {\r\n    console.log(xhr.responsetXML)\r\n  }\r\n}\r\n\r\n// 发起请求\r\nxhr.send();\r\n```\r\n### fetch\r\n> Fetch是一种现代的数据网络请求API，它旨在解决XHR的一些问题，提供了更强大、更灵活的方式来处理HTTP请求。可以理解为XMLHttpRequest的升级版。\r\n\r\n- Promise风格：Fetch API使用Promise对象来处理异步请求，使代码更具可读性和可维护性。\r\n- 更简单的语法：相较于XHR，Fetch API的语法更加简单明了，通常只需要几行代码来完成请求。\r\n- 默认不接受跨域请求：为了安全性Fetch API默认不接受跨域请求，但可以通过CORS（跨域资源共享）来进行配置。\r\n- 更现代的架构：Fetch API是建立在Promise和Stream之上的，支持更灵活的数据处理和流式传输。\r\n```\r\nfetch("https://baidu.com/test").then(response => {\r\n  if (!response.ok) {\r\n    throw new Error("请求失败状态码：" + response.status);\r\n  }\r\n  return response.json();\r\n}).then(data => {\r\n  // 请求成功，处理响应数据\r\n  console.log("成功获取数据：", data);\r\n}).catch(error => {\r\n  // 请求失败，处理错误\r\n  console.error(error);\r\n});\r\n```\r\n### XHR和Fetch的对比\r\n> XHR和Fetch都用于进行HTTP请求，但它们之间存在一些关键区别。\r\n\r\n- 语法：Fetch使用Promise，更直观和易于理解。\r\n- 跨域请求：Fetch在跨域请求方面更灵活，支持CORS。\r\n- 流式传输：Fetch支持可读流，适用于大文件下载。\r\n- 维护性：Fetch更容易维护和扩展。\r\n### axios\r\n> 一个流行的HTTP请求库，基于XHR开发，支持浏览器和Node.js。\r\n\r\n### AJAX\r\n> 异步JavaScript和XML，它是一个技术统称，本身不是一种技术。\r\n\r\n'},function(r,n,e){"use strict";e.r(n),n.default="## 轮询\r\n> 适用需要多次调用接口的情景。\r\n\r\n### 短轮询\r\n> 浏览器定时向服务器发送请求，获取最新数据，由于定时发送请求，两次请求之间的数据更新并不能及时响应，可能会有实时数据更新不及时的情况。\r\n\r\n```\r\n// 请求数据方法\r\nconst request = () => {}\r\n// 每隔5秒发送一次请求\r\nsetInterval(request(), 5000)\r\n```\r\n### 长轮询\r\n> 页面发送请求，保持连接，当数据有更新时，服务端返回新的数据，随机又发起下一次的数据请求，要注意请求的超时设置问题。\r\n\r\n```\r\n// 请求数据方法\r\nconst request = () => {}\r\n// 当数据请求返回结果后发起下一次请求\r\nrequest().then(res => {\r\n  request();\r\n})\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## 冒泡排序\r\n- 比较所有相邻元素，如果第一个比第二个大就交换它们。\r\n- 执行一次后可以保证当前循环的最后一个数字是最大的。\r\n- 重复执行n-1次，就可以完成排序。\r\n```\r\n// 时间复杂度O(n ^ 2)，n为数组长度\r\n// 空间复杂度O(1)\r\n\r\nconst bubbleSort = (arr) => {\r\n  for (i = 0; i < arr.length - 1; i++) {\r\n    for (let j = 0; j < arr.length - 1 - i; j++) {\r\n      if (arr[j] > arr[j + 1]) {\r\n        // 交换数据\r\n        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];\r\n      }\r\n    }\r\n  }\r\n  return arr;\r\n}\r\n```\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## 归并排序\r\n- 分：把数组劈成两半，递归的对子数组进行分操作，直到分成一个个单独的数。\r\n- 合：把两个数合并为有序数组，再对有序数组进行合并，直到全部子数组合并为一个完整的数组。\r\n```\r\n// 时间复杂度O(nlogn)，分需要劈开数组，所以是logn，合则是n\r\n// 空间复杂度O(n)\r\n\r\nconst mergeSort = (originArr) => {\r\n  const rec = (arr) => {\r\n    // 递归终点\r\n    if (arr.length === 1) return arr;\r\n    // 获取中间索引\r\n    const mid = arr.length >> 1;\r\n    // 通过中间下标,进行分割数组\r\n    const left = arr.slice(0, mid);\r\n    const right = arr.slice(mid);\r\n    // 左边和右边的数组进行递归，会得到有序的左数组,和有序的右数组\r\n    const orderLeft = rec(left);\r\n    const orderRight = rec(right);\r\n    // 存放结果的数组\r\n    const res = [];\r\n    // 对两个有序数组进行顺序合并\r\n    while (orderLeft.length || orderRight.length) {\r\n      // 如左边和右边数组都有值\r\n      if (orderLeft.length && orderRight.length) {\r\n        // 左边队头的值小于右边队头的值 就左边队头出队,否则就是右边队头出队\r\n        res.push(orderLeft[0] < orderRight[0] ? orderLeft.shift() : orderRight.shift())\r\n      } else if (orderLeft.length) {\r\n        // 把左边的队头放入数组\r\n        res.push(orderLeft.shift())\r\n      } else if (orderRight.length) {\r\n        // 把右边的队头放入数组\r\n        res.push(orderRight.shift())\r\n      }\r\n    }\r\n    return res;\r\n  }\r\n  const res = rec(originArr);\r\n  return res;\r\n}\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## 快速排序\r\n- 分区：从数组中任意选择一个基准，所有比基准小的元素放在基准前面，比基准大的元素放在基准后面。\r\n- 递归：递归的对基准前后的子数组进行分区。\r\n```\r\n// 时间复杂度O(nlogN)\r\n// 空间复杂度O(1)\r\n\r\nconst quickSort = (originArr) => {\r\n  const rec = (arr) => {\r\n    // 如果数组长度小于等于1 就不用排序了\r\n    if (arr.length <= 1) {\r\n      return arr;\r\n    }\r\n    // 存放基准前后的数组\r\n    const left = [];\r\n    const right = [];\r\n    // 取基准\r\n    const mid = arr[0];\r\n    for (let i = 1; i < arr.length; i++) {\r\n      // 如果当前值小于基准就放到基准前数组里面\r\n      if (arr[i] < mid) {\r\n        left.push(arr[i]);\r\n      } else {\r\n        // 否则就放到基准后数组里面\r\n        right.push(arr[i]);\r\n      }\r\n    }\r\n    // 递归调用两边的子数组\r\n    return [...rec(left), mid, ...rec(right)];\r\n  };\r\n\r\n  const res = rec(originArr);\r\n  return res;\r\n}\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## 插入排序\r\n- 从第二个数，开始往前比较。\r\n- 如它大就往后排。\r\n- 以此类推进行到最后一个数。\r\n```\r\n// 时间复杂度O(n ^ 2)\r\n\r\nconst insertionSort = (arr) => {\r\n  // 遍历数组 从第二个开始\r\n  for (let i = 1; i < arr.length; i++) {\r\n    // 获取第二个元素\r\n    const temp = arr[i];\r\n    let j = i;\r\n    while (j > 0) {\r\n      // 如果当前元素小于前一个元素，当前元素的值修改为前一个元素的值\r\n      if (arr[j - 1] > temp) {\r\n        arr[j] = arr[j - 1];\r\n      } else {\r\n        // 否则就跳出循环\r\n        break;\r\n      }\r\n      // 递减\r\n      j--;\r\n    }\r\n    // 前一位置赋值为当前元素\r\n    arr[j] = temp;\r\n  }\r\n  return arr;\r\n}\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## 选择排序\r\n- 找到数组中最小的值，选中它并放到第一位。\r\n- 接着找到数组中第二小的值，选中它并放到第二位。\r\n- 重复上述步骤执行n-1次。\r\n```\r\n// 时间复杂度O(n ^ 2)，n为数组长度\r\n// 空间复杂度O(1)\r\n\r\nconst selectionSort = (arr) => {\r\n  for (let i = 0; i < arr.length - 1; i++) {\r\n    let indexMin = i;\r\n    for (let j = i; j < arr.length; j++) {\r\n      // 如果当前这个元素 小于最小值的下标 就更新最小值的下标\r\n      if (arr[j] < arr[indexMin]) {\r\n        indexMin = j;\r\n      }\r\n    }\r\n    // 避免自己和自己进行交换\r\n    if (indexMin !== i) {\r\n      // 进行交换数据\r\n      [arr[i], arr[indexMin]] = [arr[indexMin], arr[i]];\r\n    }\r\n  }\r\n  return arr;\r\n}\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## react和vue的异同\r\n### 相同点\r\n- 都提倡组件化。\r\n- 都使用虚拟DOM高效的更新视图。\r\n- 都实现了数据驱动视图。\r\n- 都使用diff算法，也都对diff算法进行了优化。\r\n- 都有router库实现url到组件的映射。\r\n- 都有状态管理。\r\n### 组件化\r\n- 组件是独立和可复用的代码组织单元，它使开发者使用小型、独立和通常可复用的组件构建大型应用。\r\n- 能大幅提高应用开发效率、测试性、复用性、维护性，降低整个系统的耦合度。\r\n- 调试方便，根据报错的组件快速定位问题，之所以能够快速定位，是因为每个组件之间低耦合，职责单一，所以逻辑会比分析整个系统要简单。\r\n- 提高可维护性，由于每个组件的职责单一，并且组件在系统中是被复用的，所以对代码进行优化可获得系统的整体升级。\r\n### 组件化相同点\r\n- react和vue都推崇组件化，通过将页面拆分成一个一个小的可复用单元来提高代码的复用率和开发效率。\r\n- 在开发时react和vue有相同的套路，比如都有父子组件传参，都有数据状态管理，都有前端路由等。\r\n### 组件化差异\r\n- React推荐的做法是JSX + inline style, 也就是把 HTML 和 CSS 全都写进 JavaScript 中，即 all in js。\r\n- Vue 推荐的做法是 template 的单文件组件格式,即 html,css,JS 写在同一个文件(vue也支持JSX写法)。\r\n### 虚拟DOM\r\n- 虚拟dom是一个js对象，存储在内存之中。\r\n- 虚拟dom能够描述真实dom（存在一个对应关系）。\r\n- 当数据变化的时候，生成新的DOM，对比新旧虚拟DOM的差异，将差异更新到真实DOM上。\r\n### 虚拟DOM相同点\r\n- Vue与React都使用了虚拟DOM + Diff算法，不管是Vue的Template模板 + options api写法， 还是React的Class或者Function写法，最后都是生成render函数，而render函数执行返回VNode(虚拟DOM的数据结构，本质上是棵树)。\r\n- 当每一次UI更新时，总会根据render重新生成最新的VNode，然后跟以前缓存起来老的VNode进行比对，再使用Diff算法（框架核心）去真正更新真实DOM（虚拟DOM是JS对象结构，同样在JS引擎中，而真实DOM在浏览器渲染引擎中，所以操作虚拟DOM比操作真实DOM开销要小的多）。\r\n![虚拟DOM](./img/%E8%99%9A%E6%8B%9FDOM.jpg)\r\n### 虚拟DOM差异\r\n- react会自顶向下全diff。vue会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。\r\n- 在react中当状态发生改变时，组件树就会自顶向下的全diff，重新render页面，重新生成新的虚拟dom tree, 新旧dom tree进行比较，进行patch打补丁方式，局部更新dom。所以react为了避免父组件更新而引起不必要的子组件更新，可以在shouldComponentUpdate做逻辑判断，减少没必要的render，以及重新生成虚拟dom做差量对比的过程。\r\n- 在vue中通过Object.defineProperty把data属性全部转为getter/setter。同时watcher实例对象会在组件渲染时，将属性记录为dep, 当dep项中的setter被调用时，通知watch重新计算，使得关联组件更新。\r\n### Diff算法\r\n- 在处理老节点部分，都需要把节点处理 key - value 的 Map 数据结构，方便在往后的比对中可以快速通过节点的 key 取到对应的节点。\r\n- 同样在比对两个新老节点是否相同时，key 是否相同也是非常重要的判断标准。所以不同是 React, 还是 Vue，在写动态列表的时候，都需要设置一个唯一值 key，这样在 diff 算法处理的时候性能才最大化。\r\n### Diff算法的相同点\r\n- tag不同认为是不同节点。\r\n- 只比较同一层级，不跨级比较。\r\n- 同一层级的节点用key唯一标识，tag和key都相同则认为是同一节点。\r\n- Diff算法借助元素的 Key 判断元素是新增、删除、修改，从而减少不必要的元素重渲染。\r\n### Diff算法的差异\r\n- vue对比节点时当节点元素相同，但是classname不同，认为是不同类型的元素，删除重建，而react认为是同类型节点，只是修改节点属性。\r\n- vue的列表对比，采用的是两端到中间比对的方式，而react采用的是从左到右依次对比的方式。当一个集合只是把最后一个节点移到了第一个，react会把前面的节点依次移动，而vue只会把最后一个节点移到第一个。\r\n### 数据驱动视图\r\n> 数据变化的时候，相应的视图会得到更新。开发者只需要关注数据的变化而不用再去手动的操作DOM。\r\n\r\n### vue中的数据驱动视图\r\n> Vuejs的数据驱动是通过MVVM这种框架来实现的。MVVM框架主要包含3个部分:model、view和 viewModel。Model:指的是数据部分，对应到前端就是javascript对象；View:指的是视图部分，对应前端就是dom；ViewModel:就是连接视图与数据的中间件。\r\n\r\n- ViewModel是实现数据驱动视图的核心，当数据变化的时候，ViewModel能够监听到这种变化，并及时的通知view做出修改。同样的，当页面有事件触发时，ViewModel也能够监听到事件，并通知model进行响应。ViewModel就相当于一个观察者，监控着双方的动作，并及时通知对方进行相应的操作。\r\n- vuejs在实例化的过程中，会对遍历传给实例化对象选项中的data 选项，遍历其所有属性并使用 Object.defineProperty 把这些属性全部转为 getter/setter。\r\n同时每一个实例对象都有一个watcher实例对象，他会在模板编译的过程中，用getter去访问data的属性，watcher此时就会把用到的data属性记为依赖，这样就建立了视图与数据之间的联系。\r\n- 当之后我们渲染视图的数据依赖发生改变（即数据的setter被调用）的时候，watcher会对比前后两个的数值是否发生变化，然后确定是否通知视图进行重新渲染。这样就实现了所谓的数据对于视图的驱动。\r\n### react的数据驱动视图\r\n> React通过setState实现数据驱动视图，通过setState来引发一次组件的更新过程从而实现页面的重新渲染(除非shouldComponentUpdate返回false)。pending：当前所有等待更新的state队列；isBatchingUpdates：React中用于标识当前是否处理批量更新状态，默认false；dirtyComponent：当前所有待更新state的组件队列。\r\n\r\n- setState()首先将接收的第一个参数state存储在pending队列中。（state）\r\n- 判断当前React是否处于批量更新状态，是的话就将需要更新state的组件添加到dirtyComponents中。（组件）\r\n- 不是的话，它会遍历dirtyComponents的所有组件，调用updateComponent方法更新每个dirty组件。（开启批量更新事务）\r\n### 响应式原理的差异\r\n> react和vue都是通过修改数据来改变dom的显示，react需要调用setState方法，而vue直接修改变量就行，看似是api不同其实是响应式的原理不同。\r\n\r\n- 在react中，组件的状态是不能被修改的，setState没有修改原来那块内存中的变量，而是去新开辟一块内存；而vue则是直接修改保存状态的那块原始内存。\r\n- react中，调用setState方法后，会自顶向下重新渲染组件，自顶向下的含义是，该组件以及它的子组件全部需要渲染；而vue使用Object.defineProperty（vue@3迁移到了Proxy）对数据的设置（setter）和获取（getter）做了劫持，也就是说，vue能准确知道视图模版中哪一块用到了这个数据，并且在这个数据修改时，告诉这个视图，你需要重新渲染了。所以当一个数据改变，react的组件渲染是很消耗性能的——父组件的状态更新了，所有的子组件得跟着一起渲染，它不能像vue一样，精确到使用当前修改数据的组件粒度。\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## 使用EventBus进行跨组件通信\r\n### Vue中使用EventBus进行跨组件通信\r\n- event-bus.js\r\n```\r\nimport Vue from 'vue';\r\n\r\n// 创建一个新的Vue实例作为事件总线\r\nconst EventBus = new Vue();\r\n\r\n// 导出该实例，以便在应用程序中的其他地方使用\r\nexport default EventBus;\r\n```\r\n- 组件A\r\n```\r\n<template>\r\n  <div>\r\n    <button @click=\"emitEvent\">触发事件</button>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nimport EventBus from './event-bus.js';\r\n\r\nexport default {\r\n  methods: {\r\n    emitEvent() {\r\n      // 使用事件总线触发名为'custom-event'的事件，并传递数据\r\n      EventBus.$emit('custom-event', '这是传递的数据');\r\n    }\r\n  }\r\n}\r\n<\/script>\r\n```\r\n- 组件B\r\n```\r\n<template>\r\n  <div>\r\n    <p>{{ eventData }}</p>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nimport EventBus from './event-bus.js';\r\n\r\nexport default {\r\n  data() {\r\n    return {\r\n      eventData: ''\r\n    };\r\n  },\r\n  mounted() {\r\n    // 在组件创建时，通过事件总线监听'custom-event'事件\r\n    EventBus.$on('custom-event', eventData => {\r\n      // 更新组件的数据\r\n      this.eventData = eventData;\r\n      console.log('收到事件，数据为:', eventData);\r\n    });\r\n  }\r\n}\r\n<\/script>\r\n```\r\n### React中使用EventBus进行跨组件通信\r\n> 在React中没有像Vue中的事件总线那样的直接内置机制。可以使用第三方库eventemitter3。\r\n\r\n- 安装eventemitter3\r\n```\r\nnpm install eventemitter3\r\n```\r\n- 创建全局的事件管理器 eventBus.js\r\n```\r\nimport { EventEmitter } from 'eventemitter3';\r\n\r\nconst eventBus = new EventEmitter();\r\n\r\nexport default eventBus;\r\n```\r\n- 组件A\r\n```\r\nimport React from 'react';\r\nimport eventBus from './eventBus';\r\n\r\nclass ComponentA extends React.Component {\r\n  emitEvent = () => {\r\n    eventBus.emit('custom-event', '这是传递的数据');\r\n  };\r\n\r\n  render() {\r\n    return (\r\n      <div>\r\n        <button onClick={this.emitEvent}>触发事件</button>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default ComponentA;\r\n```\r\n- 组件B\r\n```\r\nimport React, { useState, useEffect } from 'react';\r\nimport eventBus from './eventBus';\r\n\r\nconst ComponentB = () => {\r\n  const [eventData, setEventData] = useState('');\r\n\r\n  useEffect(() => {\r\n    const eventBusListener = (data) => {\r\n      setEventData(data);\r\n      console.log('收到事件，数据为:', data);\r\n    };\r\n\r\n    eventBus.on('custom-event', eventBusListener);\r\n\r\n    return () => {\r\n      // 在组件卸载时取消事件监听\r\n      eventBus.off('custom-event', eventBusListener);\r\n    };\r\n  }, []);\r\n\r\n  return (\r\n    <div>\r\n      <p>{eventData}</p>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default ComponentB;\r\n```\r\n### 使用EventBus进行跨组件通信优点\r\n- 解耦组件：事件总线能够实现组件之间的解耦，使得它们不需要直接引用或依赖彼此，提高了代码的灵活性和可维护性。\r\n- 简化通信：对于一些简单的通信需求，事件总线提供了一种相对简单的方式，避免了通过 props 和回调函数传递数据时的繁琐操作。\r\n- 全局通信：事件总线通常是全局性的，能够在整个应用程序中的任何地方进行通信，适用于全局状态的传递和应用的整体控制。\r\n- 跨组件通信：事件总线可以方便地实现非父子组件之间的通信，而不需要在组件之间建立直接的关联。\r\n### 使用EventBus进行跨组件通信缺点\r\n- 全局状态管理：使用事件总线可能引入全局状态，导致应用状态变得难以追踪和理解，特别是在大型应用中。\r\n- 难以调试：全局性的事件监听和触发可能使得追踪代码执行流程和调试变得更加困难，尤其是在复杂的应用场景下。\r\n- 潜在的性能问题：大量的全局事件监听和触发可能导致性能问题，尤其是在频繁触发事件的情况下。\r\n- 不明确的数据流向：使用事件总线时，数据的流向相对不明确，可能增加代码的复杂性，使得应用程序的数据流变得更加难以理解。\r\n- 安全性问题：由于事件总线是全局的，可能存在安全风险，例如某个组件监听了不应该被其它组件触发的敏感事件。"},function(r,n,e){"use strict";e.r(n),n.default='## Cookie\r\n- Cookie最开始被设计出来其实并不是来做本地存储的，而是为了弥补HTTP在状态管理上的不足。HTTP协议是一个无状态协议，客户端向服务器发请求，服务端无法识别客户端身份。利用Cookie向同一个域名下发送请求，都会携带相同的Cookie，服务器拿到Cookie进行解析便能拿到客户端的状态。\r\n- 服务端可以通过响应头中的Set-Cookie字段来对客户端写入Cookie。\r\n- Cookie都是name=value的结构在浏览器中存储，name和value都为字符串。\r\n### 服务端设置Cookie，后续请求携带Cookie的流程\r\n1. 在首次访问网站时，浏览器发送请求中并未携带Cookie。\r\n2. 浏览器看到请求中未携带Cookie，在HTTP的响应头中加入Set-Cookie。\r\n3. 浏览器收到Set-Cookie后，会将Cookie保存下来。\r\n4. 之后该网站的请求，HTTP请求头就会携带Cookie(浏览器默认行为)。\r\n### Cookie配置属性\r\n- Name：Cookie的名称\r\n- Value：对应名称的值\r\n- Domain：Cookie生效的域名，只能设置范围小于等于自己的域名范围。没有指定时默认值为当前文档访问地址中的主机部分(不包含子域名)\r\n- Path：Cookie生效的路径，只有当路径匹配时才会向服务器发送Cookie。设置“/”表示此域下所有路径都可以携带cookie。\r\n- Expires：过期时间，过了这个时间后Cookie失效\r\n- Max-Age：生效时间，表示Cookie在多长时间后失效，单位为秒\r\n- Size：Cookie的长度，为name和value的长度和\r\n- HttpOnly：禁止通过JavaScript访问Cookie(防止跨站脚本攻击XSS)\r\n- Secure：只在HTTPS协议的情况下才会将Cookie传到服务端\r\n- SameSite：是否允许跨站请求时发送Cookie\r\n- Priority：优先级，Cookie的大小一般为4KB，当超出这个范围时会移除旧的Cookie，删除时按照优先级由低到高删除。\r\n- Partitioned：第三方Cookie分区\r\n### Cookie生命周期\r\n- 如果没有指定Expires或Max-Age属性默认值是Session，即它只在本次对话存在，一旦用户关闭浏览器，浏览器就不会再保留这个Cookie。\r\n- 如果同时指定了Expires和Max-Age，那么Max-Age的值将优先生效。\r\n#### Session\r\n- 这里的Session并不是存储在服务端的Session，而是指浏览器会话。\r\n- 如果Cookie的有效期为Session，一般关闭会话时Cookie便会失效。而一些浏览器重启时也会将会话恢复，此时Cookie并不会失效。\r\n#### Expires\r\n- Expires表示过期时间，是一个确定的日期时间，例如Expires=Wed, 21 Oct 2015 07:28:00 GMT。当浏览器端本地的当前时间超过这个时间时Cookie便会失效。\r\n#### Max-Age\r\n- Max-Age表示Cookie的存活时间，以秒作为单位，例如Max-Age=3000。当获取到该Cookie后开始倒计时，3000秒之后便失效。\r\n- 当Max-Age < 0时表示该Cookie只是一个会话性Cookie。当Max-Age = 0时会立即删除这个Cookie。\r\n### Cookie作用范围\r\n#### Domain\r\n- Domain用来设置Cookie作用的域名，即Cookie在哪个网站生效。\r\n- 默认情况下生效的域名为当前访问的域名。例如我们在dyx.com设置的Cookie，就只能限制在该网站内使用。\r\n#### 多级域名\r\n- 如果访问的网站有多级域名，则Cookie默认仅在访问的多级域名内生效。例如在a.dyx.com下设置的Cookie，就只在这个域名下生效。\r\n- 如果希望在更大范围内生效，可以指定域名。如果在设置Cookie时同时设置了domain=dyx.com，则该Cookie可以在dyx.com下的任何域名内生效。比如：\r\n  - dyx.com\r\n  - a.dyx.com\r\n  - b.dyx.com\r\n  - c.d.dyx.com\r\n#### Path\r\n- 当希望Cookie仅仅在部分路径下生效，就可以使用Path进行限制，默认的Path=/，即在所有路径下生效。 \r\n- 如果设置了path=/abc，则只在/abc路径下生效。比如：\r\n  - dyx.com 不生效\r\n  - dyx.com/abc 生效\r\n  - dyx.com/abc/def 生效\r\n  - dyx.com/qaz 不生效\r\n  - dyx.com/qaz/abc 不生效\r\n### 个数和大小限制\r\n- 不同的浏览器允许的Cookie大小并不相同，通常的个数限制为: 20~50；总大小限制为: 4KB左右。\r\n- 一个Cookie的大小可以在浏览器中查看Size属性得知，这个大小是key和value的和。\r\n### HttpOnly\r\n- 通常的Cookie在客户端是可以通过js脚本代码访问的。\r\n- 如果设置了HttpOnly属性，则该Cookie在浏览器中无法通过js代码读取也无法写入。这样可以防止窃取Cookie信息，一般用来防止XSS攻击。\r\n### Secure\r\n- 只能通过HTTPS传输Cookie。\r\n### Priority优先级\r\n- 当Cookie的数量超过限制时，浏览器会清除一部分Cookie，低优先级的Cookie会优先被清除。\r\n- Priority属性用来定义Cookie的优先级。\r\n  - Low\r\n  - Medium\r\n  - High\r\n### 跨站与SameSite设置\r\n- SameSite是Cookie的跨站属性，也可以看做是“更高级”的作用范围设置。\r\n#### 跨站与跨域\r\n- web中任何请求都受到同源限制，Cookie在此基础上还会受到同站策略限制(samesite指定)。\r\n- ajax跨域请求一般有两个问题。\r\n  1. 请求能否发出去。\r\n  2. Cookie能否携带上。\r\n- 一般浏览器限制请求的内容是按照跨域来判断的，比如XHR和fetch。但是SameSite限制的并不是跨域而是跨站。\r\n- 跨站是比跨域更宽松的一种限制。如果跨站那么肯定会跨域，但如果跨域不一定会跨站。\r\n#### 跨站和跨域的主要区别\r\n- 子域名不同时属于跨域不属于跨站。例如a.dyx.com与b.dyx.com。\r\n- 端口不同时属于跨域不属于跨站。例如dyx.com:8000与dyx.com:9000。\r\n- IP不同时(如果直接使用IP访问网站)属于跨域和跨站。\r\n#### 请求分类\r\n- 可能打开新页面或者改变当前页面的请求。例如：window.open()，`<a>`链接，form表单提交等。\r\n- 不改变当前页面的请求。例如：`<script>、<css>、<img>`等标签，fetch，XHR请求等。\r\n- 这两类的主要区别是第一类请求直接把页面替换了或者打开了一个新的页面，即和原有的页面不属于同一个页面。而第二类请求依然在原页面上，仅仅是做一些内容上的更新。\r\n- 请求分类与SameSite配置相关。\r\n#### SameSite设置\r\n- None：关闭SameSite属性，即不对跨站Cookie做限制。关闭的前提是设置了Secure，即Cookie只能在HTTPS下使用，否则关闭是无效的。\r\n- Strict：禁止发送跨站Cookie。即不管是什么请求，如果我们请求的地址与所在的页面地址属于跨站，那么Strict的Cookie将不会被发送。\r\n- Lax(默认值)：请求分类的第一种情况下可以发送跨站Cookie，即可能打开新页面或者改变当前页面的请求而且是个Get请求时可以发送。其它请求不允许发送。\r\n![samesite](./img/samesite.webp)\r\n### JavaScript中操作Cookie\r\n- 设置Cookie\r\n> 一次只能设置一个Cookie。但是可以同时对单个Cookie的多个属性进行设置，每个属性使用分隔符;\r\n\r\n```\r\ndocument.cookie = "name=dyx";\r\ndocument.cookie = "name=dyx; doamin=dyx.com";\r\ndocument.cookie = "name=dyx; doamin=dyx.com; path=/abc";\r\n```\r\n- 修改Cookie\r\n> 修改Cookie相当于对其进行重新设置。\r\n\r\n- 读取Cookie\r\n> 读取到的是一个字符串，内容为该页面的所有Cookie，不同的Cookie用分隔符;分隔。只能读到key和value，其余的属性读不到。\r\n\r\n```\r\ndocument.cookie\r\n// 读取到的值\r\n"name=dyx; name1=douyaxing"\r\n```\r\n- 删除Cookie\r\n> js中没有直接删除Cookie的方法。如果需要删除某个Cookie，需要重新设置该Cookie，将它的有效期直接设置为过期即可实现删除功能。\r\n\r\n```\r\ndocument.cookie = "name=dyx; max-age=-1";\r\n```\r\n### 相同域名下的不同端口的Cookie可以共享\r\n### 跨域请求携带Cookie\r\n- 网站a中使用ajax请求跨域访问网站b的接口。\r\n- 网站b的服务端需要设置CORS，这样网站a的跨域请求才能够被正常处理。\r\n  1. 设置响应头Access-Control-Allow-Credentials为true。\r\n  2. Access-Control-Allow-Origin不能设置为*，必须是请求方的具体源。\r\n- 网站a的请求参数中添加withCredentials=true属性，这样浏览器才会携带Cookie到网站b的服务端。\r\n- ajax跨域请求无法携带SameSite=Lax的Cookie。\r\n### 跨域无法携带Cookie VS 浏览器全面禁止第三方Cookie\r\n- 目的不同：跨域请求默认不携带Cookie主要是出于安全考虑，防止跨站点请求伪造等攻击；禁止第三方Cookie主要是出于隐私保护考虑，防止用户跨网站被追踪。\r\n- 操作层面不同：跨域Cookie的发送需要通过适当的服务器和客户端配置来实现；第三方Cookie的禁用是由浏览器控制，影响所有第三方来源的Cookie。\r\n### Cookie相较于WebStorage的缺陷\r\n- 容量缺陷：Cookie的体积上限只有4KB，只能用来存储少量的信息。\r\n- 安全缺陷：Cookie在每次请求中都会被发送，如果不使用HTTPS并对其加密，其保存的信息很容易被窃取导致安全风险。\r\n- 操作缺陷：Cookie的操作相较于WebStorage较为繁琐复杂。\r\n### Cookie与Session的区别\r\n- 存储位置不同：Cookie的数据信息存放在客户端浏览器上，Session的数据信息存放在服务器上。\r\n- 存储容量不同：单个Cookie保存的数据<=4KB，一个站点最多保存20个Cookie，而对于Session来说并没有上限，但出于对服务器端的性能考虑，Session内不要存放过多的东西，并且设置Session删除机制。\r\n- 存储方式不同：Cookie中只能保管ASCII字符串，并需要通过编码方式存储为Unicode字符或者二进制数据。Session中能够存储任何类型的数据，包括且不限于string，integer，list，map等。\r\n- 隐私策略不同：Cookie对客户端是可见的，别有用心的人可以分析存放在本地的Cookie并进行Cookie欺骗，所以它是不安全的，而Session存储在服务器上，对客户端是不透明的，不存在敏感信息泄漏的风险。\r\n- 有效期上不同：开发可以通过设置Cookie的属性，达到使Cookie长期有效的效果。Session依赖于名为JSESSIONID的Cookie，而Cookie JSESSIONID的过期时间默认为-1，只需关闭窗口该Session就会失效，因而Session不能达到长期有效的效果。\r\n- 服务器压力不同：Cookie保管在客户端，不占用服务器资源。对于并发用户十分多的网站Cookie是很好的选择。Session是保管在服务器端的，每个用户都会产生一个Session。假如并发访问的用户十分多，会产生十分多的Session，耗费大量的内存。\r\n- 跨域支持上不同：Cookie支持跨域名访问(二级域名是可以共享Cookie的)。Session不支持跨域名访问。'},function(r,n,e){"use strict";e.r(n),n.default='## WebStorage\r\n### localStorage\r\n- 使用Key-Value形式储存，通过setItem和getItem等方法进行操作，使用很方便。\r\n- Key和Value以字符串形式储存。对于一些复杂的数据存储需要使用JSON.stringify()。\r\n- 持久化存储，不手动清除不会消失。\r\n- 存储大小有10MB。\r\n- 只存储在客户端，默认不参与与服务端的通信。这样就很好地避免了Cookie在http传输过程带来的性能问题和安全问题。\r\n- localStorage受同源策略的限制，不能跨域共享。\r\n#### 应用场景\r\n- 利用localStorage的较大容量和持久特性，可以利用localStorage存储一些内容稳定的资源如token。\r\n### sessionStorage\r\n- sessionStorage和localStorage有一个本质的区别，sessionStorage只是会话级别的存储，localStorage是持久化存储。\r\n- 会话结束也就是页面关闭，sessionStorage就不存在了。\r\n- localStorage受同源策略的限制，不能跨域共享。\r\n#### 在标签或窗口打开一个新页面时会复制当前会话的上下文作为新会话的上下文。\r\n- 多窗口之间sessionStorage不可以共享状态，但是在某些特定场景下新开的页面会复制之前页面的sessionStorage，复制之后的新窗口的sessionStorage和之前窗口的sessionStorage各自独立互不影响。\r\n- window.open("同源页面")这种方式新开的页面会复制之前的sessionStorage，通过a标签新开的页面同样也会。\r\n- 如果不想要这种复制的效果，可以先新建一个空白页面窗口，再将url设置到窗口中的地址栏中去。\r\n#### 应用场景\r\n- 存储本次浏览记录，关闭之后不再需要这些记录。\r\n### JavaScript中操作WebStorage\r\n- 设置WebStorage\r\n```\r\nlocalStorage.setItem("name", "dyx");\r\n```\r\n- 修改WebStorage\r\n> 修改WebStorage相当于对其进行重新设置。\r\n\r\n- 读取WebStorage\r\n```\r\nconst name = localStorage.getItem("name");\r\n```\r\n- 删除WebStorage\r\n```\r\nlocalStorage.removeItem("name");\r\n```\r\n- 删除所有WebStorage\r\n```\r\nlocalStorage.clear();\r\n```'},function(r,n,e){"use strict";e.r(n),n.default="## 回流和重绘\r\n- 回流必将引起重绘，重绘不一定会引起回流。回流比重绘的代价要更高。\r\n### 回流(重排)\r\n> 当RenderTree中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为回流。\r\n\r\n- 页面首次渲染\r\n- 元素尺寸或位置发生改变\r\n- 元素内容变化（文字数量或图片大小等等）\r\n- 元素字体大小变化\r\n- 添加或者删除可见的DOM元素\r\n- 浏览器窗口大小发生改变\r\n- 激活CSS伪类（例如：:hover）\r\n- 查询某些属性或调用某些方法\r\n  - clientWidth、clientHeight、clientTop、clientLeft\r\n  - offsetWidth、offsetHeight、offsetTop、offsetLeft\r\n  - scrollWidth、scrollHeight、scrollTop、scrollLeft\r\n  - scrollIntoView()、scrollIntoViewIfNeeded()\r\n  - getComputedStyle()\r\n  - getBoundingClientRect()\r\n  - scrollTo()\r\n### 重绘\r\n- 当页面中元素样式的改变并不影响它在文档流中的位置时例如：color、background-color、visibility等，浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。\r\n### 如何避免回流和重绘\r\n- 避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性。\r\n- 避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中。\r\n- 对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## 复合图层\r\n- 浏览器渲染的图层一般分为两大类：普通图层以及复合图层。\r\n- Chrome源码调试 -> More Tools -> Rendering -> Layer borders勾选后，黄色的就是复合图层信息。\r\n### 多个复合图层互不影响\r\n- 普通文档流可以理解为一个复合图层(称为默认复合层，里面不管添加多少元素，其实都是在同一个复合图层中)。\r\n- absolute布局(fixed也一样)虽然可以脱离普通文档流，但它仍然属于默认复合层。\r\n- 可以通过硬件加速的方式声明一个新的复合图层，它会单独分配资源(也会脱离普通文档流，这样一来不管这个复合图层中怎么变化，也不会影响默认复合层)。\r\n- GPU中各个复合图层是单独绘制的，所以互不影响。\r\n### 生成新的复合图层(硬件加速)\r\n- 最常用的方式：translate3d、translateZ。\r\n- opacity属性/过渡动画(需要动画执行的过程中才会创建复合图层，动画没有开始或结束后元素还会回到之前的状态)。\r\n- will-change属性，一般配合opacity与translate使用(作用是提前告诉浏览器要变化，这样浏览器会开始做一些优化工作)。\r\n- `<video><iframe><canvas><webgl>`等元素。\r\n### absolute和生成新的复合图层(硬件加速)的区别\r\n- absolute虽然可以脱离普通文档流，但是无法脱离默认复合层。所以就算absolute中信息改变时不会改变普通文档流中render树，但是浏览器最终绘制时是整个复合层绘制的，所以absolute中信息的改变，仍然会影响整个复合层的绘制。(浏览器会重绘它，如果复合层中内容多，absolute带来的绘制信息变化过大，资源消耗也是非常严重的)\r\n- 生成新的复合图层(硬件加速)直接就是在另一个复合层了，所以它的信息改变不会影响默认复合层。\r\n### 生成新的复合图层作用\r\n- 元素开启硬件加速后会变成复合图层，可以独立于普通文档流中，改动后可以避免整个页面重绘，提升性能。\r\n- 尽量不要大量使用复合图层，否则由于资源消耗过度，页面反而会变的更卡。\r\n### 生成新的复合图层要使用index\r\n- 使用硬件加速生成新的复合层时，尽可能的使用index，防止浏览器默认给后续的元素创建复合层渲染。\r\n- 如果某个元素添加了硬件加速，并且index层级比较低，那么在这个元素的后面其它元素(层级比这个元素高的或者相同的，并且relative或absolute属性相同的)，会默认变为复合层渲染，如果处理不当会极大的影响性能。如果a是一个复合图层，而且b在a上面，那么b也会被隐式转为一个复合图层。\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## [多进程的浏览器](https://segmentfault.com/a/1190000012925872)\r\n- 浏览器是多进程的。\r\n- 浏览器之所以能够运行，是因为系统给它的进程分配了资源(cpu、内存)。\r\n- 每打开一个Tab页，就相当于创建了一个独立的浏览器渲染进程。浏览器有自己的优化机制有时会将多个进程合并(譬如打开多个空白标签页后，会发现多个空白标签页被合并成了一个进程)。\r\n### 浏览器包含的进程\r\n1. Browser进程：浏览器的主进程(负责协调、主控)，只有一个。作用如下：\r\n    - 负责浏览器界面显示绘制，与用户交互。如前进，后退等。\r\n    - 负责各个页面的管理，创建和销毁其它进程。\r\n    - 将浏览器渲染进程得到的内存中的Bitmap绘制到用户界面上。\r\n    - 网络资源的管理，下载等。\r\n2. 第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建。\r\n3. GPU进程：最多一个，用于3D绘制等。\r\n4. 浏览器渲染进程(浏览器内核)：内部是多线程的，默认每个Tab页面一个进程，互不影响。主要作用为页面渲染，脚本执行，事件处理等。\r\n### 浏览器多进程的优势\r\n- 避免单个page crash影响整个浏览器。\r\n- 避免第三方插件crash影响整个浏览器。\r\n- 多进程充分利用多核优势。\r\n- 方便使用沙盒模型隔离插件等进程，提高浏览器稳定性。\r\n### Browser进程和浏览器渲染进程的通信过程\r\n1. Browser进程收到用户请求，首先需要获取页面内容(譬如通过网络下载资源)，随后将该任务通过RendererHost接口传递给渲染进程。\r\n2. 渲染进程的Renderer接口收到消息，简单解释后，交给GUI渲染线程，然后开始渲染。\r\n    - 渲染线程接收请求，加载网页并渲染网页，这其中可能需要Browser进程获取资源和需要GPU进程来帮助渲染。\r\n    - 当然可能会有JS线程操作DOM(可能会造成回流并重绘)。\r\n    - 最后渲染进程将结果传递给Browser进程。\r\n3. Browser进程接收到结果并将结果绘制出来。"},function(r,n,e){"use strict";e.r(n),n.default="## 浏览器渲染流程\r\n> 构造文档对象模型和构造CSS对象模型是并行的过程。\r\n\r\n- 构造文档对象模型(DOM)\r\n- 构造CSS对象模型(CSSOM)\r\n- 生成渲染树\r\n- 布局\r\n- 绘制\r\n\r\n![html渲染](./img/html%E6%B8%B2%E6%9F%93.png)\r\n### 构造文档对象模型(DOM)\r\n> 当浏览器访问网页接受到HTML文档时，会对于接受到的HTML进行Parsing过程（解析HTML文档），这一过程主要分为以下四个阶段。\r\n\r\n- 转化\r\n> 首先浏览器从磁盘（缓存）或网络读取HTML的原始字节，并根据文件的指定编码（例如UTF-8）将它们转换为单个字符。\r\n\r\n- 词法分析\r\n> 词法分析就是把源码的字符串分割出来，生成一系列的token（如W3C HTML5标准所指定的例如`<html>`、`<body>`以及尖括号内的其他字符串）。每个Token都有特殊的含义和自己的一套规则。\r\n\r\n- 语法分析\r\n> 语法分析的输入就是词法分析的输出，输出是AST抽象语法树。当程序出现语法错误的时候，V8在语法分析阶段抛出异常。\r\n\r\n- 构造DomTree\r\n> 构造文档对象模型的最后一步就是构建DomTree。因为HTML中定义了不同标签之间的关系（一些标签包含在其他标签中等等），所以最终浏览器的到的对象是一个树型结构，该结构中通过嵌套等关系描述了文档中不同标签的关系。\r\n\r\n![domTree](./img/domTree.png)\r\n### 构造CSS对象模型(CSSOM)\r\n- CSS的处理和HTML差不多，CSS文件经过转化为字符、词法分析、语法分析、构造树状的CSSOM。\r\n- 之所以将CSS也处理为树状结构，是因为CSS的规则是支持“向下级联”的嵌套方案的，也就是我们在日常开发中CSS的继承特性。浏览器在计算节点的样式时，它会从适用于该节点的最通用（顶层）的规则开始进行计算，之后会一层一层进行递归从而得到该节点最终的样式。\r\n- CSS写在style标签中在chrome中style标签会被Html Parse来解析。\r\n- 加载样式脚本并不会阻塞后续DOM解析（这里的非阻塞更多相对于JS文件，因为同步JS文件的加载是会阻塞后续DOM解析的），而主线程构造CSS对象模型的过程是会和构造文档对象模型抢占主线程资源的（主线程并不会同时构造CSS对象模型以及同时构造文档对象模型）。\r\n\r\n![cssomTree](./img/cssomTree.png)\r\n### 生成渲染树\r\n- 上述的两个过程中基于HTML和CSS分别得到了DomTree以及CssomTree，此时这两棵树是互相独立的两个树状对象。\r\n- DomTree描述了页面中所有的DOM结构内容，CssomTree描述了需要应用在页面节点上的样式规则。\r\n- 浏览器会将两个Tree进行合并，最终组成一个具有所有可见（元素在布局中仍然占据空间）节点样式和内容的RenderTree。\r\n  1. 从DomTree开始遍历，遍历每一个可见节点。一些脚本标签、元标签等节点是不可见的会被省略。对于一些通过CSS隐藏的节点，也会从渲染树中省略。\r\n  2. 对于DomTree中的每个可见节点，在CssomTree中找到合适匹配的CSSOM规则并应用它们。\r\n  3. 最终在RenderTree上挂载这些带有内容以及样式的可见节点。\r\n\r\n![renderTree](./img/renderTree.png)\r\n### 布局\r\n- 上述过程得到RenderTree后，浏览器已经明确的清楚哪些节点应该被渲染到页面上同时也获得了可见节点的样式，但是浏览器并未计算出每个节点在对应设备（屏幕）上确切的位置和大小。\r\n- 布局过程会计算出每个节点在对应设备（屏幕）上确切的位置和大小。\r\n### 绘制\r\n- 一旦渲染树创建并且布局完成，像素就可以被绘制在屏幕上，既然浏览器已经明确的知道哪些节点是可见的，以及它们的样式和几何形状，绘制阶段就是将RenderTree中的每个节点转换为屏幕上的实际像素。\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## 浏览器渲染进程(浏览器内核)\r\n- 浏览器渲染进程是多线程的。\r\n### 浏览器渲染进程包含的线程\r\n1. GUI渲染线程\r\n    - 负责渲染浏览器界面，解析HTML，CSS，构建DOM树和CSSOM树和Render树，布局和渲染等。\r\n    - 当界面需要重绘(Repaint)或由于某种操作引发回流(reflow)时，该线程就会执行。\r\n    - **GUI渲染线程与JS引擎线程是互斥的**，当JS引擎执行时GUI线程会被挂起(相当于被冻结了)，GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。\r\n2. JS引擎线程\r\n    - 也称为JS内核，负责处理Javascript脚本程序。\r\n    - JS引擎线程负责解析Javascript脚本，运行代码。\r\n    - JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页(浏览器渲染进程)中无论什么时候都只有一个JS线程在运行JS程序。\r\n    - **GUI渲染线程与JS引擎线程是互斥的**，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。\r\n3. 事件触发线程\r\n    - 归属于浏览器而不是JS引擎，用来控制事件循环。\r\n    - 当JS引擎执行代码块如setTimeOut时(也可来自浏览器渲染进程的其他线程，如鼠标点击、AJAX异步请求等)，会将对应任务添加到事件线程中。\r\n    - 当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理。\r\n    - 由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理(当JS引擎空闲时才会去执行)。\r\n4. 定时触发器线程\r\n    - setInterval与setTimeout所在线程。\r\n    - 浏览器定时计数器并不是由JavaScript引擎计数的，(因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确)。\r\n    - 因此通过单独线程来计时并触发定时(计时完毕后，添加到事件队列中，等待JS引擎空闲后执行)。\r\n    - W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。\r\n5. 异步http请求线程\r\n    - 在XMLHttpRequest在连接后是通过浏览器新开一个线程请求。\r\n    - 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由JavaScript引擎执行。\r\n\r\n![浏览器渲染进程](./img/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E8%BF%9B%E7%A8%8B.png)\r\n### GUI渲染线程与JS引擎线程互斥\r\n- 由于JavaScript是可操纵DOM的，如果在修改这些元素属性同时渲染界面(即JS线程和UI线程同时运行)，那么渲染线程前后获得的元素数据就可能不一致了。\r\n- 为了防止渲染出现不可预期的结果，浏览器设置GUI渲染线程与JS引擎为互斥的关系，当JS引擎执行时GUI线程会被挂起，GUI更新则会被保存在一个队列中等到JS引擎线程空闲时立即被执行。\r\n### JS阻塞页面加载\r\n- JS如果执行时间过长就会阻塞页面。假设JS引擎正在进行巨量的计算，此时就算GUI有更新，也会被保存到队列中，等待JS引擎空闲后执行。由于巨量计算JS引擎很可能很久后才能空闲，GUI更新很久后才会被执行，所以会感觉到卡顿。\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## 输入URL到页面显示\r\n1. DNS域名解析(网址到IP地址的转换)，会查DNS缓存(浏览器缓存、系统缓存)。\r\n2. 发起TCP连接，建立客户端和服务器之间的连接。\r\n3. 发送HTTP请求(会查询缓存，强缓存或者协商缓存)。\r\n4. 服务器处理请求并返回HTTP报文。\r\n5. 浏览器接收HTTP响应并解析渲染页面。\r\n    - 解析HTML构造文档对象模型(DOM树创建)。\r\n    - 解析CSS构造CSS对象模型(CSSOM树创建)。\r\n    - 将文档对象模型与CSS对象模型合并生成渲染树(渲染树创建)。\r\n    - 遍历渲染树开始布局，计算每一个节点的位置大小信息(布局)。\r\n    - 将渲染树每个节点绘制到屏幕上(绘制)。"},function(r,n,e){"use strict";e.r(n),n.default="## 进程和线程\r\n- 进程是cpu资源分配的最小单位(是能拥有资源和独立运行的最小单位)。\r\n- 线程是cpu调度的最小单位(线程是建立在进程基础上的一次程序运行单位，一个进程中可以有多个线程)。\r\n- 不同进程之间也可以通信但是代价较大。\r\n- 单线程与多线程是指在一个进程内的单和多(核心还是得属于一个进程)。\r\n### 比喻\r\n- 进程是一个工厂，工厂有它的独立资源，工厂之间相互独立。\r\n- 线程是工厂中的工人，多个工人协作完成任务，工厂内有一个或多个工人，工人之间共享空间。\r\n- 工厂有它的独立资源 -> 系统分配的内存(独立的一块内存)。\r\n- 工厂之间的相互独立 -> 进程之间相互独立。\r\n- 多个工人协作完成任务 -> 多个线程在进程中协作完成任务。\r\n- 工厂内有一个或多个工人 -> 一个进程由一个或多个线程组成。\r\n- 工人之间共享空间 -> 同一进程下的各个线程之间共享程序的内存空间。"},function(r,n,e){"use strict";e.r(n),n.default='## Android使用WebView\r\n### AndroidManifest.xml\r\n- 加入联网的权限\r\n```\r\n<uses-permission android:name="android.permission.INTERNET"></uses-permission>\r\n```\r\n- 设置允许对app debug\r\n```\r\n<application\r\n  android:debuggable="true"\r\n  tools:ignore="HardcodedDebugMode"\r\n>\r\n</application>\r\n```\r\n### Activity\r\n- 设置可运行JavaScript脚本\r\n```\r\nwebView.settings.javaScriptEnabled=true\r\n```\r\n- 设置启用HTML5 DOM storage API\r\n```\r\nwebView.settings.domStorageEnabled=true\r\n```\r\n- 设置启用调试模式\r\n```\r\ntry {\r\n  // 启用调试模式\r\n  // 由于 WebView#setWebContentsDebuggingEnabled 函数不能直接访问，必须使用反射进行访问\r\n  val method = Class.forName("android.webkit.WebView")\r\n    .getMethod("setWebContentsDebuggingEnabled", java.lang.Boolean.TYPE)\r\n  if (method != null) {\r\n    method.isAccessible = true\r\n    method.invoke(null, true)\r\n  }\r\n} catch (e: Exception) {\r\n  // JavaScript出错处理 此处不进行任何操作\r\n}\r\n```\r\n### WebView加载的H5页面初始存在重定向时可能会导致最后无法退出应用的问题\r\n- 可以调整加载的H5页面链接为重定向后的地址。\r\n### WebView加载H5页面后返回键会关闭Activity的问题\r\n- 通过监听返回键事件实现WebView内部后退逻辑\r\n```\r\noverride fun onKeyDown(keyCode: Int, event: KeyEvent?): Boolean {\r\n  val webView: WebView = findViewById(R.id.h5WebView)\r\n  if (keyCode == KeyEvent.KEYCODE_BACK) { // 判断按下的是否为返回键\r\n    if (webView.canGoBack()) {\r\n      webView?.goBack() // 调用WebView的goBack()函数进行页面后退操作\r\n      return true // 返回true表示已处理该事件\r\n    } else {\r\n      // WebView不能页面后退时调用默认的后退事件\r\n      super.onBackPressed();\r\n    }\r\n  }\r\n  return super.onKeyDown(keyCode, event)\r\n}\r\n```'},function(r,n,e){"use strict";e.r(n),n.default="## JSBridge\r\n- 跨平台开发：JSBridge允许在混合应用中使用一套代码同时运行在不同的平台上。这意味着可以使用Web技术来开发应用的核心逻辑，并在需要时通过JSBridge调用原生功能，从而实现跨平台开发，提高开发效率。\r\n- 原生功能扩展：使用JSBridge可以充分利用原生平台提供的功能和能力，例如访问硬件设备、调用系统API等。可以为应用添加更多丰富的功能，提升用户体验。\r\n- 通信桥梁：JSBridge充当了Web应用和原生应用之间的通信桥梁。通过JSBridge可以在Web应用和原生应用之间进行双向通信，使两者能够互相调用和传递数据。\r\n- 灵活性和扩展性：JSBridge提供了一种灵活和可扩展的方式来实现Web应用和原生应用之间的通信。开发人员可以根据应用的需求随时添加新的原生功能，并通过JSBridge在JavaScript中调用这些功能，从而实现应用的功能扩展和升级。\r\n### Native向Web发送消息\r\n- Native向Web发送消息基本原理是在WebView容器中动态地执行一段JS脚本，通常情况下是调用一个挂载在全局上下文的方法。\r\n- Native端可以直接调用挂载在window上的全局方法并传入相应的函数执行参数，并且在函数执行结束后Native端可以直接拿到执行结果。\r\n### Native向Web发送消息的调用顺序\r\n1. Web端提前subscribe订阅事件(存储事件处理函数)。\r\n2. 原生调用一个挂载在全局上下文的方法，此事件处理中emit发布事件，执行之前Web端subscribe订阅时存储的事件处理函数。\r\n### Native向Web发送消息的实现方式\r\n- WEB：全局挂载方法。\r\n- iOS：evaluatingJavaScript。\r\n- 安卓：两种方法类似，使用方法也类似。\r\n  - 4.4以上：evaluatingJavaScript。\r\n  - 4.4以下：loadUrl。\r\n### Web向Native发送消息\r\n- Web向Native发送消息基本原理是在WEB中某段JS代码的执行端上是可感知的，端上感知到WEB中的行为后根据相关约定进行处理。\r\n### Web向Native发送消息的实现方式\r\n- 跳转拦截(不选择)\r\n  - 客户端无差别拦截所有请求，正常URL放行，符合约定协议的请求拦截，并做出对应的操作。\r\n  - 同时发送多个请求会丢消息、URL有长度限制。\r\n  - iOS和安卓都支持。\r\n- 弹窗拦截(alert/confirm/prompt)\r\n  - 无明显短板，支持同步返回数据。\r\n  - 不支持直接传递对象，需要序列化数据，在高频/大数据量通信的场景可能有一些性能上的损耗。\r\n  - iOS和安卓都支持。\r\n- addJavascriptInterface注入(推荐)\r\n  - 目前推荐的方案，具备JSContext注入的所有优点。\r\n  - 没有参数的限制，可直接传对象，无需序列化。同时也支持同步返回结果。\r\n  - 安卓4.2以上版本支持。\r\n- JSContext注入(不推荐)\r\n  - 能力强大，但是只有UIWebview支持。\r\n  - 低版本iOS支持。\r\n- MessageHandler注入(推荐)\r\n  - 官方推荐的通信API，无需JSON化传数据，不丢消息，但不支持同步返回。\r\n  - 高版本iOS支持。\r\n### Web向Native发送消息的最佳方式\r\n- iOS：推荐使用MessageHandler + 弹窗拦截拦截两个方案并存，同时实现异步和同步调用。\r\n- 安卓：推荐使用addJavaScriptInterface。\r\n### 拦截式\r\n- WebView中发出的所有请求都是可以被Native容器感知到的，因此拦截式具体指的是Native拦截Web发出的URL请求，双方在此之前约定一个JSB请求格式，如果该请求是JSB则进行相应的处理，若不是则直接转发。\r\n- Web端发出请求的方式非常多样，例如a标签、iframe.src、location.href、ajax等，但a标签需要用户手动触发，location.href可能会导致页面跳转，安卓端拦截ajax的能力有所欠缺，因此绝大多数拦截式实现方案均采用iframe来发送请求。\r\n- 拦截式在双端都具有非常好的向下兼容性，曾经是最主流的JSB实现方案，但目前在高版本的系统中已经逐渐被淘汰。\r\n### 拦截式劣势 \r\n- 连续发送时可能会造成消息丢失(可以使用消息队列解决该问题)。\r\n- URL字符串长度有限制。\r\n- 性能一般，URLrequest创建请求有一定的耗时。\r\n### 注入式\r\n- 这种方式简单而直观，并且不存在参数长度限制和性能瓶颈等问题，目前主流的JSBridge SDK都将注入式方案作为优先选择。\r\n### 拦截式 VS 注入式\r\n| 方案 | 兼容性 | 性能 | 参数长度限制 |\r\n| --- | --- | --- | --- |\r\n| 拦截式 | 无兼容性问题\t| 较差，安卓端尤为明显 | 有限制 |\r\n| 注入式 | 安卓4.2+ 和 iOS 7+以上可用 |\t较好 | 无 |\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## WebView\r\n> WebView是移动端中的一个控件，它为JS运行提供了一个沙箱环境。WebView能够加载指定的url，拦截页面发出的各种请求，控制页面的各种功能，JSBridge的实现就依赖于WebView暴露的各种接口。\r\n\r\n| 平台和版本 | WebView 内核\t|\r\n| --- | --- |\r\n| Android 4.4+ | Chrome |\r\n| Android 4.4- | Webkit |\r\n| iOS 8+ | WKWebView |\r\n| iOS 2-8 |\tUIWebView |\r\n### Android WebView\r\n- 在Android4.4以前，WebView是Android webkit浏览器内核，很多HTML5标准语法不支持，canvas性能也非常差。\r\n- Android4.4起，WebView变成了chromium内核，内核版本是chrome30，性能和现代语法支持大幅提升。\r\n- 从Android5开始，WebView脱离rom可单独更新，伴随着chrome的发版，google会在google play store上同步更新Android system webview。\r\n### Android system webview\r\n- 它自带于手机rom中，所有依赖系统WebView的应用都调用这个WebView。\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## dsbridge\r\n### 调用原生同步方法\r\n```\r\nimport dsBridge from 'dsbridge';\r\n\r\nconst __function = function(name, defaultValue) {\r\n  return function (args) {\r\n    const returnValue = dsBridge.call(name, args);\r\n    if (returnValue) {\r\n      return JSON.parse(returnValue);\r\n    } else {\r\n      if (!window.isApp) {\r\n        return defaultValue;\r\n      } else {\r\n        throw new Error(`函数 ${name} 没有有效的返回值`);\r\n      }\r\n    }\r\n  };\r\n};\r\n\r\n// 使用\r\nconst getStatusBarHeight = __function(\"getStatusBarHeight\", 45);\r\nconst height = getStatusBarHeight()\r\n```\r\n### 调用原生异步方法\r\n```\r\nimport dsBridge from 'dsbridge';\r\n\r\nconst __functionAsync = function(name, defaultValue) {\r\n  return function (args) {\r\n    return new Promise((resolve, reject) => {\r\n      if (!window.isApp) {\r\n        resolve(defaultValue);\r\n      } else {\r\n        dsBridge.call(name, args, (returnValue) => {\r\n          resolve(JSON.parse(returnValue));\r\n        });\r\n      }\r\n    });\r\n  };\r\n};\r\n\r\n// 使用\r\nconst getSystemPushStatus = __functionAsync('getSystemPushStatus', { systemPushStatus: 0 });\r\nconst getStatus = async() => {\r\n  const res = await getSystemPushStatus();\r\n}\r\n```\r\n### 判断是否有此方法\r\n```\r\nimport dsBridge from 'dsbridge';\r\n\r\n// 判断方法是否存在\r\ndsBridge.hasNativeMethod('getStatusBarHeight');\r\n```\r\n"},function(r,n,e){"use strict";e.r(n),n.default='## 安卓应用和H5相互调用\r\n### 安卓调用H5方法\r\n- H5端在全局上下文对象(window)中注入方法，原生应用可以通过evaluateJavascript调用H5在window上注入的方法。\r\n```\r\n// H5端注入h5MinusCount方法\r\nwindow.h5MinusCount = (minusNum: number) => {\r\n  setCount((prev: number) => prev - minusNum);\r\n  return \'h5MinusCountValue\';\r\n};\r\n\r\n// 原生应用调用h5MinusCount方法\r\nh5MinusCountButton.setOnClickListener {\r\n  val minusNum: Number = 3\r\n  // 调用H5的h5MinusCount方法\r\n  myWebView.evaluateJavascript("javascript:h5MinusCount(${minusNum})", ValueCallback<String>() {\r\n    Toast.makeText(this, it, Toast.LENGTH_SHORT).show()\r\n  })\r\n}\r\n```\r\n### H5端调用安卓应用方法\r\n- 原生应用通过addJavascriptInterface可以在H5端的全局上下文对象(window)中注入方法，H5端直接调用原生应用在window上注入的方法。\r\n```\r\n// 原生应用注入showNativeToast方法\r\nmyWebView.addJavascriptInterface(WebAppInterface(this), "jsbridge")\r\nclass WebAppInterface(private val mContext: Context) {\r\n  @JavascriptInterface\r\n  fun showNativeToast(toast: String): String {\r\n    Toast.makeText(mContext, toast, Toast.LENGTH_SHORT).show()\r\n    return "showNativeToast return value"\r\n  }\r\n}\r\n\r\n// H5端调用showNativeToast方法\r\nwindow.jsbridge?.showNativeToast(\'h5 click showNativeToast\');\r\n```'},function(r,n,e){"use strict";e.r(n),n.default="## 混合开发\r\n- Native和H5都有着各自的优缺点，为了满足业务的需要，项目的开发过程中往往会融合两者进行Hybrid开发。\r\n- 使用JSBridge连接两端的Native和H5，可以方便的在APP内实现Native调用JS，JS调用Native。\r\n\r\n| | H5\t| Native |\r\n| --- | --- | --- |\r\n| 稳定性 | 调用系统浏览器内核，稳定性较差 | 使用原生内核，更加稳定 |\r\n| 灵活性 | 版本迭代快，上线灵活 | 迭代慢，需要应用商店审核，上线速度受限制 |\r\n| 受网速 | 影响较大 | 较小 |\r\n| 流畅度 | 有时加载慢，给用户“卡顿”的感觉 |\t加载速度快，更加流畅 |\r\n| 用户体验 | 功能受浏览器限制，体验有时较差 | 原生系统api丰富，能实现的功能较多，体验较好 |\r\n| 可移植性 | 兼容跨平台跨系统，如PC与移动端，iOS与Android | 可移植性较低，对于iOS和Android需要维护两套代码 |\r\n\r\n### 区分APP页面是H5页面还是原生页面\r\n- 断开网络\r\n  - 显示404或错误页面的大概率是H5页面，如果还有控件大概率是原生页面。\r\n- 看页面布局边界(仅针对安卓手机适用)\r\n  1. 在手机设置-开发者选项中，开启显示布局边界功能。\r\n  2. 开启显示布局边界功能后，原生应用和跨端应用都会显示页面各个控件的边界布局，混合Hybrid应用只会显示整个页面的边界布局。"},function(r,n,e){"use strict";e.r(n),n.default="## JWT(JSON Web Token)\r\n- 过往的Token形式服务端验证客户端发送过来的Token时，需要查询数据库获取用户基本信息，然后验证Token是否有效。这样每次请求验证都要查询数据库，增加了查库带来的延迟等性能消耗。\r\n- JWT就是登录成功后将相关用户信息组成JSON对象，然后对这个对象进行某种方式的加密，返回给客户端。客户端在下次请求时带上这个Token，服务端再收到请求时直接校验Token的合法性并解析获取到用户信息。\r\n### JWT的优点\r\n- 校验Token合法性时不需要查询数据库，减少服务端查询数据库的次数。\r\n### JWT的缺点\r\n- 到期问题：一旦JWT签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。\r\n### JWT和Token的区别\r\n- JWT和Token区别主要体现在校验Token合法性时是否需要进入数据库查询信息。\r\n### eggjs实现JWT校验\r\n- 安装依赖\r\n```\r\nnpm install egg-jwt;\r\n```\r\n- config.default.js\r\n```\r\nexports.jwt = { \r\n  secret: 'login-server', // 可以自定义秘钥\r\n};\r\n```\r\n- plugin.js\r\n```\r\nexports.jwt = {\r\n  enable: true,\r\n  package: 'egg-jwt',\r\n};\r\n```\r\n- 登录时签发Token和Refresh Token\r\n```\r\n// 登录\r\nasync login() {\r\n  const userData = this.ctx.request.body;\r\n  const access_token = this.app.jwt.sign({\r\n    ...userData,\r\n    exp: Math.floor(Date.now() / 1000) + 60 // token有效期60秒\r\n  }, this.app.config.jwt.secret);\r\n  const refresh_token = this.app.jwt.sign({\r\n    ...userData,\r\n    exp: Math.floor(Date.now() / 1000) + 120 // refresh_token有效期120秒\r\n  }, this.app.config.jwt.secret);\r\n  this.ctx.body = {\r\n    success: true,\r\n    data: {\r\n      access_token,\r\n      refresh_token,\r\n    },\r\n    msg: null,\r\n  };\r\n}\r\n```\r\n- 校验Token\r\n```\r\nasync upsert() {\r\n  const userData = this.ctx.request.body;\r\n  const accessToken = this.ctx.request.headers.access_token; // 获取header的accessToken\r\n  let checkTokenInfo = null; // token校验信息\r\n  try {\r\n    checkTokenInfo = this.app.jwt.verify(token, this.app.config.jwt.secret);\r\n  } catch (error) {\r\n    checkTokenInfo = null;\r\n  }\r\n  if (checkTokenInfo) {\r\n    this.ctx.body = {\r\n      success: true,\r\n      data: checkTokenInfo,\r\n      msg: null,\r\n    };\r\n  } else {\r\n    this.ctx.status = 401;\r\n    this.ctx.body = {\r\n      success: false,\r\n      data: null,\r\n      msg: 'token已过期'\r\n    };\r\n  }      \r\n}\r\n```\r\n- 刷新Token\r\n```\r\n// 刷新token\r\nasync refreshToken() {\r\n  const { refresh_token } = this.ctx.request.body;\r\n  let checkTokenInfo = null; // token校验信息\r\n  try {\r\n    checkTokenInfo = this.app.jwt.verify(refresh_token, this.app.config.jwt.secret);\r\n  } catch (error) {\r\n    checkTokenInfo = null;\r\n  }\r\n  if (checkTokenInfo) {\r\n    // refresh_token校验通过生成新的Token和refresh_token\r\n    const { username, password } = userData;\r\n    const access_token = this.app.jwt.sign({\r\n      username,\r\n      password,\r\n      exp: Math.floor(Date.now() / 1000) + 60 // token有效期\r\n    }, this.app.config.jwt.secret);\r\n    const refresh_token = this.app.jwt.sign({\r\n      username,\r\n      password,\r\n      exp: Math.floor(Date.now() / 1000) + 120 // refresh_token有效期\r\n    }, this.app.config.jwt.secret);\r\n    this.ctx.body = {\r\n      success: true,\r\n      data: {\r\n        access_token,\r\n        refresh_token,\r\n      },\r\n      msg: null,\r\n    };\r\n  } else {\r\n    this.ctx.status = 401;\r\n    this.ctx.body = {\r\n      success: false,\r\n      data: null,\r\n      msg: 'refresh_token过期'\r\n    };\r\n  }\r\n}\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## Session-Cookie\r\n1. 客户端向服务器发送登录信息用户名/密码来请求登录。\r\n2. 服务器验证登录的信息，验证通过后自动创建Session（将Session保存在内存或Redis中），然后给这个Session生成一个唯一的标识作为会话身份凭证session_id(通常称为sid)，并在响应头Set-Cookie中设置这个唯一标识符。\r\n3. 客户端收到服务器的响应后会解析响应头，并自动将sid保存在本地Cookie中，浏览器在下次HTTP请求时请求头会自动附带上该域名下的Cookie信息。\r\n4. 服务器接收客户端请求时会去解析请求头Cookie中的sid，然后根据这个sid去找服务端保存的Session，然后判断该请求是否合法。\r\n### Session-Cookie的优点\r\n- Cookie简单易用。\r\n- Session数据存储在服务端，相较于JWT方便进行管理，当用户登录和主动注销只需要添加删除对应的Session即可，方便管理。\r\n- 只需要后端操作即可，前端可以无感等进行操作。\r\n### Session-Cookie的缺点\r\n- 依赖Cookie，一旦用户在浏览器端禁用Cookie就不生效。\r\n- Cookie将数据暴露在浏览器中不安全，增加了数据被盗的风险（容易被CSRF等攻击）。\r\n- Session存储在服务端，增大了服务端的开销，用户量大的时候会降低服务器性能。\r\n### Session存储方式\r\n- Redis(推荐)：内存型数据库以key-value的形式存储，且访问快。\r\n- 内存：直接放到变量里，一旦服务重启就没了。\r\n- 数据库：普通数据库，性能不高。\r\n### Session的分布式问题\r\n> 通常服务端是集群，而用户请求过来会走一次负载均衡，不一定打到哪台机器上。那一旦用户后续接口请求到的机器和他登录请求的机器不一致，或者登录请求的机器宕机，Session验证就会有问题。\r\n\r\n- 从存储角度：把Session集中存储。用独立的Redis或普通数据库把Session都存到一个库里。\r\n- 从分布角度：让相同IP的请求在负载均衡时都打到同一台机器上。以nginx为例，可以配置ip_hash来实现。"},function(r,n,e){"use strict";e.r(n),n.default="\r\n## Token\r\n1. 客户端向服务器发送登录信息用户名/密码来请求登录。\r\n2. 服务器收到请求去验证用户名与密码，验证成功后服务端会签发一个Token并把这个Token发送给客户端。\r\n3. 客户端收到Token后会把它存储起来，web端一般会放在localStorage或Cookie中，移动端原生APP一般存储在本地缓存中。\r\n4. 客户端向服务端请求API资源的时候，将Token通过HTTP请求头Authorization字段或者其它方式发送给服务端。\r\n5. 服务器收到请求后会去验证客户端请求里面带着的Token，根据Token验证结果判断该请求是否合法。\r\n### Token的优点\r\n- 服务端无状态化、可扩展性好，Token机制在服务端不需要存储会话（Session）信息，因为Token自身包含了其所标识用户的相关信息，这有利于在多个服务间共享用户状态。\r\n- 安全性好，有效避免CSRF攻击（不依赖Cookie的使用）。\r\n- 支持跨程序调用：因为Cookie是不允许跨域访问的，而Token则不存在这个问题。\r\n### Token的缺点：\r\n- 需要前后端配合处理。\r\n- Token正常情况下比sid大，消耗更多流量，占用更多宽带。\r\n- 验证Token时需要对Token进行加解密或查询数据库等操作，可能会更耗性能。\r\n- 有效期短，为了避免Token被盗用，一般Token的有效期会设置的较短，使用Refresh Token更新Token。\r\n### Token和Session-Cookie的区别\r\n> Session-Cookie和Token有很多类似的地方，但是Token更像是Session-Cookie的升级改良版。\r\n\r\n- 存储地不同：Session一般是存储在服务端，Token是无状态的一般由前端存储。\r\n- 安全性不同：Token不依赖浏览器的Cookie机制，可以降低web攻击的风险。\r\n- 支持性不同：Session-Cookie认证需要依赖浏览器的Cookie机制，如果遇到原生应用或浏览器的Cookie功能被禁用时这种机制就不起作用了。\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## 单点登录\r\n### 同域下的SSO（主域名相同）\r\n> 当百度网站存在两个相同主域名下的贴吧子系统tieba.baidu.com和网盘子系统pan.baidu.com时，以下为实现SSO的步骤：\r\n\r\n1. 客户端：用户访问某个子系统时（例如tieba.baidu.com），如果没有登录，则跳转至SSO认证中心提供的登录页面进行登录。\r\n2. 服务端：登录认证后，服务端把登录用户的信息存储于Session中，并且附加在响应头的Set-Cookie字段中，设置Cookie的Domain为.baidu.com。\r\n3. 客户端：再次发送请求时，携带主域名Domain下的Cookie给服务器，此时服务端就可以通过该Cookie来验证登录状态了。\r\n### 跨域下的SSO（主域名不同）\r\n> 购物网站天猫tmall.com和淘宝taobao.com利用CAS（Central Authentication Service）中央授权服务只需要登录其中某一个系统，另外一个系统打开后就会默认登录。\r\n\r\n![单点登录](./img/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95.png)\r\n1. 客户端：开始访问系统A。\r\n2. 系统A：发现用户未登录，重定向至CAS认证服务（sso.com），同时URL地址参数携带登录成功后回跳到系统A的页面链接（sso.com/login?redir…）。\r\n3. CAS认证服务：发现请求Cookie中没有携带登录的票据凭证（TGC），所以CAS认证服务判定用户处于未登录状态，重定向用户页面至CAS的登录界面，用户在CAS的登录页面上进行登录操作。\r\n4. 客户端：输入用户名密码进行CAS系统认证。\r\n5. CAS认证服务：校验用户信息并且生成TGC放入自己的Session中，同时以Set-Cookie形式写入Domain为sso.co的域下，同时生成一个授权令牌ST（Service Ticket），然后重定向至系统A的地址，重定向的地址中包含生成的ST（重定向地址：www.taobao.com?token=ST-345678）\r\n6. 系统A：拿着ST向CAS认证服务发送请求，CAS认证服务验证票据（ST）的有效性。验证成功后系统A服务器使用该票据（ST）创建与用户的会话，称为局部会话，返回受保护资源。\r\n7. 客户端：开始访问系统B。\r\n8. 系统B：发现用户未登录，重定向至CAS认证服务，并将自己的地址作为参数传递，并附上在sso.com域下的cookie值（第五步生成的TGC）。\r\n9. CAS认证服务：CAS认证服务中心发现用户已登录，跳转回系统B的地址，并附上票据（ST）。\r\n10. 系统B：拿着ST向CAS认证服务发送请求，CAS认证服务验证票据（ST）的有效性。验证成功后系统B服务器使用该票据（ST）创建与用户的会话，称为局部会话，返回受保护资源。\r\n### CAS一般提供四个接口：\r\n- /login：登录接口，用于登录到中央授权服务。\r\n- /logout：登出接口，用于从中央授权服务中登出。\r\n- /validate：用于验证用户是否登录中央授权服务。\r\n- /serviceValidate：用于让各个Service验证用户是否登录中央授权服务。"},function(r,n,e){"use strict";e.r(n),n.default="## 唯一登录\r\n> 用户只能在一个设备上登录，禁止用户重复登录。\r\n\r\n![唯一登录](./img/%E5%94%AF%E4%B8%80%E7%99%BB%E5%BD%95.png)\r\n- 用户在客户端A操作：\r\n  1. 输入账号密码请求登录接口。\r\n  2. 后端生成对应Token并且返回给客户端A，并且在服务端保存一个登录状态。\r\n  3. 客户端A保存Token，并且每次请求都携带对应的Token。\r\n- 用户在客户端B操作：\r\n  1. 用户在客户端B上开始登录操作，步骤和在客户端A上面操作几乎是一致的。\r\n  2. 只是后端在生成新的Token时，要先验证登录状态，如果判断是已登录状态则清除在服务端已经保存的登录状态，然后再生成对应新的Token并保存登录状态。\r\n  3. 客户端A再操作时发现Token过期提示重新登录。"},function(r,n,e){"use strict";e.r(n),n.default="## 扫码登录\r\n![扫码登录](./img/%E6%89%AB%E7%A0%81%E7%99%BB%E5%BD%95.png)\r\n- 待扫码阶段：\r\n  1. PC端：打开某个网站或者某个APP的扫码登录入口，就会携带PC端的设备信息向服务端发送一个获取二维码的请求。\r\n  2. 服务端：服务器收到请求后，随机生成一个UUID作为二维码ID，并将UUID与PC端的设备信息关联起来存储在Redis服务器中，然后返回给PC端，同时设置一个过期时间，在过期后用户登录二维码需要刷新重新获取。\r\n  3. PC端：收到二维码ID之后，将二维码ID以二维码的形式展示，等待移动端扫码。并且此时的PC端开始轮询查询二维码状态，直到登录成功。如果移动端未扫码，那么一段时间后二维码会自动失效。\r\n- 已扫码待确认阶段：\r\n  1. 手机端：打开手机端对应已登录的APP扫描识别PC端展示的二维码，移动端扫描二维码后，会自动获取到二维码ID，并将移动端登录的信息凭证Token和二维码ID作为参数发送给服务端，此时手机必须是已登录（使用扫描登录的前提是移动端的应用为已登录状态，这样才可以共享登录态）。\r\n  2. 服务端：收到手机端发来的请求后，会将Token与二维码ID关联，关联的作用是当我们在使用应用时，移动端退出后PC端也应该随之退出登录，这个关联就起到这个作用。然后会生成一个临时Token，这个Token会返回给移动端，一次性Token用作确认时的凭证。\r\n- 已确认阶段：\r\n  1. 手机端：收到确认信息后，点击确认按钮，移动端携带上一步中获取的临时Token发送给服务端校验。\r\n  2. 服务端：服务端校验完成后，会更新二维码状态，并且给PC端生成一个正式的Token，后续PC端就是持有这个正式Token访问服务端。\r\n  3. PC端：轮询到二维码状态为已登录状态，并且会获取到生成的正式Token，完成登录，后续访问都基于正式Token完成。\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## 第三方登录\r\n### 微信登录\r\n1. 应用的运营者需要在微信开放平台注册账号，并向微信申请使用微信登录功能。\r\n2. 申请成功后，得到申请的appid、appsecret。\r\n3. 用户在应用上选择使用微信登录。\r\n4. 这时会跳转微信的OAuth授权登录，并带上应用的回调地址。\r\n5. 用户输入微信账号和密码，登录成功后，需要选择具体的授权范围，如：授权用户的头像、昵称等。\r\n6. 授权之后，微信会回调到应用的回调地址并带上了一个临时票据code。\r\n7. 应用获取code之后，会使用code、appid、appsecret向微信服务器申请token，微信服务器验证成功后会下发一个token。\r\n8. 应用获取token之后就可以凭借token拿到对应的微信用户头像，用户昵称等信息。\r\n9. 应用提示用户登录成功，并将登录状态写入应用的本地存储，以作为后续访问的凭证。"},function(r,n,e){"use strict";e.r(n),n.default="## 像素\r\n### 屏幕尺寸\r\n- 屏幕尺寸指的是以屏幕对角线的长度来计算的，单位是英寸。\r\n- 电子设备一般都用英寸来描述屏幕的物理大小，1英寸=2.54厘米。\r\n### 像素pixel\r\n- 从计算机技术的角度来解释，像素是硬件和软件所能控制的最小单位。\r\n- 显示屏的画面上表示出来的最小单位，一个像素，就是一个点，或者说是一个很小的正方形。\r\n### 屏幕分辨率\r\n- 屏幕分辨率指一个屏幕具体由多少个像素点组成，单位是px。\r\n### 物理像素(设备像素)\r\n- 在同一个设备上它的物理像素是固定的，也就是厂家在生产显示设备时就决定的实际点的个数，对于不同设备物理像素点的大小是不一样的。\r\n- 常说的1920*1080像素分辨素就是用的物理像素单位。\r\n- 如果都使用物理像素就会带来问题。21英寸显示器的分辨率是1440x1080，5.8英寸的iPhone X的分辨率是2436×1125，用CSS画一条线其长度是20px，如果都以物理像素作为度量单位，那么在显示器上看起来正常，在iPhone X屏幕上就变得非常小。\r\n### 逻辑像素(设备独立像素)\r\n- 高分辨率的设备，多了一个逻辑像素。不同设备的逻辑像素仍然是有差异的，只不过差异没有物理像素那么大。\r\n- 逻辑像素是与设备无关的逻辑像素，可以通过程序控制使用的虚拟像素。\r\n- 普通屏幕下1设备独立像素等于1设备像素。高清屏幕下1设备独立像素等于N设备像素。\r\n### 逻辑像素解决的问题\r\n> 逻辑像素是为了解决屏幕相同，分辨率不同的两台显示设备，显示同一内容大小明显不一致的问题。比如说两台笔记本都是15英寸的，一个分辨率是1920 x 1080，一个分辨率是960 x 540, 在1920 x 1080分辨率的设备上每个格子比较小，在960 x 540分辨率的设备上每个格子比较大。一张200 x 200的图片，在高分率的设备上看起来会比较小，在低分辨率的设备上看起来会比较大。为了使同样尺寸的图片在两台屏幕尺寸一样大的设备上，显示尺寸看起来差不多一样大，发明了逻辑像素这个概念。规定所有电子设备呈现的图片等资源尺寸统一用逻辑像素表示。然后在高分辨率设备上提高devicePixelRatio，比如说设置1920 x 1080设备的devicePixelRatio(dpr)等于2，一个逻辑像素占用四个格子，在低分辨率设备上，比如说在960 x 540设备上设置dpr=1，一个逻辑像素占一个格子，这样两张图片在同样的设备上尺寸大小就差不多了。通常设备上的逻辑像素是等于物理像素的，在高分辨率设备上，物理像素是大于逻辑像素数量的。由此也可以看出，物理像素一出厂就是固定的，而设备的逻辑像素会随着设备像素比设置的值不同而改变。\r\n\r\n### 设备像素比dpr\r\n> 设备像素/设备独立像素，代表设备独立像素到设备像素的转换关系，在JS中可以通过window.devicePixelRatio获取，计算公式为DPR = 物理像素/逻辑像素。\r\n\r\n- 当设备像素比为1:1时，使用1（1×1）个设备像素显示1个CSS像素。\r\n- 当设备像素比为2:1时，使用4（2×2）个设备像素显示1个CSS像素。\r\n- 当设备像素比为3:1时，使用9（3×3）个设备像素显示1个CSS像素。\r\n### CSS像素\r\n- CSS中使用到的单位PX，就是CSS像素。\r\n- 当页面缩放比为1:1时，一个CSS像素等于一个设备独立像素。但CSS像素是很容易被改变的，比如用户对页面进行放大，CSS像素会被放大，此时的CSS像素会跨越更多的设备像素。\r\n- 页面缩放系数 = CSS像素 / 设备独立像素\r\n### 每英寸像素点ppi\r\n- 表示每英寸所包含的像素点数目，数值越高，说明屏幕能以更高密度显示图像。\r\n### 电脑缩放调整\r\n- 电脑将缩放调整150%时，是将设备像素比调整为1.5(物理像素/逻辑像素)，物理像素不会变化，变化的是逻辑像素(宽高缩小三分之一)。\r\n```\r\n// 设备像素比为1时(宽高为30px)\r\n物理像素：30 * 30 = 900px\r\n逻辑像素：30 * 30 = 900px\r\n\r\n// 设备像素比为1.5时(宽高为30px)\r\n物理像素：30 * 30 = 900px\r\n逻辑像素：900 / (1.5 * 1.5) = 400px\r\n逻辑像素宽高为20px：20 * 20 = 400px\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## 兼容问题\r\n### ios日期解析问题\r\n> 在某些情况下苹果系统上解析YYYY-MM-DD HH:mm:ss格式的日期会报错Invalid Date，而安卓系统则没有这个问题。解决这个问题的一种方法是将日期字符串中的 - 替换为 /。\r\n\r\n```\r\n// 将日期字符串的格式符号替换成'/'\r\n\"2023-07-16 00:00:00\".replace(/-/g, '/')\r\n```\r\n### iOS上拉边界下拉出现空白\r\n- 手指按住屏幕下拉屏幕顶部会多出一块白色区域。手指按住屏幕上拉底部多出一块白色区域。\r\n- 在iOS中手指按住屏幕上下拖动，会触发touchmove事件。这个事件触发的对象是整个webview容器，容器自然会被拖动，剩下的部分会成空白。\r\n```\r\ndocument.body.addEventListener(\r\n  'touchmove',\r\n  function(e) {\r\n    if (e._isScroller) {\r\n      return;\r\n    }\r\n    // 阻止默认事件\r\n    e.preventDefault()\r\n  },\r\n  {\r\n    passive: false\r\n  }\r\n)\r\n```\r\n### ios下点击input页面会放大\r\n- html添加禁止缩放的meta\r\n- 添加样式\r\n```\r\ninput {\r\n  font-size: 16px;\r\n}\r\n```\r\n### ios下填充密码闪烁的问题\r\n- 数字键盘下面紧跟着type=password类型的密码输入框，浏览器记住密码，每次在数字键盘输入的时候，ios会自动尝试填充密码，会出险闪烁的问题，在数字键盘下加一个input，css控制不显示(height、width等，不能真正隐藏)则会避免这种状况。\r\n### ios下验证码填充两次的问题 \r\n- 通过设置验证码对应input的maxLength解决此问题。"},function(r,n,e){"use strict";e.r(n),n.default="## 移动端点击事件\r\n> 由于移动端的双击会缩放导致click判断延迟，移动端浏览器在派发点击事件的时候，通常会出现300ms左右的延迟.\r\n\r\n### fastclick\r\n> 在检测到touchend事件的时候，会通过DOM自定义事件立即触发模拟一个click事件，并把浏览器在300ms之后真正的click事件阻止掉.\r\n\r\n```\r\n// 安装\r\nnpm install fastclick -S\r\n\r\n// 引入\r\nimport FastClick from 'fastclick'\r\n\r\n// 使用\r\nFastClick.attach(document.body);\r\n```"},function(r,n,e){"use strict";e.r(n),n.default='## [移动端适配](https://mp.weixin.qq.com/s/ruvX0hLzExQgCVVApJyDSA)\r\n> 让页面布局在不同设备上所占据视口的空间比例是相同的。\r\n\r\n- 自适应：根据不同的设备屏幕大小来自动调整尺寸、大小。\r\n- 响应式：会随着屏幕的实时变动而自动调整，是一种更强的自适应。\r\n### 媒体查询@media\r\n> 使用CSS3中的媒体查询属性@media分别为不同屏幕尺寸的移动设备编写属于当前移动设备的css属性。\r\n\r\n```\r\n/* <375px */\r\n@media screen and (max-width:375px) { \r\n  .box {\r\n    width: 100%;\r\n  }\r\n}\r\n\r\n/* >=375px and <450px */\r\n@media screen and (min-width:375px) and (max-width:450px) {\r\n  .box {\r\n    width: 90%;\r\n  }\r\n}\r\n\r\n/* >=450px */\r\n@media screen and (min-width:450px) {\r\n  .box {\r\n    width: 80%;\r\n  }\r\n}\r\n```\r\n#### 媒体查询缺点\r\n- 页面上所有的元素都得在不同的@media中定义一遍不同的尺寸，代码冗余多。\r\n- 如果再多一种屏幕尺寸，就得多写一个@media查询块。\r\n- 媒体查询块的书写顺序也有要求，后面的会覆盖前面的，很容易出错。\r\n### rem适配方案(rem单位+动态html的font-size)\r\n- 针对不同的屏幕，设置html不同的font-size\r\n- 将原来设置的尺寸单位转化成rem单位\r\n- rem是一个相对于页面根元素html的font-size的一个单位。\r\n- 假如设置了根元素html的font-size为18px，那么1rem等于18px。\r\n- rem的大小会随着根元素html的font-size的改变而改变。rem方案就是利用了这一点，根据不同的屏幕尺寸，来设置根元素html的font-size的大小，以此来达到适配不同屏幕尺寸的目的。\r\n- JS封装根据屏幕尺寸自动改变html的font-size大小的函数。\r\n```\r\nconst initFontSize = () => {\r\n  const clientWidth = document.documentElement.clientWidth || document.body.clientWidth;\r\n  // 设计图尺寸是750px，这样 * 10之后1rem就等于10px。\r\n  const fontSize = (clientWidth / 750 * 10);\r\n  document.documentElement.style.fontSize = fontSize + "px";\r\n};\r\ninitFontSize();\r\n\r\nwindow.addEventListener("resize", initFontSize);\r\nexport default initFontSize;\r\n```\r\n- CSS通过媒体查询来设置不同尺寸屏幕下html的font-size。\r\n  1. 需要针对不同的屏幕编写大量的媒体查询\r\n  2. 如果动态改变尺寸，不会实时更新，只是一个个区间\r\n#### flexible + postcss-pxtorem方案\r\n- index.html添加viewport元数据标签，使页面宽度和设备宽度一致\r\n```\r\n<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">\r\n```\r\n- 安装插件\r\n```\r\nnpm install amfe-flexible --save\r\nnpm install postcss-pxtorem --save-dev\r\n```\r\n- 在main.js中引入amfe-flexible\r\n```\r\nimport \'amfe-flexible\';\r\n```\r\n- 在postcss.config.js文件中配置postcss-pxtorem\r\n```\r\nmodule.exports = {\r\n  "plugins": {\r\n    "postcss-pxtorem": {\r\n      rootValue: 75,  // 根据设计图尺寸写，设计图是750，就写75\r\n      propList: [\'*\'] // 需要被转换的属性\r\n    }\r\n  }\r\n}\r\n```\r\n### viewport适配方案\r\n- viewport方案即是使用vw、vh作为样式单位。\r\n- vw、vh将viewport分成了一百等份，1vw等于视口1%的宽度，1vh等于视口1%的高度。当我们的设计稿是750px时，1vw就等于7.5px。\r\n#### viewport + postcss-px-to-viewport方案\r\n- index.html添加viewport元数据标签，使页面宽度和设备宽度一致\r\n```\r\n<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">\r\n```\r\n- 安装插件\r\n```\r\nnpm install postcss-px-to-viewport --save-dev\r\n```\r\n- 在postcss.config.js文件中配置postcss-px-to-viewport\r\n```\r\nmodule.exports = {\r\n  "plugins": {\r\n    "postcss-px-to-viewport": {\r\n      viewportWidth: 750,    // 设计稿的宽度\r\n      unitPrecision: 5,      // 转换后的位数，即小数点位数\r\n      viewportUnit: \'vw\',    // 转换成的视窗单位\r\n      propList: [\'*\'],       // 要进行转换的属性，如果某个属性不进行转换，只需在其前加个“!”即可\r\n      selectorBlackList: [], // 不进行转换的选择器\r\n      minPixelValue: 1,      // 小于或等于1px则不进行转换\r\n      mediaQuery: true,      // 是否在媒体查询的css代码中也进行转换，默认false\r\n    },\r\n  },\r\n};\r\n```\r\n- 标注不需要转换的属性\r\n  1. px-to-viewport-ignore-next 下一行不进行转换。\r\n  2. px-to-viewport-ignore 当前行不进行转换\r\n```\r\n/* 转化前 */\r\n.box {\r\n  /* px-to-viewport-ignore-next */\r\n  width: 100px;\r\n  padding: 20px;\r\n  height: 100px; /* px-to-viewport-ignore */\r\n}\r\n\r\n/* 转化后 */\r\n.box {\r\n  width: 100px; \r\n  padding: 2.6667vw;\r\n  height: 100px;\r\n}\r\n```\r\n### viewport适配方案相较于rem适配方案的优势\r\n1. 不需要去计算html的font-size。\r\n2. 不需要给html设置font-size，不会因为设置html的font-size大小而必须给body再设置一个font-size防止继承。\r\n3. 因为不依赖font-size的尺寸，所以不用担心某些原因html的font-size尺寸被纂改导致页面尺寸混乱。\r\n4. vw相对于rem更加语义化，1vw刚好是1/100的viewport的大小。\r\n5. rem事实上作为一种过渡的方案，它利用的也是vw的思想\r\n### 百分比单位(不推荐)\r\n- 因为不同属性的百分比值，相对的可能是不同的参照物，所以百分比往往很难统一。'},function(r,n,e){"use strict";e.r(n),n.default='## 视口viewport\r\n- 视口是浏览器或app中webview显示页面的区域。\r\n- 通常情况下PC端的视口指的是浏览器窗口区域。\r\n- 移动端有些复杂，有三个视口：\r\n  1. layout viewport：布局视口\r\n  2. visual viewport：视觉视口\r\n  3. ideal viewport：理想视口\r\n### 布局视口\r\n- 由浏览器提出的一种虚拟的布局视口，用来解决页面在手机上显示的问题。\r\n- 这种视口可以通过`<meta>`标签设置viewport来改变。移动设备上的浏览器都会把自己默认的viewport设为980px或1024px(也可能是其它值，这个是由设备自己决定的)，但带来的后果就是浏览器会出现横向滚动条，因为浏览器可视区域的宽度是比这个默认的viewport的宽度要小的。\r\n- 可以通过document.documentElement.clientWidth来获取布局视口大小。\r\n### 视觉视口\r\n- 指的是浏览器的可视区域，也就是我们在移动端设备上能够看到的区域。\r\n- 默认与当前浏览器窗口大小相等，当用户对浏览器进行缩放时，不会改变布局视口的大小，但会改变视觉窗口的大小。\r\n- 可以通过window.innerWidth来获取视觉视口大小。\r\n### 理想视口\r\n- 目的是解决在布局视口下页面元素过小的问题，显示在理想视口中的页面具有最理想的宽度，用户无需进行缩放。\r\n- 理想视口即页面绘制区域可以完美适配设备宽度的视口大小，不需要出现滚动条即可正常查看网站的所有内容，且文字图片清晰。\r\n- 当页面缩放比例为100%时，理想视口 = 视觉视口。\r\n- 可以通过screen.width来获取理想视口大小。\r\n### meta viewport\r\n> 对于移动端页面，可以采用`<meta>`标签来配置视口大小和缩放等。viewport只对移动端浏览器有效，对PC端浏览器是无效的。\r\n\r\n```\r\n<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />\r\n```\r\n- width\r\n  1. 该属性被用来控制视窗的宽度，可以将width设置为320这样确切的像素数，也可以设为device-width这样的关键字，表示设备的实际宽度。\r\n  2. 通常情况下为了自适应布局，普遍的做法是将width设置为device-width。\r\n- height\r\n  1. 该属性被用来控制视窗的高度，可以将height设置为640这样确切的像素数，也可以设为device-height这样的关键字，表示设备的实际高度。\r\n  2. 通常情况下不会设置视窗的高度，这样内容超出的话采用滚动方式浏览。\r\n- initial-scale\r\n  1. 该属性用于指定页面的初始缩放比例，可以配置0.0～10的数字。\r\n  2. initial-scale=1表示不进行缩放，视窗刚好等于理想视窗，当大于1时表示将视窗进行放大，小于1时表示缩小。\r\n  3. 这里只表示初始视窗缩放值，用户也可以自己进行缩放，例如双指拖动手势缩放或者双击手势放大。\r\n  4. 安卓设备上的initial-scale无默认值，一定要设置，这个属性才会起作用。\r\n  5. 在iphone和ipad上，无论你给viewport设的宽的是多少，如果没有指定默认的缩放值，则iphone和ipad会自动计算这个缩放值，以达到当前页面不会出现横向滚动条(或者说viewport的宽度就是屏幕的宽度)的目的。\r\n- maximum-scale\r\n  1. 该属性表示用户能够手动放大的最大比例，可以配置0.0～10的数字。\r\n- minimum-scale\r\n  1. 该属性表示用户能够手动缩小的最小比例。\r\n  2. 通常情况下不会定义该属性的值，页面太小将难以浏览。\r\n- user-scalable\r\n  1. 该属性表示是否允许用户手动进行缩放，可配置no或者yes。\r\n  2. 当配置成no时，用户将不能通过手势操作的方式对页面进行缩放。\r\n### 适配与缩放\r\n- 为了让移动端页面获得更好的显示效果，我们必须让布局视口、视觉视口都尽可能等于理想视口。\r\n- 所以通常情况下会设置width=device-width，相当于让布局视口等于理想视口。\r\n- 设置initial-scale=1.0，相当于让视觉视口等于理想视口。\r\n- width可以决定布局视口的宽度，但它并不是布局视口的唯一决定性因素，设置initial-scale也有可能影响到布局视口，因为布局视口宽度取的是width和视觉视口宽度的最大值。\r\n  1. 若手机的理想视口宽度为400px，设置width=device-width，initial-scale=2，此时视觉视口宽度 = 理想视口宽度 / initial-scale即200px，布局视口取两者最大值即device-width 400px。\r\n  2. 若设置width=device-width，initial-scale=0.5，此时视觉视口宽度 = 理想视口宽度 / initial-scale即800px，布局视口取两者最大值即800px。\r\n### `<meta name="viewport">`在移动端的作用\r\n- 没有`<meta name="viewport">`移动端渲染的页面会进行缩小，缩小到页面宽度正好与手机屏幕的宽度一样。为了让用户把页面看全，手机自动把页面缩小至屏幕内。\r\n- 有`<meta name="viewport">`移动端渲染的页面不会缩小，页面内容过大时会出现滚动条。\r\n'},function(r,n,e){"use strict";e.r(n),n.default="## [软键盘弹起](https://setcina.github.io/2020/01/20/WebView%E4%B8%8A%E8%BD%AF%E9%94%AE%E7%9B%98%E7%9A%84%E5%85%BC%E5%AE%B9%E6%96%B9%E6%A1%88/)\r\n### ios软键盘弹起表现\r\n> 在ios上，输入框获取焦点键盘弹起，页面(webview)并没有被压缩，或者说高度(height)没有改变，只是页面(webview)整体往上滚了，且最大滚动高度(scrollTop)为软键盘高度。\r\n\r\n### Android软键盘弹起表现\r\n> 在Android上，输入框获取焦点键盘弹起，页面(webview)高度会发生改变，一般来说高度为可视区高度(原高度减去软键盘高度)，除了因为页面内容被撑开可以产生滚动，webview本身不能滚动。\r\n\r\n### ios软键盘收起表现\r\n> 触发软键盘上的“收起”按钮键盘或者输入框以外的页面区域时，输入框失去焦点，软键盘收起。\r\n\r\n### Android软键盘收起表现\r\n> 触发输入框以外的区域时，输入框失去焦点，软键盘收起。触发键盘上的收起按钮键盘时，输入框不会失去焦点，软键盘会收起。\r\n\r\n### 监听软键盘弹起和收起\r\n- 在ios上，监听输入框的focus事件来获知软键盘弹起，监听输入框的blur事件获知软键盘收起。\r\n- 在Android上，监听webview高度变化，高度变小获知软键盘弹起，否则软键盘收起。\r\n```\r\n// 判断设备类型\r\nvar judgeDeviceType = function () {\r\n  var ua = window.navigator.userAgent.toLocaleLowerCase();\r\n  var isIOS = /iphone|ipad|ipod/.test(ua);\r\n  var isAndroid = /android/.test(ua);\r\n\r\n  return {\r\n    isIOS: isIOS,\r\n    isAndroid: isAndroid\r\n  }\r\n}()\r\n\r\n// 监听输入框的软键盘弹起和收起事件\r\nfunction listenKeybord($input) {\r\n  if (judgeDeviceType.isIOS) {\r\n    // IOS 键盘弹起：IOS 和 Android 输入框获取焦点键盘弹起\r\n    $input.addEventListener('focus', function () {\r\n      console.log('IOS 键盘弹起啦！');\r\n      // IOS 键盘弹起后操作\r\n    }, false)\r\n\r\n    // IOS 键盘收起：IOS 点击输入框以外区域或点击收起按钮，输入框都会失去焦点，键盘会收起，\r\n    $input.addEventListener('blur', () => {\r\n      console.log('IOS 键盘收起啦！');\r\n      // IOS 键盘收起后操作\r\n    })\r\n  }\r\n\r\n  // Andriod 键盘收起：Andriod 键盘弹起或收起页面高度会发生变化，以此为依据获知键盘收起\r\n  if (judgeDeviceType.isAndroid) {\r\n    var originHeight = document.documentElement.clientHeight || document.body.clientHeight;\r\n\r\n    window.addEventListener('resize', function () {\r\n      var resizeHeight = document.documentElement.clientHeight || document.body.clientHeight;\r\n      if (originHeight < resizeHeight) {\r\n        console.log('Android 键盘收起啦！');\r\n        // Android 键盘收起后操作\r\n      } else {\r\n        console.log('Android 键盘弹起啦！');\r\n        // Android 键盘弹起后操作\r\n      }\r\n\r\n      originHeight = resizeHeight;\r\n    }, false)\r\n  }\r\n}\r\n\r\nvar $inputs = document.querySelectorAll('.input');\r\n\r\nfor (var i = 0; i < $inputs.length; i++) {\r\n  listenKeybord($inputs[i]);\r\n}\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## [二叉搜索树中的搜索](https://leetcode.cn/problems/search-in-a-binary-search-tree/)\r\n> 给定二叉搜索树（左叶子节点比父节点小，右叶子节点比父节点大）的根节点 root 和一个整数值 val。你需要在二叉搜索树中找到节点值等于 val 的节点。 返回以该节点为根的子树。如果节点不存在，则返回 null。\r\n\r\n- 从根节点开始遍历，值相同则返回。\r\n- 如果节点的值大于要比较的值，则遍历当前节点的左子节点(左子节点比父节点的值小)。\r\n- 否则遍历当前节点的右子节点(右子节点比父节点的值大)。\r\n```\r\nvar searchBST = (root, val) => {\r\n  if (root === null) {\r\n    return null;\r\n  }\r\n  if (root.val === val) {\r\n    return root;\r\n  }\r\n  if (root.val > val) {\r\n    return searchBST(root.left, val);\r\n  } else if (root.val < val) {\r\n    return searchBST(root.right, val);\r\n  }\r\n};\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## [二叉树中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/)\r\n> 给定一个二叉树的根节点root ，返回它的中序遍历（左、中、右）。\r\n\r\n![二叉树中序遍历](../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/img/二叉树中序遍历.png)\r\n- 先判断是否存在左分支，存在则对左分支进行递归。\r\n- 左分支不存在时，将此时的值push进数组中。\r\n- 再判断是否存在右分支，存在则对右分支进行递归。\r\n```\r\nvar inorderTraversal = function(root, res = []) {\r\n  if (!root) return [];\r\n  if (root.left) {\r\n    inorderTraversal(root.left, res);\r\n  }\r\n  res.push(root.val);\r\n  if (root.right) {\r\n    inorderTraversal(root.right, res);\r\n  }\r\n  return res;\r\n};\r\n```\r\n- 新建一个空栈stack和一个ponit变量指向根节点。\r\n- 当栈stack不为空或point变量有值时进行遍历。\r\n  1. 当point存在时遍历point，栈stack存储当前节点，point赋值为当前节点的左节点。(栈内推入当前节点的所有左分支节点)\r\n  2. stack出栈，存储出栈节点的值，然后将point指向出栈节点的右节点。\r\n- 按照上述步骤遍历指导遍历结束。\r\n```\r\nconst inorderTraversal = (root) => {\r\n  if (!root) return [];\r\n  // 新建一个栈\r\n  const stack = [];\r\n  let point = root;\r\n  const res = [];\r\n  while (stack.length || point) {\r\n    // 栈内推入左分支节点\r\n    while (point) {\r\n      stack.push(point)\r\n      point = point.left\r\n    }\r\n    const n = stack.pop();\r\n    res.push(n.val)\r\n    point = n.right;\r\n  }\r\n  return res;\r\n}\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## [二叉树先序遍历](https://leetcode.cn/problems/binary-tree-preorder-traversal/)\r\n> 给定一个二叉树的根节点root ，返回它的先序遍历（中、左、右）。\r\n\r\n![二叉树先序遍历](../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/img/二叉树先序遍历.png)\r\n- 将当前节点的值push进数组中。\r\n- 判断是否存在左分支，存在则对左分支进行递归。\r\n- 再判断是否存在右分支，存在则对右分支进行递归。\r\n```\r\nvar preorderTraversal = function(root, res = []) {\r\n  if (!root) return [];\r\n  res.push(root.val);\r\n  if (root.left) {\r\n    preorderTraversal(root.left, res);\r\n  }\r\n  if (root.right) {\r\n    preorderTraversal(root.right, res);\r\n  }\r\n  return res;\r\n};\r\n```\r\n- 新建一个栈stack默认为根节点，遍历栈。\r\n- 将当前节点出栈并将当前节点的值push进数组中。\r\n- 判断当前节点是否存在右分支，存在则推入栈中。\r\n- 再判断当前节点是否存在左分支，存在则推入栈中(先序遍历先遍历左分支后遍历右分支，所以左分支在右分之后面push)。\r\n```\r\nvar preorderTraversal = function(root) {\r\n  if (!root) return [];\r\n  const res = []; // 存储最终结果\r\n  // 新建一个栈\r\n  const stack = [root];\r\n  while (stack.length > 0) {\r\n    const currentNode = stack.pop();\r\n    res.push(currentNode.val);\r\n    // 先遍历左分支后遍历右分支，所以左分支在右分之后面push\r\n    if (currentNode.right) {\r\n      stack.push(currentNode.right);\r\n    }\r\n    if (currentNode.left) {\r\n      stack.push(currentNode.left);\r\n    } \r\n  }\r\n  return res;\r\n};\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## [二叉树后序遍历](https://leetcode.cn/problems/binary-tree-postorder-traversal/)\r\n> 给定一个二叉树的根节点root ，返回它的前序遍历（左、右、中）。\r\n\r\n![二叉树后序遍历](../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/img/二叉树后序遍历.png)\r\n- 先判断是否存在左分支，存在则对左分支进行递归。\r\n- 再判断是否存在右分支，存在则对右分支进行递归。\r\n- 将当前节点的值push进数组中。\r\n```\r\nvar postorderTraversal = function(root, res = []) {\r\n  if (!root) return [];\r\n  if (root.left) {\r\n    postorderTraversal(root.left, res);\r\n  }\r\n  if (root.right) {\r\n    postorderTraversal(root.right, res);\r\n  }\r\n  res.push(root.val);\r\n  return res;\r\n};\r\n```\r\n- 新建一个栈stack默认为根节点，遍历栈。\r\n- 将当前节点出栈并将当前节点的值push进数组中。\r\n- 判断当前节点是否存在左分支，存在则推入栈中。\r\n- 再判断当前节点是否存在右分支，存在则推入栈中。\r\n- 上述的遍历最终push数组中的顺序是中、右、左，所以将数组reverse翻转后输出。\r\n```\r\nvar postorderTraversal = function(root) {\r\n  if (!root) return [];\r\n  const res = []; // 存储最终结果\r\n  // 新建一个栈\r\n  const stack = [root];\r\n  while (stack.length > 0) {\r\n    const currentNode = stack.pop();\r\n    res.push(currentNode.val);\r\n    if (currentNode.left) {\r\n      stack.push(currentNode.left);\r\n    }\r\n    if (currentNode.right) {\r\n      stack.push(currentNode.right);\r\n    }\r\n  }\r\n  return res.reverse();\r\n};\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## 二叉树层序遍历\r\n> 给定一个二叉树的根节点root ，返回它的每一层的节点。\r\n\r\n![二叉树层序遍历](../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/img/二叉树层序遍历.png)\r\n```\r\n// 返回 [[1], [2,3], [4,5]]\r\n\r\n// 时间复杂度O(n) n为树的节点数\r\n// 空间复杂度O(n) \r\nvar levelOrder = function (root) {\r\n  if (!root) return []\r\n   \r\n  // 广度优先遍历\r\n  const q = [root];\r\n  const res = [];\r\n  while (q.length) {\r\n    let len = q.length\r\n    res.push([])\r\n    // 循环每层的节点数量次\r\n    while (len--) {\r\n      const n = q.shift();\r\n      res[res.length - 1].push(n.val)\r\n      if (n.left) q.push(n.left);\r\n      if (n.right) q.push(n.right);\r\n    }\r\n  }\r\n  return res\r\n};\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## [二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)\r\n> 给定一个二叉树，找出其最大深度。最大深度是从根节点到最近叶子节点的最长路径上的节点数量。\r\n\r\n- 当根节点root不存在时，返回0。\r\n- 递归向下计算左右节点的值，返回大的值。\r\n```\r\nvar maxDepth = function(root) {\r\n  if (!root) {\r\n    return 0;\r\n  } else {\r\n    const left = maxDepth(root.left);\r\n    const right = maxDepth(root.right);\r\n    return Math.max(left, right) + 1;\r\n  }\r\n};\r\n```\r\n- 创建变量res用于存储最大深度的值。\r\n- 创建dfs方法(接受当前树节点以及目前的最大深度值两个参数)用于遍历树节点以及更行res的值。\r\n  1. 没有当前树节点直接return\r\n  2. 当前树节点没有叶子节点就更新深度值的变量res\r\n  3. 调用dfs方法传入当前树节点的左叶子节点和当前最大深度值\r\n  4. 调用dfs方法传入当前树节点的右叶子节点和当前最大深度值\r\n\r\n```\r\nvar maxDepth = function (root) {\r\n  let res = 0;\r\n  const dfs = (n, l) => {\r\n    if (!n) return;\r\n    if (!n.left && !n.right) {\r\n     // 没有叶子节点就把深度数量更新\r\n      res = Math.max(res, l);\r\n    }\r\n    dfs(n.left, l + 1)\r\n    dfs(n.right, l + 1)\r\n  }\r\n  dfs(root, 1);\r\n  return res;\r\n}\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## [二叉树的最小深度](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)\r\n> 给定一个二叉树，找出其最小深度。最小深度是从根节点到最近叶子节点的最短路径上的节点数量。\r\n\r\n- 当根节点root不存在时，返回0。\r\n- 当左右节点都不存在时，返回1。\r\n- 当右叶节点不存在时，则此时最短为左叶节点，递归向下计算。\r\n- 当左叶节点不存在时，则此时最短为右叶节点，递归向下计算。\r\n- 当左右节点都存在时，递归向下计算左右节点的值，返回小的值。\r\n```\r\nvar minDepth = (root) => {\r\n  if (!root) {\r\n    return 0;\r\n  }\r\n  if (root.right === null && root.left === null) {\r\n    return 1;\r\n  }\r\n  if (root.left && !root.right) {\r\n    return 1 + minDepth(root.left);\r\n  }\r\n  if (!root.left && root.right) {\r\n    return 1 + minDepth(root.right);\r\n  }\r\n  return 1 + Math.min(minDepth(root.left), minDepth(root.right));\r\n}\r\n```\r\n- 当根节点root不存在时，返回0。\r\n- 创建二维数组，第一项存储`[当前节点，当前节点的深度]`。\r\n- 循环此二维数组，使用shift方法获取数组的第一项，获取当前循环的节点和当前循环节点的深度。\r\n- 如果当前循环的节点没有叶子节点直接返回当前循环节点的深度为最小深度。\r\n- 如果当前循环的节点有左叶子节点则向数组中存储`[当前节点的左叶子节点，当前节点的深度 + 1]`。\r\n- 如果当前循环的节点有右叶子节点则向数组中存储`[当前节点的右叶子节点，当前节点的深度 + 1]`。\r\n```\r\nvar minDepth = function (root) {\r\n  if (!root) {\r\n    return 0;\r\n  }\r\n  // 存储根节点和根节点的深度1\r\n  const q = [[root, 1]];\r\n  while (q.length) {\r\n    // 取出当前节点\r\n    const [n, l] = q.shift();\r\n    // 如果是叶子节点直接返回深度就可\r\n    if (!n.left && !n.right) {\r\n      return l;\r\n    } \r\n    if (n.left) {\r\n      q.push([n.left, l + 1]);\r\n    }\r\n    if (n.right) {\r\n      q.push([n.right, l + 1]);\r\n    }\r\n  }\r\n}\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## [二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree)\r\n> 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。\r\n\r\n- 遍历整个二叉树，使用allParents(Map形式数据)存储所有的叶子节点与父级的对应关系。\r\n- 找到p节点所有的父级及p节点并存储，使用someOneParents(Set形式数据)存储p节点及其所有的父级节点。\r\n- 向上查找另一个子节点q的所有父级，如果也是p节点的父级则表示是两个子节点的公共父级。\r\n```\r\nvar lowestCommonAncestor = (root, p, q) => {\r\n  const someOneParents = new Set(); // 存储一个子节点的父级\r\n  const allParents = new Map(); // 存储叶子节点的父级\r\n  // 存储所有叶子节点的父级\r\n  const dfs = (root) => {\r\n    if (root.left != null) {\r\n      allParents.set(root.left.val, root);\r\n      dfs(root.left);\r\n    }\r\n    if (root.right != null) {\r\n      allParents.set(root.right.val, root);\r\n      dfs(root.right);\r\n    }\r\n  }\r\n  dfs(root);\r\n\r\n  // 找到所有p的父级及p并存储\r\n  while (p != null) {\r\n    someOneParents.add(p.val);\r\n    p = allParents.get(p.val);\r\n  }\r\n  \r\n  // 向上查找q的父级，如果也在p父级中则表示是两者公共的父级\r\n  while (q != null) {\r\n    if (someOneParents.has(q.val)) {\r\n      return q;\r\n    }\r\n    q = allParents.get(q.val);\r\n  }\r\n  return null;\r\n};\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## [对称二叉树](https://leetcode.cn/problems/symmetric-tree)\r\n> 给你一个二叉树的根节点 root ， 检查它是否轴对称。\r\n\r\n- 递归判断左右树节点是否相同\r\n- 因为是对称二叉树，判断左右树时需要注意\r\n  1. 使用左侧树的左节点比较右侧树的右节点\r\n  2. 使用左侧树的右节点比较右侧树的左节点\r\n```\r\nvar isSymmetric = function (root) {\r\n  if (!root) {\r\n    return true;\r\n  }\r\n  const isMirror = (l, r) => {\r\n    if (!l && !r) {\r\n      return true;\r\n    }\r\n    if (\r\n      l && r \r\n      && l.val === r.val\r\n      && isMirror(l.left, r.right)\r\n      && isMirror(l.right, r.left)\r\n    ) {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n  return isMirror(root.left, root.right);\r\n};\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## [相同的树](https://leetcode.cn/problems/same-tree)\r\n> 给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。\r\n\r\n- 递归比较两棵树对应的各个节点。\r\n```\r\nvar isSameTree = function (p, q) {\r\n  if (!p && !q) {\r\n    return true;\r\n  }\r\n  if (\r\n    p && q\r\n    && p.val === q.val\r\n    && isSameTree(p.left, q.left)\r\n    && isSameTree(p.right, q.right)\r\n  ) {\r\n    return true;\r\n  }\r\n  return false;\r\n};\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## [翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/)\r\n> 给定一棵二叉树的根节点root ，翻转这棵二叉树，并返回其根节点。\r\n\r\n- 递归处理每个树节点\r\n  1. 当前树节点的val不变\r\n  2. 当前树节点的左侧节点修改成当前树节点的右侧节点\r\n  3. 当前树节点的右侧节点修改成当前树节点的左侧节点\r\n```\r\nvar invertTree = function (root) {\r\n  if (!root) return null;\r\n  return {\r\n    val: root.val,\r\n    left: invertTree(root.right),\r\n    right: invertTree(root.left)\r\n  }\r\n};\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## [二进制链表转整数](https://leetcode.cn/problems/convert-binary-number-in-a-linked-list-to-integer)\r\n> 链表中每个结点的值不是 0 就是 1。此链表是一个整数数字的二进制表示形式。请返回该链表所表示数字的十进制值 。\r\n\r\n- 循环整个链表，将链表的每一项值unshift（因为二进制转十进制从右往左计算所以使用unshift）到数组arr中。\r\n- 初始十进制数decimalNum为0，循环数组arr，当前项为1时， decimalNum += Math.pow(2, index)。\r\n```\r\nvar getDecimalValue = function(head) {\r\n  let arr = [], point = head;\r\n  // 循环链表获取链表总长度\r\n  while(point) {\r\n    arr.unshift(point.val);\r\n    point = point.next;\r\n  }\r\n  let decimalNum = 0;\r\n  arr.forEach((item, index) => {\r\n    if (item === 1) {\r\n      decimalNum += Math.pow(2, index);\r\n    }\r\n  })\r\n  return decimalNum;\r\n};\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## [从尾到头打印链表](https://leetcode.cn/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/)\r\n> 输入一个链表的头节点，从尾到头返回每个节点的值（用数组返回）。\r\n\r\n- 循环链表，将链表每一个节点的值unshift到数组中(因为要求从尾到头返回)，循环结束返回数组。\r\n```\r\nvar reversePrint = function(head) {\r\n  let arr = [], point = head;\r\n  // 循环链表获取每一个节点的值\r\n  while(point) {\r\n    arr.unshift(point.val);\r\n    point = point.next;\r\n  }\r\n  return arr;\r\n};\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## [删除中间节点](https://leetcode.cn/problems/delete-middle-node-lcci/)\r\n> 已知链表的某一个中间节点，请实现一种算法，将该节点从链表中删除。例如，传入节点 c（位于单向链表 a->b->c->d->e->f 中），将其删除后，剩余链表为 a->b->d->e->f。\r\n\r\n- 当前节点的val等于当前节点下一个节点的val。\r\n- 当前节点的next等于当前节点的下一个节点的next。\r\n- 将当前节点修改为下一个节点从而实现变相的删除当前节点。\r\n```\r\nvar deleteNode = function(node) {\r\n  node.val = node.next.val\r\n  node.next = node.next.next\r\n};\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## [删除排序链表中的重复元素](https://leetcode.cn/problems/remove-duplicates-from-sorted-list/description/)\r\n> 给定一个已排序的链表的头 head，删除所有重复的元素，使每个元素只出现一次 。返回 已排序的链表。\r\n\r\n- 创建变量currentNode初始值为链表的头部节点。\r\n- 当currentNode和currentNode.next都有值时循环链表。\r\n- 判断当前节点和当前节点的next节点值是否相同\r\n  1. 相同则将当前的节点的next指向当前节点的next.next节点。\r\n  2. 不相同则将当前节点的next节点复制给currentNode变量继续循环。\r\n- 直到循环结束\r\n```\r\nvar deleteDuplicates = function(head) {\r\n  let currentNode = head;\r\n  while(currentNode && currentNode.next) {\r\n    const nextNode = currentNode.next;\r\n    if (currentNode.val === nextNode.val) {\r\n      currentNode.next = nextNode.next;\r\n    } else {\r\n      currentNode = nextNode;\r\n    }\r\n  }\r\n  return head;\r\n};\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## [反转链表](https://leetcode.cn/problems/reverse-linked-list/)\r\n> 给定单链表的头节点 head，反转链表并返回反转后的链表。\r\n\r\n- 新建两个指针current指向头节点，prev初始为null。\r\n- 遍历链表(数据后移实现所有指针的变化)\r\n  - 获取当前current.next的节点cnext。\r\n  - current指针的.next指向prev指针对应的节点。\r\n  - prev指针指向current指针指向的节点。\r\n  - current指向cnext。\r\n```\r\nvar reverseList = function(head) {\r\n  let current = head;\r\n  let prev = null;\r\n  while (current) {\r\n    const cnext = current.next;\r\n    // 当前的next指向前一个\r\n    current.next = prev;\r\n    // 数据后移\r\n    prev = current;\r\n    current = cnext;\r\n  }\r\n  return prev;\r\n};\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## [合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/)\r\n> 将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。\r\n\r\n- 新建一个链表最为最终需要返回的链表。\r\n- 新建三个指针分别指向新建的链表和传入的两个升序链表。\r\n- 遍历传入的两个升序链表，判断对应的指针指向节点的值，将新建的链表的next指向节点值较小的节点，同时将节点值较小的链表对应的指针和新链表的指针向后移动一位。以此逻辑循环遍历，直到传入的两个链表对应指针指向的节点有其一为空时终止循环。\r\n- 如果传入的某个链表还有值，就把后面的值全部接入新链表。\r\n```\r\nvar mergeTwoLists = function(list1, list2) {\r\n  // 新建一个新链表 作为返回值\r\n  const res = {\r\n    val: 0,\r\n    next: null\r\n  }\r\n  // 指向新链表的指针\r\n  let p = res;\r\n  // 建立两个指针分别指向两个链表\r\n  let p1 = list1;\r\n  let p2 = list2;\r\n  // 遍历两个链表\r\n  while (p1 && p2) {\r\n    // 如果链表1 小于 链表2的值 就接入链表1的值\r\n    if (p1.val < p2.val) {\r\n      p.next = p1;\r\n      // 需要往后移动\r\n      p1 = p1.next;\r\n    } else {\r\n      // 否则接入链表2的值\r\n      p.next = p2;\r\n      // 需要往后移动\r\n      p2 = p2.next;\r\n    }\r\n    // p永远要往后移动一位\r\n    p = p.next;\r\n  }\r\n  // 如果链表1或者链表2还有值，就把后面的值全部接入新链表\r\n  if (p1) {\r\n    p.next = p1;\r\n  }\r\n  if (p2) {\r\n    p.next = p2;\r\n  }\r\n  return res.next;\r\n};\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## [回文链表](https://leetcode-cn.com/problems/palindrome-linked-list/)\r\n> 给定一个单链表的头节点head，判断该链表是否为回文链表。如果是返回true，否则返回false。\r\n\r\n- 创建两个字符串。\r\n- 一个向头部插入，一个向尾部插入。\r\n- 最后两个字符串一致则表示是回文链表。\r\n```\r\nvar isPalindrome = head => {\r\n  let preStr = '', afterStr = '';\r\n  while(head) {\r\n    preStr = preStr + head.val;\r\n    afterStr = head.val + afterStr;\r\n    head = head.next;\r\n  }\r\n  return preStr === afterStr;\r\n}\r\n```\r\n- 利用链表的后续遍历，使用函数调用栈作为后序遍历栈，来判断是否回文链表。\r\n```\r\nconst isPalindrome = head => {\r\n  let left = head;\r\n  function traverse(right) {\r\n    if (right == null) return true;\r\n    let res = traverse(right.next);\r\n    res = res && (right.val === left.val);\r\n    left = left.next;\r\n    return res;\r\n  }\r\n  return traverse(head);\r\n};\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## [环型链表](https://leetcode.cn/problems/linked-list-cycle/)\r\n> 判断链表中是否有环。\r\n\r\n- 首先创建两个指针slowPoint、fastPoint，同时指向这个链表的头节点，然后开始循环。\r\n- 每一次循环指针slowPoint向后移动一个节点，指针fastPoint每次向后移动两个节点。\r\n- 比较两个指针指向的节点是否相同。如果相同，则判断出链表有环，如果不同，则继续下一次循环。\r\n- 当slowPoint、fastPoint其中一个对应节点没有值时终止循环。\r\n```\r\nvar hasCycle = function(head) {\r\n  if (head && head.next) {\r\n    let slowPoint = head;\r\n    let fastPoint = head;\r\n    while (slowPoint && fastPoint) {\r\n      slowPoint = slowPoint.next;\r\n      fastPoint = fastPoint.next && fastPoint.next.next;\r\n      if (slowPoint === fastPoint) {\r\n        return true;\r\n      }\r\n    }\r\n  }\r\n  return false;\r\n};\r\n```\r\n### [为什么快慢指针会相遇，且快指针的步长选择2](https://www.pianshen.com/article/6467918110/)\r\n> 对于链表有环的情况，当快指针刚刚绕到慢指针后面时，快指针离慢指针有n步。那么，对于接下来的每一次“快指针往前走两步、慢指针往前走一步”，快指针和慢指针之间的距离由n步变成n-1步、由n-1步变成n-2步、……、由3步变成2步、由2步变成1步、由1步变成0步。所以对于有环的情况，快慢指针一定会相遇。对于链表没有环的情况，快指针最终指向NULL指针。"},function(r,n,e){"use strict";e.r(n),n.default="## [相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/)\r\n> 给出两个单链表的头节点headA和headB，找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null。\r\n\r\n- 分别遍历两个链表，获取两个链表的长度。\r\n- 如果两个链表最后的节点相同表示是相交链表。\r\n  - 根据两个链表的长度获取两个链表的长度差值。\r\n  - 先让较长的链表遍历长度的差值(对齐开始比较的节点)。\r\n  - 然后两个链表同时遍历，判断是否相等，如果相等，就是第一个相交的结点。\r\n```\r\nvar getIntersectionNode = (head1, head2) => {\r\n  if (head1 && head2) {\r\n    // 计算链表的长度\r\n    let len1 = 0, long = head1;\r\n    let len2 = 0, short = head2;\r\n    while(long.next) {\r\n      len1++;\r\n      long = long.next;\r\n    }\r\n\r\n    while(short.next) {\r\n      len2++;\r\n      short = short.next;\r\n    }\r\n\r\n    // 两条链表的终点一样表示相交\r\n    if (long === short) {\r\n      let len = 0;\r\n      if (len1 > len2) {\r\n        len = len1 - len2;\r\n        long = head1;\r\n        short = head2;\r\n      } else {\r\n        len = len2 - len1;\r\n        long = head2;\r\n        short = head1;\r\n      }\r\n      \r\n      // 对齐两个链开始比较的节点\r\n      while(len > 0) {\r\n        len--;\r\n        long = long.next;\r\n      }\r\n\r\n      while(long && short && long !== short) {\r\n        long = long.next;\r\n        short = short.next;\r\n      }\r\n      return long;\r\n    }\r\n  }\r\n  return null;\r\n}\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## [移除链表元素](https://leetcode.cn/problems/remove-linked-list-elements)\r\n> 给定一个链表的头节点 head 和一个整数 val，删除链表中所有满足 Node.val == val 的节点，并返回新的头节点。\r\n\r\n- 新建新的链表newHead、新链表的指针newHeadPoint、传入链表的指针point。\r\n- 遍历传入的链表，当当前遍历节点的val与传入的val相同时\r\n  - 如果newHead为空则将当前节点的val赋值给newHead的val，newHeadPoint指针指向newHead。\r\n  - 如果newHead不为空时将当前节点的val赋值给newHeadPoint.next节点的val，同时newHeadPoint指针向后移动。\r\n```\r\nvar removeElements = function(head, val) {\r\n  let newHead = null; // 新链表\r\n  let newHeadPoint = null; // 新链表的指针\r\n  let point = head;\r\n  while(point) {\r\n    // 遍历传入的链表，如果val相同\r\n    if (point.val !== val) {\r\n      if (newHead) {\r\n        // 初始新链表的next节点\r\n        newHeadPoint.next = {\r\n          val: point.val,\r\n          next: null,\r\n        };\r\n        newHeadPoint = newHeadPoint.next;\r\n      } else {\r\n        // 初始新链表\r\n        newHead = {\r\n          val: point.val,\r\n          next: null,\r\n        };\r\n        newHeadPoint = newHead;\r\n      }\r\n    }\r\n    point = point.next;\r\n  }\r\n  return newHead;\r\n};\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## [移除重复节点](https://leetcode.cn/problems/remove-duplicate-node-lcci/)\r\n> 移除未排序链表中的重复节点。保留最开始出现的节点。\r\n\r\n- 新建新的链表newHead、新链表的指针newHeadPoint、传入链表的指针point、uniqueMap存储链表节点值是否出现过。\r\n- 遍历传入的链表，如果值没有在uniqueMap出现过则作为链表的一个节点，uniqueMap存储当前值。\r\n  - 如果newHead为空则将当前节点的val赋值给newHead的val，newHeadPoint指针指向newHead。\r\n  - 如果newHead不为空时将当前节点的val赋值给newHeadPoint.next节点的val，同时newHeadPoint指针向后移动。\r\n```\r\nvar removeDuplicateNodes = function(head) {\r\n  const uniqueMap = new Map(); // 新建Map存储链表节点值是否出现过\r\n  let newHead = null; // 新链表\r\n  let newHeadPoint = null; // 新链表的指针\r\n  let point = head; // 遍历链表的指针\r\n  while(point) {\r\n    // 如果值没有出现过作为链表的一个节点\r\n    if (!uniqueMap.has(point.val)) {\r\n      if (newHead) {\r\n        // 初始新链表的next节点\r\n        newHeadPoint.next = {\r\n          val: point.val,\r\n          next: null,\r\n        };\r\n        newHeadPoint = newHeadPoint.next;\r\n      } else {\r\n        // 初始新链表\r\n        newHead = {\r\n          val: point.val,\r\n          next: null,\r\n        };\r\n        newHeadPoint = newHead;\r\n      }\r\n    }\r\n    // 存储当前节点的值表示出现过\r\n    uniqueMap.set(point.val, true);\r\n    point = point.next;\r\n  }\r\n  return newHead;\r\n};\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## [链表中倒数第k个节点](https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/)\r\n> 输入一个链表，输出该链表中倒数第k个节点。从1开始计数，即链表的尾节点是倒数第1个节点。\r\n\r\n- 循环链表，创建对象obj以index为key节点为value存储每个节点，直到循环结束。\r\n- 上一步循环获取到最后一个节点的index值，index - k即是倒数第k个节点的index值。最终返回obj[index - k]。\r\n```\r\nvar getKthFromEnd = function(head, k) {\r\n  let obj = {}, point = head, index = 0;\r\n  // 循环链表存储链表每个节点信息\r\n  while(point) {\r\n    obj[index] = point\r\n    index++;\r\n    point = point.next;\r\n  }\r\n  return obj[index - k];\r\n};\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## [链表的中间结点](https://leetcode.cn/problems/middle-of-the-linked-list)\r\n> 给定一个头结点为 head 的非空单链表，返回链表的中间结点。如果有两个中间结点，则返回第二个中间结点。\r\n\r\n- 循环链表获取链表总长度。\r\n- 根据获取到的总长度得到链表中间位置midPosition，按要求如果存在两个中间节点返回第二个所以使用Math.ceil向上取整。\r\n- 再次循环链获取midPosition对应的链表节点信息并返回。\r\n```\r\nvar middleNode = function(head) {\r\n  let length = 1, point = head;\r\n  let position = 1, midNode = head;\r\n  // 循环链表获取链表总长度\r\n  while(point.next) {\r\n    length++;\r\n    point = point.next;\r\n  }\r\n  // 根据要求获取链表中间位置\r\n  const midPosition = Math.ceil((length + 1) / 2);\r\n  // 循环链表获取midPosition对应的节点信息\r\n  while(position < midPosition) {\r\n    position++;\r\n    midNode = midNode.next;\r\n  }\r\n  return midNode;\r\n};\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## [两数之和](https://leetcode.cn/problems/two-sum/)\r\n> 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。\r\n\r\n- 对整数数组进行循环，创建Map，每一次循环以当前项与目标值的差值为key，当前项的下标为value进行存储。\r\n- 循环过程中Map中存在以当前项为key的值时表示已找到两个相加为目标值的数字，对应的数组下标分别是当前循环项的下标和Map中以当前项为key的值。\r\n- 注意：应该先判断Map中是否存在以当前项为key的值再进行Map的存储，从而避免数组当前项与目标值 - 当前项值相同的情况(数组当前项为3，target为6，如果先进行Map存储，此时Map中是否存在以当前项为key的值的判断会成立所以应该先判断再进行Map存储)。\r\n```\r\nvar twoSum = function(nums, target) {\r\n  const objMap = new Map();\r\n  for (let index = 0; index < nums.length; index++) {\r\n    const item = nums[index];\r\n    if (objMap.has(item)) {\r\n      return [index, objMap.get(item)];\r\n      break;\r\n    }\r\n    objMap.set(target - item, index);\r\n  }\r\n};\r\n```\r\n- 双层for循环\r\n```\r\nconst twoSum = (nums, target) => {\r\n  for(let i = 0; i< nums.length; i++) {\r\n    for(let j = i + 1; j < nums.length; j++) {\r\n      if (nums[i] + nums[j] === target) {\r\n        return [i, j]\r\n      }\r\n    } \r\n  }\r\n};\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="\r\n## 买卖股票最佳时机\r\n- 给定一个数组prices，其中prices[i]是一支给定股票第i天的价格。设计一个算法来计算你所能获取的最大利润。\r\n- 可以尽可能地完成更多的交易（多次买卖一支股票）。\r\n- 不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\r\n- 只要今天比昨天高就说明有利润可以卖出。\r\n```\r\nconst maxProfit = (prices) => {\r\n  let result = 0\r\n  for(let i = 1; i < prices.length; i++) {\r\n    // 今天比昨天高就卖出\r\n    if(prices[i] > prices[i-1]) {\r\n      result += prices[i] - prices[i - 1]\r\n    }\r\n  }\r\n  return result;\r\n};\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## [二进制求和](https://leetcode.cn/problems/add-binary/)\r\n> 两个二进制字符串a和b ，以二进制字符串的形式返回它们的和。\r\n\r\n- 使用padStart方法将两个字符串设置成相同长度，较短的字符串前面填充为0。\r\n- 设置一个变量frontAdd表示前一项是否要加一。\r\n- 从后往前遍历两个字符串，两个当前项相加如果frontAdd为true则再加一，如果相加的结果大于等于2，设置当前项为 相加的结果 - 2且frontAdd设置为true，否则设置当前项为相加的结果且frontAdd设置为false。\r\n- 遍历结束之后，如果frontAdd为true，最终的字符串的最前加一位设置为1。\r\n```\r\nvar addBinary = function(a, b) {\r\n  const maxLength = Math.max(a.length, b.length);\r\n  const newA = a.padStart(maxLength, 0);\r\n  const newB = b.padStart(maxLength, 0);\r\n  let frontAdd = false; // 前一项是否要加一\r\n  let res = ''; // 最后返回结果\r\n  for (let index = maxLength - 1; index >= 0; index--) {\r\n    const aItem = Number(newA[index]);\r\n    const bItem = Number(newB[index]);\r\n    let addItem = aItem + bItem;\r\n    if (frontAdd) {\r\n      addItem += 1;\r\n    }\r\n    if (addItem >= 2) {\r\n      res = (addItem - 2) + res;\r\n      frontAdd = true;\r\n    } else {\r\n      res = addItem + res;\r\n      frontAdd = false;\r\n    }\r\n  }\r\n  if (frontAdd) {\r\n    res = 1 + res; \r\n  }\r\n  return res;\r\n};\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## 全排列\r\n- 输入 [1, 2, 3]\r\n- 输出 [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\r\n```\r\n// 时间复杂度 O(n!) n! = 1 * 2 * 3 * ··· * (n-1) * n;\r\n// 空间复杂度 O(n)\r\nvar permute = function (nums) {\r\n  // 存放结果\r\n  const res = [];\r\n  const backTrack = (path) => {\r\n    // 递归结束条件 \r\n    if (path.length === nums.length) {\r\n      res.push(path);\r\n      return;\r\n    }\r\n    // 遍历传入数组\r\n    nums.forEach(n => {\r\n      // 如果子数组中有这个元素就是死路，需要回溯回去走其他路\r\n      if (path.includes(n)) return;\r\n      // 加入到子数组里\r\n      backTrack(path.concat(n));\r\n    })\r\n  }\r\n\r\n  backTrack([]);\r\n  return res;\r\n};\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## [删除有序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/)\r\n> 给你一个升序排列的数组nums，原地删除重复出现的元素，使每个元素只出现一次，返回删除后数组的新长度。元素的 相对顺序应该保持一致。\r\n\r\n- 遍历循环传入的数组，如果当前项等于下一项时，删除数组中对应当前index的值，因为删除数组元素，所以同时需要将当前循环的指针index值减一继续循环。\r\n```\r\nvar removeDuplicates = function(nums) {\r\n  for (let index = 0; index < nums.length; index++) {\r\n    const item = nums[index];\r\n    if (nums[index] === nums[index + 1]) {\r\n      nums.splice(index, 1);\r\n      index -= 1;\r\n    }\r\n  }\r\n};\r\n```\r\n- 创建快慢指针，循环数组，如果快慢指针对应值相同，则快指针+1。\r\n- 如果快慢指针对应的值不同，将慢指针加1，同时将此时慢指针的值修改为快指针对应的值。将后面较大的数值移动到前面，保持前面的数组为有序数组。\r\n- 直到快指针等于数组长度时循环结束。\r\n```\r\nconst removeDuplicates = (nums) => {\r\n  if (nums.length <= 1) return nums.length;\r\n  let slow = 0, quick = 0;\r\n  while (quick < nums.length) {\r\n    while (nums[slow] === nums[quick] && quick < nums.length) quick++;\r\n    if (nums[slow] !== nums[quick] && quick < nums.length) {\r\n      slow++;\r\n      nums[slow] = nums[quick];\r\n      quick++;\r\n    }\r\n  }\r\n  return slow + 1;\r\n};\r\n```\r\n## 删除数组的重复项,返回数组的长度。不要使用额外的数组空间，必须在原地修改数组\r\n> 慢指针是i，快指针是j，如果nums[i] 等于 nums[j] 说明是相同的元素，j继续走，i还在原位，如果nums[i] 不等于 nums[j] 说明是不相同的元素，那么nums[i++] = nums[j]，j继续向前走，就相当于i指针保证它和它前面的数字都是不重复的，j就是一个遍历器。\r\n\r\n```\r\nconst removeDuplicates = (nums) => {\r\n  let i = 0;\r\n  for(let j = 1; j < nums.length; j++) {\r\n    if(nums[j] !== nums[i]) {\r\n      nums[i+1] = nums[j];\r\n      i++;\r\n    }\r\n  }\r\n  return i + 1\r\n};\r\n```"},function(r,n,e){"use strict";e.r(n),n.default='## 判断html标签是否匹配\r\n1. 声明变量stack、nodes，并从头遍历HTML字符串，查找字符"<"的位置。\r\n2. 如果字符"<"的位置等于0\r\n    1. 则继续尝试匹配HTML结束标签，匹配成功并且与栈顶的标签名称一致，则弹出栈顶；否则报错。\r\n    2. 匹配HTML结束标签失败以后，则尝试匹配开始标签的起始部分，然后循环匹配标签属性对，最后匹配开始标签的结束部分。匹配完成以后，将匹配到的标签压入栈顶；并构建node节点数。\r\n3. 如果字符"<"的位置大于0\r\n    1. 则html.slice(0, pos)，创建文本节点。\r\n```\r\nconst parseHtml = (html = \'\') => {\r\n  const startIndex = 0;\r\n  const endIndex = 0;\r\n\r\n  // 匹配标签<div>、<br/>等标签的开始部分"<div、<br"\r\n  const startTagOpen = /^<([a-zA-Z\\d]+)/;\r\n\r\n  // 匹配标签<div>、<br/>等标签的闭合部分">、/>"\r\n  const startTagClose = /^\\s*(/?)>/;\r\n\r\n  // 匹配属性\r\n  const attribute = /^\\s*([\\w-]+)(?:="([^"]*)")?\\s*/;\r\n\r\n  // 匹配闭合标签，例如</div>、</p>\r\n  const endTag = /^</([a-zA-Z\\d]+)>/;\r\n\r\n  const stack = [];\r\n  const nodes = [];\r\n  while(html) {\r\n    // 查找<的起始位置\r\n    const index = html.indexOf(\'<\');\r\n    if (index === 0) {\r\n      // 先匹配整体结束标签，例如</div>、</p>\r\n      let endTagMatch = html.match(endTag);\r\n\r\n      if (endTagMatch) {\r\n        if (stack[stack.length - 1]) {\r\n          if (stack[stack.length - 1].tag === endTagMatch[1]) {\r\n            // 出栈\r\n            stack.pop();\r\n            advanced(endTagMatch[0].length);\r\n            continue;\r\n          } else {\r\n            throw new Error(`起始标签和结束标签不匹配: 起始标签（${stack[stack.length - 1].tag}），结束标签（${endTagMatch[0]}）`);\r\n          }\r\n        } else {\r\n          throw new Error(`${endTagMatch[0]}没有起始标签`);\r\n        }\r\n      }\r\n\r\n      // 然后匹配起始标签的开始部分，例如<div>的<div、<p>的<p、<br/>的<br\r\n      let startTagOpenMatch = html.match(startTagOpen);\r\n      if (startTagOpenMatch) {\r\n        const node = {\r\n          nodeType: 1,\r\n          tag: startTagOpenMatch[1],\r\n          attrs: [],\r\n          children: [],\r\n        };\r\n        advanced(startTagOpenMatch[0].length);\r\n        let end, attr;\r\n        // 匹配标签属性列表\r\n        while(!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {\r\n          advanced(attr[0].length);\r\n          node.attrs.push({\r\n            name: attr[1],\r\n            value: attr[2],\r\n          });\r\n        }\r\n\r\n        // 匹配起始标签的结束部分\r\n        if (end) {\r\n          if (stack.length === 0) {\r\n            nodes.push(node);\r\n          } else {\r\n            stack[stack.length - 1].children.push(node);\r\n          }\r\n          // 自闭和标签不加入栈中\r\n          if (end[1] !== \'/\') {\r\n            stack.push(node);\r\n          }\r\n          advanced(end[0].length);\r\n        }\r\n      }\r\n    } else {\r\n      // 文本\r\n      const node = {\r\n        nodeType: 3,\r\n        textContent: html.slice(0, index)\r\n      };\r\n\r\n      if (stack.length === 0) {\r\n        nodes.push(node);\r\n      } else {\r\n        stack[stack.length - 1].children.push(node);\r\n      }\r\n      advanced(node.textContent.length);\r\n    }\r\n  }\r\n\r\n  function advanced(n) {\r\n    html = html.substring(n);\r\n  }\r\n\r\n  return nodes;\r\n}\r\nparseHtml(\'<div id="test" class="a b"></div>\');\r\nparseHtml(\'<div id="test" class="a b">Hello World</div>\');\r\nparseHtml(\'开始<div id="test" class="a b">Hello World</div>\');\r\nparseHtml(\'<div id="test" class="a b"><br class="br" />Hello World</div>\');\r\nparseHtml(\'</div>\');\r\nparseHtml(\'<div></p>\');\r\n```'},function(r,n,e){"use strict";e.r(n),n.default="## 判断是否为有效的字母异位词(两个字符串s和t，若s和t中每个字符出现的次数都相同，则称s和t互为字母异位词)\r\n> 判断两个字符串长度是否相同，如果相同根据长度进行循环，用一个对象来计数，字符串s对应的字符加1，字符串t对应的字符减1，最后所有的value都为0，表示两个字符串的字符出现次数相同。\r\n\r\n```\r\nconst isAnagram = (s, t) => {\r\n  const sLen = s.length;\r\n  const tLen = t.length;\r\n  if(sLen !== tLen) {\r\n    return false;\r\n  }\r\n  const obj = {};\r\n  for(let i = 0; i < sLen; i++) {\r\n    const currentS = s[i];\r\n    const currentT = t[i];\r\n    obj[currentS] ? obj[currentS]++ : obj[currentS] = 1;\r\n    obj[currentT] ? obj[currentT]-- : obj[currentT] = -1;\r\n  }\r\n  return Object.values(obj).every(v => v === 0);\r\n};\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## 加一\r\n> 给一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。可以假设除了整数 0 之外，这个整数不会以零开头。\r\n\r\n- 从后向前循环，如果循环的当前项不为9，直接当前项加一返回数组。\r\n- 如果循环的当前项为9，则当前项修改为0，在这里并不需要对前一位加一，因为它是向前遍历最后返回的时候第一项会加1。\r\n- 最终返回的数组为 [1, ...digits]。\r\n```\r\nvar plusOne = function(digits) {\r\n  for (let i = digits.length - 1; i >= 0; i--) {\r\n    if (digits[i] !== 9) {\r\n      digits[i]++;\r\n      return digits;\r\n    } else {\r\n      // 在这里并不需要对前一位加一，因为它是向前遍历的前面一位会自己加一\r\n      digits[i] = 0;\r\n    }\r\n  }\r\n  return [1, ...digits];\r\n};\r\n```"},function(r,n,e){"use strict";e.r(n),n.default='## 十进制转二进制\r\n```\r\n// 时间复杂度O(n) n为二进制的长度\r\n// 空间复杂度O(n) n为二进制的长度\r\nconst dec2bin = (dec) => {\r\n  // 创建一个字符串\r\n  let res = "";\r\n\r\n  // 创建一个栈\r\n  const stack = [];\r\n\r\n  // 遍历数字如果大于0就可以继续转换2进制\r\n  while (dec > 0) {\r\n    // 将数字的余数入栈\r\n    stack.push(dec % 2);\r\n\r\n    // 除以2\r\n    dec = dec >> 1;\r\n  }\r\n\r\n  // 取出栈中的数字\r\n  while (stack.length) {\r\n    res += stack.pop();\r\n  }\r\n\r\n  // 返回这个字符串\r\n  return res;\r\n};\r\n```'},function(r,n,e){"use strict";e.r(n),n.default="## 回文字符串\r\n- 双指针，头尾向中间靠拢。\r\n```\r\nconst isPalindrome = (s) => {\r\n  s = s.replace(/[^\\w]/g, '').toLowerCase();\r\n  let leftPointer = 0;\r\n  let rightPointer = s.length - 1;\r\n  while(rightPointer > leftPointer) {\r\n    if(s[leftPointer++] === s[rightPointer--]) {\r\n      continue;\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n};\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## [回文数](https://leetcode.cn/problems/palindrome-number/)\r\n> 一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。\r\n\r\n- 将整数转为字符串再使用split方法转为数组，转为数组之后使用reverse方法反转数组，再使用join方法生成新的字符串。\r\n- 判断新生成的字符串和传入的数字字符串是否相等\r\n```\r\nvar isPalindrome = function(x) {\r\n  const reverseString = `${x}`.split('').reverse().join('');\r\n  return `${x}` === reverseString;\r\n};\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## 子集\r\n- 输入 [1, 2, 3]\r\n- 输出 [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]]\r\n```\r\n// 时间复杂度 O(2 ^ N) 每个元素都有两种可能\r\n// 空间复杂度 O(N)\r\nvar subsets = function (nums) {\r\n  // 存放结果数组\r\n  const res = [];\r\n  const backTrack = (path, l, start) => {\r\n    // 递归结束条件\r\n    if (path.length === l) {\r\n      res.push(path);\r\n      return;\r\n    }\r\n    // 遍历输入的数组长度 起始位置是start\r\n    for (let i = start; i < nums.length; i++) {\r\n      // 递归调用 需要保证子集的有序, start为 i+1\r\n      backTrack(path.concat(nums[i]), l, i + 1);\r\n    }\r\n  };\r\n\r\n  // 遍历输入数组长度\r\n  for (let i = 0; i <= nums.length; i++) {\r\n    // 传入长度 起始索引\r\n    backTrack([], i, 0);\r\n  }\r\n  return res\r\n};\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## [判断字符串是否为某一个字符串的子序列(顺序一致即可，不一定要是连续的)](https://leetcode-cn.com/problems/is-subsequence/)\r\n> 利用双指针遍历两个字符串，整串的指针移动，当匹配时子串的的指针向后移动，最后比较子串的指针index与子串的长度比较。\r\n\r\n```\r\nconst isSubsequence = (s, t) => {\r\n  let i = 0; // 子串的指针\r\n  let j = 0; // 整串的指针\r\n  while (i < s.length && j < t.length) {\r\n    if (s[i] == t[j]) i++;\r\n    j++;\r\n  }\r\n  return i == s.length;\r\n}\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## 将0移动到数组末尾\r\n> 给定一个数组将所有0移动到数组的末尾，同时保持非零元素的相对顺序。\r\n\r\n- 用快慢指针来交换数组项的位置。\r\n```\r\nconst moveZeroes = (nums) => {\r\n  let i = j = 0;\r\n  while(i < nums.length) {\r\n    if(nums[i] !== 0) {\r\n      // 交换位置，将非0的值前移\r\n      [nums[i], nums[j]] = [nums[j], nums[i]];\r\n      j++;\r\n    }\r\n    i++;\r\n  }\r\n  return nums\r\n};\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## 搜索插入位置\r\n> 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。必须使用时间复杂度为 O(log n) 的算法。\r\n\r\n- 因为要求使用时间复杂度为 O(log n) 的算法，所以使用二分法进行查找。\r\n- 设置两个变量表示左右两个指针分别为0和数组的长度减一，取两个值的中间值作为索引与目标值比较，中间索引的值小于目标值则左指针加一，中间索引的值大于目标值则右指针减一，中间索引的值等于目标值返回当前的中间索引值。\r\n- 当左索引大于右索引时表示没有找到对应的值，此时返回左索引的值则是插入目标值的位置。\r\n```\r\nconst searchInsert = (nums, target) => {\r\n  let left = 0, right = nums.length - 1;\r\n  while (left <= right) {\r\n    let mid = Math.floor((left + right) / 2);\r\n    if(nums[mid] == target) {\r\n      return mid;\r\n    } else if(nums[mid] < target) {\r\n      left = mid + 1;\r\n    } else {\r\n      right = mid - 1;\r\n    }\r\n  }\r\n  return left;\r\n}\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## 数组中字符串翻转\r\n> 利用首尾双指针进行数组值替换。\r\n\r\n```\r\nconst reverseString = (s) => {\r\n  let l = 0 ;\r\n  let r = s.length - 1;\r\n  while(l < r) {\r\n    [s[l], s[r]] = [s[r], s[l]];\r\n    l++; r--;\r\n  }\r\n  return s;\r\n};\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## [找出数组中最长的连续递增序列，并返回长度](https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/)\r\n> 两个变量一个存储全局最长的长度，一个存储当前循环过程中的长度，数组前后比较进行长度变量的变化。\r\n\r\n```\r\nconst findLengthOfLCIS = function(nums) {\r\n  if (nums.length === 0) {\r\n    return 0;\r\n  }\r\n  let globalMaxLength = 1, maxLength = 1;\r\n  nums.reduce((prev, curr) => {\r\n    if (curr > prev) {\r\n      maxLength ++;\r\n    } else {\r\n      maxLength = 1;\r\n    }\r\n    globalMaxLength = Math.max(globalMaxLength, maxLength);\r\n    return curr\r\n  })\r\n  return globalMaxLength;\r\n};\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## 斐波那契数列\r\n> 指的是这样一个数列：0、1、1、2、3、5、8、13、21、34。\r\n\r\n```\r\n// 时间复杂度 O(n) \r\n// 空间复杂度 O(n)\r\nfunction fib(n) {\r\n  let dp = [0, 1, 1];\r\n  for (let i = 3; i <= n; i++) {\r\n    // 当前值等于前两个值之和\r\n    dp[i] = dp[i - 1] + dp[i - 2];\r\n  }\r\n  return dp[n];\r\n}\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## [最后一个单词长度](https://leetcode.cn/problems/length-of-last-word/)\r\n> 给一个字符串s，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中最后一个单词的长度。单词指仅由字母组成、不包含任何空格字符的最大子字符串。\r\n\r\n- 先使用trim方法将传入的字符去除头尾的空格字符\r\n- 设定一个变量finalLength初始值为0用于存储单词长度\r\n- 循环字符串，如果当前项有值则finalLength加1，否则 finalLength 重置为0。\r\n- 直到循环结束返回最终的finalLength值则是最后一个单词的长度。\r\n```\r\nvar lengthOfLastWord = function(s) {\r\n  let finalLength = 0;\r\n  const sTrim = s.trim();\r\n  for (let index = 0; index < sTrim.length; index++) {\r\n    const item = sTrim[index];\r\n    if (item.trim()) {\r\n      finalLength += 1;\r\n    } else {\r\n      finalLength = 0;\r\n    }\r\n  }\r\n  return finalLength;\r\n};\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## [最大子数组和](https://leetcode-cn.com/problems/maximum-subarray/)\r\n> 初始将数组每一个index对应的值存储为0，循环数组将当前index对应的值存储为当前index对应的数据和当前index对应数据和上一个index对应数据和中较大的值，存储较大的值，直到循环结束。\r\n\r\n```\r\nconst maxSubArray = (nums) => {\r\n  let maxSum = -Infinity; // 最大值\r\n  let dp = [], n = nums.length;\r\n  // 每一个index对应的初始值都为0\r\n  for (let i = -1; i < n; i++) {\r\n    dp[i] = 0;\r\n  }\r\n  for (let i = 0; i < n; i++) {\r\n    // 比较当前值和当前值与前一个值相加的结果，存储较大的值\r\n    dp[i] = Math.max(nums[i], dp[i - 1] + nums[i]);\r\n    maxSum = Math.max(maxSum, dp[i]);\r\n  }\r\n  return maxSum;\r\n};\r\n```"},function(r,n,e){"use strict";e.r(n),n.default='## 最小覆盖字串\r\n```\r\n// 输入：s = "ADOBECODEBANC", t = "ABC"\r\n// 输出："BANC"\r\n\r\n// 时间复杂度 O(m + n) m是t的长度 n是s的长度\r\n// 空间复杂度 O(k) k是字符串中不重复字符的个数\r\nconst minWindow = function (s, t) {\r\n  // 定义双指针维护一个滑动窗口\r\n  let l = 0;\r\n  let r = 0;\r\n\r\n  // 建立一个字典\r\n  const need = new Map();\r\n  //  遍历t\r\n  for (const c of t) {\r\n    need.set(c, need.has(c) ? need.get(c) + 1 : 1)\r\n  }\r\n  let needType = need.size\r\n  // 记录最小子串\r\n  let res = ""\r\n\r\n  // 移动右指针\r\n  while (r < s.length) {\r\n    // 获取当前字符\r\n    const c = s[r];\r\n    // 如果字典里有这个字符\r\n    if (need.has(c)) {\r\n      // 减少字典里面的次数\r\n      need.set(c, need.get(c) - 1);\r\n      // 减少需要的值\r\n      if (need.get(c) === 0) needType -= 1;\r\n    }\r\n    // 如果字典中所有的值都为0了 就说明找到了一个最小子串\r\n    while (needType === 0) {\r\n      // 取出当前符合要求的子串\r\n      const newRes = s.substring(l, r + 1)\r\n      // 如果当前子串是小于上次的子串就进行覆盖\r\n      if (!res || newRes.length < res.length) res = newRes;\r\n      // 获取左指针的字符\r\n      const c2 = s[l];\r\n      // 如果字典里有这个字符\r\n      if (need.has(c2)) {\r\n        // 增加字典里面的次数\r\n        need.set(c2, need.get(c2) + 1);\r\n        // 增加需要的值\r\n        if (need.get(c2) === 1) needType += 1;\r\n      }\r\n      l += 1;\r\n    }\r\n    r += 1;\r\n  }\r\n  return res;\r\n};\r\n```'},function(r,n,e){"use strict";e.r(n),n.default="## 最近的请求次数\r\n```\r\nconst RecentCounter = () => {\r\n  // 初始化队列\r\n  this.q = [];\r\n};\r\n\r\n// 输入 inputs = [[],[1],[100],[3001],[3002]] 请求间隔为 3000ms\r\n// 输出 outputs = [null,1,2,3,3]   \r\n\r\n// 时间复杂度 O(n) n为剔出老请求的长度\r\n// 空间复杂度 O(n) n为最近请求的次数\r\nRecentCounter.prototype.ping = function (t) {\r\n  // 如果传入的时间小于等于最近请求的时间，则直接返回0\r\n  if (!t) return null\r\n\r\n  // 将传入的时间放入队列\r\n  this.q.push(t);\r\n\r\n  // 如果队头小于 t - 3000 则剔除队头\r\n  while (this.q[0] < t - 3000) {\r\n    this.q.shift();\r\n  }\r\n\r\n  // 返回最近请求的次数\r\n  return this.q.length;\r\n};\r\n```"},function(r,n,e){"use strict";e.r(n),n.default='## [最长公共前缀](https://leetcode.cn/problems/longest-common-prefix/)\r\n> 编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 ""。\r\n\r\n- 使用数组的reduce方法对当前项和下一项的字符串进行循环比较获取最长的公共前缀，将当前获取到的公共前缀返回作为当前项再与后一项进行比较，直到返回最终的公共前缀。\r\n- 当前项和下一项的字符串进行循环比较获取最长的公共前缀时一旦匹配不上需要退出循环否则会出现错误，比如`["cir","car"]`不退出循环获取到的最长公共前缀将是\'cr\'。\r\n```\r\nvar longestCommonPrefix = function(strs) {\r\n  const prefix = strs.reduce((prev, curr) => {\r\n    let currentPrefix = \'\'\r\n    for (let index = 0; index < prev.length; index++) {\r\n      if (prev[index] === curr[index]) {\r\n        currentPrefix += prev[index];\r\n      } else {\r\n        break;\r\n      }\r\n    }\r\n    return currentPrefix;\r\n  })\r\n  return prefix;\r\n};\r\n```'},function(r,n,e){"use strict";e.r(n),n.default="## 有序数组二分搜索\r\n> 数组必须是有序的，如不是则需要先进行排序。\r\n\r\n- 从数组中的中间位置开始搜索，如果中间元素正好是目标值，则搜索结束。\r\n- 如果目标值大于或者小于中间元素，则在大于或者小于中间元素的那一半数组中搜索。\r\n```\r\n// 时间复杂度：O(log n)  分割成两半的 基本都是logn\r\n// 空间复杂度：O(1)\r\nArray.prototype.binarySearch = function (item) {\r\n  // 代表数组的最小索引\r\n  let low = 0;\r\n  // 和最大索引\r\n  let higt = this.length - 1;\r\n  while (low <= higt) {\r\n    // 获取中间元素索引\r\n    const mid = (low + higt) >> 1;\r\n    const element = this[mid];\r\n    // 如果中间元素小于要查找的元素 就把最小索引更新为中间索引的下一个\r\n    if (element < item) {\r\n      low = mid + 1;\r\n    } else if (element > item) {\r\n    // 如果中间元素大于要查找的元素 就把最大索引更新为中间索引的前一个\r\n      higt = mid - 1;\r\n    } else {\r\n      // 如果中间元素等于要查找的元素 就返回索引\r\n      return mid;\r\n    }\r\n  }\r\n  return -1\r\n}\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## 有效的括号\r\n> 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。\r\n\r\n- 维护一个所有括号类型的对象\r\n- 循环字符串使用数组模拟栈的数据结构，如果是左括号入栈，如果是右括号时判断：\r\n  1. 如果栈内没有数据，直接返回false\r\n  2. 有数据移除栈顶的元素，使用栈顶元素作为key从括号类型的对象进行匹配，如果匹配到的内容不等于当前循环的括号类型直接返回false\r\n- 循环结束之后判断栈的长度，长度为0表示完全匹配括号有效否则无效。\r\n```\r\nvar isValid = function(s) {\r\n  const pairingMap = {\r\n    '(': ')',\r\n    '[': ']',\r\n    '{': '}'\r\n  }\r\n  const stack = [];\r\n  for(let i of s) {\r\n    if (pairingMap[i]) {\r\n      // 左括号入栈\r\n      stack.push(i)\r\n    } else {\r\n      // 右括号匹配\r\n      // 1. 如果栈内没有数据，直接false\r\n      // 2. 有数据但是栈顶元素不是当前的右括号\r\n      if (!stack.length || pairingMap[stack.pop()] !== i) {\r\n        return false\r\n      }\r\n    }\r\n  }\r\n  // 栈内还有数据说明没有完全匹配\r\n  return !stack.length\r\n};\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## 杨辉三角\r\n1. 三角中的每一行数据都依赖于上一行的数据。\r\n2. 我们首先创建队列 queue，用于存储每一行的数据，供下一行数据使用。\r\n3. 然后初始化第一行的数据 1 入队，这里需要两个 for 循环嵌套，外层的 for 循环决定最终打印的总行数，内层的 for 循环生成每行的数据。\r\n4. 在生成当前行的数据时，将队列中的数据源依次出队，然后将新生成的数据入队；并记录当前出队的数据，供生成新数据使用。\r\n```\r\nconst printYangHui = (num) => {\r\n  const queue = [];\r\n  // 存储第一行数据\r\n  queue.push(1);\r\n\r\n  for(let i = 1; i <= num; i++) {\r\n    let rowArr = [];\r\n    // 填充空格\r\n    for(let j = 0; j < Math.floor((num - i) / 2); j++) {\r\n      rowArr.push('');\r\n    }\r\n    let prev = 0;\r\n    for(let j = 0; j < i; j++) {\r\n      const num = queue.shift();\r\n      queue.push(prev + num);\r\n      rowArr.push(num);\r\n      prev = num;\r\n    }\r\n    queue.push(1);\r\n    console.log(rowArr.join(' '));\r\n  }\r\n}\r\n\r\nprintYangHui(3);\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## [爬楼梯](https://leetcode.cn/problems/climbing-stairs/)\r\n> 需要 n 阶才能到达楼顶。每次可以爬 1 或 2 个台阶。一共有多少种不同的方法可以爬到楼顶。\r\n\r\n- 定义一个数组res，定义数组的每一项值代表爬上第 i 级台阶有多少种方案。对于不同的i有不同的值。\r\n- 初始 res[0] = 1; res[1] = 1;表示爬0阶和1阶都只有一种方法。\r\n- 再将问题分成多个子问题，爬第n阶楼梯的方法数量，等于爬上 n-1 阶楼梯的方法数量和爬上 n-2 阶楼梯的方法数量。\r\n```\r\nvar climbStairs = function (n) {\r\n  const res = [];\r\n  res[0] = 1;\r\n  res[1] = 1;\r\n  for (let i = 2; i <= n; i++) {\r\n    res[i] = res[i - 1] + res[i - 2]\r\n  }\r\n  return res[n];\r\n};\r\n```\r\n"},function(r,n,e){"use strict";e.r(n),n.default='## 版本号比较\r\n- 版本号v1、v2按照符号"."分割成数组，从左右依次进行大小比较。\r\n- v1大于v2返回1，v1小于v2返回-1，v1等于v2返回0。\r\n```\r\n/*\r\n  比较版本号大小\r\n  v1：第一个版本号\r\n  v2：第二个版本号\r\n  如果版本号相等，返回0, 如果第一个版本号低于第二个返回 -1，否则返回 1。\r\n*/\r\nfunction compareVersion(v1, v2) {\r\n  if (!v1 && !v2) return 0;\r\n  if (!v1) return -1;\r\n  if (!v2) return 1;\r\n  const v1Stack = v1.split(\'.\');\r\n  const v2Stack = v2.split(\'.\');\r\n  const maxLen = Math.max(v1Stack.length, v2Stack.length);\r\n\r\n  for(let i = 0; i < maxLen; i++) {\r\n    // 必须转整，否则按照字符顺序比较大小\r\n    const prevVal = ~~v1Stack[i];\r\n    const currVal = ~~v2Stack[i];\r\n    if (prevVal > currVal) {\r\n      return 1;\r\n    }\r\n    if (prevVal < currVal) {\r\n      return -1;\r\n    }\r\n  }\r\n  return 0;\r\n}\r\n\r\nconsole.log(compareVersion("2.2.1", "2.2.01")); // 0\r\nconsole.log(compareVersion("2.2.1", "2.2.0")); // 1\r\nconsole.log(compareVersion("2.2.1", "2.1.9")); // 1\r\nconsole.log(compareVersion("2.2", "2.1.1")); // 1\r\nconsole.log(compareVersion("2.2", "2.2.1")); // -1\r\nconsole.log(compareVersion("2.2.3.4.5.6", "2.2.2.4.5.12")); // 1\r\nconsole.log(compareVersion("2.2.3.4.5.6", "2.2.3.4.5.12")); // -1\r\n```'},function(r,n,e){"use strict";e.r(n),n.default="## [盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/)\r\n- 双层循环\r\n> 所有区间计算结果的比较，取最大的值。\r\n\r\n```\r\nconst maxArea = function(height) {\r\n  let max = 0\r\n  for(let i = 0; i < height.length; i++) {\r\n    for(let j = i + 1; j < height.length; j++) {\r\n      currentValue = (j - i) * Math.min(height[i], height[j])\r\n      if (max < currentValue) {\r\n        max = currentValue\r\n      }\r\n    }\r\n  }\r\n  return max\r\n};\r\n```\r\n- [双指针](https://mp.weixin.qq.com/s/Nm4tgudd7RB3dxCy8FP8BQ)\r\n> 从起始和结束两个指针向中间压缩，比较区间的值，取最大的值。\r\n\r\n```\r\nconst maxArea = function(height) {\r\n  let max = 0\r\n  let left = 0\r\n  let right = height.length\r\n  while(left < right) {\r\n    currentValue = (right - left) * Math.min(height[left], height[right])\r\n    if (max < currentValue) {\r\n      max = currentValue\r\n    }\r\n    if (height[left] < height[right]) {\r\n      left++\r\n    } else {\r\n      right--\r\n    }\r\n  }\r\n  return max\r\n};\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## [移除数组元素](https://leetcode.cn/problems/remove-element/)\r\n> 一个数组 nums 和一个值 val，需要 原地 移除所有数值等于 val 的元素。\r\n\r\n- 遍历循环传入的数组，如果当前项等于传入的值时，删除数组中对应当前index的值，因为删除数组元素，所以同时需要将当前循环的指针index值减一继续循环。\r\n```\r\nvar removeElement = function(nums, val) {\r\n  for (let index = 0; index < nums.length; index++) {\r\n    const item = nums[index];\r\n    if (item === val) {\r\n      nums.splice(index, 1);\r\n      index -= 1;\r\n    }\r\n  }\r\n};\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## 约瑟夫环\r\n> 一个数组存放了 100 个数据 0-99，要求每隔两个数删除一个数，到末尾时再循环至开头继续进行，求最后一个被删除的数字。\r\n\r\n1. 创建队列，将 0 到 99 的数字入队。\r\n2. 循环队列，依次出列队列中的数字，对当前出队的数字进行计数 index + 1。\r\n3. 判断当前出列的 index % 3 是否等于 0，如果不等于 0 则再次入队。\r\n4. 直到队列的长度为 1，退出循环，返回队列中的数字。\r\n```\r\nfunction ring(arr) {\r\n  const queue = new Queue();\r\n  arr.forEach(v => queue.enqueue(v));\r\n  let index = 0;\r\n  while(queue.size() > 1) {\r\n    const item = queue.dequeue();\r\n    if (++index % 3 !== 0) {\r\n      queue.enqueue(item);\r\n    }\r\n  }\r\n  return queue.head();\r\n}\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## [罗马数字转整数](https://leetcode.cn/problems/roman-to-integer/)\r\n> 给定一个罗马数字，将其转换成整数。\r\n\r\n- 将罗马数字所对应整数的值维护在对象中，循环字符串进行匹配，根据罗马数字的规则进行不同的匹配(当前项和后一项的大小比较区分两种情况)。\r\n- 罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况。\r\n  1. I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。\r\n  2. X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 \r\n  3. C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。\r\n\r\n```\r\nvar romanToInt = function(s) {\r\n  const romanObj = {\r\n    I: 1,\r\n    V: 5,\r\n    X: 10,\r\n    L: 50,\r\n    C: 100,\r\n    D: 500,\r\n    M: 1000,\r\n    IV: 4,\r\n    IX: 9,\r\n    XL: 40,\r\n    XC: 90,\r\n    CD: 400,\r\n    CM: 900,\r\n  };\r\n  let num = 0;\r\n  for (let index = 0; index < s.length; index++) {\r\n    const item = s[index];\r\n    const nextItem = s[index + 1];\r\n    if (index + 1 <= s.length) {\r\n      if (romanObj[nextItem]) {\r\n        if (romanObj[item] >= romanObj[nextItem]) {\r\n          num += romanObj[item];\r\n        } else {\r\n          num += romanObj[`${item}${nextItem}`];\r\n          index ++;\r\n        }\r\n      } else {\r\n        num += romanObj[item];\r\n      }\r\n    }\r\n  }\r\n  return num;\r\n};\r\n```\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## [设计哈希映射](https://leetcode.cn/problems/design-hashmap)\r\n> 实现 MyHashMap 类：put(int key, int value) 向 HashMap 插入一个键值对 (key, value)。如果 key 已经存在于映射中，则更新其对应的值 value；get(int key) 返回特定的 key 所映射的 value；如果映射中不包含 key 的映射，返回 -1；remove(key) 如果映射中存在 key 的映射，则移除 key 和它所对应的 value。\r\n\r\n- 使用二维数组进行存储数据\r\n  1. put方法直接使用push方法往数组中添加内容（判断是否已有此key，有此key时更新对应的value）。\r\n  2. get方法，遍历数组获取对应相同key数据对应的value值，没有找到则返回-1。\r\n  3. remove方法，遍历数组获取对应相同key数据的index值，删除该项。\r\n```\r\n// 建立哈希表 用数组每一项存储每一个哈希值对应链表\r\nvar MyHashMap = function() {\r\n  const hash = new Array(2069);\r\n  for (var i = 0; i < hash.length; i++) {\r\n    hash[i] = [];\r\n  }\r\n  this.hash = hash;\r\n};\r\n\r\nfunction getIndex(key) {\r\n  const N = 2069;\r\n  return key % N;\r\n}\r\n\r\nMyHashMap.prototype.put = function(key, value) {\r\n  const index = getIndex(key); // 获取哈希索引\r\n  \r\n  // 如果当前索引对应的桶里面没有值， 直接放入 \r\n  if (this.hash[index].length === 0) {\r\n    this.hash[index].push([key, value]);\r\n    return;\r\n  }\r\n\r\n  // 否则先遍历该桶，判断是否已有对应的key， 如果有就更新key\r\n  for(var i = 0; i < this.hash[index].length; i++) {\r\n    let tuple = this.hash[index][i];\r\n    if (tuple[0] === key) {\r\n      tuple[1] = value;\r\n      return;\r\n    }\r\n  }\r\n  // 如果桶中没有新加的key值，那就把key加入\r\n  this.hash[index].push([key, value]);\r\n};\r\n\r\n\r\nMyHashMap.prototype.get = function(key) {\r\n  const index = getIndex(key); // 获取哈希索引\r\n\r\n  for(var i = 0; i < this.hash[index].length; i++) {\r\n    let tuple = this.hash[index][i];\r\n    if (tuple[0] === key) {\r\n      return tuple[1];\r\n    }\r\n  }\r\n  return -1;\r\n};\r\n\r\n\r\nMyHashMap.prototype.remove = function(key) {\r\n  const index = getIndex(key); // 获取哈希索引\r\n  for(var i = 0; i < this.hash[index].length; i++) {\r\n    let tuple = this.hash[index][i];\r\n    if (tuple[0] === key) {\r\n      this.hash[index].splice(i, 1);\r\n    }\r\n  }\r\n};\r\n\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## [设计哈希集合](https://leetcode.cn/problems/design-hashset)\r\n> 实现 MyHashSet 类：add(key) 向哈希集合中插入值 key。contains(key) 返回哈希集合中是否存在这个值 key 。\r\nremove(key) 将给定值 key 从哈希集合中删除。如果哈希集合中没有这个值，什么也不做。\r\n\r\n- 使用数组进行存储数据\r\n  1. add方法直接使用push方法往数组中添加内容。\r\n  2. remove方法，遍历数组删除对应的元素。\r\n  3. contains方法，使用indexOf方法判断数组中是否有此元素。\r\n```\r\nvar MyHashSet = function() {\r\n  this.arr = [];\r\n};\r\n\r\nMyHashSet.prototype.add = function(key) {\r\n  this.arr.push(key);\r\n};\r\n\r\nMyHashSet.prototype.remove = function(key) {\r\n  for (let i = 0; i < this.arr.length; i++) {\r\n    if (this.arr[i] === key) {\r\n      this.arr.splice(i, 1);\r\n      i--;\r\n    }\r\n  }\r\n};\r\n\r\nMyHashSet.prototype.contains = function(key) {\r\n  return this.arr.indexOf(key) !== -1;\r\n};\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## LRU\r\n> LRU（Least recently used，最近最少使用），如果数据最近被访问过，那么将来被访问的几率也更高。所以越常被使用的数据权重越高。当需要清理数据时总是清理最不常使用的数据。\r\n\r\n### 实践\r\n- 浏览器的访问历史\r\n- tab形式页面的切换\r\n### 实现\r\n> 主要是使用什么数据结构来存储数据，因为map的存取非常快所以采用了它，当然数组、链表其实也可以实现的。\r\n\r\n- set方法：往map里面添加新数据，如果添加的数据存在了，则先删除该条数据然后再添加。如果添加数据后超长了，则需要删除最久远的一条数据。data.keys().next().value 便是获取第一个键（最先存入map集合的键）。\r\n- get方法：首先从map对象中拿出该条数据，然后删除该条数据，最后再重新插入该条数据，确保将该条数据移动到最前面。\r\n```\r\nclass LRUCache {\r\n  constructor(lenght) {\r\n    this.length = lenght; // 存储长度\r\n    this.data = new Map(); // 存储数据\r\n  }\r\n\r\n  // 存储数据，通过键值对的方式\r\n  set(key, value) {\r\n    const data = this.data;\r\n    if (data.has(key)) {\r\n      data.delete(key)\r\n    }\r\n    data.set(key, value);\r\n\r\n    // 如果超出了容量，则需要删除最久的数据\r\n    if (data.size > this.length) {\r\n      const delKey = data.keys().next().value;\r\n      data.delete(delKey);\r\n    }\r\n  }\r\n\r\n  // 获取数据\r\n  get(key) {\r\n    const data = this.data;\r\n    // 未找到\r\n    if (!data.has(key)) {\r\n      return null;\r\n    }\r\n    const value = data.get(key); // 获取元素\r\n    data.delete(key); // 删除元素\r\n    data.set(key, value); // 重新插入元素\r\n  }\r\n}\r\nconst lruCache = new LRUCache(5);\r\n```\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## 分而治之\r\n> 算法设计中的一种思想，将一个问题分成多个子问题，递归解决子问题，然后将子问题的解合并成最终的解。\r\n\r\n### 归并排序\r\n- 分：把数组从中间一分为二。\r\n- 解：递归地对两个子数组进行归并排序。\r\n- 合：合并有序子数组。\r\n### 快速排序\r\n- 分：选基准，按基准把数组分成两个子数组。\r\n- 解：递归地对两个子数组进行快速排序。\r\n- 合：对两个子数组进行合并。\r\n### 有序数组二分搜索\r\n- 从数组中的中间位置开始搜索，如果中间元素正好是目标值，则搜索结束。\r\n- 如果目标值大于或者小于中间元素，则在大于或者小于中间元素的那一半数组中搜索。\r\n### 翻转二叉树\r\n- 左侧树节点、右侧树节点分开处理。\r\n### 比较是否是相同的树\r\n- 左侧树节点、右侧树节点分开处理。\r\n### 对称二叉树 (详见二叉树文档)\r\n- 左侧树节点、右侧树节点分开处理。\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## 动态规划\r\n> 算法设计中的一种思想，将一个问题分解为相互重叠的子问题，通过反复求解子问题来解决原来的问题。\r\n\r\n- 斐波那契数列\r\n- 爬楼梯\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## 回溯算法\r\n> 算法设计中的一种思想，一种渐进式寻找并构建问题解决方式的策略，会先从一个可能的动作开始解决问题，如不行就回溯选择另外一个动作，直到找到一个解。\r\n\r\n- 全排列\r\n- 子集"},function(r,n,e){"use strict";e.r(n),n.default="## 复杂度\r\n### 时间复杂度\r\n> 一个函数用大O表示，定义描述算法的运行时间。\r\n\r\n- O(1)\r\n```\r\nlet i = 0;\r\ni += 1;\r\n```\r\n- O(n)：如果是O(1) + O(n) 则还是O(n)\r\n```\r\nfor (let i = 0; i < n; i += 1) {\r\n  console.log(i);\r\n}\r\n```\r\n- O(n^2)：O(n) * O(n), 双层循环，自此类推：O(n^3)...\r\n```\r\nfor (let i = 0; i < n; i += 1) {\r\n  for (let j = 0; j < n; j += 1) {\r\n    console.log(i, j);\r\n  }\r\n}\r\n```\r\n- O(logn)：就是求log以2为底的多少次方等于n\r\n```\r\n// 这个例子就是求2的多少次方会大于i，然后就会结束循环。 这就是一个典型的O(logn)\r\nlet i = 1;\r\nwhile (i < n) {\r\n  console.log(i);\r\n  i *= 2;\r\n}\r\n```\r\n### 空间复杂度\r\n> 空间复杂度也是用大O表示，用来定义描述算法运行过程中临时占用的存储空间大小。\r\n\r\n- O(1)：单个变量，所以占用永远是O(1)\r\n```\r\nlet i = 0;\r\ni += 1;\r\n```\r\n- O(n)：声明一个数组，添加n个值， 相当于占用了n个空间单元\r\n```\r\nconst arr = []\r\nfor (let i = 0; i < n; i += 1) {\r\n  arr.push(i);\r\n}\r\n```\r\n- O(n^2)：类似一个矩阵的概念，二维数组\r\n```\r\nconst arr = [];\r\nfor (let i = 0; i < n; i += 1) {\r\n  arr.push([]);\r\n  for (let j = 0; j < n; j += 1) {\r\n    arr[i].push(j);\r\n  }\r\n}\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## 贪心算法\r\n> 算法设计中的一种思想，期盼通过每个阶段的局部最优选择，从而达到全局的最优，但结果并不一定是最优。\r\n\r\n- 买卖股票最佳时机"},function(r,n,e){"use strict";e.r(n),n.default="## 代理模式\r\n- 代理模式是为其它对象提供一种代理以控制这个对象的访问，具体执行的功能还是这个对象本身。\r\n### 何时使用代理模式\r\n- 模块职责单一且可复用。\r\n- 两个模块间的交互需要一定限制关系。\r\n### 使用代理模式\r\n- 先通过一张loading图占位，然后通过异步的方式加载图片，等图片加载好了再把完成的图片加载到img标签里面。\r\n- 本体\r\n```\r\nconst imgFunc = (function() {\r\n  const imgNode = document.createElement('img');\r\n  document.body.appendChild(imgNode);\r\n  return {\r\n    setSrc: function(src) {\r\n      imgNode.src = src;\r\n    }\r\n  }\r\n})();\r\n```\r\n- 代理\r\n```\r\nconst proxyImage = (function() {\r\n  const img = new Image();\r\n  img.onload = function() {\r\n    imgFunc.setSrc(this.src);\r\n  }\r\n  return {\r\n    setSrc: function(src) {\r\n      imgFunc.setSrc('./loading.gif');\r\n      img.src = src;\r\n    }\r\n  }\r\n})();\r\n```\r\n- 调用\r\n```\r\nproxyImage.setSrc('./pic.png');\r\n```"},function(r,n,e){"use strict";e.r(n),n.default='## 单例模式\r\n- 保证一个类仅有一个实例，并提供一个访问它的全局访问点。\r\n- 实现的逻辑是先判断实例是否存在，如果存在则直接返回，如果不存在就创建了再返回，这就确保了一个类只有一个实例对象。\r\n### 单例模式使用场景\r\n- jquery只有一个实例。\r\n### 使用单例模式\r\n```\r\nclass CreateUser {\r\n  constructor(name) {\r\n    this.name = name;\r\n    this.getName();\r\n  }\r\n  getName() {\r\n    return this.name;\r\n  }\r\n}\r\n\r\n// 代理实现单例模式\r\nconst ProxyMode = (function() {\r\n  let instance = null;\r\n  return function(name) {\r\n    if(!instance) {\r\n      instance = new CreateUser(name);\r\n    }\r\n    return instance;\r\n  }\r\n})();\r\n\r\n// 测试单体模式的实例\r\nconst dyx = new ProxyMode("dyx");\r\nconst douyaxing = new ProxyMode("douyaxing");\r\n\r\n// 因为只实例化一次，所以两个实例是相等的\r\nconsole.log(dyx === douyaxing);  // true\r\n```\r\n\r\n'},function(r,n,e){"use strict";e.r(n),n.default="## [发布订阅和观察者模式](https://juejin.cn/post/6844904018964119566)\r\n> 观察者模式是观察者直接观察目标对象，没有中介层。而发布订阅模式多了一个事件调度中心，发布者和订阅者依赖于事件调度中心，并不直接通信。\r\n\r\n- 观察者模式里只有两个角色观察者和被观察者，而发布订阅模式里却不仅仅只有发布者和订阅者两个角色，还有一个事件调度中心。\r\n- 观察者和被观察者是松耦合的关系，发布者和订阅者则完全不存在耦合。\r\n- 观察者模式多用于同步场景，发布订阅模式多用于异步场景。"},function(r,n,e){"use strict";e.r(n),n.default="## 发布订阅模式\r\n- 发布订阅模式中包含发布者、事件调度中心、订阅者三个角色。\r\n- 实现的EventBus的每一个实例就是一个事件调度中心，发布者和订阅者是松散耦合的，互不关心对方是否存在，它们关注的是事件本身。\r\n- 发布者借用事件调度中心提供的emit方法进行事件发布，而订阅者则通过subscribe进行事件订阅。可类比于DOM事件中的dispatchEvent和addEventListener。\r\n### 发布订阅模式应用场景\r\n- Mobx的实现中，依赖搜集都是依赖发布订阅模式。\r\n- 表单保存校验功能。\r\n- 组件层级较深时的数据通信。\r\n- Node.js中EventEmitter模块。\r\n### EventBus\r\n```\r\ntype EventCallback = (...args: any[]) => void;\r\n\r\ninterface UnsubscribeFunction {\r\n  (): void;\r\n}\r\n\r\nclass EventBus {\r\n  private eventMap: Record<string, Record<string, EventCallback>> = {}; // 存储订阅的事件处理方法\r\n  private maxListeners: number; // 最大订阅数量\r\n  private callbackId: number = 0; // 订阅的事件处理方法唯一ID\r\n\r\n  // 初始化设置最大订阅数量\r\n  constructor(maxListeners: number = Infinity) {\r\n    this.maxListeners = maxListeners;\r\n  }\r\n\r\n  // 订阅事件\r\n  subscribe(eventName: string, funCallback: EventCallback): UnsubscribeFunction {\r\n    if (!this.eventMap[eventName]) {\r\n      this.eventMap[eventName] = {};\r\n    }\r\n\r\n    // 判断是否超过最大订阅数量\r\n    if (\r\n      this.maxListeners !== Infinity &&\r\n      Object.keys(this.eventMap[eventName]).length >= this.maxListeners\r\n    ) {\r\n      console.warn(`该事件 ${eventName} 超过了最大监听数`);\r\n    }\r\n\r\n    // 事件ID自增，存储事件处理方法\r\n    const thisCallbackId = String(this.callbackId++);\r\n    this.eventMap[eventName][thisCallbackId] = funCallback;\r\n\r\n    // 返回取消订阅事件的方法\r\n    return () => {\r\n      delete this.eventMap[eventName][thisCallbackId];\r\n      if (Object.keys(this.eventMap[eventName]).length === 0) {\r\n        delete this.eventMap[eventName];\r\n      }\r\n    };\r\n  }\r\n\r\n  // 发布事件\r\n  emit(eventName: string, ...args: any[]): void {\r\n    const callbackList = this.eventMap[eventName];\r\n\r\n    if (!callbackList) {\r\n      console.warn(`从未订阅过此事件 ${eventName}`);\r\n      return;\r\n    }\r\n\r\n    // 执行所有订阅的事件处理方法\r\n    for (const [id, callback] of Object.entries(callbackList)) {\r\n      callback(...args);\r\n      // 如果是只订阅一次则删除订阅的事件处理方法\r\n      if (id.startsWith('one')) {\r\n        delete callbackList[id];\r\n      }\r\n    }\r\n  }\r\n\r\n  // 清除某个事件的订阅\r\n  clear(eventName: string): void {\r\n    if (!eventName) {\r\n      console.warn(`需提供要被清除的事件名称 ${eventName}`);\r\n      return;\r\n    }\r\n    delete this.eventMap[eventName];\r\n  }\r\n\r\n  // 清除所有事件的订阅\r\n  clearAll(): void {\r\n    this.eventMap = {};\r\n  }\r\n\r\n  // 只订阅一次事件\r\n  subscribeOne(eventName: string, callback: EventCallback): UnsubscribeFunction {\r\n    if (!this.eventMap[eventName]) {\r\n      this.eventMap[eventName] = {};\r\n    }\r\n\r\n    // 事件ID自增且添加订阅一次事件的标识，存储事件处理方法\r\n    const theCallbackId = 'one' + String(this.callbackId++);\r\n    this.eventMap[eventName][theCallbackId] = callback;\r\n\r\n    // 返回取消订阅事件的方法\r\n    return () => {\r\n      delete this.eventMap[eventName][theCallbackId];\r\n      if (Object.keys(this.eventMap[eventName]).length === 0) {\r\n        delete this.eventMap[eventName];\r\n      }\r\n    };\r\n  }\r\n}\r\n\r\nexport default EventBus;\r\n```\r\n### 使用EventBus\r\n- 内部组件订阅某个事件\r\n```\r\nconst eventBus = new EventBus();\r\nconst dyxtest = () => {};\r\n\r\nuseEffect(() => {\r\n  const unsubscribe = eventBus.subscribe(\"dyxtest\", dyxtest);\r\n  return () => {\r\n    unsubscribe();\r\n  };\r\n}, []);\r\n```\r\n- 全局组件中满足条件时发布内部组件所订阅的事件\r\n```\r\neventBus.emit(\"dyxtest\");\r\n```\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## 策略模式\r\n- 定义一系列的方法，把它们封装起来，并且使它们可以相互替换。将方法的使用形式的实现分离开来。\r\n### 何时使用策略模式\r\n- 各判断条件下的策略相互独立且可复用。\r\n- 策略内部逻辑相对复杂。\r\n- 策略需要灵活组合。\r\n### 使用策略模式\r\n- 一组策略（可变），策略类封装了具体的方法，并负责具体的逻辑过程。\r\n```\r\n// 维护权限列表\r\nconst jobList = ['FE', 'BE'];\r\n\r\n// 策略\r\nconst strategies = {\r\n  checkRole: function(value) {\r\n    return value === 'juejin';\r\n  },\r\n  checkGrade: function(value) {\r\n    return value >= 1;\r\n  },\r\n  checkJob: function(value) {\r\n    return jobList.indexOf(value) > 1;\r\n  },\r\n  checkEatType: function(value) {\r\n    return value === 'eat melons';\r\n  }\r\n};\r\n```\r\n- 第二个部分是校验的方法（不变），校验的方法接收用户的调用，随后将请求委托给某一个策略。校验的方法中要维持对策略对象的引用。\r\n```\r\n// 校验规则\r\nconst Validator = function() {\r\n  this.cache = [];\r\n\r\n  // 添加策略事件\r\n  this.add = function(value, method) {\r\n    this.cache.push(function() {\r\n      return strategies[method](value);\r\n    });\r\n  };\r\n\r\n  // 检查\r\n  this.check = function() {\r\n    for (let i = 0; i < this.cache.length; i++) {\r\n      const valiFn = this.cache[i];\r\n      const data = valiFn(); // 开始检查\r\n      if (!data) {\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  };\r\n};\r\n```\r\n- 调用\r\n```\r\nconst validate = function() {\r\n  const validator = new Validator();\r\n  const data = {\r\n    role: 'juejin',\r\n    grade: 3\r\n  };\r\n  validator.add(data.role, 'checkRole');\r\n  validator.add(data.grade, 'checkGrade');\r\n  const result = validator.check();\r\n  return result;\r\n};\r\nvalidate();\r\n```\r\n\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## 装饰者模式\r\n- 装饰器是对类、函数、属性之类的一种装饰，可以针对其添加一些额外的行为。通俗的理解可以认为就是在原有代码外层包装了一层处理逻辑。\r\n### 装饰者模式应用场景\r\n- redux的connect方法。\r\n### 对原有方法或类添加功能\r\n```\r\n// 对现有的类添加功能\r\nclass Calc {\r\n  getData() {\r\n    return {\r\n      name: 'dyx'\r\n    }\r\n  }\r\n}\r\n\r\nfunction wrap(Model, key) {\r\n  // 获取class对应的原型\r\n  const target = Model.prototype;\r\n  // 获取函数对应的描述符\r\n  const descriptor = Object.getOwnPropertyDescriptor(target, key)\r\n  // 生成新的函数，添加耗时统计逻辑\r\n  const log = function(...arg) {\r\n    const start = new Date().valueOf();\r\n    try {\r\n      return descriptor.value.apply(this, arg); // 调用之前的函数\r\n    } finally {\r\n      const end = new Date().valueOf();\r\n      console.log(`start: ${start} end: ${end} consume: ${end - start}`)\r\n    }\r\n  }\r\n  // 将修改后的函数重新定义到原型链上\r\n  Object.defineProperty(target, key, {\r\n    ...descriptor,\r\n    value: log\r\n  })\r\n}\r\nwrap(Calc, 'getData');\r\nconsole.log(new Calc().getData());\r\n```\r\n### class继承多个类\r\n```\r\nclass A {\r\n  say () {\r\n    return 1;\r\n  }\r\n}\r\n\r\nclass B {\r\n  hi () {\r\n    return 2;\r\n  }\r\n}\r\n\r\nclass C {\r\n  go () {\r\n    return 3;\r\n  }\r\n}\r\n\r\nfunction mixin(constructor) {\r\n  return function(...args) {\r\n    for (const arg of args) {\r\n      for (const key of Object.getOwnPropertyNames(arg.prototype)) {\r\n        if (key === 'constructor') continue;  // 跳过构造函数\r\n        Object.defineProperty(constructor.prototype, key, Object.getOwnPropertyDescriptor(arg.prototype, key));\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nmixin(C)(A, B)\r\nconst c = new C();\r\nconsole.log(c)\r\nconsole.log(c.say())\r\nconsole.log(c.hi())\r\nconsole.log(c.go())\r\n```\r\n### 高阶组件\r\n```\r\nimport React from 'react';\r\n\r\nconst yellowHOC = WrapperComponent => {\r\n  return class extends React.Component {\r\n    render() {\r\n      return (\r\n        <div style={{ backgroundColor: 'yellow' }}>\r\n          <WrapperComponent {...this.props} />\r\n        </div>\r\n      );\r\n    }\r\n  };\r\n};\r\n\r\nexport default yellowHOC;\r\n```\r\n\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## 观察者模式\r\n- 在观察者模式中只有两个主体，分别是被观察者对象，观察者对象。\r\n### 观察者对象\r\n```\r\nclass Observer {\r\n  constructor() {\r\n    this.observers = [];\r\n  }\r\n\r\n  // 添加观察者\r\n  subscribe(callback) {\r\n    this.observers.push(callback);\r\n  }\r\n\r\n  // 移除观察者\r\n  unsubscribe(callback) {\r\n    this.observers = this.observers.filter(observer => observer !== callback);\r\n  }\r\n\r\n  // 通知观察者\r\n  notify(data) {\r\n    this.observers.forEach(observer => observer(data));\r\n  }\r\n}\r\n```\r\n### 被观察者对象\r\n```\r\nclass Subject {\r\n  constructor() {\r\n    this.observers = new Observer();\r\n    this.state = 0;\r\n  }\r\n\r\n  // 设置状态并通知观察者\r\n  setState(state) {\r\n    this.state = state;\r\n    this.observers.notify(this.state);\r\n  }\r\n}\r\n```\r\n### 使用观察者模式\r\n```\r\n// 创建观察者实例\r\nconst observerA = data => console.log(`Observer A: ${data}`);\r\nconst observerB = data => console.log(`Observer B: ${data}`);\r\nconst observerC = data => console.log(`Observer C: ${data}`);\r\n\r\n// 创建被观察者实例\r\nconst subject = new Subject();\r\n\r\n// 订阅观察者\r\nsubject.observers.subscribe(observerA);\r\nsubject.observers.subscribe(observerB);\r\n\r\n// 设置主题状态，触发通知\r\nsubject.setState(1);\r\n\r\n// 取消订阅observerA\r\nsubject.observers.unsubscribe(observerA);\r\n\r\n// 再次设置主题状态，触发通知\r\nsubject.setState(2);\r\n\r\n// 添加一个新观察者\r\nsubject.observers.subscribe(observerC);\r\n\r\n// 再次设置主题状态，触发通知\r\nsubject.setState(3);\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## 设计模式\r\n- 在面向对象软件设计的工程中，针对特定的问题简洁优雅的一种解决方案。\r\n- 通过设计模式可以增加代码的可重用性，可扩展性，可维护性，最终使得我们的代码高内聚、低耦合。\r\n### 核心\r\n> 设计模式的核心操作是去观察整个逻辑里面的变与不变，然后将变与不变分离，达到使变化的部分灵活、不变的地方稳定的目的。\r\n\r\n### 设计模式的五大设计原则\r\n- 单一职责：一个程序只需要做好一件事。如果功能过于复杂就拆分开，保证每个部分的独立。\r\n- 开放封闭原则：对扩展开放，对修改封闭。增加需求时扩展新代码而不是修改源代码。这是软件设计的终极目标。\r\n- 里氏置换原则：子类能覆盖父类，父类能出现的地方子类也能出现。\r\n- 接口独立原则：保持接口的单一独立，避免出现“胖接口”。这点目前在TS中运用到。\r\n- 依赖倒置原则：面向接口编程，依赖于抽象而不依赖于具体。使用方只专注接口而不用关注具体类的实现。俗称“鸭子类型”。\r\n\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## CORS\r\n- 跨源资源共享是一种基于HTTP头的机制，该机制通过允许服务器标示除了它自己以外的其他源，使得浏览器允许这些源访问加载服务器的资源。\r\n- 跨源资源共享还通过一种机制来检查服务器是否会允许要发送的真实请求，该机制通过浏览器发起一个到服务器托管的跨源资源的“预检”请求。在预检中浏览器发送的头中标示有HTTP方法和真实请求中会用到的请求头。\r\n### CORS功能\r\n- 跨源资源共享标准新增了一组HTTP标头字段，允许服务器声明哪些源站通过浏览器有权限访问哪些资源。\r\n- 对那些可能对服务器数据产生副作用的HTTP请求方法，浏览器必须首先使用OPTIONS方法发起一个预检请求(preflight request)，从而获知服务端是否允许该跨源请求。服务器确认允许之后浏览器才发起实际的HTTP请求。在预检请求的返回中服务器端也可以通知客户端是否需要携带身份凭证(例如Cookie和HTTP认证相关数据)。\r\n- CORS请求失败会产生错误，但是为了安全在JavaScript代码层面无法获知到底具体是哪里出了问题，只能查看浏览器的控制台以得知具体是哪里出现了错误。\r\n### CORS请求类型\r\n- 一个请求可以附带很多信息，从而会对服务器造成不同程度的影响，比如有的请求只是获取一些信息，有的请求会改动服务器的数据。\r\n- 针对不同的请求，CORS规定了三种不同的交互模式，分别是：简单请求、需要预检的请求、附带身份凭证的请求。这三种模式依次可以做的事越来越多，要求也越来越严格。\r\n### 简单请求(同时满足以下要求)\r\n> 使用请求头Origin和响应头Access-Control-Allow-Origin就能完成简单请求的访问控制。\r\n\r\n- 使用下列方法之一\r\n    - GET\r\n    - HEAD\r\n    - POST\r\n- 除了被用户代理自动设置的请求头(例如Connection、User-Agent等)，允许人为设置的请求头字段如下\r\n    - Accept\r\n    - Accept-Language\r\n    - Content-Language\r\n    - Content-Type(需要注意额外的限制)\r\n    - Range(只允许简单的范围请求头值如 bytes=256- 或 bytes=127-255)\r\n- Content-Type请求头所指定的媒体类型的值仅限于下列之一\r\n    - text/plain\r\n    - multipart/form-data\r\n    - application/x-www-form-urlencoded\r\n- 如果请求是使用XMLHttpRequest对象发出的，在返回的XMLHttpRequest.upload对象属性上没有注册任何事件监听器。给定一个XMLHttpRequest实例xhr，没有调用 xhr.upload.addEventListener()监听该上传请求。\r\n- 请求中没有使用ReadableStream对象。\r\n### 需要预检的请求\r\n> 需要预检的请求必须首先使用OPTIONS方法发起一个预检请求到服务器，以获知服务器是否允许该实际请求。预检请求的使用可以避免跨域请求对服务器的数据产生未预期的影响。\r\n\r\n1. 浏览器发送预检请求，询问服务器是否允许后续的真实请求\r\n    - 请求方法为OPTIONS。\r\n    - 请求中不包含真实请求定义的请求头内容，也没有请求体。\r\n    - 请求头中包含Origin：请求的源；Access-Control-Request-Method：后续的真实请求将使用的请求方法；Access-Control-Request-Headers：后续的真实请求会使用的请求头。\r\n2. 服务器收到预检请求\r\n    - 服务器收到预检请求后检查预检请求中包含的信息。\r\n    - 如果允许这样的请求不需要响应任何的消息体，响应头会包含Access-Control-Allow-Origin：表示允许的源；Access-Control-Allow-Methods：表示允许的后续真实的请求方法；Access-Control-Allow-Headers：表示允许使用的请求头；Access-Control-Max-Age：告诉浏览器多少秒内对于同样的请求源、方法、请求头都不需要再发送预检请求了。\r\n3. 浏览器判断预检请求响应头决定是否发起后续真实请求\r\n    - 预检请求允许后续请求时，浏览器发送真实请求，服务器完成真实请求的响应。\r\n    - 预检请求不允许后续请求时，浏览器不发送真实请求，浏览器network面板可以看到真实请求发送报CORS错误，其实服务端不会收到真实请求。\r\n### 附带身份凭证的请求\r\n> 默认情况下ajax的跨域请求并不会附带Cookie，这样某些需要权限的操作就无法进行，可以通过设置credentials实现跨域请求附带Cookie。\r\n\r\n```\r\n// xhr\r\nvar xhr = new XMLHttpRequest();\r\nxhr.withCredentials = true;\r\n\r\n// fetch api\r\nfetch(url, {\r\n  credentials: 'include',\r\n});\r\n```\r\n- 当发起一个附带身份凭证的跨域请求时(无论是简单请求还是需要预检的请求)，服务器响应时需要在响应头中添加Access-Control-Allow-Credentials: true。若服务器没有明确告知客户端服务器允许这样的凭据，浏览器仍然视为跨域被拒绝。\r\n- 特别注意的是对于附带身份凭证的请求，服务器不得设置Access-Control-Allow-Origin、Access-Control-Allow-Headers、Access-Control-Allow-Methods的值为*。\r\n### 跨域请求时JS使用响应头\r\n- 在跨域访问时JS只能拿到一些最基本的响应头如Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma，如果要访问其它响应头则需要服务器特殊设置。\r\n- 通过设置Access-Control-Expose-Headers响应头，服务器把允许浏览器访问的头放入白名单，这样JS就能够访问指定的响应头了。\r\n```\r\nAccess-Control-Expose-Headers: authorization, a, b\r\n```\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## 跨域\r\n- 浏览器有一个重要的安全策略为同源策略。\r\n- 源 = 协议 + 主机 + 端口。\r\n- 两个源相同称之为同源，两个源不同称之为跨源或跨域。\r\n### 同源策略\r\n- 同源策略是指若页面的源和页面运行过程中加载的源不一致时，浏览器出于安全考虑会对跨域的资源访问进行一些限制。\r\n### 非同源的限制\r\n- 不能读取和修改对方的DOM。\r\n- 不能访问对方的Cookie、IndexDB和WebStorage。\r\n- 限制ajax请求。\r\n### 跨域请求\r\n- 当浏览器向目标地址发起ajax请求时，只要当前URL和目标URL不同源则产生跨域，被称为跨域请求。\r\n- 跨域请求的响应会被浏览器所拦截，服务端会收到请求，请求响应也会正常到达客户端只是被浏览器拦截。\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## 跨域解决方案\r\n### webpack的proxy代理(只能用于开发阶段)\r\n- 通过webpack-dev-server的proxy实现代理，前端请求通过中间服务器进行转发。\r\n### nginx反向代理\r\n- 反向代理收到客户端的请求后将请求转发给其它服务器。\r\n- 反向代理主要的场景是维持服务器集群的负载均衡。\r\n```\r\n// nginx相当于起了一个跳板机，这个跳板机的域名是client.com(客户端的域名client.com)，客户端首先访问client.com/api是没有跨域的，然后nginx服务器作为反向代理将请求转发给server.com，当响应返回时又将响应返回给客户端，这就完成整个跨域请求的过程。\r\n\r\nserver {\r\n  listen  80;\r\n  server_name  client.com;\r\n  location /api {\r\n    proxy_pass server.com;\r\n  }\r\n}\r\n```\r\n### CORS\r\n- 跨源资源共享是一种基于HTTP头的机制，该机制通过允许服务器标示除了它自己以外的其它源，使得浏览器允许这些源访问加载自己的资源。浏览器要跨域访问服务器的资源，需要获得服务器的允许。\r\n### JSONP\r\n- 虽然XMLHttpRequest对象遵循同源政策，但是script标签不一样，它可以通过src填上目标地址从而发出GET请求，实现跨域请求并拿到响应，这也就是JSONP的原理。\r\n- 优点：和CORS相比JSONP最大的优势在于兼容性好，IE低版本不能使用CORS但可以使用JSONP。\r\n- 缺点：请求方法单一，只支持GET请求。\r\n```\r\nconst jsonp = ({ url, params, callbackName }) => {\r\n  const generateUrl = () => {\r\n    let dataSrc = ''\r\n    for (let key in params) {\r\n      if (params.hasOwnProperty(key)) {\r\n        dataSrc += `${key}=${params[key]}&`\r\n      }\r\n    }\r\n    dataSrc += `callback=${callbackName}`\r\n    return `${url}?${dataSrc}`\r\n  }\r\n  return new Promise((resolve, reject) => {\r\n    const scriptEle = document.createElement('script')\r\n    scriptEle.src = generateUrl()\r\n    document.body.appendChild(scriptEle)\r\n    window[callbackName] = data => {\r\n      resolve(data)\r\n      document.removeChild(scriptEle)\r\n    }\r\n  })\r\n}\r\n\r\n// 使用\r\njsonp({\r\n  url: 'http://localhost:3000',\r\n  params: { \r\n    a: 1,\r\n    b: 2\r\n  }\r\n}).then(data => {\r\n  // 拿到数据进行处理\r\n  console.log(data);\r\n})\r\n```\r\n### chrome设置允许跨域(只能用于开发阶段)\r\n- windows\r\n```\r\n新建一个chrome快捷方式，右键“属性”。\r\n“快捷方式”选项卡里选择“目标”，添加 --args --disable-web-security --user-data-dir\r\n```\r\n- mac\r\n```\r\nopen -n /Applications/Google\\ Chrome.app/ --args --disable-web-security --ignore-certificate-errors --user-data-dir=/Users/${此处完成用户名}/MyChromeDevUserData/\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## hash路由\r\n- hash路由模式不需要服务端特殊处理。\r\n- url中接一个#，#后的值就是哈希值，在浏览器url后加个哈希值，哈希值的变更不会引起浏览器页面的刷新。通过window.location.href或window.location.replace改变哈希值。\r\n```\r\nwindow.location.href = '';\r\nwindow.location.replace = '';\r\n```\r\n- hashchange事件可以自动监听hash值的变更，从而更新页面内容。a标签跳转、浏览器前进后退、window.location方法都会触发hashchange事件。\r\n```\r\nwindow.addEventListener('hashchange', (e) => {\r\n  /* 监听改变 */\r\n  const oldURL = e.oldURL; // 改变后旧的页面路径\r\n  const newURL = e.newURL; // 改变后新的页面路径\r\n});\r\n```\r\n### demo\r\n```\r\n<body>\r\n  <ul>\r\n    <li><a href=\"#/home\">首页</a></li> \r\n    <li><a href=\"#/about\">关于</a></li>\r\n  </ul>\r\n\r\n  <div id=\"routeView\"></div>\r\n\r\n  <script>\r\n    const routes = [\r\n      {\r\n        path: '#/home',\r\n        component: '首页内容'\r\n      },\r\n      {\r\n        path: '#/about',\r\n        component: '关于页面内容'\r\n      }\r\n    ];\r\n      \r\n    const routeView = document.getElementById('routeView')\r\n    window.addEventListener('DOMContentLoaded', onHashChange) \r\n    window.addEventListener('hashchange', onHashChange)\r\n    \r\n    function onHashChange() {\r\n      routes.forEach((item, index) => {\r\n        if (item.path === location.hash) {\r\n          routeView.innerHTML = item.component\r\n        }\r\n      })\r\n    }\r\n  <\/script>\r\n</body>\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## history路由\r\n- history路由模式如果跳转路由后再次刷新会出现404的错误，这个错误是因为浏览器把整个地址当成一个可访问的静态资源路径进行访问，然后服务端并没有这个文件。所以一般情况需要配置下nginx的try_files参数，当访问的路径资源不存在的时候默认指向静态资源index.html。\r\n- 通过history.pushState或history.replaceState修改url且不引起页面的刷新。\r\n```\r\nhistory.pushState(state, title, path);\r\nhistory.replaceState(state, title, path);\r\n```\r\n- 通过popstate事件监听history模式下url改变，从而更新页面内容。\r\n  1. popstate事件只会在浏览器某些行为下触发, 比如点击后退、前进按钮或者调用history.back()、history.forward()、history.go()方法。\r\n  2. history.pushState()或者history.replaceState()改变url不会触发popstate事件。\r\n```\r\nwindow.addEventListener('popstate', () => {\r\n  /* 监听改变 */\r\n});\r\n```\r\n### history.pushState()或者history.replaceState()不会触发popstate事件\r\n- 通过dispatchEvent改写这两个方法实现对这两个方法的监听。\r\n```\r\nconst _wr = (type) => {\r\n  const orig = history[type];\r\n  return function () {\r\n    const rv = orig.apply(this, arguments);\r\n    const e = new Event(type);\r\n    e.arguments = arguments;\r\n    window.dispatchEvent(e);\r\n    return rv;\r\n  }\r\n}\r\n\r\nhistory.pushState = _wr('pushState');\r\nhistory.replaceState = _wr('replaceState');\r\n\r\nwindow.addEventListener('pushState', () => {\r\n  /* 监听改变 */\r\n});\r\nwindow.addEventListener('replaceState', () => {\r\n  /* 监听改变 */\r\n});\r\n```\r\n- 调用history.pushState()或者history.replaceState()时手动触发页面内容更新。\r\n  1. 首先生成一个最新的location对象。\r\n  2. 然后通过window.history.pushState或者window.history.replaceState方法改变浏览器当前url。\r\n  3. 最后手动触发组件更新，并传递当前最新的location对象。\r\n### demo\r\n```\r\n<body>\r\n  <ul>\r\n    <li><a href=\"/home\">首页</a></li> \r\n    <li><a href=\"/about\">关于</a></li>\r\n  </ul>\r\n\r\n  <div id=\"routeView\"></div>\r\n\r\n  <script>\r\n    const routes = [\r\n      {\r\n        path: '/home',\r\n        component: '首页内容'\r\n      },\r\n      {\r\n        path: '/about',\r\n        component: '关于页面内容'\r\n      }\r\n    ]\r\n    \r\n    const routeView = document.getElementById('routeView')\r\n    window.addEventListener('DOMContentLoaded', onLoad)\r\n    window.addEventListener('popstate', onPopState)\r\n\r\n    function onLoad() {\r\n      const links = document.querySelectorAll('li a')\r\n      links.forEach((a) => {\r\n        a.addEventListener('click', (e) => {\r\n          e.preventDefault()\r\n          history.pushState(null, '', a.getAttribute('href'))\r\n          onPopState()\r\n        })\r\n      })\r\n    }\r\n\r\n    function onPopState() {\r\n      routes.forEach((item) => {\r\n        if (item.path === location.pathname) {\r\n          routeView.innerHTML = item.component\r\n        }\r\n      })\r\n    }\r\n  <\/script>\r\n</body>\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## 路由\r\n- 路由一词最早来自服务器，和前端没有关系。\r\n- 当想要从服务器中读取某个盘的文件，这个文件的路径就是路由。路由是服务器端用来描述路径的，或者说是url和文件的映射关系。\r\n### 前端路由\r\n- 前端的SPA单页应用借鉴了路由这个概念，浏览器的url改变后需要映射到页面的某个组件，前端路由是url和组件的映射关系。\r\n- 前端路由使得SPA单页应用能够在用户与应用交互时动态地加载不同的视图，而无需每次都重新加载整个页面。\r\n### 实现前端路由需要解决的问题\r\n- 如何修改url不引起页面的刷新。\r\n- 如何知道url变化从而更新页面内容。"},function(r,n,e){"use strict";e.r(n),n.default="## flvjs播放直播流\r\n**火狐浏览器不支持使用flv.js播放flv资源，因为火狐不支持265视频编码**\r\n### 安装依赖\r\n```\r\nnpm install flv.js\r\n```\r\n### 播放直播流\r\n```\r\nimport flvjs from 'flv.js';\r\n\r\nif (flvjs.isSupported()) {\r\n  const videoDom = document.getElementById('video');\r\n  const flvPlayer = flvjs.createPlayer({\r\n    type: 'flv',\r\n    isLive: true,\r\n    cors: true,\r\n    hasAudio: false,\r\n    hasVideo: true,\r\n    url: liveUrl\r\n  }); // 创建flvPlayer\r\n  flvPlayer.attachMediaElement(videoDom); // 挂载元素\r\n  flvPlayer.load(); // 加载视频流\r\n  flvPlayer.play(); // 播放视频流\r\n}\r\n```\r\n### 销毁flv播放器\r\n```\r\nflvPlayer.pause();\r\nflvPlayer.unload();\r\nflvPlayer.detachMediaElement();\r\nflvPlayer.destroy();\r\n```\r\n### 获取单位时间获取的数据量\r\n- 当推流速度快于播放速度时，后面正常播放但是不再获取数据会显示0。\r\n```\r\nflvPlayer.on('statistics_info', (res) => {\r\n  console.log(res.speed); // KB/S\r\n});\r\n```\r\n### 页面不可见时会暂停拉流\r\n- mpegtsjs、flv.js在页面不可见时不会暂停播放停止拉流。\r\n### The play() request was interrupted by a call to pause()错误\r\n> 错误原因是因为在播放视频(play方法)之前被调用的pause方法中断了。\r\n\r\n- 资源加载不成功(直播流链接错误)，导致没有资源可以播放。\r\n- 时机不对，可添加定时器处理。\r\n```\r\nflvPlayer.load();\r\nsetTimeout(() => {\r\n  flvPlayer.play();\r\n}, '时间')\r\n```\r\n### 追帧\r\n> 直播暂停后继续播放时切换到最新的画面帧。\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## video\r\n### autoplay\r\n- 视频就绪后自动播放。\r\n- 设置autoplay属性没有效果时给video标签加上muted属性静音播放就可以自动播放了，原因是谷歌浏览器和火狐浏览器不支持非静音自动播放。\r\n- 网站url前方按钮打开网站设置，将声音设置的自动（默认）修改为允许，刷新网页之后就可以支持非静音自动播放了。\r\n### controls\r\n- 控制是否显示视频操作控件，默认为true。\r\n### muted\r\n- 是否禁音，默认为true。\r\n### controlslist属性\r\n- 三种属性值取值如下，空格隔开，可单独配置\r\n  1. nodownload：取消更多控件弹窗的下载功能。\r\n  2. nofullscreen：取消全屏功能。\r\n  3. noremoteplayback：取消远程播放视频功能。\r\n### 媒体事件\r\n- 播放\r\n```\r\nvideo.play();\r\n```\r\n- 暂停\r\n```\r\nvideo.pause();\r\n```\r\n- 全屏\r\n```\r\nvideo.webkitRequestFullScreen();\r\n```\r\n- 获取播放进度时间\r\n> 视频暂停后继续播放currentTime会从0重新开始更新。\r\n\r\n```\r\nvideo.currentTime\r\n```\r\n- 获取播放总时长\r\n```\r\nvideo.duration\r\n```\r\n- 改变音量\r\n```\r\n// 设置为0 - 1的数字\r\nvideo.volume = 0.5;\r\n```\r\n- 设置倍速播放\r\n```\r\n// rate一般在[2, 1.75, 1.5, 1.0, 0.75, 0.5]范围\r\nvideo.playbackRate = rate;\r\n```\r\n### 媒体事件监听\r\n- play：开始播放时触发\r\n```\r\nvideo.addEventListener('play', () => {});\r\n```\r\n- pause：暂停播放时触发\r\n```\r\nvideo.addEventListener('pause', () => {});\r\n```\r\n- waiting：视频加载中\r\n```\r\nvideo.addEventListener('waiting', () => {});\r\n```\r\n- ended：播放结束时触发\r\n```\r\nvideo.addEventListener('ended', () => {});\r\n```\r\n- timeupdate：播放时间发生变化时触发，可配合实现自定义进度条\r\n```\r\nvideo.addEventListener('timeupdate', () => {});\r\n```\r\n- canplay：可以开始播放时触发，表示已经加载到足够的数据供播放\r\n```\r\nvideo.addEventListener('canplay', () => {});\r\n```\r\n- loadedmetadata：当媒体的元数据加载完成时触发\r\n```\r\nvideo.addEventListener('loadedmetadata', () => {\r\n  console.log(video.duration);\r\n  console.log(video.videoWidth);\r\n  console.log(video.videoHeight);\r\n});\r\n```\r\n- seeking：用户开始移动/跳跃到新的音频/视频播放位置时触发，拖动进度条如果需要加载资源会触发seeking事件。\r\n```\r\nvideo.addEventListener('seeking', () => {});\r\n```\r\n- seeked：用户已移动/跳跃到音频/视频中的新位置时触发，拖动进度条如果可以直接播放会触发seeked事件。\r\n```\r\nvideo.addEventListener('seeked', () => {});\r\n```\r\n- error：当媒体加载或播放过程发生错误时触发\r\n```\r\nvideo.addEventListener('error', () => {});\r\n```\r\n### 控制video控件的显示\r\n```\r\n// 隐藏全屏按钮\r\nvideo::-webkit-media-controls-fullscreen-button {\r\n  display: none;\r\n}\r\n// 隐藏播放按钮\r\nvideo::-webkit-media-controls-play-button {\r\n  display: none;\r\n}\r\n// 隐藏进度条\r\nvideo::-webkit-media-controls-timeline {\r\n  display: none;\r\n}\r\n// 隐藏观看的当前时间\r\nvideo::-webkit-media-controls-current-time-display {\r\n  display: none;\r\n}\r\n// 隐藏剩余时间\r\nvideo::-webkit-media-controls-time-remaining-display {\r\n  display: none;\r\n}\r\n// 隐藏音量按钮\r\nvideo::-webkit-media-controls-mute-button {\r\n  display: none; \r\n}\r\n// 隐藏音量的控制条\r\nvideo::-webkit-media-controls-volume-slider {\r\n  display: none;\r\n}\r\n// 隐藏所有控件\r\nvideo::-webkit-media-controls-enclosure{ \r\n  display: none;\r\n}\r\n```\r\n### 视频初始加载显示loading的处理\r\n- 组件初次渲染时loading属性默认为true显示加载效果，当视频元数据加载时取消loading。\r\n### 视频播放过程中卡顿显示loading的处理\r\n- 视频卡顿时显示loading通过监听onWaiting事件实现。\r\n- 不卡顿时取消loading通过监听onCanPlay事件实现。\r\n### 样式设置\r\n- video最大宽度、最大高度设置100%时外层容器要设置overflow: hidden。\r\n- object-fit可以指定元素的内容应该如何去适应指定容器的高度与宽度。可以对img、video元素进行保留原始比例的剪切、缩放或者直接进行拉伸等。"},function(r,n,e){"use strict";e.r(n),n.default="## [xgPlayer](https://h5player.bytedance.com/)\r\n### 使用xgplayer-flv播放直播流\r\n- 播放直播流时不支持显示播放进度条和播放时间。\r\n- 在播放回放直播时推流速度快于播放速度时会自动追帧。\r\n- 默认点击暂停按钮会停止拉流、重新播放后重新开始拉流。\r\n- 页面隐藏时会触发pause事件停止拉流，页面显示后会重新播放开始拉流。\r\n### error事件\r\n- readyState(mediaElement readyState)为0时表示没有媒体资源数据，播放器显示网络错误请刷新。视频机不推流导致。\r\n- readyState(mediaElement readyState)为2时表示数据已经可以播放(当前位置已经加载)但没有数据能播放下一帧的内容，播放器显示重播。网络错误或者视频机推流慢导致。\r\n- readyState(mediaElement readyState)为4时可用数据足以开始播放 - 如果网速得到保障 那么视频可以一直播放到底，播放器显示网络错误请刷新。网络错误导致。\r\n### 设置播放事件前置处理\r\n- 自动播放以及暂停之后重新播放都会触发play事件。\r\n```\r\nplayer.setEventsMiddleware({\r\n  play: async (e: any, callback: any) => {\r\n    if (canPlay) {\r\n      // 可直接播放时callback\r\n      callback(e.eventName, e);\r\n    } else {\r\n      // 不可播放时请求接口后再callback\r\n      // ...\r\n      callback(e.eventName, e);\r\n    }\r\n  }\r\n})\r\n```\r\n- playing事件不是暂停后恢复播放触发而是在播放过程中一直触发。"},function(r,n,e){"use strict";e.r(n),n.default="## 回放直播流支持进度条拖拽\r\n### 西瓜播放器\r\n- 播放直播流不显示进度条。\r\n- 播放时如果推流速度快于正常播放速度，会自动追帧到最新推流的内容。\r\n### 使用原生video的进度条和flvjs\r\n- 修改推流时间节点时如果内容已经加载了会出现时间戳错乱的问题，如果没有加载可以正常播放。\r\n### 自定义原生video的进度条\r\n- 自定义进度条修改进度条后修改推流时间节点可以正常播放但是推流的内容会变慢。\r\n"},,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,function(r,n,e){"use strict";Object.defineProperty(n,"__esModule",{value:!0});n.isPC=function(){for(var r=navigator.userAgent,n=["Android","iPhone","ymbianOS","Windows Phone","iPad","iPod"],e=!0,t=0;t<n.length;t++)if(r.indexOf(n[t])>0){e=!1;break}return e}},function(r,n,e){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.default=void 0;var t,o,s=f(e(138)),a=function(){function r(r,n){for(var e=0;e<n.length;e++){var t=n[e];t.enumerable=t.enumerable||!1,t.configurable=!0,"value"in t&&(t.writable=!0),Object.defineProperty(r,t.key,t)}}return function(n,e,t){return e&&r(n.prototype,e),t&&r(n,t),n}}();e(405);var i=e(1),c=f(i),l=e(72),u=f(e(137)),d=f(e(998)),p=f(e(996)),m=f(e(44));function f(r){return r&&r.__esModule?r:{default:r}}function h(r,n){if(!(r instanceof n))throw new TypeError("Cannot call a class as a function")}function g(r,n){if(!r)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!n||"object"!=typeof n&&"function"!=typeof n?r:n}var b=s.default.SubMenu,v=(t=(0,m.default)(p.default),(0,l.withRouter)(o=t(o=function(r){function n(){return h(this,n),g(this,(n.__proto__||Object.getPrototypeOf(n)).apply(this,arguments))}return function(r,n){if("function"!=typeof n&&null!==n)throw new TypeError("Super expression must either be null or a function, not "+typeof n);r.prototype=Object.create(n&&n.prototype,{constructor:{value:r,enumerable:!1,writable:!0,configurable:!0}}),n&&(Object.setPrototypeOf?Object.setPrototypeOf(r,n):r.__proto__=n)}(n,r),a(n,[{key:"render",value:function(){var r=this.props,n=r.location.pathname,e=r.menuConfig,t=r.defaultOpenKeys,o=(e||[]).find((function(r){return(0,d.default)(r.submenu)?n===r.key:r.submenu.find((function(r){return r.key===n}))}));return o=o?(0,d.default)(o.submenu)?o.key:(0,u.default)(o.submenu.find((function(r){return r.key===n})),"key"):"",c.default.createElement("div",{styleName:"left-nav"},c.default.createElement(s.default,{mode:"inline",selectedKeys:[o],defaultOpenKeys:t||[]},(e||[]).map((function(r){return(r.submenu||[]).length>0?c.default.createElement(b,{key:r.key,title:r.label},r.submenu.map((function(r){return c.default.createElement(s.default.Item,{key:r.key},c.default.createElement(l.Link,{to:r.key,title:r.label},r.label))}))):c.default.createElement(s.default.Item,{key:r.key},c.default.createElement(l.Link,{to:r.key,title:r.label},r.label))}))))}}]),n}(i.Component))||o)||o);n.default=v},function(r,n,e){var t=e(997);"string"==typeof t&&(t=[[r.i,t,""]]);var o={hmr:!0,transform:void 0,insertInto:void 0};e(25)(t,o);t.locals&&(r.exports=t.locals)},function(r,n,e){(n=r.exports=e(24)(!1)).push([r.i,".index__left-nav--pdueK {\n  height: calc(100vh - 49px);\n  overflow-y: auto;\n  -webkit-flex-shrink: 0;\n  -ms-flex-negative: 0;\n  flex-shrink: 0;\n  border-right: 1px solid #eee;\n}\n.index__left-nav--pdueK .ant-menu {\n  width: 256px;\n}\n.index__left-nav--pdueK .ant-menu .ant-menu-item {\n  width: 100% !important;\n}\n.index__left-nav--pdueK .ant-menu .ant-menu-item a {\n  width: 100%;\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n.index__left-nav--pdueK .ant-menu-inline,\n.index__left-nav--pdueK .ant-menu-vertical,\n.index__left-nav--pdueK .ant-menu-vertical-left {\n  border: none;\n}\n.index__left-nav--pdueK .ant-menu-inline .ant-menu-item,\n.index__left-nav--pdueK .ant-menu-inline .ant-menu-submenu-title {\n  width: 100%;\n}\n@media only screen and (max-width: 700px) {\n  .index__left-nav--pdueK .ant-menu {\n    width: 100px;\n  }\n}\n",""]),n.locals={"left-nav":"index__left-nav--pdueK"}},,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,function(r,n,e){"use strict";Object.defineProperty(n,"__esModule",{value:!0});o(e(1));var t=o(e(1312));function o(r){return r&&r.__esModule?r:{default:r}}n.default={allScreen:[],partScreen:[{exact:!0,path:"/interview/:classification/:name",component:t.default}]}},function(r,n,e){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.default=void 0;var t,o=p(e(64)),s=function(){function r(r,n){for(var e=0;e<n.length;e++){var t=n[e];t.enumerable=t.enumerable||!1,t.configurable=!0,"value"in t&&(t.writable=!0),Object.defineProperty(r,t.key,t)}}return function(n,e,t){return e&&r(n.prototype,e),t&&r(n,t),n}}();e(63);var a=p(e(1)),i=p(e(44)),c=p(e(156)),l=p(e(137)),u=p(e(157)),d=p(e(1313));function p(r){return r&&r.__esModule?r:{default:r}}function m(r,n){if(!(r instanceof n))throw new TypeError("Cannot call a class as a function")}function f(r,n){if(!r)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!n||"object"!=typeof n&&"function"!=typeof n?r:n}var h=new u.default.Converter,g=e(425).keys().map((function(r){var n=r.split("/");if(3===n.length){var e=n[1],t=n[2].replace(".md","");return{key:"/interview/"+e+"/"+t,label:e+"/"+t}}})),b=(0,i.default)(d.default)(t=function(r){function n(){var r,e,t;m(this,n);for(var s=arguments.length,a=Array(s),i=0;i<s;i++)a[i]=arguments[i];return e=t=f(this,(r=n.__proto__||Object.getPrototypeOf(n)).call.apply(r,[this].concat(a))),t.copyCode=function(r){var n=r&&r.innerText;if(navigator.clipboard)navigator.clipboard.writeText(n).then((function(){o.default.success("复制成功")}),(function(r){o.default.error("复制失败")}));else{var e=document.createElement("textarea");e.value=n,e.style.position="fixed",document.body.appendChild(e),e.focus(),e.select();try{document.execCommand("copy");o.default.success("复制成功")}catch(r){o.default.error("复制失败")}document.body.removeChild(e)}},t.hightLight=function(){var r=document.getElementById("category-md").getElementsByTagName("pre"),n=document.createElement("div");n.setAttribute("class","pre-code"),n.innerText="复制",(Array.from(r)||[]).forEach((function(r){r.setAttribute("style","position: relative"),r.appendChild(n),c.default.highlightBlock(r)})),Array.from(document.querySelectorAll(".pre-code")).forEach((function(r){return r.addEventListener("click",(function(){return t.copyCode(r.previousSibling)}))}))},t.jump=function(r){t.props.history.push(g[r].key)},f(t,e)}return function(r,n){if("function"!=typeof n&&null!==n)throw new TypeError("Super expression must either be null or a function, not "+typeof n);r.prototype=Object.create(n&&n.prototype,{constructor:{value:r,enumerable:!1,writable:!0,configurable:!0}}),n&&(Object.setPrototypeOf?Object.setPrototypeOf(r,n):r.__proto__=n)}(n,r),s(n,[{key:"componentDidMount",value:function(){this.hightLight()}},{key:"componentDidUpdate",value:function(){var r=document.querySelector(".right-content");r&&(r.scrollTop=0),this.hightLight()}},{key:"componentWillUnMount",value:function(){Array.from(document.querySelectorAll(".pre-code")).removeEventListener("click",this.copyCode)}},{key:"render",value:function(){var r=this,n=(0,l.default)(this.props,"match.params.classification"),t=(0,l.default)(this.props,"match.params.name"),o=g.findIndex((function(r){return r.label===n+"/"+t})),s=o+1,i=o-1;return o===g.length-1&&(s=0),0===o&&(i=g.length-1),a.default.createElement("div",{styleName:"content"},a.default.createElement("div",{styleName:"top"},a.default.createElement("div",{onClick:function(){return r.jump(i)}},"上一篇：",g[i].label),a.default.createElement("div",{onClick:function(){return r.jump(s)}},"下一篇：",g[s].label)),a.default.createElement("div",{styleName:"category-md",dangerouslySetInnerHTML:{__html:h.makeHtml(e(1315)("./"+n+"/"+t+".md").default)},id:"category-md"}))}}]),n}(a.default.Component))||t;n.default=b},function(r,n,e){var t=e(1314);"string"==typeof t&&(t=[[r.i,t,""]]);var o={hmr:!0,transform:void 0,insertInto:void 0};e(25)(t,o);t.locals&&(r.exports=t.locals)},function(r,n,e){(n=r.exports=e(24)(!1)).push([r.i,".index__content--3YxyC {\n  width: 100%;\n}\n.index__content--3YxyC .index__top--3YZi9 {\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-box-pack: justify;\n  -webkit-justify-content: space-between;\n  -ms-flex-pack: justify;\n  justify-content: space-between;\n  -webkit-flex-wrap: wrap;\n  -ms-flex-wrap: wrap;\n  flex-wrap: wrap;\n  font-size: 14px;\n  margin-bottom: 24px;\n  color: #1890ff;\n  cursor: pointer;\n}\n.index__content--3YxyC .index__category-md--3yiT5 {\n  width: 100%;\n}\n.index__content--3YxyC .index__category-md--3yiT5 blockquote {\n  padding: 8px;\n  line-height: 24px;\n  color: #666;\n  margin: 8px 0;\n  border-left: 4px solid #cbcbcb;\n  background-color: #f8f8f8;\n}\n.index__content--3YxyC .index__category-md--3yiT5 blockquote p {\n  margin: 0;\n}\n.index__content--3YxyC .index__category-md--3yiT5 .pre-code {\n  position: absolute;\n  top: 8px;\n  right: 8px;\n  cursor: pointer;\n}\n",""]),n.locals={content:"index__content--3YxyC",top:"index__top--3YZi9","category-md":"index__category-md--3yiT5"}},function(r,n,e){var t={"./Immutable/Immutable Data.md":426,"./Immutable/react中使用Immutable Data.md":427,"./Web Worker/Service Worker.md":428,"./Web Worker/Shared Worker.md":429,"./Web Worker/Web Worker.md":430,"./Web Worker/react中使用Web Worker.md":431,"./WebSocket/SSE.md":432,"./WebSocket/WebSocket.md":433,"./WebSocket/WebSocket心跳.md":434,"./WebSocket/断网时现象.md":435,"./babel/Babel.md":436,"./babel/Babel配置.md":437,"./cli/cli.md":438,"./css/bfc.md":439,"./css/css.md":440,"./css/css3.md":441,"./css/css变量.md":442,"./css/css选择器-child和-of-type的使用差异.md":443,"./css/css选择器.md":444,"./css/flex.md":445,"./css/grid.md":446,"./css/scss变量.md":447,"./css/伪类伪元素.md":448,"./css/居中.md":449,"./css/换行.md":450,"./css/样式隔离.md":451,"./css/浮动.md":452,"./css/父元素使用max-height，子元素使用百分比不生效.md":453,"./css/盒子模型.md":454,"./css/网页变黑白颜色.md":455,"./css/雪碧图.md":456,"./diff/React、Vue3、Vue2 列表的 Diff 算法对比.md":457,"./diff/react Diff.md":458,"./diff/react Diff更新.md":459,"./docker/copy命令.md":460,"./docker/docker.md":461,"./docker/docker常用命令.md":462,"./docker/docker镜像.md":463,"./fiber/FiberNode.md":464,"./git/fetch和merge的区别.md":465,"./git/git提交规范.md":466,"./git/rebase和merge的区别.md":467,"./html/css加载.md":468,"./html/meta.md":469,"./html/修改页签icon.md":470,"./html/搜索引擎优化.md":471,"./html/页面可见性.md":472,"./html/页面生命周期.md":473,"./http/Accept系列字段.md":474,"./http/URI.md":475,"./http/dns.md":476,"./http/http.md":477,"./http/http2.md":478,"./http/https.md":479,"./http/http代理.md":480,"./http/http状态码.md":481,"./http/http请求方法.md":482,"./http/三次握手.md":483,"./http/四次挥手.md":484,"./http/头.md":485,"./http/定长不定长的数据处理.md":486,"./http/队头阻塞.md":487,"./http缓存/http缓存.md":488,"./http缓存/协商缓存.md":489,"./http缓存/启发式缓存.md":490,"./http缓存/强缓存.md":491,"./http缓存/最佳实践.md":492,"./http缓存/浏览器刷新.md":493,"./http缓存/缓存位置.md":494,"./js/==和===.md":495,"./js/Array.md":496,"./js/ES6.md":497,"./js/Generator和协程.md":498,"./js/Map.md":499,"./js/Object.defineProperty.md":500,"./js/ResizeObserver.md":501,"./js/Set.md":502,"./js/Symbol.md":503,"./js/WebComponent.md":504,"./js/a == 1 && a == 2 && a == 3.md":505,"./js/arguments.md":506,"./js/async在循环中使用的问题.md":507,"./js/async的错误捕获.md":508,"./js/beforeunload事件.md":509,"./js/encodeURI和encodeURIComponent的异同.md":510,"./js/esModule和commonjs的区别.md":511,"./js/forEach的局限.md":512,"./js/hasOwnProperty与in的区别.md":513,"./js/js事件流.md":514,"./js/js加载方式.md":515,"./js/new操作符.md":516,"./js/promise.md":517,"./js/promiseAll控制并发.md":518,"./js/requestIdleCallback.md":519,"./js/setTimeout和setInterval.md":520,"./js/this.md":521,"./js/var let const差异.md":522,"./js/事件委托.md":523,"./js/事件循环eventLoop.md":524,"./js/作用域.md":525,"./js/前端获取网络信息.md":526,"./js/图像懒加载和预加载.md":527,"./js/实现准时的setTimeout.md":528,"./js/对象创建.md":529,"./js/异步处理方案.md":530,"./js/数据类型及判断方法.md":531,"./js/浏览器页面不可见时定时器是否准时.md":532,"./js/浮点数精度丢失.md":533,"./js/深浅拷贝.md":534,"./js/渲染大量数据.md":535,"./js/箭头函数与普通函数的区别.md":536,"./js/类和原型实现相同功能.md":537,"./js/类型转换.md":538,"./js/继承.md":539,"./js/节流与防抖.md":540,"./js/运算符.md":541,"./js/闭包.md":542,"./js/预解析.md":543,"./js/高级函数用法.md":544,"./js内存/优化内存使用.md":545,"./js内存/内存泄漏场景.md":546,"./js内存/内存管理机制.md":547,"./js内存/垃圾回收.md":548,"./monorepo/lerna + Yarn Workspace.md":549,"./monorepo/pnpm-monorepo.md":550,"./monorepo/项目依赖管理.md":551,"./nginx/IP黑白名单.md":552,"./nginx/gzip压缩.md":553,"./nginx/location.md":554,"./nginx/nginx.md":555,"./nginx/proxy_pass.md":556,"./nginx/root和alias.md":557,"./nginx/try_files.md":558,"./nginx/常用命令.md":559,"./nginx/常用配置.md":560,"./nginx/正向代理反向代理.md":561,"./nginx/解决跨域问题.md":562,"./nginx/负载均衡.md":563,"./nginx/配置SSL证书.md":564,"./nginx/防盗链.md":565,"./node/node安装.md":566,"./node/node执行命令添加参数.md":567,"./node/nvm.md":568,"./node/path.md":569,"./npm/npm run xxx.md":570,"./npm/npm源管理.md":571,"./npm/npm版本符号.md":572,"./npm/package-lock.md":573,"./npm/package.md":574,"./npm/yarn.md":575,"./npm/修改npm包逻辑.md":576,"./npm/常用命令.md":577,"./react/Context.md":578,"./react/api.md":579,"./react/class组件的super.md":580,"./react/fiber.md":581,"./react/hooks.md":582,"./react/hooks中使用防抖节流.md":583,"./react/hooks作用.md":584,"./react/hooks模拟class生命周期.md":585,"./react/hooks生命周期.md":586,"./react/jsx.md":587,"./react/jsx转换的变化.md":588,"./react/key.md":589,"./react/key的作用.md":590,"./react/re-render.md":591,"./react/react-router4 Prompt实现路由跳转前的提示.md":592,"./react/react-router6组件外部路由跳转.md":593,"./react/react.md":594,"./react/react18变化.md":595,"./react/react18并发模式.md":596,"./react/react为什么需要一个根标签包裹.md":597,"./react/react事件机制.md":598,"./react/react架构.md":599,"./react/react模式.md":600,"./react/react渲染.md":601,"./react/react错误捕获.md":602,"./react/ref.md":603,"./react/renderProps.md":604,"./react/router.md":605,"./react/setState.md":606,"./react/state和props.md":607,"./react/useEffect和useLayoutEffect.md":608,"./react/useMemo和useCallback.md":609,"./react/useReducer.md":610,"./react/不依赖客户端时间的倒计时.md":611,"./react/受控和非受控组件.md":612,"./react/状态管理.md":613,"./react/生命周期.md":614,"./react/简单react.md":615,"./react/类组件中方法绑定到类实例.md":616,"./react/组件封装.md":617,"./react/组件通信.md":618,"./react/自定义hooks.md":619,"./react/虚拟DOM.md":620,"./react/高阶组件.md":621,"./react/高阶组件和hooks对比.md":622,"./react源码/Component.md":623,"./react源码/commit阶段.md":624,"./react源码/createElement.md":625,"./react源码/源码调试.md":626,"./react状态管理/react-redux实现.md":627,"./react状态管理/redux.md":628,"./react状态管理/redux与mobx对比.md":629,"./react状态管理/redux实现.md":630,"./seo/seo.md":631,"./sourcemap/sourcemap.md":632,"./sourcemap/webpack中使用sourcemap.md":633,"./ssr/react服务端渲染.md":634,"./ssr/ssr.md":635,"./todo.md":636,"./typescript/export和export type的区别.md":637,"./typescript/interface和type的异同.md":638,"./typescript/tsconfig.md":639,"./typescript/typescript.md":640,"./typescript/unknown和any.md":641,"./typescript/常用示例.md":642,"./typescript/映射类型.md":643,"./typescript/泛型.md":644,"./typescript/类型声明文件.md":645,"./vite/esbuild构建速度快于webpack.md":646,"./vite/vite VS webpack.md":647,"./vite/vite配置项.md":648,"./vite/依赖预构建.md":649,"./vue/defineProperty缺陷.md":650,"./vue/v-for中加入条件判断.md":651,"./vue/vue3.md":652,"./vue/vue的data是通过方法返回.md":653,"./vue/生命周期.md":654,"./vue/简易vue实现.md":655,"./webpack使用/chunk.md":656,"./webpack使用/css-loader.md":657,"./webpack使用/css文件提取成单独的文件.md":658,"./webpack使用/loader.md":659,"./webpack使用/output.md":660,"./webpack使用/output的hash.md":661,"./webpack使用/plugin.md":662,"./webpack使用/proxy.md":663,"./webpack使用/splitChunksPlugin.md":664,"./webpack使用/webpack5变化.md":665,"./webpack使用/webpack5搭建react+ts项目.md":666,"./webpack使用/webpack的作用.md":667,"./webpack使用/构建体积优化.md":668,"./webpack使用/构建时间优化.md":669,"./webpack使用/配置项.md":670,"./webpack原理/plugin.md":671,"./webpack原理/异步加载(懒加载).md":672,"./webpack原理/热更新.md":673,"./webrtc/mediaDevices.md":674,"./web安全/csrf.md":675,"./web安全/react防御xss.md":676,"./web安全/sql注入.md":677,"./web安全/xss.md":678,"./web安全/接口加密.md":679,"./代码优化/减少if-else的使用.md":680,"./前端主题切换/antd v5实现主题切换.md":681,"./前端主题切换/前端主题切换方案.md":682,"./前端回滚/前端回滚.md":683,"./前端回滚/秒级回滚-未使用docker.md":684,"./前端工程化/BFF.md":685,"./前端工程化/Eslint + Prettier + husky + lint-staged规范前端工程.md":686,"./前端工程化/browserslist.md":687,"./前端工程化/cdn.md":688,"./前端工程化/dayjs代替moment.md":689,"./前端工程化/前端工程化.md":690,"./前端工程化/前端规范.md":691,"./前端工程化/统一node版本.md":692,"./前端工程化/统一npm版本.md":693,"./前端工程化/负载均衡.md":694,"./前端异常/try-catch.md":695,"./前端异常/前端异常.md":696,"./前端异常/异常处理.md":697,"./前端异常/异常监控.md":698,"./前端文件处理/ArrayBuffer.md":699,"./前端文件处理/Base64.md":700,"./前端文件处理/Blob.md":701,"./前端文件处理/File.md":702,"./前端文件处理/FileReader.md":703,"./前端文件处理/ObjectURL.md":704,"./前端文件处理/前端请求文件数据流.md":705,"./前端文件处理/大文件切片上传.md":706,"./前端文件处理/大文件断点续传.md":707,"./前端文件处理/文件上传.md":708,"./前端文件处理/文件下载.md":709,"./前端文件处理/文件预览.md":710,"./前端文件处理/格式转化.md":711,"./前端模块化/ES Module.md":712,"./前端模块化/export和export default的区别.md":713,"./前端模块化/module.exports和exports的区别.md":714,"./前端模块化/umd.md":715,"./前端模块化/前端模块化.md":716,"./前端监控/webpack插件上传sourcemap.md":717,"./前端监控/前端监控.md":718,"./前端监控/性能数据采集.md":719,"./前端监控/接口请求错误数据采集.md":720,"./前端监控/数据上报.md":721,"./前端监控/行为数据采集.md":722,"./前端监控/解析错误信息源码.md":723,"./前端监控/错误数据采集.md":724,"./前端调试-react/React Profiler.md":725,"./前端调试-react/Redux DevTools.md":726,"./前端调试-移动端/inspect调试.md":727,"./前端调试-移动端/whistle.md":728,"./前端调试-移动端/微信h5调试.md":729,"./前端调试/修改线上代码调试.md":730,"./前端调试/断点调试.md":731,"./前端调试/生产环境使用本地sourcemap调试.md":732,"./前端调试/线上问题调试.md":733,"./前端部署/docker部署项目.md":734,"./前端部署/gitlab runner部署项目.md":735,"./前端部署/html引用资源部署.md":736,"./前端部署/nginx配置前端项目.md":737,"./前端部署/版本更新提示.md":738,"./原型原型链/api.md":739,"./原型原型链/原型原型链.md":740,"./原型原型链/原型对象值修改.md":741,"./原型原型链/对象的属性和方法查找.md":742,"./国际化/react-intl国际化.md":743,"./国际化/项目国际化工作项.md":744,"./开发功能总结/react-markdown渲染markdown文件.md":745,"./开发功能总结/复制粘贴功能.md":746,"./开发功能总结/复制网页内容为图片.md":747,"./微前端/qiankun微前端.md":748,"./微前端/qiankun微前端各应用分别部署.md":749,"./微前端/qiankun微前端部署同级目录.md":750,"./微前端/qiankun微前端部署非同级目录.md":751,"./微前端/微前端.md":752,"./性能优化-react/PureComponent比较逻辑.md":753,"./性能优化-react/react性能优化.md":754,"./性能优化-react/优化场景.md":755,"./性能优化-react/更快的完成Diff比较.md":756,"./性能优化-react/跳过不必要的组件更新.md":757,"./性能优化-react/通用优化.md":758,"./性能优化/前端处理高并发.md":759,"./性能优化/图片资源优化.md":760,"./性能优化/客户端优化H5加载速度.md":761,"./性能优化/性能优化.md":762,"./性能优化/性能指标.md":763,"./性能优化/网络请求优化.md":764,"./性能优化/资源体积优化.md":765,"./性能优化/项目细节优化.md":766,"./手写代码/手写ES6数组方法.md":767,"./手写代码/手写bind、call、apply.md":768,"./手写代码/手写instanceof.md":769,"./手写代码/手写promise.md":770,"./数据结构/字典.md":771,"./数据结构/栈.md":772,"./数据结构/树.md":773,"./数据结构/链表.md":774,"./数据结构/队列.md":775,"./数据结构/集合.md":776,"./数据请求/refreshToken.md":777,"./数据请求/sendBeacon.md":778,"./数据请求/数据请求.md":779,"./数据请求/数据请求轮询.md":780,"./数组排序/冒泡排序.md":781,"./数组排序/归并排序.md":782,"./数组排序/快速排序.md":783,"./数组排序/插入排序.md":784,"./数组排序/选择排序.md":785,"./框架/react和vue的异同.md":786,"./框架/使用EventBus进行跨组件通信.md":787,"./浏览器/Cookie.md":788,"./浏览器/WebStorage.md":789,"./浏览器/回流和重绘.md":790,"./浏览器/复合图层.md":791,"./浏览器/多进程的浏览器.md":792,"./浏览器/浏览器渲染流程.md":793,"./浏览器/浏览器渲染进程(浏览器内核).md":794,"./浏览器/输入URL到显示.md":795,"./浏览器/进程和线程.md":796,"./混合开发/Android使用WebView.md":797,"./混合开发/JSBridge.md":798,"./混合开发/WebView.md":799,"./混合开发/dsbridge.md":800,"./混合开发/安卓应用和H5相互调用.md":801,"./混合开发/混合开发.md":802,"./登录/JWT.md":803,"./登录/Session-Cookie.md":804,"./登录/Token.md":805,"./登录/单点登录.md":806,"./登录/唯一登录.md":807,"./登录/扫码登录.md":808,"./登录/第三方登录.md":809,"./移动端/像素.md":810,"./移动端/兼容问题.md":811,"./移动端/点击问题.md":812,"./移动端/移动端适配.md":813,"./移动端/视口.md":814,"./移动端/软键盘弹起.md":815,"./算法-二叉树/二叉搜索树中的搜索.md":816,"./算法-二叉树/二叉树中序遍历.md":817,"./算法-二叉树/二叉树先序遍历.md":818,"./算法-二叉树/二叉树后序遍历.md":819,"./算法-二叉树/二叉树层序遍历.md":820,"./算法-二叉树/二叉树的最大深度.md":821,"./算法-二叉树/二叉树的最小深度.md":822,"./算法-二叉树/二叉树的最近公共祖先.md":823,"./算法-二叉树/对称二叉树.md":824,"./算法-二叉树/相同的树.md":825,"./算法-二叉树/翻转二叉树.md":826,"./算法-链表/二进制链表转整数.md":827,"./算法-链表/从尾到头打印链表.md":828,"./算法-链表/删除中间节点.md":829,"./算法-链表/删除排序链表中的重复元素.md":830,"./算法-链表/反转链表.md":831,"./算法-链表/合并两个有序链表.md":832,"./算法-链表/回文链表.md":833,"./算法-链表/环形链表.md":834,"./算法-链表/相交链表.md":835,"./算法-链表/移除链表元素.md":836,"./算法-链表/移除链表重复节点.md":837,"./算法-链表/链表中倒数第k个节点.md":838,"./算法-链表/链表的中间结点.md":839,"./算法/两数之和.md":840,"./算法/买卖股票最佳时机.md":841,"./算法/二进制求和.md":842,"./算法/全排列.md":843,"./算法/删除有序数组中的重复项.md":844,"./算法/判断html标签是否匹配.md":845,"./算法/判断是否为有效的字母异位词.md":846,"./算法/加一.md":847,"./算法/十进制转二进制.md":848,"./算法/回文字符串.md":849,"./算法/回文数.md":850,"./算法/子集.md":851,"./算法/字符串是否为子序列.md":852,"./算法/将0移动到数组末尾.md":853,"./算法/搜索插入位置.md":854,"./算法/数组中字符串翻转.md":855,"./算法/数组中最长的连续递增序列并返回长度.md":856,"./算法/斐波那契数列.md":857,"./算法/最后一个单词长度.md":858,"./算法/最大子数组和.md":859,"./算法/最小覆盖字串.md":860,"./算法/最近的请求次数.md":861,"./算法/最长公共前缀.md":862,"./算法/有序数组二分搜索.md":863,"./算法/有效的括号.md":864,"./算法/杨辉三角.md":865,"./算法/爬楼梯.md":866,"./算法/版本号比较.md":867,"./算法/盛最多水的容器.md":868,"./算法/移除数组元素.md":869,"./算法/约瑟夫环.md":870,"./算法/罗马数字转整数.md":871,"./算法/设计哈希映射.md":872,"./算法/设计哈希集合.md":873,"./算法思想/LRU(最少最近使用).md":874,"./算法思想/分而治之.md":875,"./算法思想/动态规划.md":876,"./算法思想/回溯算法.md":877,"./算法思想/复杂度.md":878,"./算法思想/贪心算法.md":879,"./设计模式/代理模式.md":880,"./设计模式/单例模式.md":881,"./设计模式/发布订阅和观察者模式.md":882,"./设计模式/发布订阅模式.md":883,"./设计模式/策略模式.md":884,"./设计模式/装饰者模式.md":885,"./设计模式/观察者模式.md":886,"./设计模式/设计模式.md":887,"./跨域/cors.md":888,"./跨域/跨域.md":889,"./跨域/跨域解决方案.md":890,"./路由/hash路由.md":891,"./路由/history路由.md":892,"./路由/路由.md":893,"./音视频/flvjs播放直播流.md":894,"./音视频/video.md":895,"./音视频/xgplayer.md":896,"./音视频/回放直播流支持进度条拖拽.md":897};function o(r){var n=s(r);return e(n)}function s(r){if(!e.o(t,r)){var n=new Error("Cannot find module '"+r+"'");throw n.code="MODULE_NOT_FOUND",n}return t[r]}o.keys=function(){return Object.keys(t)},o.resolve=s,r.exports=o,o.id=1315},function(r,n,e){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var t=e(425),o=[];t.keys().forEach((function(r){var n=r.split("/");if(3===n.length){var e=n[1],t=n[2].replace(".md",""),s=o.findIndex((function(r){return r.key===e}));s>-1?o[s].submenu.push({key:"/interview/"+e+"/"+t,label:t}):o.push({key:e,label:e,submenu:[{key:"/interview/"+e+"/"+t,label:t}]})}})),n.default=o},,,,,,,function(r,n,e){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.default=void 0;var t=Object.assign||function(r){for(var n=1;n<arguments.length;n++){var e=arguments[n];for(var t in e)Object.prototype.hasOwnProperty.call(e,t)&&(r[t]=e[t])}return r},o=function(){function r(r,n){for(var e=0;e<n.length;e++){var t=n[e];t.enumerable=t.enumerable||!1,t.configurable=!0,"value"in t&&(t.writable=!0),Object.defineProperty(r,t.key,t)}}return function(n,e,t){return e&&r(n.prototype,e),t&&r(n,t),n}}(),s=e(1),a=p(s),i=e(72),c=p(e(135)),l=p(e(136)),u=p(e(1311)),d=p(e(1316));function p(r){return r&&r.__esModule?r:{default:r}}function m(r,n){if(!(r instanceof n))throw new TypeError("Cannot call a class as a function")}function f(r,n){if(!r)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!n||"object"!=typeof n&&"function"!=typeof n?r:n}var h=function(r){function n(){return m(this,n),f(this,(n.__proto__||Object.getPrototypeOf(n)).apply(this,arguments))}return function(r,n){if("function"!=typeof n&&null!==n)throw new TypeError("Super expression must either be null or a function, not "+typeof n);r.prototype=Object.create(n&&n.prototype,{constructor:{value:r,enumerable:!1,writable:!0,configurable:!0}}),n&&(Object.setPrototypeOf?Object.setPrototypeOf(r,n):r.__proto__=n)}(n,r),o(n,[{key:"render",value:function(){return a.default.createElement(i.Switch,null,a.default.createElement(i.Redirect,{exact:!0,from:"/interview",to:d.default[0].submenu[0].key}),u.default.allScreen.map((function(r,n){return a.default.createElement(l.default,t({key:n},r))})),u.default.partScreen.map((function(r,n){return a.default.createElement(l.default,{key:n,exact:r.exact,path:r.path,routePermission:r.routePermission,render:function(n){return a.default.createElement(c.default,t({},n,{component:r.component,menuConfig:d.default,defaultOpenKeys:["js"],hiddenLeftNav:!0}))}})})),a.default.createElement(i.Redirect,{to:"/interview"}))}}]),n}(s.Component);n.default=h}])]);