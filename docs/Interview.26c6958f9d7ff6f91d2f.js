(window.webpackJsonp=window.webpackJsonp||[]).push([[5],Array(135).concat([function(r,n,e){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var t=a(e(1)),o=e(862),s=a(e(863));function a(r){return r&&r.__esModule?r:{default:r}}n.default=function(r){var n=r.component,e=r.menuConfig,a=r.defaultOpenKeys,i=void 0===a?[]:a,c=r.hiddenLeftNav,l=function(r,n){var e={};for(var t in r)n.indexOf(t)>=0||Object.prototype.hasOwnProperty.call(r,t)&&(e[t]=r[t]);return e}(r,["component","menuConfig","defaultOpenKeys","hiddenLeftNav"]),u=!(0,o.isPC)()&&c;return t.default.createElement("div",{className:"all-content"},u||t.default.createElement(s.default,{menuConfig:e,defaultOpenKeys:i}),t.default.createElement("div",{className:"right-content"},t.default.createElement(n,l)))}},function(r,n,e){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.default=void 0;var t,o,s=function(){function r(r,n){for(var e=0;e<n.length;e++){var t=n[e];t.enumerable=t.enumerable||!1,t.configurable=!0,"value"in t&&(t.writable=!0),Object.defineProperty(r,t.key,t)}}return function(n,e,t){return e&&r(n.prototype,e),t&&r(n,t),n}}(),a=e(1),i=d(a),c=e(96),l=e(72),u=d(e(269));function d(r){return r&&r.__esModule?r:{default:r}}function p(r,n){if(!(r instanceof n))throw new TypeError("Cannot call a class as a function")}function m(r,n){if(!r)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!n||"object"!=typeof n&&"function"!=typeof n?r:n}var f=(t=(0,c.connect)((function(r){return{isLogin:r.loginStore.isLogin,permission:r.loginStore.permission}}),null),(0,l.withRouter)(o=t(o=function(r){function n(){return p(this,n),m(this,(n.__proto__||Object.getPrototypeOf(n)).apply(this,arguments))}return function(r,n){if("function"!=typeof n&&null!==n)throw new TypeError("Super expression must either be null or a function, not "+typeof n);r.prototype=Object.create(n&&n.prototype,{constructor:{value:r,enumerable:!1,writable:!0,configurable:!0}}),n&&(Object.setPrototypeOf?Object.setPrototypeOf(r,n):r.__proto__=n)}(n,r),s(n,[{key:"render",value:function(){var r=this.props,n=r.routePermission,e=r.permission,t=!n||"normal"===n||n===e;return r.isLogin&&!e&&"manager"===n?i.default.createElement(u.default,null):t?i.default.createElement(l.Route,this.props):i.default.createElement(l.Redirect,{to:"/nopermission"})}}]),n}(a.Component))||o)||o);n.default=f},,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,function(r,n,e){var t={"./WebSocket/WebSocket.md":426,"./WebSocket/WebSocket心跳.md":427,"./babel/Babel.md":428,"./babel/Babel配置.md":429,"./cli/cli.md":430,"./css/bfc.md":431,"./css/css.md":432,"./css/css3.md":433,"./css/css选择器-child和-of-type的使用差异.md":434,"./css/css选择器.md":435,"./css/flex.md":436,"./css/scss变量.md":437,"./css/伪类伪元素.md":438,"./css/居中.md":439,"./css/换行.md":440,"./css/样式隔离.md":441,"./css/浮动.md":442,"./css/盒子模型.md":443,"./css/网页变黑白颜色.md":444,"./css/雪碧图.md":445,"./docker/docker.md":446,"./docker/docker常用命令.md":447,"./done.md":448,"./git/fetch和merge的区别.md":449,"./git/git提交规范.md":450,"./git/rebase和merge的区别.md":451,"./html/html渲染.md":452,"./html/meta.md":453,"./html/修改页签icon.md":454,"./html/页面可见性.md":455,"./html/页面生命周期.md":456,"./http/Accept系列字段.md":457,"./http/URI.md":458,"./http/dns.md":459,"./http/http.md":460,"./http/http2.md":461,"./http/https.md":462,"./http/http代理.md":463,"./http/http状态码.md":464,"./http/http缓存.md":465,"./http/http请求方法.md":466,"./http/三次握手和四次挥手.md":467,"./http/定长不定长的数据处理.md":468,"./http/队头阻塞.md":469,"./js/==和===.md":470,"./js/Array.md":471,"./js/ES6.md":472,"./js/Generator和协程.md":473,"./js/Map.md":474,"./js/Object.defineProperty.md":475,"./js/Service Worker.md":476,"./js/Set.md":477,"./js/Symbol.md":478,"./js/Web Worker.md":479,"./js/WebComponent.md":480,"./js/a == 1 && a == 2 && a == 3.md":481,"./js/arguments.md":482,"./js/async在循环中使用的问题.md":483,"./js/beforeunload事件.md":484,"./js/esModule和commonjs的区别.md":485,"./js/forEach的局限.md":486,"./js/hasOwnProperty与in的区别.md":487,"./js/js事件流.md":488,"./js/js加载方式.md":489,"./js/new操作符.md":490,"./js/promise.md":491,"./js/promiseAll控制并发.md":492,"./js/setTimeout和setInterval.md":493,"./js/this.md":494,"./js/var let const差异.md":495,"./js/事件委托.md":496,"./js/事件循环eventLoop.md":497,"./js/作用域.md":498,"./js/内存泄漏和垃圾回收.md":499,"./js/前端模块化.md":500,"./js/前端获取网络信息.md":501,"./js/前端路由.md":502,"./js/原型原型链.md":503,"./js/图像懒加载和预加载.md":504,"./js/对象创建.md":505,"./js/异步处理方案.md":506,"./js/数据类型及判断方法.md":507,"./js/浏览器页面不可见时定时器是否准时.md":508,"./js/浮点数精度丢失.md":509,"./js/深浅拷贝.md":510,"./js/渲染大量数据.md":511,"./js/箭头函数与普通函数的区别.md":512,"./js/类型转换.md":513,"./js/继承.md":514,"./js/节流与防抖.md":515,"./js/鉴权.md":516,"./js/闭包.md":517,"./js/预解析.md":518,"./js/高级函数用法.md":519,"./leetcode二叉树中等/二叉树的最近公共祖先.md":520,"./leetcode二叉树简单/二叉搜索树中的搜索.md":521,"./leetcode二叉树简单/二叉树中序遍历.md":522,"./leetcode二叉树简单/二叉树前序遍历.md":523,"./leetcode二叉树简单/二叉树后序遍历.md":524,"./leetcode二叉树简单/二叉树的最大深度.md":525,"./leetcode二叉树简单/二叉树的最小深度.md":526,"./leetcode二叉树简单/对称二叉树.md":527,"./leetcode二叉树简单/相同的树.md":528,"./leetcode二叉树简单/翻转二叉树.md":529,"./leetcode简单/两数之和.md":530,"./leetcode简单/二进制求和.md":531,"./leetcode简单/删除有序数组中的重复项.md":532,"./leetcode简单/加一.md":533,"./leetcode简单/回文数.md":534,"./leetcode简单/搜索插入位置.md":535,"./leetcode简单/最后一个单词长度.md":536,"./leetcode简单/最长公共前缀.md":537,"./leetcode简单/有效的括号.md":538,"./leetcode简单/爬楼梯.md":539,"./leetcode简单/移除数组元素.md":540,"./leetcode简单/罗马数字转整数.md":541,"./leetcode简单/设计哈希映射.md":542,"./leetcode简单/设计哈希集合.md":543,"./leetcode链表简单/二进制链表转整数.md":544,"./leetcode链表简单/从尾到头打印链表.md":545,"./leetcode链表简单/删除中间节点.md":546,"./leetcode链表简单/删除排序链表中的重复元素.md":547,"./leetcode链表简单/反转链表.md":548,"./leetcode链表简单/合并两个有序链表.md":549,"./leetcode链表简单/回文链表.md":550,"./leetcode链表简单/环形链表.md":551,"./leetcode链表简单/相交链表.md":552,"./leetcode链表简单/移除链表元素.md":553,"./leetcode链表简单/移除链表重复节点.md":554,"./leetcode链表简单/链表中倒数第k个节点.md":555,"./leetcode链表简单/链表的中间结点.md":556,"./nginx/IP黑白名单.md":557,"./nginx/gzip压缩.md":558,"./nginx/location.md":559,"./nginx/nginx.md":560,"./nginx/proxy_pass.md":561,"./nginx/root和alias.md":562,"./nginx/try_files.md":563,"./nginx/常用命令.md":564,"./nginx/常用配置.md":565,"./nginx/正向代理反向代理.md":566,"./nginx/解决跨域问题.md":567,"./nginx/负载均衡.md":568,"./nginx/配置SSL证书.md":569,"./nginx/防盗链.md":570,"./node/module.exports和exports的区别.md":571,"./node/node执行命令添加参数.md":572,"./node/nvm.md":573,"./npm/npm run xxx.md":574,"./npm/npm源管理.md":575,"./npm/npm版本符号.md":576,"./npm/package-lock.md":577,"./npm/package.md":578,"./react/Immutable Data.md":579,"./react/api.md":580,"./react/class组件的super.md":581,"./react/diff.md":582,"./react/fiber.md":583,"./react/hooks.md":584,"./react/hooks中使用防抖节流.md":585,"./react/hooks作用.md":586,"./react/jsx.md":587,"./react/jsx转换的变化.md":588,"./react/key.md":589,"./react/re-render.md":590,"./react/react-intl国际化.md":591,"./react/react-router4 Prompt实现路由跳转前的提示.md":592,"./react/react.md":593,"./react/react18变化.md":594,"./react/react18并发模式.md":595,"./react/react为什么需要一个根标签包裹.md":596,"./react/react事件机制.md":597,"./react/react性能优化.md":598,"./react/react架构.md":599,"./react/react错误捕获.md":600,"./react/redux.md":601,"./react/ref.md":602,"./react/renderProps.md":603,"./react/router.md":604,"./react/setState.md":605,"./react/state和props.md":606,"./react/useEffect和useLayoutEffect.md":607,"./react/useMemo和useCallback.md":608,"./react/不依赖客户端时间的倒计时.md":609,"./react/状态管理.md":610,"./react/生命周期.md":611,"./react/简单react.md":612,"./react/类组件中方法绑定到类实例.md":613,"./react/组件封装.md":614,"./react/组件通信.md":615,"./react/自定义hooks.md":616,"./react/虚拟DOM.md":617,"./react源码/Component.md":618,"./react源码/createElement.md":619,"./ssr/react服务端渲染.md":620,"./ssr/ssr.md":621,"./typescript/interface和type的异同.md":622,"./typescript/tsconfig.md":623,"./typescript/typescript.md":624,"./typescript/unknown和any.md":625,"./typescript/映射类型.md":626,"./typescript/泛型.md":627,"./vue/defineProperty缺陷.md":628,"./vue/vue的data是通过方法返回.md":629,"./vue/生命周期.md":630,"./vue/简易vue实现.md":631,"./webpack/chunk.md":632,"./webpack/css-loader.md":633,"./webpack/css文件提取成单独的文件.md":634,"./webpack/loader.md":635,"./webpack/output.md":636,"./webpack/output的hash.md":637,"./webpack/plugin.md":638,"./webpack/proxy.md":639,"./webpack/sourcemap.md":640,"./webpack/splitChunksPlugin.md":641,"./webpack/webpack5变化.md":642,"./webpack/webpack5搭建react+ts项目.md":643,"./webpack/webpack的作用.md":644,"./webpack/构建体积优化.md":645,"./webpack/构建时间优化.md":646,"./web安全/csrf.md":647,"./web安全/react防御xss.md":648,"./web安全/sql注入.md":649,"./web安全/xss.md":650,"./代码优化/减少if-else的使用.md":651,"./前端工程化/BFF.md":652,"./前端工程化/Eslint + Prettier + husky + lint-staged规范前端工程.md":653,"./前端工程化/browserslist.md":654,"./前端工程化/cdn.md":655,"./前端工程化/dayjs代替moment.md":656,"./前端工程化/monorepo.md":657,"./前端工程化/前端主题切换方案.md":658,"./前端工程化/前端工程化.md":659,"./前端工程化/前端规范.md":660,"./前端异常/try-catch.md":661,"./前端异常/前端异常.md":662,"./前端异常/异常处理.md":663,"./前端异常/异常监控.md":664,"./前端文件处理/ArrayBuffer.md":665,"./前端文件处理/Base64.md":666,"./前端文件处理/Blob.md":667,"./前端文件处理/File.md":668,"./前端文件处理/FileReader.md":669,"./前端文件处理/ObjectURL.md":670,"./前端文件处理/前端请求文件数据流.md":671,"./前端文件处理/大文件切片上传.md":672,"./前端文件处理/大文件断点续传.md":673,"./前端文件处理/文件上传.md":674,"./前端文件处理/文件下载.md":675,"./前端文件处理/文件预览.md":676,"./前端文件处理/格式转化.md":677,"./前端监控/sendBeacon.md":678,"./前端监控/前端监控.md":679,"./前端监控/性能数据采集.md":680,"./前端监控/接口请求错误数据采集.md":681,"./前端监控/数据上报.md":682,"./前端监控/行为数据采集.md":683,"./前端监控/解析错误信息源码.md":684,"./前端监控/错误数据采集.md":685,"./前端调试/Redux DevTools.md":686,"./前端部署/docker部署项目.md":687,"./前端部署/gitlab runner部署项目.md":688,"./前端部署/nginx配置前端项目.md":689,"./开发功能总结/react-markdown渲染markdown文件.md":690,"./微前端/qiankun微前端.md":691,"./微前端/qiankun微前端各应用分别部署.md":692,"./微前端/qiankun微前端部署同级目录.md":693,"./微前端/qiankun微前端部署非同级目录.md":694,"./微前端/微前端.md":695,"./性能优化/图片资源优化.md":696,"./性能优化/客户端优化H5加载速度.md":697,"./性能优化/性能指标.md":698,"./性能优化/网络请求优化.md":699,"./性能优化/资源体积优化.md":700,"./性能优化/项目细节优化.md":701,"./手写代码/手写ES6数组方法.md":702,"./手写代码/手写bind、call、apply.md":703,"./手写代码/手写instanceof.md":704,"./手写代码/手写promise.md":705,"./数据结构/字典.md":706,"./数据结构/栈.md":707,"./数据结构/树.md":708,"./数据结构/链表.md":709,"./数据结构/队列.md":710,"./数据结构/集合.md":711,"./数据请求/refreshToken.md":712,"./数据请求/sendBeacon.md":713,"./数据请求/数据请求.md":714,"./数据请求/数据请求轮询.md":715,"./数组排序/冒泡排序.md":716,"./数组排序/归并排序.md":717,"./数组排序/快速排序.md":718,"./数组排序/插入排序.md":719,"./数组排序/选择排序.md":720,"./构建工具/vite VS webpack.md":721,"./框架/React、Vue3、Vue2 列表的 Diff 算法对比.md":722,"./框架/react和vue的异同.md":723,"./浏览器/Cookie.md":724,"./浏览器/WebStorage.md":725,"./浏览器/回流和重绘.md":726,"./浏览器/复合图层.md":727,"./浏览器/浏览器内核(渲染进程).md":728,"./浏览器/跨域.md":729,"./浏览器/输入URL到显示.md":730,"./混合开发/JSBridge.md":731,"./混合开发/dsbridge.md":732,"./混合开发/whistle.md":733,"./混合开发/混合开发.md":734,"./移动端/像素.md":735,"./移动端/兼容问题.md":736,"./移动端/微信h5调试.md":737,"./移动端/点击问题.md":738,"./移动端/移动端适配.md":739,"./移动端/视口.md":740,"./移动端/软键盘弹起.md":741,"./算法/LRU(最少最近使用).md":742,"./算法/conclude.md":743,"./算法/分而治之.md":744,"./算法/动态规划.md":745,"./算法/双指针.md":746,"./算法/哈希表.md":747,"./算法/回溯算法.md":748,"./算法/复杂度.md":749,"./算法/字典.md":750,"./算法/找规律题.md":751,"./算法/数组.md":752,"./算法/数组搜索.md":753,"./算法/栈.md":754,"./算法/贪心算法.md":755,"./算法/队列.md":756,"./算法/集合.md":757,"./设计模式/代理模式.md":758,"./设计模式/单例模式.md":759,"./设计模式/发布订阅和观察者模式.md":760,"./设计模式/发布订阅模式.md":761,"./设计模式/策略模式.md":762,"./设计模式/装饰者模式.md":763,"./设计模式/观察者模式.md":764,"./设计模式/设计模式.md":765};function o(r){var n=s(r);return e(n)}function s(r){if(!e.o(t,r)){var n=new Error("Cannot find module '"+r+"'");throw n.code="MODULE_NOT_FOUND",n}return t[r]}o.keys=function(){return Object.keys(t)},o.resolve=s,r.exports=o,o.id=425},function(r,n,e){"use strict";e.r(n),n.default="## WebSocket\r\n- WebSocket是一种在单个TCP连接上进行全双工通信的协议，它可以让客户端和服务器之间进行实时的双向通信，客户端和服务器之间可以互相发送消息。\r\n- 与传统的HTTP请求不同，WebSocket使用了一个长连接，在客户端和服务器之间保持持久的连接，从而可以实时地发送和接收数据。\r\n### WebSocket与HTTP的区别\r\n- WebSocket是一种双向通信的协议，通过一次握手即可建立持久性的连接，服务器和客户端可以随时发送和接收数据。\r\n- HTTP协议是一种请求-响应模式的协议，每次通信都需要发送一条请求并等待服务器的响应。\r\n- WebSocket的实时性更好，延迟更低，并且在服务器和客户端之间提供双向的即时通信能力，适用于需要实时数据传输的场景。\r\n### 前端使用WebSocket\r\n- 创建WebSocket对象\r\n> 通过JavaScript中的new WebSocket(URL)方法创建WebSocket对象，其中URL是WebSocket服务器的地址。\r\n\r\n```\r\nconst socket = new WebSocket('ws://localhost:8000');\r\n```\r\n- 监听WebSocket事件\r\n  1. open：当与服务器建立连接时触发。\r\n  2. message：当收到服务器发送的消息时触发。\r\n  3. close：当与服务器断开连接时触发。\r\n  4. error：当连接或通信过程中发生错误时触发。\r\n```\r\nsocket.addEventListener('open', () => {\r\n  console.log('WebSocket连接已建立');\r\n});\r\n\r\nsocket.addEventListener('message', (event) => {\r\n  const message = event.data;\r\n  console.log('收到消息：', message);\r\n});\r\n\r\nsocket.addEventListener('close', () => {\r\n  console.log('WebSocket连接已断开');\r\n});\r\n\r\nsocket.addEventListener('error', (error) => {\r\n  console.error('发生错误：', error);\r\n});\r\n```\r\n- 发送消息\r\n> 通过WebSocket对象的send(data)方法发送消息，其中data是要发送的数据，可以是字符串、JSON对象等。\r\n\r\n```\r\nconst message = 'Hello, server!';\r\nsocket.send(message);\r\n```\r\n- 关闭WebSocket连接\r\n> 当通信结束或不再需要与服务器通信时，需要关闭WebSocket连接以释放资源。通过调用WebSocket对象的close()方法可以主动关闭连接。\r\n\r\n```\r\nsocket.close();\r\n```\r\n### WebSocket的应用场景\r\n- 实时聊天应用：WebSocket能够提供双向、实时的通信机制，使得实时聊天应用能够快速、高效地发送和接收消息，实现即时通信。\r\n- 实时协作应用：WebSocket可以用于实时协作工具，如协同编辑文档、白板绘画、团队任务管理等，团队成员可以实时地在同一页面上进行互动和实时更新。\r\n- 实时数据推送：WebSocket可以用于实时数据推送场景，如股票行情、新闻快讯、实时天气信息等，服务器可以实时将数据推送给客户端，确保数据的及时性和准确性。\r\n- 在线客服和客户支持：WebSocket可以用于在线客服和客户支持系统，实现实时的客户沟通和问题解决，提供更好的用户体验，减少等待时间。\r\n### WebSocket的缺点和不足\r\n- WebSocket需要浏览器和服务器端都支持该协议。\r\n- WebSocket会增加服务器的负担，不适合大规模连接的应用场景。\r\n\r\n\r\n\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## WebSocket心跳\r\n### WebSocket心跳包机制\r\n> WebSocket心跳包是WebSocket协议的保活机制，用于维持长连接。有效的心跳包可以防止长时间不通讯时，WebSocket自动断开连接。\r\n\r\n- 客户端定时向服务器发送心跳数据包，以保持长连接。\r\n- 服务器定时向客户端发送心跳数据包，以检测客户端连接是否正常。\r\n- 双向发送心跳数据包。\r\n### WebSocket心跳机制作用\r\n- 使WebSocket连接保持长连接，保持WebSocket连接不被断开。\r\n- 检测WebSocket连接状态，及时处理异常情况。\r\n- 减少WebSocket连接及服务器资源的消耗。\r\n### 前端实现WebSocket心跳机制的方式\r\n- 使用setInterval定时发送心跳包。\r\n> 会对服务器造成很大的压力，因为即使WebSocket连接正常，也要定时发送心跳包，从而消耗服务器资源。\r\n\r\n- 在监听到WebSocket的onclose()事件时，重新创建WebSocket连接。\r\n> 这种方式虽然减轻了服务器的负担，但是在重连时可能会丢失一些数据。\r\n\r\n### WebSocket重连机制\r\n> WebSocket在发送和接收数据时，可能会因为网络原因、服务器宕机等因素而断开连接，此时需要使用WebSocket重连机制进行重新连接。\r\n\r\n- 前端监听WebSocket的onclose()事件，重新创建WebSocket连接。\r\n- 使用WebSocket插件或库，例如Sockjs、Stompjs等。\r\n- 使用心跳机制检测WebSocket连接状态，自动重连。\r\n- 使用断线重连插件或库，例如ReconnectingWebSocket等。\r\n"},function(r,n,e){"use strict";e.r(n),n.default='## [Babel](https://juejin.cn/post/7190312484492804156)\r\n> Babel是一个JavaScript编译器，主要用于将使用ECMAScript 2015+(ES6+)语法编写的代码转换为向后兼容的JavaScript语法，以便能够运行在当前和旧版本的浏览器或其他环境中。\r\n\r\n- ES6+最新语法转化(let、class、箭头函数等)。\r\n- 实现旧版本浏览器不支持的ES6+的API(Promise、Symbol、Array.prototype.includes等)。\r\n- 实现ES6+最新语法转化只需要使用@babel/preset-env就可以。\r\n- 实现旧版本浏览器不支持的ES6+的API就需要用core-js这个包来提供polyfill，并与@babel/preset-env或者@babel/plugin-transform-runtime的配置功能相互配合使用。\r\n### Babel配置文件大致架构\r\n> 一般主要用到的是presets、plugins这两个配置。\r\n\r\n```\r\n// babel.config.js\r\nmodule.exports = {\r\n  ...,\r\n  sourceType: "unambiguous",\r\n  envName: "development",\r\n  presets: [],\r\n  plugins: [],\r\n  passPerPreset: false,\r\n  targets: {},\r\n  browserslistConfigFile: true,\r\n  browserslistEnv: undefined,\r\n  inputSourceMap: true\r\n  ...\r\n}\r\n```\r\n### @babel/core\r\n> Babel实现编译的核心库。要使用Babel，@babel/core一定是必不可少的。平常说的babel版本指的就是@babel/core的版本。\r\n\r\n```\r\nnpm install @babel/core -D\r\n```\r\n### @babel/cli\r\n> cli命令行工具，可通过命令行编译文件。\r\n\r\n### @babel/preset-env\r\n- @babel/preset-env是一个智能预设，通过@babel/preset-env我们可以使用最新的JavaScript，而无需微观管理目标环境需要哪些语法转换(以及可选的浏览器polyfill)，也可以让JavaScript的包更小。\r\n- @babel/preset-env只编译ES6+语法并不提供polyfill，但是可以通过配置我们代码运行的目标环境，从而控制polyfill的导入跟语法编译，使ES6+的新特性可以在我们想要的目标环境中顺利运行。\r\n- 可以通过@babel/preset-env --\x3e package.json --\x3e dependencies查看@babel/preset-env包含了哪些预设。\r\n```\r\nnpm install @babel/preset-env -D\r\n```\r\n#### preset预设\r\n- Babel编译ES6+语法是通过一个个plugin去实现的，@babel/preset-env是一个语法插件集合包，通过@babel/preset-env我们只用安装这一个包，不需要一个个配插件，就可以编译ES6+语法了。\r\n#### env环境\r\n- @babel/preset-env还有一个配置功能，我们可以通过配置我们代码运行的目标环境，来控制polyfill(一个提供低版本浏览器缺失的ES6+新特性的方法与实现的集合)的导入跟语法编译，从而使ES6+新的特性可以在我们想要的目标环境中顺利运行。\r\n### polyfill\r\n- ES6+除了提供很多简洁的语法(let、class、箭头函数等)外，还为我们提供了很多便捷的API(Promise、Symbol、Array.prototype.includes等)。但旧版本浏览器是不支持这些API的，而polyfill存放了这些API方法的实现，所以通过polyfill可以在不支持ES6+ API的浏览器中正常使用这些API。这种存放了ES6+的API方法实现的集合叫做polyfill，也就是我们经常说的垫片。\r\n- polyfill分很多种，像core-js是会提供旧版本浏览器缺失的所有的API。还有一些只提供某个API的polyfill，例如promise-polyfill、proxy-polyfill等。\r\n- Babel配置polyfill的过程就是实现旧版本浏览器对这些API支持的过程。\r\n### @babel/polyfill\r\n```\r\nnpm install @babel/polyfill -S\r\n```\r\n- 这个包由core-js(版本为2.x.x，放了很多ES6+ API的实现)与regenerator-runtime(Async、Generator函数使用)两个包组成。\r\n- 这个包在Babel 7.4.0以后就废弃了，所以在Babel 7.4.0以后，想让一些不支持ES6+ API的旧版本浏览器支持这些API，直接安装core-js@3.x.x的包即可。\r\n- 在Babel 7.18.0及其以后的版本，regenerator-runtime包里面的内容会以局部变量的方式内联注入到我们的代码中，所以我们只用引入import "core-js/stable"这一个包就可以了。\r\n- Babel 7.4.0版本之前引入polyfill\r\n```\r\nimport \'@babel/polyfill\';\r\n```\r\n- Babel 7.18.0版本之前引入polyfill形式\r\n```\r\nimport "core-js/stable"; // core-js必须是3.x.x版本，因为2.x.x版本，不包含stable文件夹\r\nimport "regenerator-runtime/runtime";\r\n```\r\n- Babel 7.18.0及其以后的版本引入polyfill形式\r\n```\r\n// 不需要再 import "regenerator-runtime/runtime";\r\nimport "core-js/stable"; // core-js必须是3.x.x版本，因为2.x.x版本，不包含stable文件夹\r\n```\r\n### core-js\r\n> 会提供旧版本浏览器缺失的所有的ES6+的API。\r\n\r\n```\r\nnpm install core-js -S\r\n```\r\n- 当我们想垫平所有的ES6+的API(包括提案阶段)，可以导入core-js所有内容。\r\n```\r\nimport \'core-js\';\r\n```\r\n- 当需要垫平所有稳定版本的ES6+的API，可以导入stable文件夹。\r\n```\r\nimport \'core-js/stable\';\r\n```\r\n- 当只需要垫平某个稳定的ES6+的API，可以导入es这个文件夹里的polyfill来垫平。\r\n```\r\nimport X from \'core-js/es/xx\';\r\n```\r\n- 当需要用到提案阶段的API时，可以导入proposals这个文件夹里的polyfill来垫平。\r\n```\r\nimport X from \'core-js/proposals/xx\';\r\n```\r\n### @babel/runtime\r\n> 在Babel编译的时候，编译以后会生成很多辅助函数，这些函数就是ES6+一些语法糖的实现，并且会以内联的方式插入到我们的代码中。@babel/runtime是存放了Babel辅助函数的一个集合包。\r\n\r\n```\r\nnpm install @babel/runtime -S\r\n```\r\n### @babel/plugin-transform-runtime\r\n- @babel/plugin-transform-runtime会将我们用到的辅助函数，从@babel/runtime中以require的方式引入到我们的文件中实现复用，避免多个文件使用ES6+语法糖辅助函数生成多次内联插入多次的问题，从而减小我们最终输出包的体积。\r\n- @babel/runtime跟@babel/plugin-transform-runtime通常是配合一起使用。\r\n- 也有一个配置功能，用来处理polyfill如何垫平。\r\n```\r\nnpm install @babel/plugin-transform-runtime -D\r\n```\r\n### @babel/preset-react\r\n> 使用@babel/preset-react转化jsx语法。\r\n\r\n```\r\nnpm install @babel/preset-react -D\r\n```\r\n### @babel/preset-typescript\r\n> 使用@babel/preset-typescript将ts语法转化为js语法。\r\n\r\n```\r\nnpm install @babel/preset-typescript -D\r\n```\r\n\r\n### babel-loader\r\n> webpack中loader的本质就是一个函数，接受我们的源代码作为入参同时返回新的内容。babel-loader的作用就是将匹配到的js相关文件进行编译。babel-loader支持直接通过loader的参数形式注入，同时也支持在loader函数内部自动读取`.babelrc、babel.config.js、babel.config.json`等文件配置。\r\n\r\n```\r\nnpm install babel-loader -D\r\n```\r\n'},function(r,n,e){"use strict";e.r(n),n.default="## [Babel配置](https://juejin.cn/post/7197666704435920957)\r\n### @bable/preset-env\r\n#### modules\r\n- 启用ES模块语法向另一种模块类型的转换。\r\n- 默认值：auto。可取的值：\"amd\" | \"umd\" | \"systemjs\" | \"commonjs\" | \"cjs\" | \"auto\" | false。\r\n- 当我们设置成false的时候，Babel编译使用的一些辅助函数的引入方式会变成ES6模块方式import。可以对代码静态分析很好地tree shaking减少代码体积，所以我们配置Babel的时候建议设置modules: false。\r\n#### targets\r\n- 用来设置我们的代码需要兼容的目标环境，可以有效地减少ES6+的语法编译，也可以有效控制polyfill导入的多少。\r\n- 如果没有设置这个配置项时会去Babel配置文件找顶层的targets。如果顶层没有设置targets则会去package.json里的browserslist或者根目录找.browserslistrc文件。如果还没有则默认值为{}。\r\n- 如果没有设置这个配置项时Babel会假设我们要兼容的目标环境是最旧的浏览器，所以会将所有的ES6+语法代码转化为ES5。所以在配置Babel的时候，要设置targets以减少输出代码大小。\r\n#### useBuiltIns\r\n> 这个配置就是用来设置我们core-js的垫平方式的。\r\n\r\n- entry\r\n  - 我们需要手动import所有或者某块polyfill。\r\n  - Babel会根据我们设置的targets(目标环境)，来判断我们手动import的所有或者某块polyfill是不是当前缺失的，如果是的话就会把我们手动import所有或者某块polyfill拆分成很多小模块，引入我们目标环境不支持的模块。\r\n  - 为了避免一些奇奇怪怪的问题，我们手动import的polyfill应该统一在入口文件。\r\n  - 如果我们想一劳永逸，直接把当前环境所有不支持的ES6+ API垫平，那我们就import 'core-js/stable'(这会垫平当前targets不支持的所有稳定版本的ES6+ API，所以也会导致包变大)。\r\n  - 如果我们只想垫平某个ES6+ API(前提是targets不支持这个API，否则手动import了也没用)。例如只想垫平Promise那我们import 'core-js/es/promise就可以了。\r\n  - 如果想垫平提案阶段的API，则也需要手动import对应提案的polyfill(import \"core-js/proposals/string-replace-all)。\r\n  - 垫平的polyfill都是注入到window全局的，或者是某个内置对象的原型(prototype)上，这影响到了全局。\r\n- usage\r\n  - 不需要手动import所有或者某块polyfill。\r\n  - Babel会根据我们当前代码中用到的ES6+ API，并判断当前的targets支不支持我们用到的这个ES6+ API，如果不支持的话则自动导入这个ES6+ API对应的polyfill。\r\n  - 如果第三方库用到了我们当前targets不支持的ES6+ API，但我们自己的代码没有用到这个API，那么这个API是不会被垫平的，这会导致我们项目报错。如果判断出哪块polyfill缺失，我们可以自己手动import去垫平。\r\n  - 垫平的polyfill都是注入到window全局的，或者是某个内置对象的原型(prototype)上，这影响到了全局。\r\n- false\r\n  - 默认值，不会自动添加polyfill也不会根据targets判断缺不缺失，也不会将我们手动import所有或者某块polyfill拆分为单个polyfill引入。\r\n  - 对我们的垫平方式没作用，源码是什么样，输出就是什么样。设置targets无效。\r\n- entry VS usage\r\n  - Promise还有很多例如Promise.any、Promise.all、Promise.finally的方法，示例代码只使用Promise不使用Promise的其它方法。\r\n  - IE11不支持Promise，Chrome80中Promise大部分方法已经实现，只有Promise.any没有实现。\r\n  - 使用entry手动导入import 'core-js/es/promise'的表现为：IE11下把Promise所有不支持的方法都垫平了；Chrome80下Promise大部分方法已经实现，只有Promise.any没有实现，所以此时只垫平了promise.any方法。\r\n  - 使用usage自动导入的表现为：IE下只垫平了Promise这个对象，不会垫平它其它相关的方法，因为示例代码中只用到了单一的Promise对象没有用到其它相关方法；Chrome80下没有任何关于Promise的垫平，因为单一的Promise对象在Chrome80已经实现只有Promise.any没有实现，但是示例代码中没有用Promise.any方法，所以不会垫平Promise.any。\r\n#### corejs\r\n- 当我们的useBuiltIns不为false的时候，需要设置corejs这个配置项。\r\n- 2版本的core-js已经不建议使用了，要尽可能的使用最新的版本。越新的包包含的polyfill才会越多。\r\n- 我们设置corejs的版本号时，不要直接指定2或者3，它会被解析为2.0或者3.0。我们应该带上子版本号(3.27.2)，这样才会有最新的polyfill。\r\n- core-js默认用稳定版的polyfill来垫平，但如果有时我们想用还处在提案阶段的API时\r\n  - 如果我们配置的是useBuiltIns: entry，我们得手动引入core-js提案的polyfill来垫平。提案的polyfill放在core-js/proposals文件夹中(import 'core-js/proposals/array-last')。\r\n  - 如果我们配置的是useBuiltIns: 'usage'，需要把corejs的proposals配置项设为true。\r\n```\r\n{\r\n  useBuiltIns: 'usage',\r\n  corejs: {\r\n    version: '3.27.2',\r\n    // 是否编译提案阶段ES6+ API\r\n    proposals: true\r\n  },\r\n}\r\n```\r\n### @babel/plugin-transform-runtime\r\n#### helpers\r\n- 控制的是我们的辅助函数，是否不内联进我们的代码中。\r\n- 默认值是true，true的话是不内联，而是引用@babel/runtime辅助函数集合包；false的话，则会内联。\r\n#### regenerator\r\n- 控制的是我们regenerator-runtime这个包的代码，是否不内联进我们的代码中。\r\n- 默认值是true，true的话是不内联，而是引用@babel/runtime辅助函数集合包；false的话，则会内联。\r\n#### corejs\r\n> 不想以全局的方式、污染的方式垫平我们的ES6+ API，我们corejs就不能为false，并且优先使用@babel/runtime-corejs3这个包来垫平(设置为3)。\r\n\r\n- corejs这个配置项一旦不为false，就是用来设置我们要垫平的ES6+ API以不污染全局的方式垫平。\r\n- false：默认值，对应依赖@babel/runtime。\r\n- 2：对应依赖@babel/runtime-corejs2，只能支持编译全局变量(如Promise)和静态属性(如Array.from)，不能编译实例相关方法([].includes)。\r\n- 3：对应依赖@babel/runtime-corejs3，既能支持编译全局变量和静态属性，又能编译实例方法，开启proposals: true还可以编译提案阶段的API。\r\n### 总结\r\n- @babel/preset-env是以全局注入方式垫平，@babel/plugin-transform-runtime是以局部变量方式垫平，两者我们应该选择其一，不要又用@babel/preset-env配置方式，又用@babel/plugin-transform-runtime配置方式，这样会出现一些奇奇怪怪的问题。\r\n- 因为使用@babel/plugin-transform-runtime垫平是以局部变量的方式来垫平，所以@babel/plugin-transform-runtime这种配置方式更适合来做三方库的开发。它可以很好的帮我们的库与使用者的项目解耦。\r\n### 开发的项目是应用程序可以这么配置\r\n- 安装依赖\r\n```\r\nnpm install @babel/core @babel/preset-env @babel/plugin-transform-runtime @babel/runtime -D\r\nnpm install core-js -S\r\n```\r\n- babel.config.js\r\n```\r\nmodule.exports = {\r\n  presets: [\r\n    [\r\n      \"@babel/preset-env\",\r\n      {\r\n        modules: false,\r\n        useBuiltIns: \"usage\",\r\n        corejs: {\r\n          version: '3.27.2',\r\n          proposals: true\r\n        }\r\n      }\r\n    ],\r\n  ],\r\n  plugins: [\r\n    \"@babel/plugin-transform-runtime\",\r\n  ]\r\n}\r\n```\r\n- .browserslistrc\r\n```\r\n> 0.2% in CN\r\nlast 10 versions\r\n```\r\n- 入口文件(如果useBuiltIns设置为entry时需要引入以下)\r\n```\r\n// 垫平全部ES6+稳定版API\r\nimport 'core-js/stable';\r\n\r\n// 垫平所有ES6+ API，包括提案阶段\r\nimport 'core-js';\r\n```\r\n### 开发一个第三方库可以这样配置\r\n- 安装依赖\r\n```\r\nnpm install @babel/core @babel/preset-env @babel/plugin-transform-runtime @babel/runtime -D\r\nnpm install @babel/runtime-corejs3 -S\r\n```\r\n- babel.config.js\r\n```\r\nmodule.exports = {\r\n  presets: [\r\n    [\r\n      \"@babel/preset-env\",\r\n      {\r\n        modules: false,\r\n      }\r\n    ],\r\n  ],\r\n  plugins: [\r\n    [\r\n      '@babel/plugin-transform-runtime',\r\n      {\r\n        corejs: {\r\n          version: 3,\r\n          proposals: true\r\n        }\r\n      }\r\n    ]\r\n  ]\r\n}\r\n```\r\n- .browserslistrc\r\n```\r\n> 0.2% in CN\r\nlast 10 versions\r\n```"},function(r,n,e){"use strict";e.r(n),n.default='## CLI\r\n> CLI全称Command Line Interface，是一类通过命令行交互的终端工具。CLI可以帮助我们更高效的操作计算机系统，我们可以将有规律可循的、重复的、繁琐的、模板化的工作集成到CLI工具中。一个命令即可快速的完成一些列操作。\r\n\r\n- GUI：更侧重易用性，用户通过点击图形界面，完成相关操作。\r\n- CLI：更侧重操作效率，通过命令组合自动化操作、批量操作等。\r\n\r\n### Node CLI开发\r\n1. npm init初始化项目。\r\n2. 定义js命令文件\r\n> 文件头部必须有#!/usr/bin/env node，告诉系统使用NodeJS执行脚本；如不声明默认按shell去解析执行。\r\n\r\n```\r\n#!/usr/bin/env node\r\n\r\nconsole.log(\'Hello Node CLI\');\r\n```\r\n3. 定义终端命令\r\n> package.json文件中声明bin字段；格式为："command": "js file"。\r\n\r\n```\r\n// package.json\r\n{\r\n  "bin": {\r\n    "test-cli": "./bin/command.js"\r\n  }\r\n}\r\n```\r\n4. 调试CLI工具\r\n> 通过软链接进行本地调试，在CLI根目录下执行npm link创建软链接，终端运行命令test-cli即可调试。\r\n\r\n5. 发布CLI工具\r\n> 登录npm：npm login；发布CLI：npm publish。'},function(r,n,e){"use strict";e.r(n),n.default="## bfc(块级格式化上下文)\r\n> BFC就是页面上一个单独的容器，容器内部的元素不会影响到外面的元素。\r\n\r\n### 创建bfc\r\n- float的值不是none\r\n- position的值是absolute、fixed\r\n- display的值是inline-block、flow-root、table-cell、table-caption、flex或者inline-flex、grid或者inline-grid\r\n- overflow的值不是visible\r\n\r\n### bfc的作用\r\n- 用BFC包住浮动的子元素，子元素浮动，脱离了普通文档流，父元素包不住子元素。\r\n  1. 父元素浮动\r\n  2. 父元素绝对定位\r\n  3. 父元素变为行内块级元素\r\n  4. 父元素的overflow设置为hidden\r\n- 和浮动元素产生边界，兄弟元素之间，其中左边元素浮动，右边元素会覆盖左边元素\r\n  1. 右侧兄弟元素margin-left设置为浮动元素宽度+想要产生的边距宽度\r\n  2. 让右侧兄弟元素的overflow设置为hidden\r\n  3. 右侧元素浮动"},function(r,n,e){"use strict";e.r(n),n.default="## css\r\n### css3新增的伪类\r\n- -child 类\r\n- -of-type 类\r\n- first-line 选择元素中的第一行（伪元素）\r\n- first-letter 选择元素中的第一个字符（伪元素）\r\n- after 在元素在该元素之后添加内容（伪元素）\r\n- before 在元素在该元素之前添加内容（伪元素）\r\n\r\n### position的值\r\n- relative（相对定位）： 生成相对定位的元素，定位原点是元素本身所在的位置；\r\n- absolute（绝对定位）：生成绝对定位的元素，定位原点是离自己这一级元素最近的一级position设置为absolute或者relative的父元素的左上角为原点的，否则是html元素。\r\n- fixed （固定定位）：生成绝对定位的元素，相对于浏览器窗口进行定位。\r\n- static：默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right、z-index 声明）。\r\n- inherit：规定从父元素继承 position 属性的值。\r\n- sticky (粘贴定位)：必须指定top、bottom、left、right4个值之一\r\n\r\n### 创建三角\r\n> 利用border的特性，隐藏其中三条边。\r\n\r\n### 为什么要初始化CSS样式\r\n> 因为浏览器的兼容问题，不同浏览器对标签的默认值是不同的，如果没有对浏览器的CSS初始化，会造成相同页面在不同浏览器的显示存在差异。\r\n\r\n### CSS预处理器/后处理器\r\n- 预处理器，如：less，sass，增加了css代码的复用性，还有层级，变量，循环， 函数等，对编写以及开发UI组件都极为方便。\r\n- 后处理器，如：postCss，目前最常做的是给css属性添加浏览器私有前缀，实现跨浏览器兼容性的问题。\r\n\r\n### rgba 和 opacity 的透明效果有什么不同\r\n- opacity 作用于元素以及元素内的所有内容（包括文字）的透明度\r\n- rgba 只作用于元素自身的颜色或其背景色，子元素不会继承透明效果\r\n\r\n### 外边距重叠\r\n- 两个相邻的外面边距是正数时，折叠结果就是他们之中的较大值\r\n- 两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值\r\n- 两个外边距一正一负时，折叠结果是两者的相加的和\r\n\r\n### 解析css\r\n> CSS选择器的解析是从右向左解析的，这样会提高查找选择器所对应的元素的效率。若从左向右的匹配，发现不符合规则，需要进行回溯，会损失很多性能。若从右向左匹配，先找到所有的最右节点，对于每一个节点，向上寻找其父节点直到找到根元素或满足条件的匹配规则。\r\n\r\n### others\r\n- transform移动之后有锯齿 加 translateZ(0) 可解决\r\n- rgba的背景色的透明度不影响文字的显示，opacity会影响。\r\n- cursor: not-allowed;  和  pointer-events: none;  共用前面不生效， 两层元素可解决此问题，外层使用前者，内层使用后者\r\n- sass继承另一个类的样式 @extend\r\n```\r\n.button-basic  {\r\n  border: none;\r\n  padding: 15px 30px;\r\n  text-align: center;\r\n  font-size: 16px;\r\n  cursor: pointer;\r\n}\r\n\r\n.button-report  {\r\n  @extend .button-basic;\r\n  background-color: red;\r\n}\r\n```\r\n\r\n\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## css3\r\n- 过渡  transition\r\n- 动画  animation\r\n- 形状转化  transform\r\n- 选择器\r\n- flex   弹性布局\r\n- grid   栅格布局\r\n- column 多列布局\r\n- 阴影 box-shadow\r\n- 圆角 border-raduis\r\n- 文字特效 text-shadow\r\n- 媒体查询 @media\r\n- RGBA和透明度\r\n- 盒子类型 box-sizing"},function(r,n,e){"use strict";e.r(n),n.default='## css选择器-child和-of-type的使用差异\r\n> 平时开发中经常 -child 和 -of-type 傻傻分不清楚，本文将以:first-child和:first-of-type为例说明其差异。\r\n\r\n### 选择器\r\n- :first-child         :first-of-type\r\n- :last-child          :last-of-type\r\n- :nth-child(n)        :nth-of-type(n)\r\n- :nth-last-child(n)   :nth-last-of-type(n)\r\n- only-child           :only-of-type\r\n### :first-child\r\n> :first-child 选择器用于选取属于其父元素的首个子元素的指定选择器\r\n\r\n### :first-of-type\r\n> :first-of-type 选择器匹配属于其父元素的特定类型的首个子元素的每个元素\r\n\r\n### 使用示例\r\n**使用元素选择器**\r\n> p:first-child 可以理解为查找p元素的父元素中第一个子元素，如果为p元素则应用，否则不应用。p:first-of-type 可以理解为查找p元素的父元素中第一个为p的元素，找到并应用。\r\n\r\n- :first-child\r\n> 没有任何子元素应用背景色，因为p标签的父元素的第一个子元素是div不是p，所以选择器不生效。\r\n\r\n```\r\np:first-child {\r\n  background: #ff0000;\r\n}\r\n<div>\r\n  <div>div</div>\r\n  <p>1</p>\r\n  <p>2</p>\r\n  <p>3</p>\r\n</div>\r\n```\r\n- :first-of-type\r\n> 查找p元素的父元素中第一个为p的元素，所以第一个p元素应用背景色。\r\n\r\n```\r\np:first-of-type {\r\n  background: #ff0000;\r\n}\r\n<div>\r\n  <div>div</div>\r\n  <p>1</p> // 应用背景色\r\n  <p>2</p>\r\n  <p>3</p>\r\n</div>\r\n```\r\n\r\n**使用class或者id选择器**\r\n> .exer:first-child 可以理解为查找.exer元素的父元素中第一个子元素，如果为该元素元素有.exer类则应用，否则不应用。.exer:first-of-type 可以理解为查找.exer元素，然后根据对应元素的标签开始找同类型标签的兄弟节点，如果查找到这个元素是同类型兄弟元素中的第一个，则应用，否则不应用。\r\n\r\n- :first-child\r\n> 没有任何子元素应用背景色，因为.exer的父元素的第一个子元素没有exer类，所以选择器不生效。\r\n\r\n```\r\n.exer:first-child {\r\n  background: #ff0000;\r\n}\r\n<div>\r\n  <p>p</p>\r\n  <p class="exer">1</p>\r\n  <p class="exer">2</p>\r\n  <p class="exer">3</p>\r\n</div>\r\n```\r\n- :first-of-type\r\n> 没有任何子元素应用背景色，因为.exer的元素类型是p元素，该元素在同为p的兄弟元素中不是第一个所以没有任何元素应用背景色。\r\n\r\n```\r\n.exer:first-of-type {\r\n  background: #ff0000;\r\n}\r\n<div>\r\n  <p>p</p>\r\n  <p class="exer">1</p>\r\n  <p class="exer">2</p>\r\n  <p class="exer">3</p>\r\n</div>\r\n```\r\n\r\n**使用class或者id选择器搭配:first-of-type查找到的元素节点有很多种**\r\n- :first-child\r\n> .exer:first-child 因为.exer的父元素的第一个子元素有exer类，所以选择器生效。\r\n\r\n```\r\n.exer:first-child {\r\n  background: #ff0000;\r\n}\r\n<body class="body">\r\n  <h1 class="exer">标题1</h1> // 应用背景色\r\n  <h1 class="exer">标题2</h1>\r\n  <p>段落1</p>\r\n  <p class="exer">段落2</p>\r\n  <p class="exer">段落3</p>\r\n  <p class="exer">段落4</p>\r\n  <div class="exer">div 1</div>\r\n  <div>div 2</div>\r\n</body>\r\n```\r\n- :first-of-type\r\n> .exer:first-of-type 会匹配到的元素类型有h1、p、div标签但是找到的p标签不是同为p标签的兄弟元素中的第一个，所以只有h1、div标签应用背景色。\r\n\r\n```\r\n.exer:first-of-type {\r\n  background: #ff0000;\r\n}\r\n<body class="body">\r\n  <h1 class="exer">标题1</h1> // 应用背景色\r\n  <h1 class="exer">标题2</h1>\r\n  <p>段落1</p>\r\n  <p class="exer">段落2</p>\r\n  <p class="exer">段落3</p>\r\n  <p class="exer">段落4</p>\r\n  <div class="exer">div 1</div> // 应用背景色\r\n  <div>div 2</div>\r\n</body>\r\n```\r\n### 总结\r\n- first-child会判断选择器选择到的元素的第一个兄弟元素是否匹配对应的选择器，不会考虑元素的html标签类型。\r\n- first-of-type会判断选择器选择到的元素的html标签类型，判断相同html标签类型的第一个兄弟元素是否匹配对应的选择器。\r\n'},function(r,n,e){"use strict";e.r(n),n.default='## css选择器\r\n- 标签选择器（div, p, span等）\r\n- id选择器（#content）\r\n- 类选择器（.content）\r\n- 相邻选择器（h1+p）\r\n- 子选择器（ul>li）\r\n- 后代选择器（li a）\r\n- 通配符选择器（*）\r\n- 属性选择器（a[rel = "external"]）\r\n- 伪类选择器（a:hover, li:nth-child）\r\n### css 优先级\r\n- !important > id选择器 > 类选择器 > 标签选择器   !important 比 内联优先级高。\r\n- 考虑到就近原则，同权重情况下样式定义以最近者为准。\r\n- 同权重情况下 内联样式表（标签内部）> 嵌入样式表（当前文件中）> 外部样式表（外部文件中）'},function(r,n,e){"use strict";e.r(n),n.default="## flex\r\n### flex属性\r\n> flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。\r\n\r\n- auto (1 1 auto)\r\n- none (0 0 auto)\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## scss变量\r\n### 定义变量\r\n```\r\n// common.scss\r\n$primaryColor: #1890FF;\r\n$buttonSpacing: 8px;\r\n\r\n:export {\r\n  primaryColor: $primaryColor;\r\n  buttonSpacing: $buttonSpacing;\r\n}\r\n```\r\n### scss文件中使用变量\r\n```\r\n@import \"@/styles/common.scss\";\r\n\r\n.icon {\r\n  cursor: pointer;\r\n  color: $primaryColor;\r\n}\r\n```\r\n### js文件中使用变量\r\n```\r\nimport styleConfig from '@/styles/common.scss';\r\n\r\nconst { primaryColor } = styleConfig;\r\n<div style={{ color: primaryColor }}>dyx</div>\r\n```"},function(r,n,e){"use strict";e.r(n),n.default='## 伪类伪元素\r\n- ":" 是伪类，"::" 是伪元素。伪即假，伪类和伪元素都是假的，不存在于 HTML 或 DOM 元素的，他们是由 CSS 创建的。\r\n- ":" 伪类用于表示元素的一种状态，比如 :hover、:visited、:checked 等，CSS 中差不多有 30+ 种伪类。"::" 伪元素用于选择元素的一部分，比如 ::first-letter、::first-line、::before、::after 等，CSS 中目前有 17 个伪元素。\r\n'},function(r,n,e){"use strict";e.r(n),n.default="## 水平垂直居中\r\n### 固定宽高\r\n- flex布局\r\n```\r\n.outer {\r\n  height: 400px;\r\n  width: 400px;\r\n  border: 1px solid #eee;\r\n  display: flex;\r\n  justify-content: center;\r\n  align-items: center;\r\n}\r\n.inner {\r\n  width: 100px;\r\n  height: 100px;\r\n  background: red;\r\n}\r\n```\r\n- grid布局\r\n```\r\n.outer {\r\n  height: 400px;\r\n  width: 400px;\r\n  border: 1px solid #eee;\r\n  display: grid;\r\n}\r\n.inner {\r\n  width: 100px;\r\n  height: 100px;\r\n  background: red;\r\n  margin: auto;\r\n}\r\n```\r\n- 绝对定位加margin负值\r\n```\r\n.outer {\r\n  position: relative;\r\n  height: 400px;\r\n  width: 400px;\r\n  border: 1px solid #eee;\r\n}\r\n.inner {\r\n  position: absolute;\r\n  width: 100px;\r\n  height: 100px;\r\n  background: red;\r\n  left: 50%;\r\n  top: 50%;\r\n  margin-left: -50px;\r\n  margin-top: -50px; \r\n}\r\n```\r\n- 绝对定位 + transform\r\n```\r\n.outer {\r\n  position: relative;\r\n  height: 400px;\r\n  width: 400px;\r\n  border: 1px solid #eee;\r\n}\r\n.inner {\r\n  position: absolute;\r\n  width: 100px;\r\n  height: 100px;\r\n  background: red;\r\n  left: 50%;\r\n  top: 50%;\r\n  transform: translate(-50%, -50%);\r\n}\r\n```\r\n- 绝对定位 + left/right/bottom/top + margin\r\n```\r\n.outer {\r\n  position: relative;\r\n  height: 400px;\r\n  width: 400px;\r\n  border: 1px solid #eee;\r\n}\r\n.inner {\r\n  position: absolute;\r\n  width: 100px;\r\n  height: 100px;\r\n  background: red;\r\n  left: 0;\r\n  right: 0;\r\n  top: 0;\r\n  bottom: 0;\r\n  margin: auto;\r\n}\r\n```\r\n- table-cell + vertical-align + inline-block/margin: auto\r\n```\r\n.outer {\r\n  height: 400px;\r\n  width: 400px;\r\n  border: 1px solid #eee;\r\n  display: table-cell;\r\n  text-align: center;\r\n  vertical-align: middle;\r\n}\r\n.inner {\r\n  width: 100px;\r\n  height: 100px;\r\n  background: red;\r\n  /* 可以换成margin: auto; */\r\n  display: inline-block;\r\n}\r\n```\r\n### 不定宽高\r\n- flex布局\r\n```\r\n.outer {\r\n  height: 400px;\r\n  width: 400px;\r\n  border: 1px solid #eee;\r\n  display: flex;\r\n  justify-content: center;\r\n  align-items: center;\r\n}\r\n.inner {\r\n  background: red;\r\n}\r\n```\r\n- 绝对定位 + transform\r\n```\r\n.outer {\r\n  height: 400px;\r\n  width: 400px;\r\n  border: 1px solid #eee;\r\n  position: relative;\r\n}\r\n.inner {\r\n  background: red;\r\n  position: absolute;\r\n  left: 50%;\r\n  top: 50%;\r\n  transform: translate(-50%, -50%);\r\n}\r\n```\r\n- table-cell\r\n```\r\n.outer {\r\n  height: 400px;\r\n  width: 400px;\r\n  border: 1px solid #eee;\r\n  display: table-cell;\r\n  text-align: center;\r\n  vertical-align: middle;\r\n}\r\n.inner {\r\n  background: red;\r\n  display: inline-block;\r\n}\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## 换行\r\n### white-space\r\n> 这个属性是用来控制空白字符的显示的。\r\n\r\n- normal  默认情况，空格被合并，换行符不生效，自动换行。\r\n- nowrap  空格被合并，换行符无效，原本的自动换行效果也没有了，只有`<br>`才能导致换行。\r\n- pre     空格和换行符被保留了下来，原本的自动换行效果没有了。\r\n- pre-wrap  保留空格和换行符，且可以自动换行。\r\n- pre-line  空格被合并了，换行符可以发挥作用，自动换行还在。\r\n### word-break\r\n> 这个属性是控制单词如何被拆分换行的。\r\n\r\n- normal  默认情况。\r\n- keep-all   所有单词(包括连续的字符)一律不拆分换行，可以理解为只有空格可以触发自动换行。\r\n- break-all  所有单词碰到边界一律拆分换行。\r\n### word-wrap (overflow-wrap)\r\n> 这个属性也是控制单词如何被拆分换行的。\r\n\r\n- normal  默认情况。\r\n- break-word  只有当一个单词一整行都显示不下时，才会拆分换行该单词。"},function(r,n,e){"use strict";e.r(n),n.default='## [样式隔离](https://mp.weixin.qq.com/s/DZjtKB7NgIz4MKEI4IuTdA)\r\n### 运行时通过命名空间来区分，需要人为约定，出错可能性较大。\r\n### 编译时自动转换选择器名字，添加上唯一标识\r\n#### scoped\r\n> scoped 是 vue-loader 支持的方案，它是通过编译的方式在元素上添加了 data-xxx 的属性，然后给 css 选择器加上`[data-xxx]` 全局唯一的属性选择器的方式实现 css 的样式隔离。\r\n\r\n```\r\n<style scoped> \r\n  .guang { \r\n    color: red; \r\n  } \r\n</style>  \r\n<template>  \r\n  <div class="guang">hi</div>  \r\n</template>\r\n\r\n// 编译为\r\n<style> \r\n  .guang[data-v-f3f3eg9] { \r\n    color: red; \r\n  } \r\n</style> \r\n<template> \r\n  <div class="guang" data-v-f3f3eg9>hi</div> \r\n</template>\r\n```\r\n\r\n#### CSS Modules\r\n> css-modules 是 css-loader 支持的方案，在 vue、react 中都可以用，它是通过编译的方式修改选择器名字为全局唯一的方式来实现 css 的样式隔离。\r\n\r\n```\r\n<style module> \r\n  .guang {\r\n    color: red; \r\n  } \r\n</style>  \r\n<template>\r\n  <p :class="$style.guang">hi</p>  \r\n</template>\r\n\r\n<style module>\r\n  ._1yZGjg0pYkMbaHPr4wT6P__1 { \r\n    color: red; \r\n  } \r\n</style> \r\n<template> \r\n  <p class="_1yZGjg0pYkMbaHPr4wT6P__1">hi</p> \r\n</template>\r\n```\r\n#### 两者比较\r\n> 两种方案都是通过编译实现的，但是开发者的使用感受还是不太一样的：scoped 的方案是添加的 data-xxx 属性选择器，因为 data-xx 是编译时自动生成和添加的，开发者感受不到。css-modules 的方案是修改 class、id 等选择器的名字，组件里就要通过 styles.xx 的方式引用这些编译后的名字，开发者是能感受到的。\r\n\r\n#### css-in-js\r\n> 可以通过 JS 来组织 css，利用 JS 的作用域来实现 css 隔离。\r\n\r\n```\r\nimport styled from \'styled-components\';\r\n\r\nconst Wrapper = styled.div`\r\n  font-size: 50px;\r\n  color: red;\r\n`;\r\n\r\nfunction Guang {\r\n  return (\r\n    <div>\r\n      <Wrapper>内部文件写法</Wrapper>\r\n    </div>\r\n  );\r\n}\r\n```\r\n#### 实现 css-modules\r\n> css-loader 是通过 postcss 插件来实现 css-modules 的，其中最核心的是 postcss-modules-scope 插件。\r\n\r\n- 遍历所有选择器，对 :local 伪元素包裹的选择器做转化，并且收集到 exports 中。\r\n- 对 composes 的选择器做一对多的映射，也收集到 exports 中。\r\n- 根据 exports 收集到的映射关系生成 :exports 样式。\r\n- 可以用这个映射关系生成 js 模块，组件里就可以用 styles.xxx 的方式引入对应的 css 了。'},function(r,n,e){"use strict";e.r(n),n.default="## 浮动\r\n### 浮动现象\r\n- 浮动元素脱离文档流，不占据空间引起“高度塌陷”现象。\r\n- 浮动元素碰到包含它的边框或其他浮动元素的边框停留。\r\n### 浮动的问题\r\n- 父级元素的高度将会无法被撑开，会影响与父级元素同级的元素\r\n- 与浮动元素同级的非浮动元素（内联元素）会跟随其后\r\n- 若浮动的元素不是第一个元素，则该元素之前的元素也要浮动，否则会影响页面的显示结构\r\n### 清除浮动\r\n- 父级盒子定义高度height\r\n- 最后一个浮动元素后面加一个div空标签，并且添加样式clear: both\r\n- 包含浮动元素的父级标签添加样式overflow为hidden或both\r\n- 父级div定义zoom"},function(r,n,e){"use strict";e.r(n),n.default="## 盒子模型\r\n- 标准盒子模型盒子的height和width是content（内容）的宽高。\r\n- 而IE盒子模型盒子的宽高则包括content+padding+border部分。\r\n### box-sizing，修改盒子模型\r\n- content-box 默认的标准(W3C)盒模型元素效果 (默认值)\r\n- border-box 触发怪异(IE)盒模型元素的效果\r\n- inherit 继承父元素 box-sizing 属性的值"},function(r,n,e){"use strict";e.r(n),n.default="## 网页变黑白颜色\r\n> 使用CSS filter属性，并使用 grayscale 对图片进行灰度转换，允许有一个参数，可以是数字（0到1）或百分比，0% 到 100% 之间的值会使灰度线性变化。如果不想完全灰掉，可以设置个相对小的数字。\r\n\r\n- 把filter样式加到body元素上通常没有问题，如果网页内有绝对和固定定位元素，要把filter样式加到html上。加在body上有时候会出现横向滚动条，建议加在html上。\r\n```\r\nhtml {\r\n  filter: grayscale(1);\r\n  // 更好的兼容性，加一个带 -webkit- 前缀的样式。\r\n  -webkit-filter: grayscale(1);\r\n}\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## css雪碧图\r\n> 一个网页可能有很多很多的小图标，浏览器在显示页面的时候，就需要像服务器发送很多次访问请求，造成资源浪费，还会导致访问速度变慢。可以把很多小图片（需要使用的小图标）放在一张图片上，按照一定的距离隔开，可以减少网页的http请求，从而大大的提高页面的性能。通过设置background-position的值，移动图片到自己想要的图标位置。\r\n\r\n### 雪碧图动画\r\n> 动画均匀地分多段执行(steps)，每次都有固定相等的偏移量。"},function(r,n,e){"use strict";e.r(n),n.default="## docker\r\n> Docker是一种容器技术，可以在操作系统上创建多个相互隔离的容器。容器内独立安装软件、运行服务。但是这个容器和宿主机还是有关联的，比如可以把宿主机的端口映射到容器内的端口、宿主机某个目录挂载到容器内的目录。\r\n\r\n### [优化镜像体积](https://mp.weixin.qq.com/s/JnTmB7H-8tJuRWMosnHCKA)\r\n- 使用alpine镜像，而不是默认的linux镜像。\r\n> alpine去掉了很多linux里用不到的功能，使得镜像体积更小。\r\n\r\n```\r\n// Dockerfile\r\n\r\n// before\r\nFROM node:lts\r\nFROM nginx:stable\r\n\r\n// after\r\nFROM node:lts-alpine\r\nFROM nginx:stable-alpine\r\n```\r\n- 多阶段构建\r\n> 源码和依赖是不需要的，但是现在都保存在了镜像里。实际上我们只需要构建出来的build目录下的文件。\r\n\r\n1. FROM后面添加一个as来指定当前构建阶段的名字。\r\n2. 通过COPY --from=xxx 可以从上个阶段复制文件过来。\r\n3. docker build之后，只会留下最后一个阶段的镜像。\r\n4. 最终构建出来的镜像里是没有源码的，有的只是build的文件，这样镜像就会小很多。\r\n```\r\n# build stage\r\nFROM node:lts-alpine as build-stage\r\n\r\nWORKDIR /app\r\n\r\nCOPY package.json ./\r\n\r\nCOPY yarn.lock ./\r\n\r\nRUN yarn\r\n\r\nCOPY . . \r\n\r\nRUN npm run build\r\n\r\n# production stage \r\nFROM nginx:stable-alpine as production-stage\r\n\r\nCOPY --from=build-stage /app/build /home/admin/build/\r\n\r\nCOPY default.conf /etc/nginx/conf.d/default.conf\r\n```\r\n### 优化镜像构建速度\r\n- 充分利用缓存\r\n> docker是分层存储的，dockerfile里的每一行指令是一层，会做缓存。每次docker build的时候，只会从变化的层开始重新构建，没变的层会直接复用。现在这种写法(先复制package.json进去，安装依赖之后再复制其他文件)，如果package.json没变，就不会执行yarn，直接复用之前的。如果一开始就把所有文件复制进去那不管package.json变没变，任何一个文件变了都会重新yarn，这样没法充分利用缓存性能不好。\r\n\r\n```\r\n# build stage\r\nFROM node:lts-alpine as build-stage\r\n\r\nWORKDIR /app\r\n\r\nCOPY package.json ./\r\n\r\nCOPY yarn.lock ./\r\n\r\nRUN yarn\r\n\r\nCOPY . . \r\n\r\nRUN npm run build\r\n\r\n# production stage \r\nFROM nginx:stable-alpine as production-stage\r\n\r\nCOPY --from=build-stage /app/build /home/admin/build/\r\n\r\nCOPY default.conf /etc/nginx/conf.d/default.conf\r\n```\r\n\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## docker常用命令\r\n- docker --version 查看docker版本\r\n### 镜像相关命令\r\n- 构建镜像\r\n  1. -t 设置镜像的名字及标签name:tag，可以为一个镜像名设置多个标签。不设置tag时tag默认为latest。\r\n  2. . 表示当前路径，也可指定其他路径。\r\n```\r\n// 镜像名admin，tag为0.0.1\r\ndocker build -t admin:0.0.1 .\r\n```\r\n- docker images 列出镜像\r\n- docker rmi imageId | imageName:imageTag 删除镜像\r\n- docker rmi imageId | imageName:imageTag --force 强制删除镜像(被容器使用的镜像不可被删除)\r\n### 容器相关命令\r\n- 启动容器\r\n  1. -d 后台运行。\r\n  2. -p 指定映射端口号，前一个端口号为服务监听端口号，后一个为容器内部监听端口号，80:80将宿主服务的80端口映射到容器的80端口。\r\n  3. -v 指定数据卷挂载，/aaa:/bbb/ccc挂载宿主机的/aaa目录到容器的/bbb/ccc目录。容器内读写/bbb/ccc目录的时候改的就是宿主机的/aaa目录，改宿主机/aaa目录，容器内的/bbb/ccc也会改。\r\n  4. --name admin 容器名为admin。\r\n  5. admin:0.0.1 使用镜像名为admin的 0.0.1 tag版本，不指定tag版本默认使用latest版本。\r\n```\r\ndocker run -d -p 80:80 -v /aaa:/bbb/ccc --name admin admin:0.0.1\r\n```\r\n- docker ps 查看正在运行的容器\r\n- docker ps -a 查看所有的容器\r\n- docker start containerId | containerName 启动容器\r\n- docker restart containerId | containerName 重启容器\r\n- docker stop containerId | containerName 停止容器\r\n- docker rm containerId | containerName 删除容器 (运行中的容器不能删除，需先停止容器才删除)\r\n- docker rm -f containerId | containerName 强制删除容器 (运行中的容器能强制删除)\r\n- docker同一容器需要更换镜像，需要先将容器删除，更换镜像之后再开启容器\r\n### 进入容器内部相关命令\r\n- docker exec -it containerId | containerName ls  查看容器的文件目录\r\n- docker exec -it containerId | containerName sh  进入容器\r\n- exit  进入容器后退出\r\n### 容器内文件复制到服务器操作\r\n> 在docker容器中进行文件的读写，改动并不会同步到服务器的文件，需要将容器的文件复制到服务器。\r\n\r\n```\r\n// docker cp containerId:docker文件路径 服务器文件路径\r\ndocker cp containerId:/app/schedule.json /root/fe \r\n```\r\n\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## 开发功能总结 done\r\n## 浏览器 done\r\n## 前端调试 done\r\n## 前端工程化  done\r\n## 前端监控 done\r\n## 前端文件处理\r\n- 前端请求文件数据流 \r\n- 文件下载 \r\n- 文件预览\r\n## 前端异常 done\r\n## 性能优化 done\r\n## 移动端 done\r\n## babel  done\r\n## css\r\n- scss变量 \r\n## html  done\r\n## js\r\n- 箭头函数与普通函数的区别\r\n- 节流与防抖\r\n- 浏览器页面不可见时定时器是否准时\r\n- 前端获取网络信息\r\n- 前端路由\r\n- 事件委托\r\n- 渲染大量数据\r\n- beforeunload事件\r\n- hasOwnProperty与in的区别\r\n- js加载方式\r\n- Symbol\r\n## react done\r\n- react事件机制  no\r\n## nginx\r\n- try_files\r\n## web安全  done\r\n## webpack\r\n- css文件提取成单独的文件\r\n- css-loader\r\n- sourcemap\r\n## WebSocket done\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## fetch和merge的区别\r\n> git fetch相当于从远程获取最新代码到本地，但是不会自动merge。\r\n\r\n```\r\ngit fetch origin master 将远程的master分支下载到本地\r\ngit merge origin/master 将远程的master分支进行合并\r\n\r\ngit fetch origin master:mastercopy 获取最新远程的master分支并在本地建立mastercopy分支\r\ngit merge mastercopy 将mastercopy分支合并到当前分支\r\n\r\n// 使用pull代替\r\ngit pull origin master\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## git提交规范\r\n- feat：新增功能\r\n- fix：修复bug\r\n- docs：文档变更\r\n- style：代码格式调整(空格、分号等格式)\r\n- refactor：代码重构\r\n- perf：改善性能\r\n- test：测试\r\n- build：项目构建或外部依赖变更\r\n- ci：持续集成相关调整\r\n- chore：变更构建流程或辅助工具\r\n- revert：代码回退"},function(r,n,e){"use strict";e.r(n),n.default="## rebase和merge的区别\r\n### merge\r\n- 只处理一次冲突\r\n- 会把两个分支最新的2个commit合并成一个新的commit\r\n- 合并后的所有 commit 会按照提交时间从旧到新排列\r\n### rebase\r\n- 在 dev 分支执行 git reabse master 会将 dev 分支的当前提交复制到master的最新提交之后\r\n- 可能会多次解决同一个地方的冲突\r\n- 不会产生合并的commit\r\n- 合并后的所有 commit 顺序不一定按照 commit 的提交时间排列\r\n### merge VS rebase\r\n> 当从a分支切到b分支的时候在b分支中做了多次提交，而且a分支在切到b分支之后也做了多次提交。\r\n\r\n- 将b分支merge到a分支，a分支的提交记录会按a、b分支的提交顺序记录，且有合并的一次记录。最后的分支树呈现非线性的结构。\r\n- 将b分支rebase到a分支，a分支的提交记录会先记录a分支的提交，再记录b分支的提交，且没有合并的一次记录。会形成一个线性的分支树。"},function(r,n,e){"use strict";e.r(n),n.default="## html渲染\r\n- 构造文档对象模型(DOM)\r\n- 构造CSS对象模型(CSSOM)\r\n- 生成渲染树\r\n- 布局\r\n- 绘制\r\n\r\n![html渲染](./img/html%E6%B8%B2%E6%9F%93.png)\r\n### 构造文档对象模型(DOM)\r\n> 当浏览器访问网页接受到HTML文档时，会对于接受到的HTML进行Parsing过程（解析HTML文档），这一过程主要分为以下四个阶段。\r\n\r\n- 转化\r\n> 首先浏览器从磁盘（缓存）或网络读取HTML的原始字节，并根据文件的指定编码（例如UTF-8）将它们转换为单个字符。\r\n\r\n- 词法分析\r\n> 浏览器会将上一步骤得到的字符串转换为一个一个Token（如W3C HTML5标准所指定的例如`<html>`、`<body>`以及尖括号内的其他字符串）。每个Token都有特殊的含义和自己的一套规则。\r\n\r\n- 语法分析\r\n> 浏览器会将上一步的到的Tokens转换为一个“对象”，这些对象定义了它们的属性和规则。\r\n\r\n- 构造DomTree\r\n> 构造文档对象模型的最后一步就是构建DomTree。因为HTML中定义了不同标签之间的关系（一些标签包含在其他标签中等等），所以最终浏览器的到的对象是一个树型结构，该结构中通过嵌套等关系描述了文档中不同标签的关系。\r\n\r\n![domTree](./img/domTree.png)\r\n### 构造CSS对象模型(CSSOM)\r\n- CSS的处理和HTML差不多，CSS文件经过转化为字符、词法分析、语法分析、构造树状的CSSOM。\r\n- 之所以将CSS也处理为树状结构，是因为CSS的规则是支持“向下级联”的嵌套方案的，也就是我们在日常开发中CSS的继承特性。浏览器在计算节点的样式时，它会从适用于该节点的最通用（顶层）的规则开始进行计算，之后会一层一层进行递归从而得到该节点最终的样式。\r\n- CSS写在style标签中在chrome中style标签会被Html Parse来解析。\r\n- 加载样式脚本并不会阻塞后续DOM解析（这里的非阻塞更多相对于JS文件，因为同步JS文件的加载是会阻塞后续DOM解析的），而主线程构造CSS对象模型的过程是会和构造文档对象模型抢占主线程资源的（主线程并不会同时构造CSS对象模型以及同时构造文档对象模型）。\r\n\r\n![cssomTree](./img/cssomTree.png)\r\n### 生成渲染树\r\n- 上述的两个过程中基于HTML和CSS分别得到了DomTree以及CssomTree，此时这两棵树是互相独立的两个树状对象。\r\n- DomTree描述了页面中所有的DOM结构内容，CssomTree描述了需要应用在页面节点上的样式规则。\r\n- 浏览器会将两个Tree进行合并，最终组成一个具有所有可见（元素在布局中仍然占据空间）节点样式和内容的RenderTree。\r\n  1. 从DomTree开始遍历，遍历每一个可见节点。一些脚本标签、元标签等节点是不可见的会被省略。对于一些通过CSS隐藏的节点，也会从渲染树中省略。\r\n  2. 对于DomTree中的每个可见节点，在CssomTree中找到合适匹配的CSSOM规则并应用它们。\r\n  3. 最终在RenderTree上挂载这些带有内容以及样式的可见节点。\r\n\r\n![renderTree](./img/renderTree.png)\r\n### 布局\r\n- 上述过程得到RenderTree后，浏览器已经明确的清楚哪些节点应该被渲染到页面上同时也获得了可见节点的样式，但是浏览器并未计算出每个节点在对应设备（屏幕）上确切的位置和大小。\r\n- 布局过程会计算出每个节点在对应设备（屏幕）上确切的位置和大小。\r\n### 绘制\r\n- 一旦渲染树创建并且布局完成，像素就可以被绘制在屏幕上，既然浏览器已经明确的知道哪些节点是可见的，以及它们的样式和几何形状，绘制阶段就是将RenderTree中的每个节点转换为屏幕上的实际像素。\r\n### CSS加载不会阻塞构造文档对象模型，但是CSS加载会阻塞生成渲染树。 \r\n- 构造文档对象模型和构造CSS对象模型是并行的，这也解释了CSS加载不会阻塞构造文档对象模型。\r\n- 由于RenderTree是依赖于DomTree和CssomTree的，所以RenderTree必须等待CssomTree构建完成，也就是CSS资源加载完成(或者CSS资源加载失败)后，才能开始生成渲染树。因此CSS加载会阻塞生成渲染树。\r\n- 由于js可能会操作之前的DOM节点和CSS样式，因此浏览器会维持html中CSS和JS的顺序。因此CSS会在后面的JS执行前先加载执行完毕。所以CSS会阻塞后面JS的执行。\r\n\r\n\r\n"},function(r,n,e){"use strict";e.r(n),n.default='## meta\r\n> meta是文档级元数据元素，meta标签一般放在整个html页面的head部分。\r\n\r\n### description\r\n- 一段简短而精确对页面内容的描述。\r\n```\r\n<meta name="description" content="dyxweb个人网站">\r\n```\r\n### keywords\r\n- 与页面内容相关的关键词，使用逗号分隔。\r\n- 某些搜索引擎在遇到这些关键字时，会用这些关键字对文档进行分类。\r\n```\r\n<meta name="keywords" content="dyxweb,个人网站">\r\n```\r\n### viewport\r\n- 用来配置视口大小和缩放等。\r\n- viewport只对移动端浏览器有效，对PC端浏览器是无效的。\r\n```\r\n<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />\r\n```\r\n### author\r\n- 用来表示网页的作者的名字，例如某个组织或者机构。\r\n```\r\n<meta name="author" content="dyxweb">\r\n```\r\n### robots\r\n- 表示爬虫对此页面的处理行为，是用来做搜索引擎抓取的。content值如下。\r\n  1. all：搜索引擎将索引此网页，并继续通过此网页的链接索引搜索其它的网页。\r\n  2. none：搜索引擎将忽略此网页。\r\n  3. index：搜索引擎索引此网页。\r\n  4. follow：搜索引擎继续通过此网页的链接索引搜索其它的网页。\r\n```\r\n<meta name="robots" content="all">\r\n```\r\n### renderer\r\n- 用来指定双核浏览器的渲染方式。\r\n```\r\n<meta name="renderer" content="webkit"> // 默认webkit内核\r\n<meta name="renderer" content="ie-comp"> // 默认IE兼容模式\r\n<meta name="renderer" content="ie-stand"> // 默认IE标准模式\r\n```\r\n'},function(r,n,e){"use strict";e.r(n),n.default='## 修改页签icon\r\n### 正常显示\r\n```\r\n<head>\r\n  <link rel="shortcut icon" href="./logo.png" type="image/x-icon" />\r\n</head>\r\n```\r\n### react中使用react-helmet动态修改页签\r\n```\r\nimport Helmet from "react-helmet";\r\nimport logoImg from \'@/assets/image/logo.png\';\r\n\r\n<Helmet link={[{ rel: \'shortcut icon\', href: logoImg }]} />\r\n```'},function(r,n,e){"use strict";e.r(n),n.default='## 页面可见性\r\n### document.visibilityState\r\n> 只读属性，返回document的可见性。\r\n\r\n- visible：此时页面内容至少是部分可见。即此页面在前景标签页中，并且窗口没有最小化。\r\n- hidden：此时页面对用户不可见。即文档处于背景标签页或者窗口处于最小化状态，或者操作系统正处于锁屏状态。\r\n- prerender：页面此时正在渲染中，因此是不可见的，文档只能从此状态开始，永远不能从其它值变为此状态。\r\n### visibilitychange监听页面可见性变化\r\n```\r\ndocument.addEventListener("visibilitychange", () => {\r\n  if (document.visibilityState === "visible") {\r\n    // 页面变为可见时的操作\r\n  } else {\r\n    // 页面变为不可见时的操作\r\n  }\r\n});\r\n```'},function(r,n,e){"use strict";e.r(n),n.default="## 页面生命周期\r\n### HTML页面的生命周期主要有三个重要事件\r\n- DOMContentLoaded：浏览器已经完全加载了HTML，DOM树已经构建完毕，但是像是`<img>`和样式表等外部资源可能并没有下载完毕。\r\n- load：浏览器已经加载了所有的资源（图像，样式表等）。\r\n- beforeunload/unload：当用户离开页面的时候触发。\r\n### 每个事件特定的用途\r\n- DOMContentLoaded：DOM加载完毕，所以JS可以访问所有DOM节点，初始化界面。\r\n- load：附加资源已经加载完毕，可以在此事件触发时获得图像的大小。\r\n- beforeunload/unload：用户正在离开页面，可以询问用户是否保存了更改以及是否确定要离开页面。\r\n### DOMContentLoaded\r\n- DOMContentLoaded由document对象触发，可以使用addEventListener来监听它。\r\n```\r\ndocument.addEventListener(\"DOMContentLoaded\", () => {});\r\n```\r\n- 当浏览器在解析HTML页面时遇到`<script>...<\/script>`标签，将无法继续构建DOM树（UI渲染线程与JS引擎是互斥的，当JS引擎执行时UI线程会被挂起），必须立即下载、执行脚本，所以DOMContentLoaded有可能在所有脚本执行完毕后触发。带async和defer属性的外部JS脚本，JS脚本的下载会异步下载不会影响DOM树的构建。\r\n- 外部样式表并不会阻塞DOM的解析，DOMContentLoaded不会被它们影响。但是如果在样式后面有一个内联脚本，那么脚本必须等待样式先加载完。JS因为有可能会去获取DOM的样式，所以JS会等待样式表加载完毕，而JS是阻塞DOM的解析的，所以在有外部样式表的时候，JS会一直阻塞到外部样式表下载完毕。\r\n```\r\n<link type=\"text/css\" rel=\"stylesheet\" href=\"style.css\">\r\n<script>\r\n  // 脚本直到样式表加载完毕后才会执行。\r\n  alert(getComputedStyle(document.body).marginTop);\r\n<\/script>\r\n```\r\n### load\r\n- window对象上的onload事件可以监听到load事件的触发，onload事件在所有资源包括样式表、图片和其它资源下载完毕后触发。\r\n```\r\nwindow.onload = () => {};\r\n```\r\n### beforeunload/unload\r\n- 用户离开页面的时候，window对象上的unload事件会被触发，可以做一些不存在延迟的事情比如关闭弹出的窗口，但是无法阻止用户转移到另一个页面上。\r\n```\r\nwindow.onunload = () => {};\r\n```\r\n- 用户即将离开页面或者关闭窗口时，beforeunload事件将会被触发，可以在此事件中进行额外的确认。\r\n```\r\nwindow.onbeforeunload = () => {};\r\n```\r\n### readyState\r\n- 可以通过document.readyState获取页面加载的状况\r\n  1. loading：document仍在加载。\r\n  2. interactive：文档已经完成加载已被解析，但是图像、样式表和框架之类的子资源仍在加载。时间上和DOMContentLoaded同时发生，不过顺序在DOMContentLoaded之前。\r\n  3. complete：文档和所有子资源已完成加载，load事件即将被触发。时间上和window.onload同时发生，不过顺序在window.onload之前。\r\n### readystatechange\r\n- 每当文档的加载状态改变的时候就会有readystatechange事件被触发。\r\n```\r\n// current state\r\nconsole.log(document.readyState);\r\n\r\n// print state changes\r\ndocument.addEventListener('readystatechange', () => console.log(document.readyState));\r\n```\r\n### 执行顺序\r\n- document.readyState在DOMContentLoaded前一刻变为interactive，这两个事件可以认为是同时发生。\r\n- document.readyState在所有资源加载完毕后（包括 iframe 和 img）变成complete，complete、 img.onload和window.onload几乎同时发生，区别就是window.onload在所有其他的load事件之后执行。\r\n```\r\n<script>\r\n  console.log('initial readyState:' + document.readyState);\r\n\r\n  document.addEventListener('readystatechange', () => console.log('readyState:' + document.readyState));\r\n  document.addEventListener('DOMContentLoaded', () => console.log('DOMContentLoaded'));\r\n\r\n  window.onload = () => console.log('window onload');\r\n<\/script>\r\n\r\n<iframe src=\"iframe.html\" οnlοad=\"console.log('iframe onload')\"></iframe>\r\n<img src=\"img.png\" id=\"img\">\r\n\r\n<script>\r\n  img.onload = () => console.log('img onload');\r\n<\/script>\r\n```\r\n- initial readyState:loading\r\n- readyState:interactive\r\n- DOMContentLoaded\r\n- iframe onload\r\n- readyState:complete\r\n- img onload\r\n- window onload\r\n\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## Accept 系列字段\r\n### 数据格式\r\n> 类型体现在Content-Type这个字段，这是针对于发送端而言，接收端想要收到特定类型的数据，也可以用Accept字段。\r\n\r\n- text： text/html, text/plain, text/css 等\r\n- image: image/gif, image/jpeg, image/png 等\r\n- audio/video: audio/mpeg, video/mp4 等\r\n- application: application/json, application/javascript, application/pdf, application/octet-stream\r\n### 压缩方式\r\n> 体现在了发送方的Content-Encoding字段上，接收什么样的压缩方式体现在了接受方的Accept-Encoding字段上。\r\n\r\n- gzip: 当今最流行的压缩格式\r\n- deflate: 另外一种著名的压缩格式\r\n- br: 一种专门为 HTTP 发明的压缩算法\r\n### 支持语言\r\n> 发送方Content-Language字段，接受方对应的字段为Accept-Language。\r\n\r\n```\r\n// 发送端\r\nContent-Language: zh-CN, zh, en\r\n// 接收端\r\nAccept-Language: zh-CN, zh, en\r\n```\r\n### 字符集\r\n> 接收端对应为Accept-Charset，指定可以接受的字符集，而在发送端并没有对应的Content-Charset, 而是直接放在了Content-Type中，以charset属性指定。\r\n\r\n```\r\n// 发送端\r\nContent-Type: text/html; charset=utf-8\r\n// 接收端\r\nAccept-Charset: charset=utf-8\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## URI\r\n> 全称为(Uniform Resource Identifier), 统一资源标识符，它的作用就是区分互联网上不同的资源，它并不是我们常说的网址, 网址指的是URL, 实际上URI包含了URN和URL两个部分。\r\n\r\n### 结构\r\n> scheme://  user:passwd@  host:port  path  ?query  #fragment\r\n\r\n- scheme 表示协议名，比如http, https, file等等。后面必须和://连在一起。\r\n- user:passwd@ 表示登录主机时的用户信息，不过很不安全，不推荐使用，也不常用。\r\n- host:port表示主机名和端口。\r\n- path表示请求路径，标记资源所在位置。\r\n- query表示查询参数，为key=val这种形式，多个键值对之间用&隔开。\r\n- fragment表示 URI 所定位的资源内的一个锚点，浏览器可以根据这个锚点跳转到对应的位置。\r\n### 示例\r\n> https://www.baidu.com/s?wd=HTTP&rsv_spt=1。https即scheme部分，www.baidu.com为host:port部分（注意，http 和 https 的默认端口分别为80、443），/s为path部分，而wd=HTTP&rsv_spt=1就是query部分。\r\n\r\n### URI 编码\r\n> URI 只能使用ASCII, ASCII 之外的字符是不支持显示的，而且还有一部分符号是界定符，如果不加以处理就会导致解析出错。因此，URI 引入了编码机制，将所有非 ASCII 码字符和界定符转为十六进制字节值，然后在前面加个%。\r\n\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## dns\r\n> 域名系统。万维网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。\r\n\r\n### DNS解析\r\n> 通过域名，最终得到该域名对应的IP地址的过程叫做域名解析。\r\n\r\n### DNS缓存\r\n> 有dns的地方,就有缓存。浏览器、操作系统、Local DNS、根域名服务器，它们都会对DNS结果做一定程度的缓存。\r\n\r\n1. 首先搜索浏览器自身的DNS缓存,如果存在，则域名解析到此完成。\r\n2. 如果浏览器自身的缓存里面没有找到对应的条目，那么会尝试读取操作系统的hosts文件看是否存在对应的映射关系,如果存在，则域名解析到此完成。\r\n3. 如果本地hosts文件不存在映射关系，则查找本地DNS服务器(ISP服务器,或者自己手动设置的DNS服务器),如果存在,域名到此解析完成。\r\n4. 如果本地DNS服务器还没找到的话,它就会向根服务器发出请求,进行递归查询。"},function(r,n,e){"use strict";e.r(n),n.default="## http协议(超文本传输协议)\r\n> 因特网上应用最为广泛的一种网络传输协议。HTTP是一个应用层协议，由请求和响应构成，是一个标准的客户端服务器模型。HTTP是一个无状态的协议。在HTTP开始工作前，客户端首先会通过TCP/IP协议来和服务端建立链接。\r\n\r\n### 短连接\r\n> 建立连接 - 数据传输 - 关闭连接 ... 建立连接 - 数据传输 - 关闭连接。如果客户请求频繁，将在TCP的建立和关闭操作上浪费较多时间和带宽。\r\n\r\n### 长连接 Connection:keep-alive\r\n> 建立连接 - 数据传输 ...（保持连接）... 数据传输 - 关闭连接。长连接可以省去较多的TCP建立和关闭的操作，减少浪费，节约时间。长链接分为 without pipelining 和 with pipelining。\r\n\r\n- without pipelining\r\n> 客户端只在收到前一个请求的响应后，才发出新的请求。\r\n\r\n- with pipelining\r\n> 每次建立连接后无需等待请求回来就可以发送下一个请求。\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## [http2](https://zhuanlan.zhihu.com/p/26559480)\r\n> HTTP/2 是 HTTP 协议自 1999 年 HTTP 1.1 发布后的首个更新，主要基于 SPDY 协议。\r\n\r\n### 二进制分帧\r\n- 帧：HTTP/2 数据通信的最小单位消息：指 HTTP/2 中逻辑上的 HTTP 消息。例如请求和响应等，消息由一个或多个帧组成。\r\n- 流：存在于连接中的一个虚拟通道。流可以承载双向消息，每个流都有一个唯一的整数ID。\r\n- HTTP/2 采用二进制格式传输数据，而非 HTTP 1.x 的文本格式，二进制协议解析起来更高效。 HTTP / 1 的请求和响应报文，都是由起始行，首部和实体正文（可选）组成，各部分之间以文本换行符分隔。HTTP/2 将请求和响应数据分割为更小的帧，并且它们采用二进制编码。\r\n- HTTP/2 中，同域名下所有通信都在单个连接上完成，该连接可以承载任意数量的双向数据流。每个数据流都以消息的形式发送，而消息又由一个或多个帧组成。多个帧之间可以乱序发送，根据帧首部的流标识可以重新组装。\r\n### 多路复用\r\n> http2.0中，一个tcp/ip请求可以请求多个资源，只要一次tcp/ip请求，就可以请求若干个资源。HTTP 1.x 中，如果想并发多个请求，必须使用多个 TCP 链接，且浏览器还会对单个域名有TCP连接请求限制。\r\n\r\n#### 在 HTTP/2 中，有了二进制分帧之后，HTTP /2 不再依赖 TCP 链接去实现多流并行了。\r\n- 同域名下所有通信都在单个连接上完成。\r\n- 单个连接可以承载任意数量的双向数据流。\r\n- 数据流以消息的形式发送，而消息又由一个或多个帧组成，多个帧之间可以乱序发送，根据帧首部的流标识可以重新组装。\r\n#### 性能提升\r\n- 同个域名只需要占用一个 TCP 连接，消除了因多个 TCP 连接而带来的延时和内存消耗。\r\n- 单个连接上可以并行交错的请求和响应，之间互不干扰。\r\n- 在HTTP/2中，每个请求都可以带一个31bit的优先值，0表示最高优先级， 数值越大优先级越低。有了这个优先值，客户端和服务器就可以在处理不同的流时采取不同的策略，以最优的方式发送流、消息和帧。\r\n### 头部压缩\r\n> HTTP/2对消息头采用HPACK（专为http/2头部设计的压缩格式）进行压缩传输，能够节省消息头占用的网络的流量。HTTP/2下两个请求，请求一发送了所有的头部字段，第二个请求则只需要发送差异数据，这样可以减少冗余数据，降低开销。而HTTP/1.x每次请求，都会携带大量冗余头信息，浪费了很多带宽资源。\r\n\r\n- HTTP/2在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键－值对，对于相同的数据，不再通过每次请求和响应发送。\r\n- 首部表在HTTP/2的连接存续期内始终存在，由客户端和服务器共同渐进地更新。\r\n- 每个新的首部键－值对要么被追加到当前表的末尾，要么替换表中之前的值。\r\n### 服务器推送\r\n- 服务端可以在发送页面HTML时主动推送其它资源，而不用等到浏览器解析到相应位置，发起请求再响应。例如服务端可以主动把JS和CSS文件推送给客户端，而不需要客户端解析HTML时再发送这些请求。\r\n- 服务端可以主动推送，客户端也有权利选择是否接收。如果服务端推送的资源已经被浏览器缓存过，浏览器可以通过发送RST_STREAM帧来拒收。主动推送也遵守同源策略，服务器不会随便推送第三方资源给客户端。\r\n### 请求优先级\r\n> 如果流被赋予了优先级，它就会基于这个优先级来处理，由服务器决定需要多少资源来处理该请求。\r\n\r\n### 去除某些针对HTTP/1.x的优化\r\n#### 域名分片（domain sharding）\r\n> HTTP/1.x中，通信两端最多只有六个连接，且是通过区分不同域名来维持管理的。为了突破这个限制，通常会把请求资源至于不同的域名下（如 shard1.example.org, shard2.example.org）。而在HTTP/2中，因为不需要新开连接来解决头阻塞问题，所以不需要通过这种方式来增加通信的连接数。相反的在HTTP/2中采用域名分片会造成以下两个问题\r\n\r\n- 增加DNS域名解析时间\r\n- 增加传输中压缩头部的大小。头部压缩中的数据复用是在一个连接上维持的，域名分片后新开的连接无法复用之前已经发送过的头部数据，造成一些不必要地数据在网络上的传输。\r\n#### 雪碧图\r\n> HTTP/1.x中，为了减少请求多个图片带来的头阻塞问题，通常采用把多个图片拼接成一个大图，然后一个请求将所有图片加载在浏览器中，然后使用CSS技术将所需要的部分按需展示出来。雪碧图会带来如下问题：\r\n\r\n- 增加代码量，需要写一些本不必要地CSS代码\r\n- 在浏览器渲染过程中，内存中需要加载更多的图片内容\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## [https](https://mp.weixin.qq.com/s/I5yezHTrObblrBGAoAEGkQ)\r\n> HTTP是明文传输，因此在传输过程中数据都有可能被第三方窃取或者篡改，也就是我们常说的中间人攻击。为了防范攻击，引入新的加密方案，即 HTTPS。HTTPS就是使用SSL/TLS协议进行加密传输。\r\n\r\n### 为什么需要加密\r\n> 因为http的内容是明文传输的，明文数据会经过中间代理服务器、路由器、wifi热点、通信服务运营商等多个物理节点，如果信息在传输过程中被劫持，传输的内容就完全暴露了。劫持者还可以篡改传输的信息且不被双方察觉，这就是中间人攻击。所以我们才需要对信息进行加密。\r\n\r\n### 对称加密\r\n> 一个密钥，它可以加密一段信息，也可以对加密后的信息进行解密。\r\n\r\n**对称加密不可行**\r\n> 通信双方都各自持有同一个密钥，且没有别人知道，这两方的通信安全当然是可以被保证的。然而最大的问题就是这个密钥怎么让传输的双方知晓，同时不被别人知道。如果由服务器生成一个密钥并传输给浏览器，那在这个传输过程中密钥被别人劫持了，之后他就能用密钥解开双方传输的任何内容了，所以对称加密不可行。\r\n\r\n### 非对称加密\r\n> 有两把密钥，通常一把叫做公钥、一把叫私钥，用公钥加密的内容必须用私钥才能解开，私钥加密的内容只有公钥能解开。\r\n\r\n**非对称加密不可行**\r\n> 服务器先把公钥以明文方式传输给浏览器，之后浏览器向服务器传数据前都先用这个公钥加密好再传，这条数据的安全似乎可以保障了，因为只有服务器有相应的私钥能解开公钥加密的数据。然而反过来由服务器到浏览器的这条路无法保证安全，如果服务器用它的私钥加密数据传给浏览器，那么浏览器用公钥可以解密它，而这个公钥是一开始通过明文传输给浏览器的，若这个公钥被中间人劫持到了，那他也能用该公钥解密服务器传来的信息了。\r\n\r\n**改良的非对称加密**\r\n> 通过一组公钥私钥，可以保证单个方向传输的安全性，可以尝试使用两组公钥私钥保证双向的数据传输安全。抛开此种方法仍有的漏洞（传递公钥的过程被中间人窃取公钥，详见下述的非对称和对称加密不可以行），HTTPS的加密依然没使用这种方案的原因是非对称加密算法非常耗时，而对称加密快很多。\r\n\r\n- 某网站服务器拥有公钥A与对应的私钥A’；浏览器拥有公钥B与对应的私钥B’。\r\n- 浏览器把公钥B明文传输给服务器。\r\n- 服务器把公钥A明文给传输浏览器。\r\n- 之后浏览器向服务器传输的内容都用公钥A加密，服务器收到后用私钥A’解密。由于只有服务器拥有私钥A’，所以能保证这条数据的安全。\r\n- 同理，服务器向浏览器传输的内容都用公钥B加密，浏览器收到后用私钥B’解密。同上也可以保证这条数据的安全。\r\n### 非对称加密+对称加密\r\n- 某网站拥有用于非对称加密的公钥A、私钥A’。\r\n- 浏览器向网站服务器请求，服务器把公钥A明文给传输浏览器。\r\n- 浏览器随机生成一个用于对称加密的密钥X，用公钥A加密后传给服务器。\r\n- 服务器拿到后用私钥A’解密得到密钥X。\r\n- 这样双方就都拥有对称密钥X了，且别人无法知道它。之后双方所有数据都通过密钥X加密解密即可。\r\n### 非对称加密+对称加密不可行\r\n> 如果在数据传输过程中，中间人劫持到了数据，此时他的确无法得到浏览器生成的密钥X，这个密钥本身被公钥A加密了，只有服务器才有私钥A’解开它。但是如果中间人劫持了公钥此时后续的流程都将被中间人窃取到。非对称加密+对称加密不可行的根本原因是浏览器无法确认收到的公钥是不是网站自己的，因为公钥本身是明文传输的。\r\n\r\n- 某网站有用于非对称加密的公钥A、私钥A’。\r\n- 浏览器向网站服务器请求，服务器把公钥A明文给传输浏览器。\r\n- 中间人劫持到公钥A，保存下来，把数据包中的公钥A替换成自己伪造的公钥B（它当然也拥有公钥B对应的私钥B’）。\r\n- 浏览器生成一个用于对称加密的密钥X，用公钥B（浏览器无法得知公钥被替换了）加密后传给服务器。\r\n- 中间人劫持后用私钥B’解密得到密钥X，再用公钥A加密后传给服务器。\r\n- 服务器拿到后用私钥A’解密得到密钥X。此时对称秘钥X已被中间人窃取，后续所有的通信都有可能被中间人窃取到。\r\n### 如何证明浏览器收到的公钥一定是该网站的公钥\r\n> CA机构，它是如今互联网世界正常运作的前提，而CA机构颁发的“身份证”就是数字证书，数字证书可以证明网站信息就是该网站的。\r\n\r\n**数字证书**\r\n> 网站在使用HTTPS前，需要向CA机构申领一份数字证书，数字证书里含有证书持有者信息、公钥信息等。服务器把证书传输给浏览器，浏览器从证书里获取公钥就行了，证书就如身份证，证明“该公钥对应该网站”。\r\n\r\n**验证数字证书的真实性以及如何防止数字证书传递过程中被篡改**\r\n> 把证书原本的信息生成一份“签名”，比对证书内容和签名是否一致就能判别是否被篡改。这就是数字证书的“防伪技术”，这里的“签名”被称为数字签名。原有的证书信息和签名信息共同组成了数字证书。\r\n\r\n**数字签名的生成**\r\n1. CA机构拥有非对称加密的私钥和公钥。\r\n2. CA机构对证书明文数据进行hash加密(不可逆)。\r\n3. 对hash加密后的值用私钥加密，得到数字签名。\r\n**浏览器验证数字签名**\r\n1. 拿到证书，得到明文数据和数字签名。\r\n2. 用CA机构的公钥对数字签名解密（由于是浏览器信任的机构，所以浏览器保有它的公钥）。\r\n3. 用证书里指明的hash加密算法对明文数据进行hash加密。\r\n4. 比较第二步和第三步数据的一致性，如果一致则说明证书可信。\r\n**中间人是否可以篡改数字证书信息**\r\n> 假设中间人篡改了证书的原文，由于他没有CA机构的私钥，所以无法得到此时加密后签名，无法相应地篡改签名。浏览器收到该证书后会发现原文和签名解密后的值不一致，则说明证书已被篡改，证书不可信。\r\n\r\n**中间人是否可以掉包整个证书**\r\n> 假设有另一个网站B也拿到了CA机构认证的证书，它想劫持网站A的信息。于是它成为中间人拦截到了A传给浏览器的证书，然后替换成自己的证书。替换证书之后浏览器很容易就发现证书被替换了，因为证书里包含了网站A的信息，包括域名，浏览器把证书里的域名与自己请求的域名比对一下就知道有没有被掉包了。\r\n\r\n**为什么制作数字签名时需要hash一次**\r\n- 性能问题，非对称加密效率较差，证书信息一般较长，比较耗时。而hash后得到的是固定长度的信息（比如用md5算法hash后可以得到固定的128位的值），这样加解密就快很多。\r\n- [安全问题](crypto.stackexchange.com/a/12780)\r\n**浏览器保有的CA机构的公钥可信性**\r\n> 操作系统、浏览器本身会预装一些它们信任的根证书，如果其中会有CA机构的根证书，这样就可以拿到它对应的可信公钥了。实际上证书之间的认证也可以不止一层，可以A信任B，B信任C，以此类推，我们把它叫做信任链或数字证书链。也就是一连串的数字证书，由根证书为起点，透过层层信任，使终端实体证书的持有者可以获得转授的信任，以证明身份。\r\n\r\n**每次进行HTTPS请求时都必须在SSL/TLS层进行握手传输密钥吗**\r\n> 不用，服务器会为每个浏览器（或客户端软件）维护一个session ID，在TLS握手阶段传给浏览器，浏览器生成好密钥传给服务器后，服务器会把该密钥存到相应的session ID下，之后浏览器每次请求都会携带session ID，服务器会根据session ID找到相应的密钥并进行解密加密操作，这样就不必要每次重新制作、传输密钥了。\r\n\r\n### https加密完整过程\r\n1. 客户端发起一个HTTPS请求，连接443端口。这个过程可以理解成是「请求公钥的过程」。\r\n2. 服务器收到请求后，会把数字证书（证书信息和签名信息(将证书信息hash加密之后使用CA机构私钥加密)）发送给客户端。\r\n3. 浏览器拿到证书之后会得到证书信息和签名信息，用CA机构的公钥对数字签名解密，然后使用相同的hash加密证书信息，对比公钥解密和hash加密后的信息是否一致，一致则说明证书有效。\r\n4. 在从数字证书中安全拿到「服务器公钥」后，客户端随机生成一个「对称密钥」，使用「服务器公钥」加密这个「对称密钥」，发送给服务器。\r\n5. 服务器通过自己的私钥(数字证书信息中公钥对应的私钥)解密，至此得到了「对称密钥」，此时两者都拥有了相同的「对称密钥」。\r\n6. 之后客户端和服务器之间的通信都通过此对称秘钥进行加解密。\r\n### http和https的区别\r\n> 对数据进行加密，并建立一个信息安全通道，来保证传输过程中的数据安全，对网站服务器进行真实身份认证。\r\n\r\n1. HTTP 明文传输，数据都是未加密的，安全性较差，HTTPS（SSL/TLS+HTTP） 数据传输过程是加密的，安全性较好。\r\n2. 使用 HTTPS 协议需要到 CA（Certificate Authority，数字证书认证机构） 申请证书，一般免费证书较少，因而需要一定费用。\r\n3. HTTP 页面响应速度比 HTTPS 快，主要是因为 HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，而 HTTPS除了 TCP 的三个包，还要加上 ssl 握手需要的 9 个包，所以一共是 12 个包。\r\n4. http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。\r\n5. HTTPS 其实就是建构在 SSL/TLS 之上的 HTTP 协议，HTTPS 比 HTTP 要更耗费服务器资源。"},function(r,n,e){"use strict";e.r(n),n.default="## http代理\r\n> HTTP 是基于请求-响应模型的协议，一般由客户端发请求，服务器来进行响应。也有特殊情况，就是代理服务器的情况。引入代理之后，作为代理的服务器相当于一个中间人的角色，对于客户端而言，表现为服务器进行响应；而对于源服务器，表现为客户端发起请求，具有双重身份。\r\n\r\n### 功能\r\n1. 负载均衡，客户端的请求会先到达代理服务器，后面到底有多少源服务器，IP 都是多少，客户端是不知道的。这个代理服务器可以拿到这个请求之后，可以通过特定的算法分发给不同的源服务器，让各台源服务器的负载尽量平均。这样的算法有很多，包括随机算法、轮询、一致性hash、LRU(最近最少使用)等等。\r\n2. 保障安全，利用心跳机制监控后台的服务器，一旦发现故障机就将其踢出集群。并且对于上下行的数据进行过滤，对非法 IP 限流，这些都是代理服务器的工作。\r\n3. 缓存代理，将内容缓存到代理服务器，使得客户端可以直接从代理服务器获得而不用到源服务器那里。\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## http状态码\r\n> HTTP 的状态码为三位数。\r\n\r\n- 1xx: 表示目前是协议处理的中间状态，还需要后续操作。\r\n- 2xx: 表示成功状态。\r\n- 3xx: 重定向状态，资源位置发生变动，需要重新请求。\r\n- 4xx: 请求报文有误。\r\n- 5xx: 服务器端发生错误。\r\n### 1xx\r\n- 101 Switching Protocols。在HTTP升级为WebSocket的时候，如果服务器同意变更，就会发送状态码 101。\r\n### 2xx\r\n- 200 OK是见得最多的成功状态码。通常在响应体中放有数据。\r\n- 204 No Content含义与 200 相同，但响应头后没有 body 数据。\r\n- 206 Partial Content顾名思义，表示部分内容，它的使用场景为 HTTP 分块下载和断点续传，当然也会带上相应的响应头字段Content-Range。\r\n### 3xx\r\n- 301 Moved Permanently即永久重定向。比如你的网站从 HTTP 升级到了 HTTPS 了，以前的站点再也不用了，应当返回301，这个时候浏览器默认会做缓存优化，在第二次访问的时候自动访问重定向的那个地址。\r\n- 302 Found，即临时重定向。如果只是暂时不可用，那么直接返回302即可，和301不同的是，浏览器并不会做缓存优化。\r\n- 304 Not Modified  当协商缓存命中时会返回这个状态码。\r\n### 4xx\r\n- 400 Bad Request: 只是提示了一下错误，并不知道哪里出错了。\r\n- 403 Forbidden: 并不是请求报文出错，而是服务器禁止访问。\r\n- 404 Not Found: 资源未找到，表示没在服务器上找到相应的资源。\r\n- 405 Method Not Allowed: 请求方法不被服务器端允许。\r\n- 406 Not Acceptable: 资源无法满足客户端的条件。\r\n- 408 Request Timeout: 服务器等待了太长时间。\r\n- 409 Conflict: 多个请求发生了冲突。\r\n- 413 Request Entity Too Large: get请求体的数据过大。\r\n- 414 Request-URI Too Long: 请求行里的 URI 太大。\r\n- 429 Too Many Request: 客户端发送的请求过多。\r\n- 431 Request Header Fields Too Large请求头的字段内容太大。\r\n### 5xx\r\n- 500 Internal Server Error: 服务器出错了，具体什么错无法知道。\r\n- 501 Not Implemented: 表示客户端请求的功能还不支持。\r\n- 502 Bad Gateway: 服务器自身是正常的，但访问的时候出错了，具体什么错无法知道。\r\n- 503 Service Unavailable: 表示服务器当前很忙，暂时无法响应服务。\r\n\r\n"},function(r,n,e){"use strict";e.r(n),n.default='## http缓存\r\n> http缓存主要是针对html,css,img等静态资源，常规情况下不会去缓存一些动态资源，因为缓存动态资源的话，数据的实时性就会不太好，所以我们一般都只会去缓存一些不太容易被改变的静态资源。\r\n\r\n### http缓存的优点\r\n- 缓存可以让服务器不去处理这个请求，客户端也可以拿到数据。节省带宽。\r\n- 更快的加载页面。\r\n- 减少服务器负载。\r\n### 强缓存和协商缓存的区别\r\n> 强缓存与协商缓存的共同点是如果命中，都是从客户端缓存中加载资源，而不是从服务器加载资源。区别是强缓存不发请求到服务器，协商缓存会发请求到服务器。\r\n\r\n### 强缓存\r\n> 强缓存是利用Expires或者Cache-Control这两个响应头实现的，它们都用来表示资源在客户端缓存的有效期。这两个响应头可以只启用一个，也可以同时启用，同时存在时，Cache-Control优先级高于Expires。Cache-Control是Expires的完全替代方案，能用Cache-Control就不要用Expires。\r\n\r\n#### Expires\r\n> Expires是HTTP 1.0提出的一个表示资源过期时间的响应头，它描述的是一个绝对时间，由服务器返回。由于是一个绝对时间当客户端的时间被修改后或者客户端时间不准时就会影响缓存命中的结果。\r\n\r\n1. 浏览器第一次请求某一资源，如果response的header加上了Expires的header，浏览器会将资源和header都缓存下来。\r\n2. 再次请求此资源时，找到此资源后，用Expires的时间和当前时间对比，没有过期则使用缓存的资源，如果过期重新请求资源后会更新Expires。\r\n#### Cache-Control\r\n> 一个相对时间，在配置缓存的时候，以秒为单位，用数值表示，如：Cache-Control:max-age=24000000000。Cache-Control描述的是一个相对时间，在进行缓存命中的时候，都是利用客户端时间进行判断，所以相比较Expires，Cache-Control的缓存管理更准确一些。\r\n\r\n1. 浏览器第一次请求某一资源，如果response的header加上Cache-Control的header，浏览器会将资源和header都缓存下来。\r\n2. 再次请求此资源时，找到此资源后，根据它**第一次**的请求时间和Cache-Control设定的有效期，计算出一个资源过期时间，过期时间和当前时间对比没有过期则使用缓存的资源，如果过期重新请求资源后会更新Cache-Control。\r\n#### Cache-Control的参数\r\n- max-age: 决定客户端资源被缓存多久，在多少秒内有效，是一个相对时间，这样比Expires具体的时间就更精确了。\r\n- s-maxage: 决定代理服务器缓存的时长，并只对 public 缓存有效。\r\n- no-cache：表示是强制进行协商缓存。\r\n- no-store：表示禁止任何缓存策略，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源。\r\n- public：表示资源即可以被浏览器缓存也可以被代理服务器缓存。\r\n- private：表示资源只能被浏览器缓存。\r\n#### no-cache和no-store\r\n> no-cache是Cache-control的一个属性。no-cache的意思是强制进行协商缓存。如果某一资源的Cache-control中设置了no-cache，那么该资源会直接跳过强缓存的校验，直接去服务器进行协商缓存。而no-store就是禁止所有的缓存策略了。no-cache和no-store是一组互斥属性，它们两个不能同时出现在响应头的Cache-control字段中。\r\n\r\n#### public和private\r\n> public和private就是决定资源是否可以在代理服务器进行缓存的属性。public表示资源在客户端和代理服务器都可以被缓存。private则表示资源只能在客户端被缓存，拒绝资源在代理服务器缓存。如果这两个属性值都没有被设置，则默认为private。public和private也是一组互斥属性，它们两个不能同时出现在响应头的Cache-control字段中。\r\n\r\n#### max-age和s-maxage\r\n> max-age表示的时间资源在客户端缓存的时长，而s-maxage表示的是资源在代理服务器可以缓存的时长。s-maxage因为是代理服务端的缓存时长，它必须和上面说的public属性一起使用（public属性表示资源可以在代理服务器中缓存）。max-age和s-maxage并不互斥。它们可以一起使用。\r\n\r\n#### Cache-control设置多个值\r\n> Cache-control:max-age=10000,s-maxage=200000,public\r\n\r\n### 协商缓存\r\n> 当浏览器对某个资源的请求没有命中强缓存，就会发一个请求到服务器，验证协商缓存是否命中，如果协商缓存命中，请求响应返回的http状态为304并且会显示一个Not Modified的字符串。协商缓存是利用的是【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】这两对header来管理的。协商缓存跟强缓存不一样，强缓存不发请求到服务器，所以有时候资源更新了浏览器还不知道，但是协商缓存会发请求到服务器，所以资源是否更新，服务器肯定知道。这两个header可以只启用一个，也可以同时启用，同时存在时，ETag优先级高于Last-Modified。ETag并不是last-modified的完全替代方案。而是last-modified的补充方案。项目中到底是用ETag还是last-modified完全取决于业务场景更合适使用哪个。\r\n\r\n#### 【Last-Modified，If-Modified-Since】\r\n> 如果服务器上资源有变化，但是最后修改时间却没有变化时就会影响协商缓存的可靠性。Last-Modified 能够感知的单位时间是秒，如果文件在 1 秒内改变了多次，那么这时候的 Last-Modified 并没有体现出修改了。性能上，Last-Modified优于ETag。\r\n\r\n1. 浏览器第一次请求某一资源，如果response的header加上Last-Modified的header，这个header表示这个资源在服务器上的最后修改时间。\r\n2. 再次请求此资源时，在request的header上加上If-Modified-Since的header，这个header的值就是上一次请求时返回的Last-Modified的值。\r\n3. 服务器再次收到资源请求时，根据浏览器传过来If-Modified-Since和资源在服务器上的最后修改时间判断资源是否有变化，如果没有变化则返回304 Not Modified，但是不会返回资源内容，response header中不会再添加Last-Modified的header，因为资源没有变化，Last-Modified不会改变；如果有变化，就正常返回资源内容。\r\n4. 浏览器收到304的响应后，就会从缓存中加载资源。\r\n5. 如果协商缓存没有命中，浏览器直接从服务器加载资源时，Last-Modified Header在重新加载的时候会被更新，下次请求时，If-Modified-Since会启用上次返回的Last-Modified值。\r\n#### 【ETag、If-None-Match】\r\n> ETag就是比较文件指纹(根据文件内容计算出的唯一哈希值)。文件内容一旦改变则指纹改变。ETag需要计算文件指纹意味着服务端需要更多的计算开销。\r\n\r\n1. 浏览器第一次请求某一资源，如果response的header加上ETag的header，这个header是服务器根据当前请求的资源生成的一个唯一标识，这个唯一标识是一个字符串，只要资源有变化这个字符串就不同，跟最后修改时间没有关系。\r\n2. 再次请求此资源时，在request的header上加上If-None-Match的header，这个header的值就是上一次请求时返回的ETag的值。\r\n3. 服务器再次收到资源请求时，根据浏览器传过来If-None-Match和然后再根据资源生成一个新的ETag，如果这两个值相同就说明资源没有变化，否则就是有变化；如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。与Last-Modified不一样的是，当服务器返回304 Not Modified的响应时，由于ETag重新生成过，response header中还会把这个ETag返回，即使这个ETag跟之前的没有变化。\r\n4. 浏览器收到304的响应后，就会从缓存中加载资源。\r\n5. 如果协商缓存没有命中，浏览器直接从服务器加载资源时，ETag Header在重新加载的时候会被更新，下次请求时，If-None-Match会启用上次返回的ETag值。\r\n#### 协商缓存使用注意事项\r\n1. 分布式系统里多台机器间文件的Last-Modified必须保持一致，以免负载均衡到不同机器导致比对失败。\r\n2. 分布式系统尽量关闭掉ETag(每台机器生成的ETag都会不一样）。\r\n### 检查缓存过程\r\n1. 浏览器在加载资源时，先判断它是否命中强缓存，强缓存如果命中，浏览器直接从自己的缓存中读取资源，不会发请求到服务器。\r\n2. 当强缓存没有命中的时候，浏览器一定会发送一个请求到服务器，通过服务器端依据资源的另外一些http header验证这个资源是否命中协商缓存，如果协商缓存命中，服务器会将这个请求返回，但是不会返回这个资源的数据，而是告诉客户端可以直接从缓存中加载这个资源，于是浏览器就又会从自己的缓存中去加载这个资源。\r\n3. 当协商缓存也没有命中的时候，浏览器直接从服务器加载资源数据。\r\n### 最佳实践\r\n> 由于强缓存可能会导致获取不到最新的内容(前端内容是旧的内容，后端是新的内容，这时候页面逻辑可能会崩溃)，但是协商缓存每一次都要请求服务器，也不太理想，借助构建工具可以做到每一次构建后的前端静态文件的名字不同(文件的名带有hash)，所以请求资源时请求的路径也就不同，相当于第一次请求，不存在缓存的问题。\r\n\r\n- HTML：使用协商缓存。\r\n- CSS&JS&图片：使用强缓存，文件命名带上hash值。\r\n**设置 Cache-Control: private，这可以禁用掉所有 Public Cache（比如代理），这就减少了攻击者跨界访问到公共内存的可能性。**\r\n```\r\n// nginx配置示例\r\nlocation / {\r\n\r\n  # 其它配置\r\n  ...\r\n\r\n  if ($request_uri ~* .*[.](js|css|map|jpg|png|svg|ico)$) {\r\n    #非html缓存1个月\r\n    add_header Cache-Control "private, max-age=2592000";\r\n  }\r\n\r\n  if ($request_filename ~* ^.*[.](html|htm)$) {\r\n    #html文件使用协商缓存\r\n    add_header Cache-Control "private, no-cache";\r\n  }\r\n}\r\n```\r\n### 不同刷新的请求执行过程\r\n1. 浏览器地址栏中写入URL，回车\r\n> 浏览器发现缓存中有这个文件了，不用继续请求了，直接去缓存拿。\r\n\r\n2. F5\r\n> 采用协商缓存的形式。\r\n\r\n3. Ctrl+F5\r\n> 把缓存中的文件删除，然后再去服务器请求个完整的资源文件下来。于是客户端就完成了强行更新的操作。\r\n\r\n### 缓存位置\r\n#### 优先级从高到低 (操作系统的常理：先读内存，再读硬盘。)\r\n1. Service Worker\r\n2. Memory Cache\r\n3. Disk Cache\r\n4. Push Cache\r\n#### Service Worker\r\n> Service Worker 借鉴了 Web Worker的 思路，即让 JS 运行在主线程之外，由于它脱离了浏览器的窗体，因此无法直接访问DOM。虽然如此，但它仍然能帮助我们完成很多有用的功能，比如离线缓存、消息推送和网络代理等功能。其中的离线缓存就是 Service Worker Cache。这个缓存是永久性的，关闭 TAB 或者浏览器，下次打开依然还在。有两种情况会导致这个缓存中的资源被清除：手动调用 API cache.delete(resource) 或者容量超过限制，被浏览器全部清空。\r\n\r\n#### Memory Cache\r\n> Memory Cache指的是内存缓存，从效率上讲它是最快的。但是从存活时间来讲又是最短的，**当渲染进程结束后，内存缓存也就不存在了, 关闭 TAB 或者浏览器缓存就不在了**。\r\n\r\n#### Disk Cache\r\n> Disk Cache就是存储在磁盘中的缓存，从存取效率上讲是比内存缓存慢的，但是他的优势在于存储容量和存储时长。\r\n好，现在问题来了，既然两者各有优劣，那浏览器如何决定将资源放进内存还是硬盘呢？主要策略如下：\r\n\r\n#### 区别\r\n> 比较大的JS、CSS文件会直接被丢进磁盘，反之丢进内存，内存使用率比较高的时候，文件优先进入磁盘。\r\n\r\n#### Push Cache\r\n> 推送缓存，这是浏览器缓存的最后一道防线。它是 HTTP/2 中的内容。\r\n\r\n#### 访问缓存优先级\r\n1. 先在内存中查找,如果有,直接加载。\r\n2. 如果内存中不存在,则在磁盘中查找,如果有直接加载。\r\n3. 如果磁盘中也没有,那么就进行网络请求。\r\n4. 请求获取的资源缓存到硬盘和内存。\r\n'},function(r,n,e){"use strict";e.r(n),n.default="## http 请求\r\n### 请求方法\r\n> http/1.1规定了以下请求方法(都是大写)\r\n\r\n1. GET: 通常用来获取资源\r\n2. HEAD: 获取资源的元信息\r\n3. POST: 提交数据，即上传数据\r\n4. PUT: 修改数据\r\n5. DELETE: 删除资源(几乎用不到)\r\n6. CONNECT: 建立连接隧道，用于代理服务器\r\n7. OPTIONS: 列出可对资源实行的请求方法，用来跨域请求\r\n8. TRACE: 追踪请求-响应的传输路径。\r\n### GET和POST的区别\r\n- 从缓存的角度，GET 请求会被浏览器主动缓存下来，留下历史记录，而 POST 默认不会。get请求类似于查找的过程，用户获取数据，可以不用每次都与数据库连接，所以可以使用缓存。post做的一般是修改和删除的工作，所以必须与数据库交互，所以不能使用缓存。因此get请求适合于请求缓存。\r\n- 从编码的角度，GET 只能进行 URL 编码，只能接收 ASCII 字符，而 POST 没有限制。\r\n- 从参数的角度，GET 一般放在 URL 中，因此不安全，POST 放在请求体中，更适合传输敏感信息。GET请求提交的数据有长度限制（HTTP 协议本身没有限制 URL 及正文长度，对 URL 的限制大多是浏览器和服务器的原因），POST请求没有内容长度限制。\r\n- 从幂等性的角度，GET是幂等的，而POST不是。(幂等表示执行相同的操作，结果也是相同的)\r\n- 从TCP的角度，GET 请求会把请求报文一次性发出去，而 POST 会分为两个 TCP 数据包，首先发 header 部分，如果服务器响应 100(continue)， 然后发 body 部分。(火狐浏览器除外，它的 POST 请求只发一个 TCP 包)\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## 三次握手和四次挥手\r\n### 三次握手\r\n#### 意义\r\n> 就是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常。\r\n\r\n#### 步骤\r\n> 刚开始客户端处于 Closed 的状态，服务端处于 Listen 状态。\r\n\r\n1. 客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN©。此时客户端处于 SYN_SEND 状态。\r\n2. 服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)。同时会把客户端的 ISN + 1 作为ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 的状态。\r\n3. 客户端收到 SYN 报文之后，会发送一个 ACK 报文，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接。\r\n#### 为什么需要三次，两次不行\r\n1. 需要三次握手才能确认双方的接收与发送能力是否正常。第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。\r\n2. 如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源。\r\n### 四次挥手\r\n> 建立一个连接需要三次握手，而终止一个连接要经过四次挥手（也有将四次挥手叫做四次握手的）。这由TCP的半关闭（half-close）造成的。所谓的半关闭，其实就是TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。客户端或服务器均可主动发起挥手动作。\r\n\r\n#### 步骤\r\n> 刚开始双方都处于 ESTABLISHED 状态。\r\n\r\n1. 客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态。\r\n2. 服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT 状态。\r\n3. 如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。\r\n4. 客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。\r\n#### 为什么需要四次\r\n> TCP连接时是同步的，但结束时是不同步的，当主动关闭方不会再主动发送数据，但仍然可以接收数据，此时处于半关闭状态。这样被动关闭方有足够的时间去处理以前没有处理完的数据，它可能还有一部分数据没发送出去需要处理，在此之后提出主动关闭连接。所以4次挥手的设计为连接双方都提供了一定的处理扫尾工作的时间，从而显的是必要的。\r\n\r\n1. 当客户端发出FIN报文段时，只是表示客户端已经没有数据要发送了，客户端告诉服务端它的数据已经全部发送完毕了；但是这个时候客户端还是可以接受来服务端的数据；\r\n2. 当服务端返回ACK报文段时，表示它已经知道客户端没有数据发送了，但是服务端还是可以发送数据到客户端的；\r\n3. 当服务端也发送了FIN报文段时，这个时候就表示服务端也没有数据要发送了，就会告诉客户端我也没有数据要发送了。\r\n4. 客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，之后彼此就会愉快的中断这次TCP连接。"},function(r,n,e){"use strict";e.r(n),n.default="## 定长不定长的数据处理\r\n### 定长数据\r\n> 对于定长包体而言，发送端在传输的时候会带上 Content-Length, 来指明包体的长度。\r\n\r\n- 设置长度小时，响应体会直接按照设置的长度被截去\r\n- 设置长度大时，会直接终止连接，传输失败\r\n### 不定长数据\r\n> 设置 Transfer-Encoding: chunked 字段。\r\n\r\n- Content-Length 字段会被忽略\r\n- 基于长连接持续推送动态内容"},function(r,n,e){"use strict";e.r(n),n.default="## 队头阻塞\r\n> HTTP 传输是基于请求-应答的模式进行的，报文必须是一发一收，但值得注意的是，里面的任务被放在一个任务队列中串行执行，一旦队首的请求处理太慢，就会阻塞后面请求的处理。\r\n\r\n### 并发连接\r\n> 对于一个域名允许分配多个长连接，那么相当于增加了任务队列，不至于一个队伍的任务阻塞其它所有任务。在RFC2616规定过客户端最多并发 2 个连接，事实上在现在的浏览器标准中比较多，Chrome 中是 6 个。\r\n\r\n### 域名分片\r\n> 一个域名可以并发 6 个长连接，可以多分几个域名。这样一个域名下可以分出非常多的二级域名，而它们都指向同样的一台服务器，能够并发的长连接数更多了，事实上也更好地解决了队头阻塞的问题。\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## ==和===\r\n### ===\r\n> 严格全等，不会类型转换，必须要数据类型和值完全一致，类型不同就不相等。\r\n\r\n- 基本数据类型\r\n  1. Number, String, Boolean, null 和 undefined 两边的值要一样, 才相等;\r\n  2. NaN === NaN // false; NaN不会等于任何数据,包括自己。\r\n- 引用数据类型\r\n> Object, Array, Function 如果两边的引用地址一样则是相等的。\r\n\r\n### ==\r\n> 非严格相等，会先进行类型转换，在进行值的比较。\r\n\r\n- 两边是undefined或null，返回true\r\n```\r\nconsole.log (null == undefined); // true\r\nconsole.log (null == null); // true\r\nconsole.log (undefined == undefined); // true\r\n```\r\n- 两边是String，Boolean，Number其中一种\r\n> 会将不是Number类型的数据转成Number类型，true转为1， false转为0。Number()会将非数值型字符串结果为NaN。\r\n\r\n```\r\nconsole.log (1 == true); // true  Number(true)的结果为1\r\nconsole.log ( 1 == \"true\" ); // false  Number()会将非数值型字符串结果为NaN，数值型字符串为数值，空字符串为0;\r\nconsole.log ( 1 == !\"true\" ); // false  !先将\"true\"转为布尔型false Number(false)的结果为0\r\nconsole.log ( 0 == !\"true\" ); // true\r\nconsole.log(true == 'true') // false\r\n```\r\n- 只要有一边是NaN则返回false\r\n```\r\nconsole.log ( NaN == NaN ); //false\r\n```\r\n- 只有一边为引用类型\r\n> 获取引用类型数据的原始值之后再比较；先调用valueOf方法，然后调用toString方法，valueOf:一般默认返回自身，数组的toString：默认会调用join方法拼接每个元素并且返回拼接后的字符串。\r\n\r\n```\r\n// 空数组的toString()方法会得到空字符串,而空对象的toString()方法会得到字符串[object Object]\r\nconsole.log ([].toString ()); // 空字符串\r\nconsole.log ({}.toString ()); // '[object Object]'\r\n\r\nconsole.log ([1, 2, 3].valueOf().toString()); // '1，2，3'\r\nconsole.log ([1, 2, 3] == \"1,2,3\" ); //true  (1)[1,2,3].toString() == '1,2,3'  (2)'1,2,3' == '1,2,3'\r\nconsole.log({} == '[object Object]'); //true\r\n```\r\n- 两边都是引用类型\r\n> 只比较引用地址，如果地址一致则返回true，否则返回false.\r\n\r\n### Object.is()\r\n> Object.is()，其行为与===基本一致，有两处不同。\r\n\r\n- +0不等于-0。\r\n- NaN等于自身。\r\n```\r\nif (!Object.is) {\r\n  Object.is = function(x, y) {\r\n    if (x === y) { \r\n      // 运行到1/x === 1/y的时候x和y都为0，但是1/+0 = +Infinity， 1/-0 = -Infinity, 是不一样的\r\n      return x !== 0 || 1 / x === 1 / y;\r\n    } else {\r\n      // NaN===NaN是false,这是不对的，我们在这里做一个拦截，x !== x，那么一定是 NaN, y 同理\r\n      return x !== x && y !== y;\r\n    }\r\n  };\r\n}\r\n```\r\n### 示例\r\n> == 是非严格比较操作符，false会转换为0，[]会转换成''，{}会转换为\"[object Object]\"，所以会输出1，不输出2，[]和{}是“空”的对象，不是“空”，所以会输出3,最后一个引用地址不一致，不是同一个对象，所以不会输出4;\r\n\r\n```\r\n// 输出1，3\r\nif([] == false) { console.log(1) }; // false会转换为0，[]会转换成'',空字符串转为Number型后为0。\r\nif({} == false) { console.log(2) }; // {}会转换为\"[object Object]\" 所以不会等于false\r\nif([]) { console.log(3) }; // 空对象和空数组转为Bollean类型都是true\r\nif([1] == [1]){ console.log(4) }; // 两个引用类型的数据的引用地址不同\r\n```\r\n\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## [Array](https://mp.weixin.qq.com/s/lTpFXhII7LitooRamMbLIA)\r\n### every\r\n> every 方法为数组中的每个元素执行一次 callback 函数，直到它找到一个会使 callback 返回 false 的元素。如果发现了一个这样的元素，every 方法将会立即返回 false，不再继续循环下去。否则，callback 为每一个元素返回 true，every 就会返回 true。空数组使用every永远返回true。\r\n\r\n```\r\n// 只会console一个1，因为every方法中的函数没有返回值，默认返回undefined，理解为false，所以执行一次之后就会终止循环\r\n[1,2,3].every(item => {\r\n  console.log(1);\r\n}) // false\r\n\r\n// console两个1，因为运行到2时return的false，所以不会继续运行下去\r\n[1,2,3].every(item => {\r\n  console.log(1);\r\n  return item < 2;\r\n}) // false\r\n```\r\n### some\r\n> some 为数组中的每一个元素执行一次 callback 函数，直到找到一个使得 callback 返回一个true（即可转换为布尔值 true 的值）。如果找到了这样一个值，some() 将会立即返回 true,不再往下执行。否则将返回false。空数组使用some永远返回false。\r\n\r\n```\r\n// 会console三个1，因为some方法中的函数没有返回值，默认返回undefined，理解为false，所以会一直执行下去\r\n[1,2,3].some(item => {\r\n  console.log(1);\r\n}) // false\r\n\r\n// console一个1，因为运行到1时return的true，所以不会继续运行下去\r\n[1,2,3].some(item => {\r\n  console.log(1);\r\n  return item < 2;\r\n})  // true\r\n```\r\n### Array.from()\r\n> 用于将类对象或具有length属性的对象转为真正的数组,类数组的对象和可遍历的对象（ES6的Set和Map）。也可以将字符串逐个解析生成数组。\r\n\r\n```\r\nArray.from('dyx') // [\"d\",\"y\",\"x\"]\r\nlet arrayLike = {\r\n '0': 'a',\r\n '1': 'b',\r\n '2': 'c',\r\n length: 3\r\n};\r\n// ES5的写法\r\nvar arr1 = Array.prototype.slice.call(arrayLike); // ['a', 'b', 'c']\r\n// ES6的写法\r\nlet arr2 = Array.from(arrayLike); // ['a', 'b', 'c']\r\n\r\n// NodeList对象\r\nlet ps = document.querySelectorAll('p');\r\nArray.from(ps).filter(p => {\r\n return p.textContent.length > 100;\r\n});\r\n// arguments对象\r\nfunction foo() {\r\n var args = Array.from(arguments);\r\n // ...\r\n}\r\n```\r\n### find\r\n> 查找数组中第一个符合规则的元素，如果没有找到返回undefined\r\n\r\n```\r\nconst arr = [1, 2, 3];\r\narr.find(item => item > 1) // 2\r\narr.find(item => item > 3) // undefined\r\n``` \r\n### slice\r\n> 根据规则截取数组，不会改变原数组，返回截取后的数组\r\n\r\n```\r\nconst arr = [1, 2, 3, 4, 5];\r\narr.slice(2, 4) // [3, 4]\r\narr.slice(0, -2) // [1, 2, 3] 截取直倒数第二位\r\n```\r\n### forEach\r\n- 在forEach中用return不会返回，函数会继续执行。使用try监视代码块，在需要中断的地方抛出异常。或使用every和some替代forEach函数。every在碰到return false的时候，中止循环。some在碰到return true的时候，中止循环。\r\n- 对于异步代码，forEach 并不能保证按顺序执行，因为forEach的实现是直接循环调用传入的函数，无法保证异步任务的执行顺序。使用for of 解决，for...of并不像forEach那么简单粗暴的方式去遍历执行，而是采用迭代器的形式去遍历。\r\n### Array.isArray()\r\n> 判断是否为数组类型\r\n\r\n### fill\r\n> 使用一个固定值填充或替换数组的元素。\r\n\r\n```\r\nnew Array(5).fill('dyx');\r\n```\r\n### flat\r\n> 将一个多维数组进行压平处理,默认使用一次只有一次压平处理\r\n\r\n```\r\nconst arr = [1, [2, [3, 4] ] ];\r\nconsole.log(arr.flat()); // [1, 2, [3, 4]]\r\nconsole.log(arr.flat().flat()); // [1, 2, 3, 4]\r\nconsole.log(arr.flat(Infinity)); // [1, 2, 3, 4]\r\n```\r\n### flatMap\r\n```\r\n[1, 2].flatMap(item => [item, item + 1]) // [1, 2, 2, 3]\r\n```\r\n### reduce, reduceRight\r\n> 可以使用该方法实现数组的递归，\r\n\r\n- 没有初始值时该方法的第一次迭代发生在数组第二项，方法的第一个参数是第一项，第二个参数是第二项\r\n- 有初始值时该方法的第一次迭代发生在数组第一项，方法的第一个参数是初始值，第二个参数是第一项\r\n- 空数组使用reduce必须有初始值否则会报错\r\n\r\n```\r\n// prev代表后面的初始值-1，或者每一次循环后返回的值，current代表当前循环的值\r\nconsole.log([1,2,3].reduce(\r\n  (prev, current) => {\r\n    console.log(prev, current); \r\n    return Math.max(prev,current);\r\n  }, -1));\r\n\r\n// 数组连接\r\nvar newArr = [[0, 1], [2, 3], [4, 5]].reduce((a, b) => {\r\n  return a.concat(b);\r\n});\r\n// [0, 1, 2, 3, 4, 5]\r\n\r\n// 同一个数组有无初始值循环的次数不同\r\nconst a = [1,2,3].reduce((prev, current) => {\r\n  console.log(prev, current);\r\n  return prev + current\r\n}); // 1 2; 3 3;\r\nconsole.log(a)  // 6\r\n\r\nconst a = [1,2,3].reduce((prev, current) => {\r\n  console.log(prev, current);\r\n  return prev + current\r\n}, 0); // 0 1; 1 2; 3 3;\r\nconsole.log(a)  // 6\r\n\r\nconst a = [].reduce((prev, current) => {\r\n  console.log(prev, current);\r\n  return prev + current\r\n}, 0); // 没有console，空数组必须有初始值否则报错\r\nconsole.log(a)  // 0\r\n```\r\n### 数组去重\r\n> 利用set去重没有将空对象去除，利用indexOf没有将空对象和NaN去除，使用对象属性不能相同去重可以完美去重。\r\n\r\n#### set\r\n> 利用set简单实现数组去重,去完之后不是数组要注意\r\n\r\n```\r\nconst item = new Set([1, 2, 3, 1]) // 去重\r\nconst arr = Array.from(item) // 重新转为数组\r\n\r\nconst item = new Set([1, 2, 3, 1]) // 去重\r\nconst arr = [...item] // 重新转为数组\r\n```\r\n#### 对象属性不能相同去重\r\n```\r\nconst unique = arr => {\r\n  let newArr = [];\r\n  let obj = {};\r\n  for(var i = 0; i < arr.length; i++) {\r\n    if(!obj[arr[i]]) {\r\n      newArr.push(arr[i])\r\n      obj[arr[i]] = 1;\r\n    } else {\r\n      obj[arr[i]]++;\r\n    }\r\n  }\r\n  return newArr;\r\n}\r\n```\r\n#### indexOf去重\r\n```\r\nconst unique = arr => {\r\n  var newArr = [];\r\n  for(var i in arr){\r\n    if(newArr.indexOf(arr[i]) === -1) {\r\n      newArr.push(arr[i]);\r\n    }\r\n  }\r\n  return newArr;\r\n}\r\n```\r\n```\r\nconst unique = arr => {\r\n  var len = arr.length;\r\n  var newArr = [];\r\n  for(i = 0; i < len; i++) {\r\n    for(j = i + 1; j < len; j++){\r\n      if(arr[i] === arr[j]){\r\n        j = ++i; // 先找到第一个后面没有重复的值，最外层循环不是循环了数组的长度的次数，而是循环了去重之后数组长度的次数\r\n      }\r\n    }\r\n    newArr.push(arr[i]);\r\n  }\r\n  return newArr; \r\n}\r\n```\r\n### 数组排序\r\n#### 冒泡排序\r\n```\r\n// 相邻元素的比较\r\nconst sort = arr => {\r\n  for(var i = 0; i < arr.length; i++){\r\n    for(j = i; j < arr.length; j++){\r\n      if(arr[i] < arr[j]){ // 大于小于号决定数组排序的规则\r\n        var oo;\r\n        oo = arr[j];\r\n        arr[j] = arr[i];\r\n        arr[i] = oo;\r\n      }\r\n    }\r\n  }\r\n  return arr;\r\n}\r\n```\r\n#### 选择排序\r\n```\r\n// 寻找最小(大)的值然后进行排序\r\nconst sort = arr => {\r\n  const len = arr.length;\r\n  var minIndex, temp;\r\n  for (var i = 0; i < len - 1; i++) {\r\n\t  minIndex = i;\r\n\t  for (var j = i + 1; j < len; j++) {\r\n\t    if (arr[j] < arr[minIndex]) { // 寻找最小的数\r\n\t\t    minIndex = j; // 将最小数的索引保存\r\n\t    }\r\n\t  }\r\n\t  temp = arr[i];\r\n\t  arr[i] = arr[minIndex];\r\n\t  arr[minIndex] = temp;\r\n  }\r\n  return arr;\r\n}\r\n```\r\n### 数组最大最小值\r\n```\r\nfor(var i = 0; i < arr.length; i++) {\r\n  if(amin > arr[i]) {\r\n    amin = arr[i];\r\n  }\r\n  if(amax < arr[i]) {\r\n    amax = arr[i];\r\n  }\r\n}\r\nconsole.log(`最小值：${amin} 最大值：${amax}`);\r\n```\r\n### 数组最大值\r\n```\r\nconst arr = [1, 2, 4, 6, 3, 4]\r\nconst max = arr.reduce((x, y) => x > y ? x : y);\r\nconst max = arr.reduce((x, y) => Math.max(x, y));\r\n```\r\n### 数组最小值\r\n```\r\nconst arr = [1, 2, 2, 4, 6, 3, 4]\r\nconst min = arr.reduce((x, y) => x > y ? y : x);\r\nconst min = arr.reduce((x, y) => Math.min(x, y));\r\n```\r\n### 将数组某一元素全部放在数组前面\r\n```\r\nconst arr = ['*','黄','红','白','红','*','白','*','黄','*','红','*','黄','白'];\r\nfor (let i in arr){\r\n  if(arr[i] === '*'){\r\n    arr.splice(i, 1)\r\n    arr.unshift('*')\r\n  }\r\n}\r\n```\r\n### 两个有序的数组组成一个有序的数组\r\n```\r\nconst a = [1, 3, 5, 7];\r\nconst b = [2, 4, 6, 8];\r\nlet i = 0;\r\nlet j = 0;\r\nlet al = a.length;\r\nlet bl = b.length;\r\nlet c = []; // 新的数组\r\nwhile (i < al || j < bl) {\r\n  if (a[i] <= b[j]) {\r\n    c.push(a[i]);\r\n    i++\r\n  } else {\r\n    c.push(b[j]);\r\n    j++\r\n  }\r\n}\r\n```\r\n### indexOf 和 findIndex 的区别\r\n- indexOf：查找值作为第一个参数，采用 === 比较，更多的是用于查找基本类型，如果是对象类型，则是判断是否是同一个对象的引用。\r\n- findIndex：比较函数作为第一个参数，多用于非基本类型(例如对象)的数组索引查找，或查找条件很复杂。"},function(r,n,e){"use strict";e.r(n),n.default="## ES6\r\n> ES6是新一代的JS语言标准，对分JS语言核心内容做了升级优化，规范了JS使用标准，新增了JS原生方法，使得JS使用更加规范，更加优雅，更适合大型应用的开发。\r\n\r\n### ES5、ES6和ES2015的区别\r\n> ES2015特指在2015年发布的新一代JS语言标准，ES6泛指下一代JS语言标准，包含ES2015、ES2016、ES2017、ES2018等。现阶段在绝大部分场景下，ES2015默认等同ES6。ES5泛指上一代语言标准。ES2015可以理解为ES5和ES6的时间分界线。\r\n\r\n### babel的作用\r\n> babel是一个 ES6 转码器，可以将 ES6 代码转为 ES5 代码，以便兼容那些还没支持ES6的平台。\r\n\r\n### ES6新增内容\r\n#### let 块作用域\r\n#### 字符串相关\r\n- 模板字符串\r\n- 新增方法\r\n  1. includes\r\n  2. startsWith、endsWith\r\n  3. padStart、padEnd\r\n  4. repeat\r\n#### 数组\r\n- 新增方法\r\n  1. find\r\n  2. includes\r\n  3. fill\r\n  4. flat\r\n#### 对象\r\n- 新增方法\r\n  1. assign\r\n  2. keys、values、entries\r\n#### 解构赋值\r\n#### 扩展运算符\r\n#### 箭头函数\r\n#### Promise\r\n#### 类 class\r\n#### 模块\r\n#### Symbol\r\n#### 函数默认参数\r\n#### Map Set 数据结构"},function(r,n,e){"use strict";e.r(n),n.default="## Generator和协程\r\n### Generator迭代器\r\n> ES6 新引入了 Generator 函数，可以通过 yield 关键字，把函数的执行流挂起，通过next()方法可以切换到下一个状态，为改变执行流程提供了可能，从而为异步编程提供解决方案。\r\n\r\n```\r\nfunction* myGenerator() {\r\n  yield '1';\r\n  yield '2';\r\n  return '3';\r\n}\r\n\r\nconst gen = myGenerator();  // 获取迭代器\r\ngen.next()  // { value: \"1\", done: false }\r\ngen.next()  // { value: \"2\", done: false }\r\ngen.next()  // { value: \"3\", done: true }\r\n```\r\n- 可以通过给next()传参, 让yield具有返回值\r\n```\r\nfunction* myGenerator() {\r\n  console.log(yield '1');  // test1\r\n  console.log(yield '2');  // test2\r\n  console.log(yield '3');  // test3\r\n}\r\n\r\nconst gen = myGenerator(); // 获取迭代器\r\ngen.next()\r\ngen.next('test1')\r\ngen.next('test2')\r\ngen.next('test3')\r\n```\r\n### 协程\r\n> 生成器实现机制，协程是一种比线程更加轻量级的存在，协程处在线程的环境中，一个线程可以存在多个协程，可以将协程理解为线程中的一个个任务。不像进程和线程，协程并不受操作系统的管理，而是被具体的应用程序代码所控制。一个线程一次只能执行一个协程。比如当前执行 A 协程，另外还有一个 B 协程，如果想要执行 B 的任务，就必须在 A 协程中将 JS 线程的控制权转交给 B协程，那么现在 B 执行，A 就相当于处于暂停的状态。\r\n\r\n### 示例\r\n> A 将执行权交给 B，也就是 A 启动 B，我们也称 A 是 B 的父协程。因此 B 当中最后return 100其实是将 100 传给了父协程。对于协程来说，它并不受操作系统的控制，完全由用户自定义切换。\r\n\r\n```\r\nfunction* A() {\r\n  console.log(\"我是A\");\r\n  yield B(); // A停住，在这里转交线程执行权给B\r\n  console.log(\"结束了\");\r\n}\r\nfunction B() {\r\n  console.log(\"我是B\");\r\n  return 100;// 返回，并且将线程执行权还给A\r\n}\r\nlet gen = A();\r\ngen.next();\r\ngen.next();\r\n\r\n// 我是A\r\n// 我是B\r\n// 结束了\r\n```"},function(r,n,e){"use strict";e.r(n),n.default='## Map\r\n> 它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。\r\n\r\n### 属性\r\n- size属性返回 Map 结构的成员总数。\r\n```\r\nconst map = new Map();\r\nmap.set(\'foo\', true);\r\nmap.set(\'bar\', false);\r\n\r\nmap.size // 2\r\n```\r\n### 方法\r\n- set(key, value)  set方法设置键名key对应的键值为value，然后返回整个 Map 结构。如果key已经有值，则键值会被更新，否则就新生成该键。\r\n- get(key)  get方法读取key对应的键值，如果找不到key，返回undefined。\r\n- has(key)  has方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。\r\n- delete(key)  delete方法删除某个键，返回true。如果删除失败，返回false。\r\n- clear()   clear方法清除所有成员，没有返回值。\r\n\r\n### 遍历方法\r\n> Map 的遍历顺序就是插入顺序。\r\n\r\n- keys()，values()，entries()\r\n```\r\nconst map = new Map([\r\n  [\'F\', \'no\'],\r\n  [\'T\',  \'yes\'],\r\n]);\r\n\r\nfor (let key of map.keys()) {\r\n  console.log(key);\r\n}\r\n// "F"\r\n// "T"\r\n\r\nfor (let value of map.values()) {\r\n  console.log(value);\r\n}\r\n// "no"\r\n// "yes"\r\n\r\nfor (let item of map.entries()) {\r\n  console.log(item[0], item[1]);\r\n}\r\n// "F" "no"\r\n// "T" "yes"\r\n```\r\n- forEach()，与数组的forEach方法类似\r\n### Map获取最先存入Map的键\r\n```\r\nmap.keys().next().value 获取第一个键（最先存入map集合的键）\r\nmap.delete(map.keys().next().value) 删除第一个键\r\n```\r\n### Map转数组\r\n> Map 转为数组最方便的方法，就是使用扩展运算符。\r\n\r\n```\r\nconst myMap = new Map().set(true, 7).set({foo: 3}, [\'abc\']);\r\n\r\n// [\r\n//   [ true, 7 ],\r\n//   [\r\n//     { foo: 3 },\r\n//     [\'abc\'] \r\n//   ]\r\n// ]\r\n[...myMap]\r\n```\r\n### 数组转Map\r\n> 将数组传入 Map 构造函数，就可以转为 Map。\r\n\r\n```\r\nnew Map([\r\n  [true, 7],\r\n  [{foo: 3}, [\'abc\']]\r\n])\r\n// Map {\r\n//   true => 7,\r\n//   Object {foo: 3} => [\'abc\']\r\n// }\r\n```\r\n### Map转对象\r\n> 如果所有 Map 的键都是字符串，它可以无损地转为对象。如果有非字符串的键名，那么这个键名会被转成字符串，再作为对象的键名。\r\n\r\n```\r\nfunction strMapToObj(strMap) {\r\n  let obj = Object.create(null);\r\n  for (let [k,v] of strMap) {\r\n    obj[k] = v;\r\n  }\r\n  return obj;\r\n}\r\n\r\nconst myMap = new Map().set(\'yes\', true).set(\'no\', false);\r\n\r\n// { yes: true, no: false }\r\nstrMapToObj(myMap)\r\n```\r\n### 对象转Map\r\n> 对象转为 Map 可以通过Object.entries()。也可以自己实现一个转换函数。\r\n\r\n```\r\nlet obj = {"a":1, "b":2};\r\nlet map = new Map(Object.entries(obj));\r\n\r\n// 自定义转化方法\r\nfunction objToStrMap(obj) {\r\n  let strMap = new Map();\r\n  for (let k of Object.keys(obj)) {\r\n    strMap.set(k, obj[k]);\r\n  }\r\n  return strMap;\r\n}\r\n\r\nobjToStrMap({yes: true, no: false})\r\n// Map {"yes" => true, "no" => false}\r\n```\r\n### WeakMap\r\n> WeakMap结构与Map结构类似，也是用于生成键值对的集合。但是它与 Map 有一些区别。\r\n\r\n1. WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名。\r\n2. WeakMap的键名所指向的对象，不计入垃圾回收机制。\r\n3. WeakMap不可遍历。\r\n\r\n```\r\n// Map\r\nlet dyx = { name: "dyx" };\r\nlet map = new Map();\r\nmap.set(dyx, "test");\r\n\r\n// dyx 被存储在 map 中，我们可以使用 map.keys() 来获取它\r\ndyx = null; // 覆盖引用\r\n\r\n\r\n// WeakMap\r\nlet dyx = { name: "dyx" };\r\nlet weakMap = new WeakMap();\r\nweakMap.set(dyx, "test");\r\n\r\n// john 被从内存中删除了！\r\ndyx = null; // 覆盖引用\r\n```\r\n\r\n\r\n'},function(r,n,e){"use strict";e.r(n),n.default="## Object.defineProperty\r\n> Object.defineProperty(obj, prop, descriptor)\r\n\r\n1. value  该属性对应的值\r\n2. configurable  配置对象，删除属性\r\n3. writable  修改对象\r\n4. enumerable  可以枚举\r\n5. get  获取属性值的时候就会调用get方法\r\n6. set  设置属性值的时候就会调用set方法\r\n\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## Service Worker\r\n> 一个服务器与浏览器之间的中间人角色，如果网站中注册了service worker那么它可以拦截当前网站所有的请求，进行判断（需要编写相应的判断程序），如果需要向服务器发起请求的就转给服务器，如果可以直接使用缓存的就直接返回缓存不再转给服务器。从而大大提高浏览体验。\r\n\r\n- 基于web worker（一个独立于JavaScript主线程的独立线程，在里面执行需要消耗大量资源的操作不会堵塞主线程）\r\n- 在web worker的基础上增加了离线缓存的能力\r\n- 本质上充当Web应用程序（服务器）与浏览器之间的代理服务器（可以拦截全站的请求，并作出相应的动作->由开发者指定的动作）\r\n- 创建有效的离线体验（将一些不常更新的内容缓存在浏览器，提高访问体验）\r\n- 由事件驱动的,具有生命周期\r\n- 可以访问cache和indexDB\r\n- 支持推送\r\n- 可以让开发者自己控制管理缓存的内容以及版本\r\n- Service worker运行在worker上下文 --\x3e 不能访问DOM\r\n- 设计为完全异步，同步API（如XHR和localStorage）不能在service worker中使用\r\n- 出于安全考量，Service workers只能由HTTPS承载\r\n- 在Firefox浏览器的用户隐私模式，Service Worker不可用\r\n- 其生命周期与页面无关（关联页面未关闭时，它也可以退出，没有关联页面时，它也可以启动）\r\n### 注册Service worker\r\n> 在index.html加入以下内容。\r\n\r\n```\r\n if ('serviceWorker' in navigator) {\r\n  /* 当页面加载完成就创建一个serviceWorker */\r\n  window.addEventListener('load', function () {\r\n    /* 创建并指定对应的执行内容 */\r\n    /* scope 参数是可选的，可以用来指定你想让 service worker 控制的内容的子目录。 在这个例子里，我们指定了 '/'，表示 根网域下的所有内容。这也是默认值。 */\r\n    navigator.serviceWorker.register('./serviceWorker.js', {scope: './'})\r\n      .then(function (registration) {\r\n        console.log('ServiceWorker registration successful with scope: ', registration.scope);\r\n      })\r\n      .catch(function (err) {\r\n        console.log('ServiceWorker registration failed: ', err);\r\n      });\r\n  });\r\n}\r\n```\r\n### 安装worker\r\n> 在我们指定的处理程序serviceWorker.js中书写对应的安装及拦截逻辑。\r\n\r\n```\r\nthis.addEventListener('install', function (event) {\r\n  /* 通过这个方法可以防止缓存未完成，就关闭serviceWorker */\r\n  event.waitUntil(\r\n    /* 创建一个名叫V1的缓存版本 */\r\n    caches.open('v1').then(function (cache) {\r\n      /* 指定要缓存的内容，地址为相对于跟域名的访问路径 */\r\n      return cache.addAll([\r\n        './index.html'\r\n      ]);\r\n    })\r\n  );\r\n});\r\n\r\n/* 注册fetch事件，拦截全站的请求 */\r\nthis.addEventListener('fetch', function(event) {\r\n  event.respondWith(  \r\n    /* 在缓存中匹配对应请求资源直接返回 */\r\n    caches.match(event.request)\r\n  );\r\n});\r\n```\r\n\r\n"},function(r,n,e){"use strict";e.r(n),n.default='## Set\r\n> 类似于数组，但是成员的值都是唯一的，没有重复的值。\r\n\r\n### Set函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。\r\n```\r\nconst set = new Set([1, 2, 3, 4, 4]);\r\n[...set] // [1, 2, 3, 4]\r\n\r\nconst set = new Set(document.querySelectorAll(\'div\'));\r\nset.size // 56\r\n```\r\n### 成员的值是唯一的\r\n> 向 Set 加入值的时候，不会发生类型转换。Set 内部判断两个值是否不同，使用的算法叫做“Same-value-zero equality”，它类似于精确相等运算符（===），主要的区别是向 Set 加入值时认为NaN等于自身，而精确相等运算符认为NaN不等于自身。\r\n\r\n### 属性\r\n- size：返回Set实例的成员总数。\r\n### 方法\r\n- add(value)：添加某个值，返回 Set 结构本身。\r\n- delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。\r\n- has(value)：返回一个布尔值，表示该值是否为Set的成员。\r\n- clear()：清除所有成员，没有返回值。\r\n### 遍历操作\r\n- keys()，values()，entries()\r\n> keys方法、values方法、entries方法返回的都是遍历器对象。由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以keys方法和values方法的行为完全一致。\r\n\r\n```\r\nlet set = new Set([\'red\', \'green\', \'blue\']);\r\n\r\nfor (let item of set.keys()) {\r\n  console.log(item);\r\n}\r\n// red\r\n// green\r\n// blue\r\n\r\nfor (let item of set.values()) {\r\n  console.log(item);\r\n}\r\n// red\r\n// green\r\n// blue\r\n\r\nfor (let item of set.entries()) {\r\n  console.log(item);\r\n}\r\n// ["red", "red"]\r\n// ["green", "green"]\r\n// ["blue", "blue"]\r\n```\r\n- forEach\r\n> forEach方法的参数就是一个处理函数。该函数的参数与数组的forEach一致，依次为键值、键名、集合本身（上例省略了该参数）。这里需要注意，Set 结构的键名就是键值（两者是同一个值），因此第一个参数与第二个参数的值永远都是一样的。\r\n\r\n```\r\nlet set = new Set([1, 4, 9]);\r\nset.forEach((value, key) => console.log(key + \' : \' + value))\r\n// 1 : 1\r\n// 4 : 4\r\n// 9 : 9\r\n```\r\n### WeakSet\r\n> WeakSet 结构与 Set 类似，也是不重复的值的集合。但是它与 Set 有一些区别。\r\n\r\n1. WeakSet 的成员只能是对象，而不能是其他类型的值。\r\n2. WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。\r\n3. WeakSet 不可遍历。'},function(r,n,e){"use strict";e.r(n),n.default="## [Symbol](https://mp.weixin.qq.com/s/qSo66z9mQ4CwY6E5gfDmjw)\r\n- Symbol是一种基本数据类型。Symbol()函数返回symbol类型的值。\r\n- 通过Symbol创建返回的symbol值都是唯一的。一个symbol值能作为对象属性的标识符，这是该数据类型仅有的目的。\r\n### 创建symbol值\r\n```\r\nconst symbol1 = Symbol();\r\nconst symbol2 = Symbol(123);\r\nconst symbol3 = Symbol('test');\r\n\r\nconsole.log(symbol2); // Symbol(123)\r\nconsole.log(typeof symbol1); // symbol\r\nconsole.log(symbol2 === 123); // 永远输出是false\r\nconsole.log(Symbol('test') === Symbol('test')); // 永远输出是false\r\n```\r\n### Symbol特点\r\n- Symbol不可以使用new创建，使用new创建会抛出TypeError错误。\r\n- Symbol创建的值是不可枚举的。\r\n- for in循环会遍历对象的可枚举属性，会忽略不可枚举的属性。\r\n```\r\nconst symbol = Symbol('test');\r\nconst obj = {[symbol]: 123};\r\nfor (const key in obj) {\r\n  console.log(key); // 无打印信息\r\n}\r\n```\r\n- Object.keys()方法返回一个数组，其中包含对象的所有可枚举属性的名称。不可枚举的属性不会被包含在返回的数组中。\r\n```\r\nconst symbol = Symbol('test');\r\nconst obj = {[symbol]: 123};\r\nconsole.log(Object.keys(obj)); // []\r\n```\r\n- Object.getOwnPropertySymbols、Reflect.ownKeys方法可以获取指定对象的所有Symbol属性名。\r\n```\r\nconst symbol = Symbol('test');\r\nconst obj = {[symbol]: 123};\r\nconsole.log(Object.getOwnPropertySymbols(obj)); // [Symbol(test)]\r\nconsole.log(Reflect.ownKeys(obj)); // [Symbol(test)]\r\n```\r\n- Object.assign()将源对象中可枚举属性复制到目标对象，但会包含Symbol类型作为key的属性。\r\n```\r\nconst symbolKey = Symbol('key');\r\nconst source = {\r\n  [symbolKey]: 'Symbol Property',\r\n  regularProperty: 'Regular Property'\r\n};\r\nObject.defineProperty(source, \"w\", {\r\n  value: 456,\r\n  enumerable: true,\r\n  configurable: true,\r\n  writable: true\r\n})\r\nObject.defineProperty(source, \"r\", {\r\n  value: 123,\r\n  enumerable: false,\r\n  configurable: false,\r\n  writable: false\r\n})\r\n\r\nconst target = {};\r\nObject.assign(target, source);\r\n// Symbol(key)类型会被打印，但是不可枚举属性不会打印\r\nconsole.log(target); // {regularProperty: \"Regular Property\", w: 456, Symbol(key): 'Symbol Property'}\r\n```\r\n- JSON.stringify()只会序列化对象的可枚举属性，不会包含不可枚举属性。\r\n  - JSON.stringify()转换的是一个对象时无论key还是value中有symbol类型，都会忽略掉。\r\n  - JSON.stringify()直接转换symbol类型数据，转换后的结果为undefined。\r\n  ```\r\n  const symbol = Symbol('test');\r\n  const obj = {name: symbol};\r\n  const obj1 = {[symbol]: 123};\r\n  console.log(JSON.stringify(symbol)); // undefined\r\n  console.log(JSON.stringify(obj)); // {}\r\n  console.log(JSON.stringify(obj1)); // {}\r\n  ```\r\n- 对象中声明的Symbol属性获取必须使用[]方式获取属性。\r\n```\r\nconst symbol = Symbol('test');\r\nconst obj = {[symbol]: 123};\r\nconsole.log(obj[symbol]); // 123\r\n```\r\n- 使用Symbol直接传入一个函数，会调用toString函数，将函数内容转换为字符串。\r\n```\r\nconst a = function() {\r\n  console.log('哈哈哈');\r\n}\r\nconsole.log(Symbol(a)); // Symbol(function() { console.log('哈哈哈'); })\r\nconsole.log(typeof Symbol(a)); // symbol\r\n```\r\n- Object.getOwnPropertyNames()返回一个数组，其中包含对象的所有属性（包括不可枚举属性）的名称，但是不包括使用symbol值作为名称的属性。\r\n```\r\nconst symbolKey = Symbol('key');\r\nconst obj = {\r\n  [symbolKey]: 'Symbol Property',\r\n  regularProperty: 'Regular Property'\r\n};\r\nObject.defineProperty(obj, \"w\", {\r\n  value: 456,\r\n  enumerable: true,\r\n  configurable: true,\r\n  writable: true\r\n})\r\nObject.defineProperty(obj, \"r\", {\r\n  value: 123,\r\n  enumerable: false,\r\n  configurable: false,\r\n  writable: false\r\n})\r\nconsole.log(Object.getOwnPropertyNames(obj))\r\n```\r\n### Symbol.For \r\n- 如果想要使用同一个Symbol值，可以使用Symbol.for。\r\n- 它接受一个字符串作为参数，用Symbol.for()方法创建的symbol会被放入一个全局的symbol注册表。Symbol.for()不是每次都创建新的symbol，会先搜索有没有以该参数作为名称的Symbol值。如果有就返回这个Symbol值，否则就新建并返回一个以该字符串为名称的Symbol值。\r\n```\r\nconsole.log(Symbol.for('test') === Symbol.for('test')); // true\r\nconsole.log(Symbol(\"test\") === Symbol(\"test\")); // false\r\n```\r\n### Symbol 应用场景\r\n> 应用场景不止针对的symbol这个基础的数据类型，还会针对Symbol中提供的一些函数，比如Symbol.iterator, Symbol.toStringTag等。\r\n\r\n#### 自定义迭代器之Symbol.iterator\r\n- 使用Symbol实现普通对象迭代器，普通的对象是不支持迭代器功能的，也就是普通对象不能直接使用for of功能，有了它可以让一个普通对象支持for of遍历。\r\n```\r\nconst symbolObjTest1 = {\r\n  0: \"a\",\r\n  1: \"b\",\r\n  2: \"c\",\r\n  length: 3,\r\n  [Symbol.iterator]: function() {\r\n    let index = 0;\r\n    return {\r\n      next() { // 迭代器返回的对象需要有next函数\r\n        return {\r\n          value: symbolObjTest1[index++], // value为迭代器生成的值\r\n          done: index>symbolObjTest1.length // 迭代器的终止条件，done为true时终止遍历\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfor (const iterator1 of symbolObjTest1) {\r\n  console.log(iterator1); // 打印 a b c\r\n}\r\n```\r\n#### Symbol.toStringTag\r\n- Symbol.toStringTag官方描述是一个字符串值属性，用于创建对象的默认字符串描述。由Object.property.toString()方法内部访问。\r\n- Object.property.toString()方法在开发过程中最常用场景是判断数据类型。\r\n- 自己创建的类，toString()方法只会默认返回Object标签。给类增加一个toStringTag属性，自定义的类也就拥有了自定义的类型标签。\r\n```\r\nclass TestClass {}\r\nconsole.log(Object.prototype.toString.call(new TestClass())); // '[object Object]'\r\n\r\nclass TestClass {\r\n  get [Symbol.toStringTag]() {\r\n    return \"TestToStringTag\";\r\n  }\r\n}\r\nconsole.log(Object.prototype.toString.call(new TestClass())); // '[object TestToStringTag]'\r\n```\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## Web Worker\r\n> 由于JS是单线程的，当需要对大量数据进行计算操作时，大量复杂的JS运算会独占主线程，导致页面的其他事件无法及时响应，造成页面假死的现象。可以使用Web Worker把复杂的JS操作单独放在一个线程里。创建Worker时，JS引擎向浏览器申请开一个子线程（子线程是浏览器开的，完全受主线程控制，而且不能操作DOM）JS引擎线程与worker线程间通过特定的方式通信（postMessage API，需要通过序列化对象来与线程交互特定的数据）。\r\n\r\n### JS引擎计算\r\n> 点击btn1时，js会进行大量计算，发现页面卡死了，点击input不会有任何反应。\r\n\r\n```\r\n<button id=\"btn1\">js</button>\r\n<button id=\"btn2\">worker</button>\r\n<input type=\"text\">\r\n\r\nconst btn1 = document.getElementById('btn1');\r\nbtn1.addEventListener('click', function() {\r\n  let total = 1;\r\n  for (let i = 0; i < 5000000000; i++) {\r\n    total += i;\r\n  }\r\n  console.log(total);\r\n})\r\n```\r\n### 使用Web Worker\r\n> 点击btn2时，页面并不会卡死，可以正常的对input进行输入操作。开启了一个单独的worker线程来进行复杂操作，通过postMessage和onmessage来进行两个线程间的通信。\r\n\r\n```\r\n<button id=\"btn1\">js</button>\r\n<button id=\"btn2\">worker</button>\r\n<input type=\"text\">\r\n\r\nif (window.Worker) {\r\n  const myWorker = new Worker('./worker.js');\r\n  myWorker.onmessage = function (e) {\r\n    // e.data就是postMessage传递的数据\r\n    console.log('total', e.data);\r\n  };\r\n  const btn1 = document.getElementById('btn1');\r\n  const btn2 = document.getElementById('btn2');\r\n\r\n  btn1.addEventListener('click', function () {\r\n    let total = 1;\r\n    for (let i = 0; i < 5000000000; i++) {\r\n      total += i;\r\n    }\r\n    console.log('total', total);\r\n  })\r\n\r\n  btn2.addEventListener('click', function () {\r\n    myWorker.postMessage('total');\r\n  });\r\n}\r\n\r\n\r\n// worker.js\r\nonmessage = function(e) {\r\n  // e.data就是postMessage传递的数据\r\n  if (e.data === 'total') {\r\n    let total = 1;\r\n    for (let i = 0; i < 5000000000; i++) {\r\n      total += i;\r\n    }\r\n    postMessage(total);\r\n  }\r\n}\r\n```\r\n### Web Worker与Shared Worker\r\n> 本质上就是进程和线程的区别。Shared Worker由独立的进程管理，Web Worker只是属于某个渲染进程(浏览器内核进程)下的一个线程。\r\n\r\n- Web Worker只属于某个页面，不会和其他页面的渲染进程(浏览器内核进程)共享，所以Chrome会在渲染进程(浏览器内核进程)中（每一个Tab页就是一个渲染进程）创建一个新的线程来运行Worker中的JavaScript程序。\r\n- Shared Worker是浏览器所有页面共享的，不能采用与Worker同样的方式实现，因为它不隶属于某个渲染进程(浏览器内核进程)，可以为多个渲染进程(浏览器内核进程)共享使用，所以Chrome浏览器为Shared Worker单独创建一个进程来运行JavaScript程序，在浏览器中每个相同的JavaScript只存在一个SharedWorker进程，不管它被创建多少次。\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## WebComponent\r\n> Web Component是一种W3C标准支持的组件化方案，通过它可以编写可复用的组件，同时我们也可以对自己的组件做更精细化的控制。\r\n\r\n- Custom elements：自定义元素，通过使用对应的 api，可以在不依赖框架的情况下开发原生层面的自定义元素，它将包含独立的生命周期，以及提供了自定义属性的监听。\r\n- ShadowDOM：影子dom(最大的特点是不暴露给全局)，可以通过对应的 api，将 shadow dom 附加给自定义元素，并控制其相关功能。利用 shadow dom 的特性，起到隔离的作用，使特性保密，不用再担心所编写的脚本及样式与文档其他部分冲突。\r\n- HTML 模版：通过`<template/>、<slot/>`去实现内容分发。\r\n\r\n### 定义 TextReverse 组件，TextReverse 只有一个很简单的功能，就是把传入的 字符串颠倒显示。\r\n> 使用`<text-reverse text='123'></text-reverse>` 将会显示 321。\r\n\r\n#### 定义组件\r\n- 继承 HTMLElement，然后在 构造函数 中编写自己的初始化逻辑。\r\n  1. 初始化过程中首先创建了一个shadowRoot相当于是整个组件的一个根结点。\r\n  2. 我们获取到自身的 text 属性，并且将其倒置放入新创建的 span 元素中。\r\n  3. 我们把带有 text 的 span 塞入 shadowRoot。\r\n```\r\nclass TextReverse extends HTMLElement {\r\n  constructor() {\r\n    super();\r\n    const shadowRoot = this.attachShadow({ mode: 'open' });\r\n    const text = this.getAttribute('text') || '';\r\n    const wrapper = document.createElement('span');\r\n    wrapper.textContent = text.split('').reverse().join('');\r\n    shadowRoot.appendChild(wrapper);\r\n  }\r\n}\r\n```\r\n- 定义完成之后，需要组件注册(注册的名字必须是带短横线的)。\r\n```\r\ncustomElements.define(\r\n  'text-reverse',\r\n  TextReverse\r\n)\r\n```\r\n### Shadow Dom\r\n> 上面的例子中，我们用到了 shadow root，它承载着我们组件所有的内容。这是 Web Component 核心技术。Dom 其实就是一棵树，而我们的组件则是树上的一个节点。我们可以称组件节点为 shadow host。shadow host 中含有一颗与外界隔离的 dom 树，我们称之为 shadow tree。shadow tree 中的内容不会影响到外界。Shadow Root 则是这一课shadow tree 的根节点。\r\n\r\n![Shadow Dom](./img/webComponent.png)\r\n- shadow dom 一大亮点就是样式隔离。这种样式隔离的特性很好地避免了不同组件之间的样式干扰。\r\n\r\n### Template\r\n> 在上面的例子中，采用代码的方式来创建修改节点。这种方法比较低效。可以使用 Template 来解决这问题。 html中定义了一个 template，然后，就和操作普通元素一样获取到 template 节点，然后深拷贝一份节点内容,最后直接操作这个节点。\r\n\r\n```\r\n<template id='text-reverse'>\r\n  <style>\r\n    *{\r\n      background: red;\r\n    }\r\n  </style>\r\n  <span id='text'></span>\r\n</template>\r\nclass TextReverse extends HTMLElement {\r\n  constructor() {\r\n    super();\r\n    const shadowRoot = this.attachShadow({ mode: 'open' });\r\n    const text = this.getAttribute('text') || '';\r\n    const template = document.getElementById('text-reverse').content.cloneNode(true);\r\n    template.getElementById('text').textContent = text.split('').reverse().join('');\r\n    shadowRoot.appendChild(template);\r\n  }\r\n}\r\n```\r\n### Slot\r\n> 和 Vue 的 Slot 相似，Slot 赋予了组件更高的可扩展性。通过 Slot，可以给组件传入更多的自定义内容。模版中定义一个 slot 元素，命名为 title，并且设置一个无内容时的默认值 default title。使用的时候，我们在元素中添加一个 slot 属性来与模版中的 slot 相匹配。\r\n\r\n```\r\n<text-reverse text='12345'>\r\n  <span slot='title'>text reverse</span>\r\n</text-reverse>\r\n\r\n<template id='text-reverse'>\r\n  <h1><slot name='title'>default title</slot></h1>\r\n  <span id='text'></span>\r\n</template>\r\n```\r\n### 继承现有元素\r\n> 假如我们想扩展现有系统元素，那就需要定义一个 内置自定义元素。 以一个屏蔽数字的 p 元素为例。不再是继承 HTMLElement，而是继承需要扩展的 p节点 HTMLParagraphElement。不同于独立自定义组件，我们还是需要用原有元素名去声明，并且在 is 属性中填写我们的组件名。\r\n\r\n```\r\nclass PFilter extends HTMLParagraphElement {\r\n  constructor() {\r\n    super();\r\n    const textContent = this.textContent;\r\n    this.textContent = textContent.replace(/\\d/g, '*');\r\n  }\r\n}\r\ncustomElements.define(\r\n  'p-filter',\r\n  PFilter,\r\n  {\r\n    extends: 'p'\r\n  }\r\n)\r\n\r\n// 使用\r\n<p is='p-filter'>我的手机号是：10086</p>\r\n```\r\n### 生命周期\r\n> Web Component 也含有许多控制组件生命周期的方法。 只需在定义组件的类中声明对应的方法即可。attributeChangedCallback 相对与别的属性比较特别，他需要 搭配 observedAttributes 使用。\r\n\r\n1. connectedCallback：当 custom element首次被插入 DOM 时被调用。 \r\n2. disconnectedCallback：当 custom element 从 DOM 中删除时被调用。 \r\n3. adoptedCallback：当 custom element 被移动到新的文档时被调用。 \r\n4. attributeChangedCallback: 当 custom element 增加、删除、修改自身属性时被调用。\r\n```\r\n// 我们在 observedAttributes静态方法中添加需要监听的属性值。然后，在 text 改变的时候，触发 attributeChangedCallback方法来更新 text的值。\r\nclass TextReverse extends HTMLElement {\r\n  //...\r\n  static get observedAttributes () {\r\n    return ['text'];\r\n  }\r\n  attributeChangedCallback () {\r\n    const text = this.getAttribute('text') || '';\r\n    this.shadowRoot.getElementById('text').textContent = text.split('').reverse().join('');\r\n  }\r\n}\r\n```\r\n### 优缺点\r\n- 优点\r\n  1. 浏览器原生支持，不用加入任何依赖。\r\n  2. 多种场景适用，天生组件隔离。\r\n- 缺点\r\n  1. 跟主流的框架相比，书写较为复杂，需要开发者自己进行原生 dom 操作。\r\n  2. 若要写成单文件组件，需要采用模板字符串的写法，没有语法高亮，代码提示等。"},function(r,n,e){"use strict";e.r(n),n.default="## a == 1 && a == 2 && a == 3的值为true\r\n### a 为 Object\r\n> == 会进行隐式转化，对象通过方法valueOf和toString方法转化，重写a的对应方法即可。\r\n\r\n```\r\nconst a = {\r\n  i: 1,\r\n  // valueOf 也可达到相同效果\r\n  toString: function () {\r\n    return a.i++;\r\n  }\r\n}\r\na == 1 && a == 2 && a == 3; // true\r\n```\r\n### a 为 Array\r\n> 对于数组对象，toString方法返回一个字符串，该字符串由数组中的每个元素的toString方法返回值经调用join方法连接（由逗号隔开）组成，所以重写join方法即可。\r\n\r\n```\r\nconst a = [1, 2, 3];\r\na.join = a.shift;\r\na == 1 && a == 2 && a == 3; // true\r\n```\r\n### a 为 Number\r\n> 使用defineProperty修改读取a时的逻辑。\r\n\r\n```\r\nlet val = 0;\r\nObject.defineProperty(window, 'a', {\r\n  get: function() {\r\n    return ++val;\r\n  }\r\n});\r\na == 1 && a == 2 && a == 3 // true\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## arguments\r\n> arguments对象不能显式的创建，它只有在函数中才可用，表示当前函数的实参。它可以像访问数组那样去访问每一个子元素。arguments[0],arguments[1],....arguments[n]；通过arguments.length与funcName.length(函数的length属性表示函数形参的个数)进行比较可以判断形参与实参个数是否相等。arguments不是数组而是一个类似数组的对象。类数组只能使用for循环，不能调用数组的API。\r\n\r\n1. arguments.length 为函数实参个数。\r\n2. arguments.callee 获取函数名字，引用函数自身。使用该方法调用函数本身不用考虑函数名字变化的问题，可以用此属性实现递归，详情见下。arguments.callee.length为形参的个数。\r\n```\r\nvar sum = function(n) {\r\n  if (n === 1) {\r\n    return 1\r\n  } else {\r\n    return n + arguments.callee(n - 1)\r\n  }\r\n}\r\nconsole.log(sum(5)) // 15\r\n```\r\n### 将arguments转为数组形式\r\n- [...arguments]\r\n```\r\nfunction test(num1, num2) {\r\n  console.log(arguments); // [1, 2]\r\n  const args = [...arguments];\r\n  args.push(3);\r\n  console.log(args); // [1, 2, 3]\r\n}\r\ntest(1,2);\r\n```\r\n- Array.from(arguments)\r\n```\r\nfunction test(num1, num2) {\r\n  console.log(arguments); // [1, 2]\r\n  const args = Array.from(arguments);\r\n  args.push(3);\r\n  console.log(args); // [1, 2, 3]\r\n}\r\ntest(1,2);\r\n```\r\n- Array.prototype.slice.call()\r\n```\r\nfunction test(num1, num2) {\r\n  console.log(arguments); // [1, 2]\r\n  const args = Array.prototype.slice.call(arguments);\r\n  args.push(3);\r\n  console.log(args); // [1, 2, 3]\r\n}\r\ntest(1,2);\r\n```\r\n### 箭头函数不能使用arguments,箭头函数使用剩余参数获取实参\r\n> 箭头函数无法获取arguments对象,使用剩余参数(rest)来达到获取所有形参的目的,如果没有剩余参数,rest为空数组\r\n\r\n```\r\n// ...rest表示剩余参数\r\nconst test = (...rest) => {\r\n  console.log(rest); // [1, 2]\r\n}\r\ntest(1,2)\r\n\r\n// 必须写在形参的后面，否则会报错\r\nconst test = (num1, ...rest) => {\r\n  console.log(rest); // [2]\r\n}\r\ntest(1,2)\r\n```\r\n### 类数组\r\n- 用getElementsByTagName/ClassName()获得的HTMLCollection\r\n- 用querySelector获得的nodeList"},function(r,n,e){"use strict";e.r(n),n.default="## [async在循环中使用的问题](https://zhuanlan.zhihu.com/p/68117645)\r\n### for循环中使用async\r\n> 可以正常的使用，等待await结果才会进行下一次循环。\r\n\r\n```\r\nconst arrIds = [1, 2, 3];\r\n\r\n// 写一个sleep方法模拟异步操作\r\nconst sleep = ms => {\r\n  return new Promise(resolve => setTimeout(resolve, ms));\r\n}\r\n\r\n// 假设根据id获取count的过程是异步的\r\nconst getCount = id => {\r\n  return sleep(2000).then(() => id + 10);\r\n}\r\n\r\nconst loop_for = async () => {\r\n  console.log('start');\r\n  let result = 0;\r\n  for(let i = 0; i < arrIds.length; i++) {\r\n    const count = await getCount(arrIds[i]);\r\n    console.log(count);\r\n    result += count;\r\n  }\r\n  console.log('result', result);\r\n  console.log('end');\r\n}\r\n\r\nloop_for()\r\n\r\n// start\r\n// 11\r\n// 12\r\n// 13\r\n// result 36\r\n// end\r\n```\r\n### forEach中使用\r\n> 使用forEach发现没有达到我们预期的效果。\r\n\r\n```\r\nconst arrIds = [1, 2, 3];\r\n\r\n// 写一个sleep方法模拟异步操作\r\nconst sleep = ms => {\r\n  return new Promise(resolve => setTimeout(resolve, ms));\r\n}\r\n\r\n// 假设根据id获取count的过程是异步的\r\nconst getCount = id => {\r\n  return sleep(2000).then(() => id + 10);\r\n}\r\n\r\nconst loop_forEach = () => {\r\n  console.log('start');\r\n  let result = 0;\r\n  // 在回调函数中，异步是不好控制的\r\n  arrIds.forEach(async item => {\r\n    const count = await getCount(item);\r\n    console.log(count);\r\n    result += count;\r\n  })\r\n  console.log('result', result);\r\n  console.log('end');\r\n}\r\nloop_forEach();\r\n\r\n// start\r\n// result 0\r\n// end\r\n// 11\r\n// 12\r\n// 13\r\n```\r\n### 在forEach中合理使用async\r\n> 将循环结果存储，使用promise.all进行解析。\r\n\r\n```\r\nconst arrIds = [1, 2, 3];\r\n\r\n// 写一个sleep方法模拟异步操作\r\nconst sleep = ms => {\r\n  return new Promise(resolve => setTimeout(resolve, ms));\r\n}\r\n\r\n// 假设根据id获取count的过程是异步的\r\nconst getCount = id => {\r\n  return sleep(2000).then(() => id + 10);\r\n}\r\n\r\nconst loop_forEach = async () => {\r\n  console.log('start');\r\n  const promise = [];\r\n  // 在回调函数中，异步是不好控制的\r\n  arrIds.forEach(item => {\r\n    const count = getCount(item);\r\n    promise.push(count);\r\n  });\r\n  const res = await Promise.all(promise);\r\n  console.log('res', res);\r\n  const result = res.reduce((sum, count) => sum + count);\r\n  console.log('result', result);\r\n  console.log('end');\r\n}\r\nloop_forEach();\r\n\r\n// start\r\n// res [11, 12, 13]\r\n// result 36\r\n// end\r\n```\r\n### [在forEach中不可以使用async的原因](https://www.cnblogs.com/xjnotxj/p/10629900.html)\r\n> 在forEach的实现中，调用传入的callback时是同步调用的，没有做任何异步(await)的处理。如果将callback的调用改为await将可以正常使用，不建议修改全局forEach的使用，所以建议使用for循环。\r\n\r\n```\r\n// 默认的处理逻辑\r\nArray.prototype.myForEach = function(callback, thisArg) {\r\n  if (!((typeof callback === 'Function' || typeof callback === 'function') && this)) {\r\n    throw new TypeError();\r\n  }\r\n  const arr = Object(this);  // this 就是调用当前方法的数组\r\n  const len = arr.length >>> 0;  // 转换为正整数\r\n  let i = 0;\r\n  while (i < len) {\r\n    if (i in arr) {\r\n      callback.call(thisArg, arr[i], i, arr);\r\n    }\r\n    i++;\r\n  }\r\n}\r\n\r\n// 如果将callback的调用改为await调用将没有这个问题\r\nArray.prototype.myForEach = function(callback, thisArg) {\r\n  // ...\r\n  await callback.call(thisArg, arr[i], i, arr);\r\n  // ...\r\n}\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## beforeunload事件\r\n- 当浏览器窗口关闭或者刷新时，会触发beforeunload事件。\r\n- 当阻止beforeunload事件默认行为时当前页面不会直接关闭，可以点击确定按钮关闭或刷新，也可以取消关闭或刷新。\r\n### 显示确认对话框\r\n- 根据规范要显示确认对话框，事件处理程序需要在事件上调用preventDefault()。\r\n- 并非所有浏览器都支持上述方法，有些浏览器需要事件处理程序实现两个遗留方法中的一个作为代替：\r\n  1. 将字符串分配给事件的returnValue属性。\r\n  2. 从事件处理程序返回一个字符串。\r\n### 示例\r\n- JS\r\n```\r\nwindow.addEventListener(\"beforeunload\", (event) => {\r\n  console.log('beforeunload event triggered');\r\n  // Cancel the event as stated by the standard.\r\n  event.preventDefault();\r\n  // Chrome requires returnValue to be set.\r\n  event.returnValue = \"Are you sure you want to exit?\";\r\n});\r\n```\r\n- React\r\n```\r\nconst App = () => {\r\n  useEffect(() => {\r\n    const handleTabClose = (event: any) => {\r\n      console.log('beforeunload event triggered');\r\n      // Cancel the event as stated by the standard.\r\n      event.preventDefault();\r\n      // Chrome requires returnValue to be set.\r\n      event.returnValue = \"Are you sure you want to exit?\";\r\n    };\r\n\r\n    window.addEventListener('beforeunload', handleTabClose);\r\n    return () => {\r\n      window.removeEventListener('beforeunload', handleTabClose);\r\n    };\r\n  }, []);\r\n\r\n  return (\r\n    <div>hello world</div>\r\n  );\r\n};\r\n```\r\n### 浏览器窗口关闭或者刷新时发送接口请求\r\n> 常用的异步ajax请求在unload/beforeunload事件内是不可靠的，浏览器可能会无视异步请求从而导致后端收不到。\r\n\r\n#### sendBeacon\r\n- sendBeacon设计就是用来解决页面卸载时发送请求的问题。它能保证在页面unload完成前请求能够被发送，并且由于其是异步且非阻塞的，并不会影响浏览器其它页面的显示效率。\r\n- sendBeacon只能发送http post请求。\r\n- sendBeacon无法自定义header信息。\r\n```\r\nwindow.addEventListener('beforeunload', () => {\r\n  if (window.navigator?.sendBeacon) {\r\n    const blob = new Blob([JSON.stringify(data)], {\r\n      type: 'application/json; charset=UTF-8'\r\n    });\r\n    window.navigator.sendBeacon(url, blob);\r\n  }\r\n});\r\n```\r\n#### fetch + keepalive\r\n- keepalive字段一次只能承载最大64KB的请求内容，且该限制是所有并行请求共享的，即页面卸载阶段所有fetch+keepalive请求的内容体总和不能超过64KB。\r\n- 可以发送http get请求。\r\n- 可以自定义header信息。\r\n```\r\nwindow.addEventListener('beforeunload', () => {\r\n  fetch(url, {\r\n    method: 'POST',\r\n    headers: {\r\n      \"Content-Type\": \"application/json\"\r\n    }, \r\n    body: JSON.stringify(data),\r\n    // 必须有\r\n    keepalive: true,\r\n  });\r\n})\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## esModule和CommonJS的区别\r\n- ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 属于运行时加载，都只能在运行时确定这些东西。\r\n- ES6 模块可以加载模块的部分内容，CommonJS需要加载模块整个对象。\r\n- ES6 模块输出的是值的引用，CommonJS输出的是值的拷贝(浅拷贝)。\r\n  1. CommonJS 模块输出的是值的拷贝，一旦输出一个值，模块内部的变化就影响不到这个值。由于是值的拷贝所以是深拷贝还是浅拷贝的效果存在差异。\r\n  ```\r\n  // lib.js\r\n  var counter = 3;\r\n  function incCounter() {\r\n    counter++;\r\n  }\r\n  module.exports = {\r\n    counter: counter,\r\n    incCounter: incCounter,\r\n  };\r\n  // main.js\r\n  var mod = require('./lib');\r\n\r\n  console.log(mod.counter);  // 3\r\n  mod.incCounter();\r\n  console.log(mod.counter); // 3\r\n  ```\r\n  2. ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。原始值变了，import加载的值也会跟着变。\r\n  ```\r\n  // lib.js\r\n  export let counter = 3;\r\n  export function incCounter() {\r\n    counter++;\r\n  }\r\n\r\n  // main.js\r\n  import { counter, incCounter } from './lib';\r\n  console.log(counter); // 3\r\n  incCounter();\r\n  console.log(counter); // 4\r\n\r\n  // m1.js\r\n  export var foo = 'bar';\r\n  setTimeout(() => foo = 'baz', 500);\r\n\r\n  // m2.js\r\n  import { foo } from './m1.js';\r\n  console.log(foo); // bar\r\n  setTimeout(() => console.log(foo), 500); // baz\r\n  ```\r\n- ES6模块属于编译时加载，无法像CommonJS一般，做到运行时加载。所以有一个提案，引入import()函数，完成运行时加载，或者叫动态加载。import()和require()相同点都是运行时加载；区别在于import()属于异步加载，require()属于同步加载。\r\n### 模块循环依赖不会死循环(入口文件引用了a模块，a模块引用了b模块，b模块却又引用了a模块)\r\n- CommonJS\r\n> 循环引用要解决两个问题，避免死循环以及确定输出的值。CommonJS通过模块缓存来解决，每一个模块都先加入缓存再执行，每次遇到require都先检查缓存，这样就不会出现死循环；借助缓存输出的值也很简单就能找到了。\r\n\r\n  1. 【入口模块】开始执行，把入口模块加入缓存。\r\n  2. var a = require('./a') 执行 将a模块加入缓存，进入a模块。\r\n  3. 【a模块】exports.a = '原始值-a模块内变量'执行，a模块的缓存中给变量a初始化，为原始值。\r\n  4. 执行var b = require('./b')，将b模块加入缓存，进入b模块。\r\n  5. 【b模块】exports.b ='原始值-b模块内变量'，b模块的缓存中给变量b初始化，为原始值。\r\n  6. var a = require('./a')，尝试导入a模块，发现已有a模块的缓存，所以不会进入执行，而是直接取a模块的缓存，此时打印{ a: '原始值-a模块内变量' }。\r\n  7. exports.b = '修改值-b模块内变量 执行，将b模块的缓存中变量b替换成修改值。\r\n  8. 【a模块】console.log('a模块引用b模块：',b) 执行，取缓存中的值，打印{ b: '修改值-b模块内变量' }。\r\n  9. exports.a = '修改值-a模块内变量' 执行，将a模块缓存中的变量a替换成修改值。\r\n  10. 【入口模块】console.log('入口模块引用a模块：',a) 执行，取缓存中的值，打印{ a: '修改值-a模块内变量' }。\r\n```\r\n//index.js\r\nvar a = require('./a')\r\nconsole.log('入口模块引用a模块', a)\r\n\r\n// a.js\r\nexports.a = '原始值-a模块内变量'\r\nvar b = require('./b')\r\nconsole.log('a模块引用b模块', b)\r\nexports.a = '修改值-a模块内变量'\r\n\r\n// b.js\r\nexports.b ='原始值-b模块内变量'\r\nvar a = require('./a')\r\nconsole.log('b模块引用a模块', a)\r\nexports.b = '修改值-b模块内变量'\r\n\r\n// 输出\r\nb模块引用a模块 {a: 原始值-a模块内变量}\r\na模块引用b模块 {b: 修改值-b模块内变量}\r\n入口模块引用a模块 {a: 修改值-a模块内变量}\r\n```\r\n- ES Module\r\n> 借助模块地图，已经进入过的模块标注为获取中，遇到import语句会去检查这个地图，已经标注为获取中的则不会进入，地图中的每一个节点是一个模块记录，上面有导出变量的内存地址，导入时会做一个连接——即指向同一块内存。\r\n\r\n  1. 【入口模块】首先进入入口模块，在模块地图中把入口模块的模块记录标记为“获取中”（Fetching），表示已经进入，但没执行完毕。\r\n  2. import * as a from './a.mjs' 执行，进入a模块，此时模块地图中a的模块记录标记为“获取中”。\r\n  3. 【a模块】import * as b from './b.mjs' 执行，进入b模块，此时模块地图中b的模块记录标记为“获取中”。\r\n  4. 【b模块】import * as a from './a.mjs' 执行，检查模块地图，模块a已经是Fetching态，不再进去。\r\n  5. let b = '原始值-b模块内变量' 模块记录中，存储b的内存块初始化。\r\n  6. console.log('b模块引用a模块：', a) 根据模块记录到指向的内存中取值，是{ a:}。\r\n  7. b = '修改值-b模块内变量' 模块记录中，存储b的内存块值修改。\r\n  8. 【a模块】let a = '原始值-a模块内变量' 模块记录中，存储a的内存块初始化。\r\n  9. console.log('a模块引用b模块：', b) 根据模块记录到指向的内存中取值，是{ b: '修改值-b模块内变量' }。\r\n  10. a = '修改值-a模块内变量' 模块记录中，存储a的内存块值修改。\r\n  11. 【入口模块】console.log('入口模块引用a模块：',a) 根据模块记录，到指向的内存中取值，是{ a: '修改值-a模块内变量' }。\r\n```\r\n//index.js\r\nvar a = require('./a')\r\nconsole.log('入口模块引用a模块', a)\r\n\r\n// a.js\r\nexports.a = '原始值-a模块内变量'\r\nvar b = require('./b')\r\nconsole.log('a模块引用b模块', b)\r\nexports.a = '修改值-a模块内变量'\r\n\r\n// b.js\r\nexports.b ='原始值-b模块内变量'\r\nvar a = require('./a')\r\nconsole.log('b模块引用a模块', a)\r\nexports.b = '修改值-b模块内变量'\r\n\r\n// 输出\r\nb模块引用a模块 uninitialized\r\na模块引用b模块 {b: 修改值-b模块内变量}\r\n入口模块引用a模块 {a: 修改值-a模块内变量}\r\n```\r\n### 多次引用(入口模块引用了a、b两个模块，a、b这两个模块又分别引用了c模块，此时并不存在循环引用，但是c模块被引用了两次。)\r\n- CommonJs\r\n> c模块只被执行了一次，当第二次引用c模块时，发现已经有缓存，则直接读取，而不会再去执行一次。\r\n\r\n```\r\n//index.js\r\nvar a = require('./a')\r\nvar b= require('./b')\r\n\r\n// a.js\r\nmodule.exports.a = '原始值-a模块内变量'\r\nconsole.log('a模块执行')\r\nvar c = require('./c')\r\n\r\n// b.js\r\nmodule.exports.b = '原始值-b模块内变量'\r\nconsole.log('b模块执行')\r\nvar c = require('./c')\r\n\r\n// c.js\r\nmodule.exports.c = '原始值-c模块内变量'\r\nconsole.log('c模块执行')\r\n\r\n// 输出\r\na模块执行\r\nc模块执行\r\nb模块执行\r\n```\r\n### tree shaking\r\n> tree shaking通常用于描述移除JavaScript上下文中的未引用代码（dead-code）。如果是使用模块化开发的话，就可以删除那些引入某个模块中用不到的函数。tree shaking的实现依赖于ESM的静态分析能力，会在编译过程中静态分析模块之间的导入导出，确定ESM模块中哪些导出值未曾其它模块使用，并将其删除，以此实现打包产物的优化。import和export可以实现tree shaking，但是直接export default整个对象或者使用CommonJS的语法是无法实现的。"},function(r,n,e){"use strict";e.r(n),n.default="## forEach的局限\r\n- 不支持处理异步函数\r\n> 因为forEach内部调用传入的callback时是同步调用的，没有做任何异步(await)的处理。\r\n\r\n- 除了抛出异常以外，没有办法中止或跳出forEach循环。\r\n- index不可被重置，在forEach中我们无法控制index的值，它只会无脑的自增直至大于数组的length跳出循环。\r\n- forEach性能比for循环低，for循环没有额外的函数调用栈和上下文，所以它的实现最为简单。"},function(r,n,e){"use strict";e.r(n),n.default="## hasOwnProperty与in的区别\r\n### 相同点\r\n- hasOwnProperty与in都可以检测一个对象上是否有某个属性。\r\n### 区别\r\n- in是判断对象本身和对象原型链上是否有这个属性。\r\n- hasOwnProperty是判断对象本身是否有这个属性，不会去原型链上查找。\r\n```\r\nconst Person = function(age) {\r\n  this.age = age;\r\n}\r\nPerson.prototype.name = 'dyx';\r\n\r\nconst p1 = new Person(26);\r\n\r\nconsole.log('age' in p1);  // true \r\nconsole.log('name' in p1); // true\r\nconsole.log('toString' in p1); // true\r\n\r\nconsole.log(p1.hasOwnProperty('age')); // true\r\nconsole.log(p1.hasOwnProperty('name')); // false，原型链上的name属性检测不到\r\nconsole.log(p1.hasOwnProperty('toString')); // false，原型链上的toString属性检测不到\r\n```\r\n### eslint报错Do not access Object.prototype method 'hasOwnProperty' from target object\r\n- eslint提示\r\n```\r\nobj.hasOwnProperty(key);\r\n```\r\n- eslint不提示\r\n```\r\nObject.prototype.hasOwnProperty.call(obj, key);\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## 事件流\r\n> 满足同时触发多个事件时(一次点击会触发多个不同DOM上的事件)的执行顺序：一个完整的事件流是从window开始，最后回到window的过程。并且被分为捕获阶段、目标阶段、冒泡阶段。\r\n\r\n- 捕获阶段：触发的事件从window发出，不断经过下级节点直到触发的目标节点。在到达目标节点之前的过程就是捕获阶段。\r\n- 目标阶段：触发的事件不断的传递直到目标节点的时候，最终在目标节点上触发这个事件，就是目标阶段。\r\n- 冒泡阶段：触发的事件由最精确的元素(事件发生所在的节点)然后逐级传播到较为不精确的节点的过程就是冒泡阶段。\r\n### 事件级别\r\n> DOM级别一共可以分为四个级别：DOM0级、DOM1级、DOM2级和DOM3级。而DOM事件分为3个级别：DOM0级事件处理、DOM2级事件处理和DOM3级事件处理。因为DOM1级标准没有定义事件相关的内容，所以没有所谓的1级DOM事件模型。\r\n\r\n### DOM0级事件处理\r\n> 将一个函数赋值给一个事件处理属性。\r\n\r\n```\r\n<body>\r\n\t<div></div>\r\n</body>\r\n\r\n<script type=\"text/javascript\">\r\n  const div = document.querySelector(\"div\");\r\n  div.onclick = function(){}\r\n<\/script>\r\n```\r\n### DOM2级处理事件\r\n> 定义了addEventListener和removeEventListener两个方法分别用来绑定和解绑事件。方法中包含三个参数分别是绑定的事件处理的属性名称、处理函数、是否在捕获时候执行事件处理函数。默认使用冒泡流，第三个参数设为true时使用捕获流。\r\n\r\n```\r\n<body>\r\n\t<div></div>\r\n</body>\r\n\r\n<script type=\"text/javascript\">\r\n  const div = document.querySelector(\"div\");\r\n  div.addEventListener('click', function(){}, false);\r\n<\/script>\r\n```\r\n### DOM3级处理事件\r\n> 在DOM2级事件的基础上添加了更多的事件类型，如滚动事件、触摸事件、过渡事件等。\r\n\r\n### 总结\r\n- 0级只能定义一个事件，多事件会相互覆盖。\r\n- 2级多了自定义事件，并且还有事件冒泡和捕获；可以给一个事件添加多个处理函数。\r\n- 3级添加了更多的事件类型。\r\n### 事件冒泡和事件捕获\r\n- 事件冒泡：事件按照从最精确的事件目标到最不精确的事件目标的顺序触发。\r\n```\r\n<div id='one'>\r\n  <div id='two'>\r\n    <div id='three'>\r\n      <div id='four'>\r\n        Event\r\n      </div>\r\n    </div>\r\n  </div>\r\n</div>\r\n\r\n<script type='text/javascript'>\r\n  const one=document.getElementById('one');\r\n  const two=document.getElementById('two');\r\n  const three=document.getElementById('three');\r\n  const four=document.getElementById('four');\r\n\r\n  one.addEventListener('click', function() {\r\n    alert('one');\r\n  }, false);\r\n\r\n  two.addEventListener('click', function() {\r\n    alert('two');\r\n  }, false);\r\n\r\n  three.addEventListener('click', function() {\r\n    alert('three');\r\n  }, false);\r\n\r\n  four.addEventListener('click', function() {\r\n    alert('four');\r\n  }, false);\r\n<\/script>\r\n// 点击之后弹框顺序是four、three、two、one。\r\n```\r\n- 事件捕获：事件按照从最不精确的事件目标到最精确的事件目标的顺序触发。\r\n```\r\n<div id='one'>\r\n  <div id='two'>\r\n    <div id='three'>\r\n      <div id='four'>\r\n        Event\r\n      </div>\r\n    </div>\r\n  </div>\r\n</div>\r\n\r\n<script type='text/javascript'>\r\n  const one=document.getElementById('one');\r\n  const two=document.getElementById('two');\r\n  const three=document.getElementById('three');\r\n  const four=document.getElementById('four');\r\n\r\n  one.addEventListener('click', function() {\r\n    alert('one');\r\n  }, true);\r\n\r\n  two.addEventListener('click', function() {\r\n    alert('two');\r\n  }, true);\r\n\r\n  three.addEventListener('click', function() {\r\n    alert('three');\r\n  }, true);\r\n\r\n  four.addEventListener('click', function() {\r\n    alert('four');\r\n  }, true);\r\n<\/script>\r\n// 点击之后弹框顺序是one、two、three、four。\r\n```\r\n### 事件对象\r\n> 在触发DOM上的某个事件时，会产生一个事件对象event，这个对象中包含着所有与事件有关的信息。只有在事件处理程序执行期间，event对象才会存在。一旦事件处理程序执行完成，event对象就会被销毁。\r\n\r\n- currentTarget、target\r\n> target指向事件流的目标阶段对象，currentTarget指向事件流在捕获、目标、冒泡阶段事件活动的对象。只有当事件流处在目标阶段的时候，两个的指向才是一样的，而当处于捕获和冒泡阶段的时候，target指向被触发的对象而currentTarget指向当前事件活动的对象。\r\n\r\n- event.type代表事件的类型如click\r\n- event.preventDefault()阻止事件的默认事件\r\n- stopPropagation()用于立即停止事件在DOM层次中的传播，即取消进一步的事件捕获或冒泡\r\n- e.persist() // 异步回调后事件对象的继续使用\r\n- eventPhase\r\n    - 用来确定事件当前正位于事件流的哪个阶段。捕获阶段：eventPhase = 1；处于目标对象上：eventPhase = 2；冒泡阶段：eventPhase = 3；\r\n    - 当eventPhase等于2时，this、target、currentTarget始终是相等的。\r\n```\r\n// 首先执行的事件是在捕获阶段触发的添加到document.body中的那一个，eventPhase为1。\r\n// 其次会触发在按钮上注册的事件处理程序(因为第三个参数设置为true，表示使用捕获流)，eventPhase为2。\r\n// 最后在冒泡阶段触发添加到document.body中的那一个，eventPhase为3。 \r\nbtn.onclick = function(event) {\r\n  alert(event.eventPhase); // 2\r\n}\r\ndocument.body.addEventListener(\"click\", function(event) {\r\n   alert(event.eventPhase); // 1\r\n}, true);\r\ndocument.body.onclick = function(event) {\r\n  alert(event.eventPhase); // 3\r\n}\r\n```\r\n### 同一个元素既有click事件又有addEventListener事件，点击之后两个事件都会触发，且先执行addEventListener的事件后执行click的事件。\r\n### 阻止事件传播\r\n1. 阻止冒泡：stopPropagation()；IE下：cancelBubble = true。\r\n2. 默认事件阻止：preventDefault()；IE下：window.event.returnValue = false。"},function(r,n,e){"use strict";e.r(n),n.default='## js加载方式\r\n### 正常模式\r\n- 默认情况下浏览器是同步下载js脚本，浏览器会立即下载并执行相应的脚本，这种情况下js下载会阻塞dom渲染。\r\n- 如果脚本体积很大，下载和执行的时间就会很长，因此造成浏览器堵塞，用户会感觉到浏览器“卡死”了，没有任何响应。\r\n```\r\n<script src="index.js"><\/script>\r\n```\r\n### async模式\r\n- async模式下js下载是异步的，js下载结束会立即执行，js下载不会阻塞dom渲染。\r\n- async模式下js下载是无顺序的，当js下载结束会立即执行，渲染引擎就会中断渲染，执行完这个脚本以后，再继续渲染。\r\n- 若该js资源与dom元素没有依赖关系，也不会产生其他资源所需要的数据时，可以使用async模式，比如埋点统计。\r\n```\r\n<script async src="index.js"><\/script>\r\n```\r\n### defer模式\r\n- defer模式下js下载也是异步的，会在文档完成解析后触发DOMContentLoaded事件前执行js资源，js下载不会阻塞dom渲染。\r\n- defer模式下js下载是有顺序的，如果有多个设置了defer的script标签存在，则会按照引入的前后顺序执行，即便是后面的script资源先返回。\r\n- 一般情况下都可以使用defer，特别是需要控制资源执行顺序时，比如element-ui.js和vue.js，因为element-ui.js依赖于vue，所以必须先引入vue.js再引入element-ui.js。\r\n```\r\n<script defer src="vue.js"><\/script>\r\n<script defer src="element-ui.js"><\/script>\r\n```\r\n### module模式\r\n- 在主流的现代浏览器中script标签的属性可以加上type="module"，浏览器会对其内部的import引用发起HTTP请求获取模块内容。\r\n- 这时script的行为会像defer模式一样，异步下载js并且会在文档完成解析后触发DOMContentLoaded事件前执行js资源。\r\n- vite就是利用浏览器支持原生的ES Module，开发时跳过打包的过程提升编译效率。\r\n```\r\n<script type="module">\r\n  import { a } from \'./a.js\';\r\n<\/script>\r\n```\r\n### async与defer\r\n- async和defer属性仅仅对外部脚本起作用。\r\n- async和defer属性都会异步下载js脚本，js脚本下载都不会阻塞页面的解析，但是js的执行一定是和UI线程是互斥的。\r\n- async是下载完就执行，defer是渲染完再执行。\r\n\r\n![js加载](./img/js加载.png)\r\n![js加载方式](./img/js加载方式.png)\r\n'},function(r,n,e){"use strict";e.r(n),n.default="## new操作符\r\n### new操作符的流程\r\n1. 创建一个新对象。\r\n2. 为第一步创建的对象添加原型属性(`__proto__`)属性值等于构造函数的原型对象。\r\n3. 将this指向这个新对象。\r\n4. 执行构造函数，属性和方法被添加到this指向的对象中。\r\n5. 如果构造函数返回非空对象，则返回该对象，否则返回刚创建的新对象。\r\n\r\n### 实现new操作符\r\n```\r\nfunction myNew(Con, ...args) {\r\n  // 创建空对象\r\n  let obj = {};\r\n  // 为对象添加原型属性\r\n  obj._proto_ = Con.prototype;\r\n  // 绑定 this 并执行构造函数(为对象设置属性)\r\n  const res = Con.apply(obj, args);\r\n  // 判断构造函数是否有返回值\r\n  if (res && typeof res === 'object' || typeof res === 'function') {\r\n    return res;\r\n  }\r\n  return obj;\r\n}\r\n\r\n// 构造函数\r\nfunction Test(name, age) {\r\n  this.name = name;\r\n  this.age = age;\r\n}\r\nTest.prototype.sayName = function() {\r\n  console.log(this.name);\r\n}\r\n\r\n// 实现一个 new 操作符\r\nconst a = myNew(Test, 'dyx', '26')\r\nconsole.log(a.age) // '26'\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## promise\r\n### Promise中的代码是同步执行的，then方法中是异步执行的\r\n```\r\n// 输出结果是 1 3 4 2\r\nnew Promise(resolve => {\r\n  console.log(1);\r\n  resolve(2);\r\n  console.log(3);\r\n}).then(res => console.log(res));\r\nconsole.log(4)\r\n```\r\n### Promise一旦状态改变，就不会再变,后序的操作会执行但是不影响Promise的状态,并且不会影响返回的结果\r\n```\r\n// 输出结果1\r\nnew Promise((resolve, reject) => {\r\n  resolve(1);\r\n  reject(2);\r\n  resolve(3)\r\n}).then(\r\n  res => console.log(res)\r\n).catch(\r\n  err => console.log(err)\r\n)\r\n```\r\n### then方法\r\n- then方法的第一个参数是resolved状态的回调函数，第二个参数（可选）是rejected状态的回调函数。\r\n```\r\nnew Promise((resolve, reject) => {\r\n  resolve(1);\r\n}).then(\r\n  res => console.log(res), // 1\r\n  err => console.log(err)\r\n)\r\n\r\nnew Promise((resolve, reject) => {\r\n  reject(1);\r\n}).then(\r\n  res => console.log(res),\r\n  err => console.log(err) // 1\r\n)\r\n```\r\n- then方法返回一个Promise对象，所以then方法可以链式调用。\r\n```\r\n// 输出 1 2\r\nnew Promise(resolve => {\r\n  resolve(1);\r\n}).then(\r\n  res => {\r\n    console.log(res);\r\n    return 2;\r\n  }\r\n).then(res => console.log(res))\r\n```\r\n### catch方法\r\n> 用于获取Promise中抛出的错误或者rejected状态返回的结果，效果等同于then方法中第二个参数的作用，then方法使用两个参数时，catch方法不生效。抛出错误不能return Error对象，需要throw Error对象或者使用reject。\r\n\r\n```\r\nnew Promise((resolve, reject) => {\r\n  // throw new Error('error');\r\n  reject('123')\r\n}).then(\r\n  res => {\r\n    console.log(res);\r\n    return 2;\r\n  },\r\n  err => console.log(err) // 输出结果\r\n).catch(\r\n  err => console.log(err) // 不执行\r\n)\r\n\r\n// catch 可以捕获then方法中抛出的错误, then方法的第二个参数不能捕获第一个参数中抛出的错误，只能捕获前面Promise实例抛出的错误\r\nPromise.resolve(123).then(\r\n  res => {\r\n    throw new Error('err')\r\n  },\r\n  err => console.log(err)\r\n).catch(\r\n  err => console.log(err) // 捕获错误信息\r\n)\r\n\r\n// 可以使用链式调用then方法的形式捕获上一个then方法抛出的错误\r\nPromise.resolve(123).then(\r\n  res => {\r\n    throw new Error('err')\r\n  },\r\n  err => console.log(err)\r\n).then(\r\n  res => console.log(res),\r\n  err => console.log(err) // 捕获错误信息\r\n)\r\n```\r\n### finally方法\r\n> 不管 Promise 对象最后状态如何，都会执行的操作\r\n\r\n```\r\nnew Promise((resolve, reject) => {\r\n  reject(1);\r\n}).then(\r\n  res => console.log(res)\r\n).catch(\r\n  err => console.log(err) // 1\r\n).finally(res => console.log('dyx')) // 'dyx'\r\n```\r\n### then 或者 catch 可以被调用多次，但 Promise 构造函数只执行一次。后续每次调用 then 或者 catch 都会直接拿到第一次执行的结果。\r\n- then 或 catch 返回的值不能是 当前Promise 本身，否则会造成死循环\r\n- then 或者 catch 的参数期望是函数，如果传入非函数会将最前面的Promsie的值传递过去\r\n```\r\n// 最后console的res是'123',前面的then方法中的console.log(1)依然会执行\r\nnew Promise((resolve, reject) => {\r\n  resolve('123')\r\n}).then('dyx').then(console.log(1)).then(res => console.log(res))\r\n```\r\n- 如果传入函数后面的then方法接收到的值为前面then方法中返回的值\r\n```\r\n// 最后console的res是undefined,因为前面的then方法中的函数没有return任何值\r\nnew Promise((resolve, reject) => {\r\n  resolve('123')\r\n}).then(() => 'dyx').then(() => console.log(1)).then(res => console.log(res))\r\n```\r\n### Promise.all\r\n> 接受一个数组作为参数，数组中的每一个参数都是一个promise实例。适用于对同一接口调用多次只是调用参数不同的情况。所有的Promise实例都为resolved才会返回Promise.all的结果，有Promise实例rejected时会立即返回当前rejected的结果，后序的Promise实例依然会执行，只是不影响整体的返回结果。当rejected的实例自定义了catch方法会将此实例的结果看为resolved，值为定义的catch方法的返回值。\r\n\r\n- 所有的Promise实例的结果为resolved的时候，Promise.all会返回一个数组的结果，数组内容为每一个Promise实例的返回结果\r\n```\r\n// 输出顺序是 1 2 [1,2]\r\nvar p1 = new Promise(resolve => {\r\n  setTimeout(() => {\r\n    console.log(1);\r\n    resolve(1)\r\n  }, 500);\r\n});\r\nvar p2 = new Promise(resolve => {\r\n  setTimeout(() => {\r\n    console.log(2);\r\n    resolve(2)\r\n  }, 600);\r\n});\r\nPromise.all([p1, p2]).then(res => {\r\n  console.log(res);  // [1,2]\r\n});\r\n```\r\n- 所有的Promise实例中有一个被rejected，Promise.all的状态就变成rejected，此时第一个被reject的实例的返回值会作为Promise.all的返回值，后序的Promsie实例依然会执行，只是不影响最终的结果\r\n```\r\n// 输出顺序是1 err 2\r\nvar p1 = new Promise((resolve, reject) => {\r\n  setTimeout(() => {\r\n    console.log(1);\r\n    reject('err')\r\n  }, 500);\r\n})\r\nvar p2 = new Promise(resolve => {\r\n  setTimeout(() => {\r\n    console.log(2);\r\n    resolve(2)\r\n  }, 600);\r\n});\r\nPromise.all([p1, p2]).then(\r\n  res => console.log(res),\r\n  err => console.log(err) // err\r\n)\r\n```\r\n- 如果作为参数的Promise 实例，自己定义了catch方法，那么一旦被rejected，并不会触发Promise.all()的catch方法,只会触发这个实例的catch方法\r\n```\r\n// 输出顺序是1 'err' 2 ['err', 2]\r\nvar p1 = new Promise((resolve, reject) => {\r\n  setTimeout(() => {\r\n    console.log(1);\r\n    reject('err')\r\n  }, 500);\r\n}).catch(err => {\r\n  console.log(err) // err\r\n  return err;\r\n}) \r\nvar p2 = new Promise(resolve => {\r\n  setTimeout(() => {\r\n    console.log(2);\r\n    resolve(2)\r\n  }, 600);\r\n});\r\nPromise.all([p1, p2]).then(\r\n  res => console.log(res) // ['err', 2]\r\n).catch(err => console.log(err))\r\n```\r\n### Promise.race\r\n> Promise.race同样接受一个数组作为参数，数组中的每一个参数都是一个promise实例。适用于多个接口调用有其中一个成功即可的场景。只要有一个Promise实例都为resolved就会返回Promise.race的结果，有Promise实例rejected时会立即返回当前rejected的结果，后序的Promise实例依然会执行，只是不影响整体的返回结果。当rejected的实例自定义了catch方法会将此实例的结果看为resolved，值为定义的catch方法的返回值。\r\n\r\n- Promise.race根据传入的实例，一旦有Promsie实例为resolved，则将该实例的结果作为Promise.race的结果返回，后序的Promise实例的依然会执行只是运行结果不会影响最终结果。\r\n```\r\n// 输出结果为 1 1 2\r\nvar p1 = new Promise(resolve => {\r\n  setTimeout(() => {\r\n    console.log(1);\r\n    resolve(1)\r\n  }, 500);\r\n});\r\nvar p2 = new Promise(resolve => {\r\n  setTimeout(() => {\r\n    console.log(2);\r\n    resolve(2)\r\n  }, 600);\r\n});\r\nPromise.race([p1, p2]).then(res => {\r\n  console.log(res);  // 1\r\n});\r\n```\r\n- 一旦有Promise实例为rejected，也将作为结果返回，后序的Promsie实例依然会执行，只是不影响最终的结果。\r\n```\r\n// 输出结果为 1 err 2\r\nvar p1 = new Promise((resolve, reject) => {\r\n  setTimeout(() => {\r\n    console.log(1);\r\n    reject('err')\r\n  }, 500);\r\n});\r\nvar p2 = new Promise(resolve => {\r\n  setTimeout(() => {\r\n    console.log(2);\r\n    resolve(2)\r\n  }, 600);\r\n});\r\nPromise.race([p1, p2]).then(res => {\r\n  console.log(res);  \r\n}).catch(err => console.log(err)); // err\r\n```\r\n- 如果作为参数的Promise 实例，自己定义了catch方法，那么一旦被rejected，并不会触发Promise.race()的catch方法,只会触发这个实例的catch方法\r\n```\r\n// 输出顺序是1 'err' 'err' 2\r\nvar p1 = new Promise((resolve, reject) => {\r\n  setTimeout(() => {\r\n    console.log(1);\r\n    reject('err')\r\n  }, 500);\r\n}).catch(err => {\r\n  console.log(err) // err\r\n  return err;\r\n})\r\nvar p2 = new Promise(resolve => {\r\n  setTimeout(() => {\r\n    console.log(2);\r\n    resolve(2)\r\n  }, 600);\r\n});\r\nPromise.race([p1, p2]).then(\r\n  res => console.log(res) // 'err'\r\n).catch(err => console.log(err))\r\n```\r\n### Promise.any\r\n> Promise.any同样接受一个数组作为参数，数组中的每一个参数都是一个promise实例。和Promise.race相似，只是不会因为某个 Promise 变成rejected状态而结束。只要有Promise实例为resolved就会返回Promise.any的结果，当所有Promise实例rejected时会返回一个error信息。当rejected的实例自定义了catch方法会将此实例的结果看为resolved，值为定义的catch方法的返回值。\r\n\r\n- Promise.any根据传入的实例，一旦有Promsie实例为resolved，则将该实例的结果作为Promise.any的结果返回，后序的Promise实例的依然会执行只是运行结果不会影响最终结果。\r\n```\r\n// 输出结果为 1 1 2\r\nvar p1 = new Promise(resolve => {\r\n  setTimeout(() => {\r\n    console.log(1);\r\n    resolve(1)\r\n  }, 500);\r\n});\r\nvar p2 = new Promise(resolve => {\r\n  setTimeout(() => {\r\n    console.log(2);\r\n    resolve(2)\r\n  }, 600);\r\n});\r\nPromise.any([p1, p2]).then(res => {\r\n  console.log(res);  // 1\r\n});\r\n```\r\n- 有Promise实例为rejected，不会将reject结果返回，而是会返回后续执行中实例为resolve的结果，后序的Promsie实例依然会执行，只是不影响最终的结果。\r\n```\r\n// 输出结果为 1 2 2\r\nvar p1 = new Promise((resolve, reject) => {\r\n  setTimeout(() => {\r\n    console.log(1);\r\n    reject('err')\r\n  }, 500);\r\n});\r\nvar p2 = new Promise(resolve => {\r\n  setTimeout(() => {\r\n    console.log(2);\r\n    resolve(2)\r\n  }, 600);\r\n});\r\nPromise.any([p1, p2]).then(res => {\r\n  console.log(res);  // 2\r\n}).catch(err => console.log(err)); \r\n```\r\n- 当所有的实例都reject时，会返回一个error信息，表示所有的Promise实例都rejected\r\n```\r\n// 输出结果为 1 2 All promises were rejected\r\nvar p1 = new Promise((resolve, reject) => {\r\n  setTimeout(() => {\r\n    console.log(1);\r\n    reject('err')\r\n  }, 500);\r\n});\r\nvar p2 = new Promise((resolve, reject) => {\r\n  setTimeout(() => {\r\n    console.log(2);\r\n    reject(2)\r\n  }, 600);\r\n});\r\n\r\nPromise.any([p1, p2]).then(res => {\r\n  console.log(res); \r\n}).catch(err => console.log(err)); // All promises were rejected\r\n```\r\n- 如果作为参数的Promise 实例，自己定义了catch方法，那么一旦被rejected，并不会触发Promise.any()的catch方法,只会触发这个实例的catch方法\r\n```\r\n// 输出结果为 1 'err' 'err' 2\r\nvar p1 = new Promise((resolve, reject) => {\r\n  setTimeout(() => {\r\n    console.log(1);\r\n    reject('err')\r\n  }, 500);\r\n}).catch(err => {\r\n  console.log(err) // 'err'\r\n  return err\r\n});\r\nvar p2 = new Promise((resolve, reject) => {\r\n  setTimeout(() => {\r\n    console.log(2);\r\n    reject(2)\r\n  }, 600);\r\n});\r\n\r\nPromise.any([p1, p2]).then(res => {\r\n  console.log(res); // 'err'\r\n}).catch(err => console.log(err));\r\n```\r\n### Promise.allSettled\r\n> Promise.allSettled同样接受一个数组作为参数，数组中的每一个参数都是一个promise实例。只有等到所有这些参数实例都返回结果，不管是fulfilled还是rejected，allSettled才会结束。当rejected的实例自定义了catch方法会将此实例的结果看为resolved，值为定义的catch方法的返回值。\r\n\r\n- 当所有的实例都为resolve时\r\n```\r\n// 输出结果为 1 2 [{status: \"fulfilled\", value: 1}, {status: \"fulfilled\", value: 2}]\r\nvar p1 = new Promise(resolve => {\r\n  setTimeout(() => {\r\n    console.log(1);\r\n    resolve(1)\r\n  }, 500);\r\n});\r\nvar p2 = new Promise(resolve => {\r\n  setTimeout(() => {\r\n    console.log(2);\r\n    resolve(2)\r\n  }, 600);\r\n});\r\nPromise.allSettled([p1, p2]).then(res => {\r\n  console.log(res);  // [{status: \"fulfilled\", value: 1}, {status: \"fulfilled\", value: 2}]\r\n});\r\n```\r\n- 当所有的实例都为reject时\r\n```\r\n// 输出结果为 1 2 [{status: \"rejected\", reason: 1}, {status: \"rejected\", reason: 2}]\r\nvar p1 = new Promise((resolve, reject) => {\r\n  setTimeout(() => {\r\n    console.log(1);\r\n    reject(1)\r\n  }, 500);\r\n});\r\nvar p2 = new Promise((resolve, reject) => {\r\n  setTimeout(() => {\r\n    console.log(2);\r\n    reject(2)\r\n  }, 600);\r\n});\r\nPromise.allSettled([p1, p2]).then(res => {\r\n  console.log(res);  // [{status: \"rejected\", reason: 1}, {status: \"rejected\", reason: 2}]\r\n}).catch(err => console.log(err));\r\n```\r\n- 有的实例resolve，有的reject时\r\n```\r\n// 输出结果为 1 2 [{status: \"fulfilled\", value: 1}, {status: \"rejected\", reason: 2}]\r\nvar p1 = new Promise((resolve, reject) => {\r\n  setTimeout(() => {\r\n    console.log(1);\r\n    resolve(1)\r\n  }, 500);\r\n});\r\nvar p2 = new Promise((resolve, reject) => {\r\n  setTimeout(() => {\r\n    console.log(2);\r\n    reject(2)\r\n  }, 600);\r\n});\r\nPromise.allSettled([p1, p2]).then(res => {\r\n  console.log(res);  // [{status: \"fulfilled\", value: 1}, {status: \"rejected\", reason: 2}]\r\n}).catch(err => console.log(err));\r\n```\r\n- 其中一个promise没有结果，则什么都结果都拿不到\r\n```\r\n// 输出结果为 1 \r\nvar p1 = new Promise((resolve, reject) => {\r\n  setTimeout(() => {\r\n    console.log(1);\r\n    resolve(1)\r\n  }, 500);\r\n});\r\nvar p2 = new Promise((resolve, reject) => {});\r\nPromise.allSettled([p1, p2]).then(res => {\r\n  console.log(res);  // 不会返回任何结果\r\n}).catch(err => console.log(err));\r\n```\r\n- 当reject的实例自定义catch时\r\n```\r\n// 输出结果为 1 2 2 [{status: \"fulfilled\", value: 1}, {status: \"fulfilled\", reason: 2}]\r\nvar p1 = new Promise((resolve, reject) => {\r\n  setTimeout(() => {\r\n    console.log(1);\r\n    resolve(1)\r\n  }, 500);\r\n});\r\nvar p2 = new Promise((resolve, reject) => {\r\n  setTimeout(() => {\r\n    console.log(2);\r\n    reject(2)\r\n  }, 600);\r\n}).catch(err => {\r\n  console.log(err)\r\n  return err;\r\n});\r\nPromise.allSettled([p1, p2]).then(res => {\r\n  console.log(res);  // [{status: \"fulfilled\", value: 1}, {status: \"fulfilled\", reason: 2}]\r\n}).catch(err => console.log(err));\r\n```\r\n### Promsie实现简单的延时效果\r\n```\r\nconst delay = time => new Promise(resolve => {\r\n  setTimeout(resolve, time)\r\n})\r\ndelay(3000).then(() => {\r\n  console.log(\"三秒以后执行\")\r\n})\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## promiseAll控制并发\r\n> 比如有几百个存储操作，不能要一次性去全部执行，而是要控制一次性只能执行10个操作，10个中有一个执行完了，就拿还没执行的操作补上去，就这样一直到这几百个操作全部执行完为止。减少服务器的并发压力\r\n\r\n- 从第1个异步操作开始，初始化promise对象，同时用一个executing数组保存正在执行的promise。\r\n- 不断初始化promise，直到达到poolLimt。\r\n- 使用Promise.race，获得executing中promise的执行情况，当有一个promise执行完毕，继续初始化promise并放入executing中。\r\n- 所有异步操作都执行了，调用Promise.all返回。\r\n```\r\nfunction asyncPool(poolLimit, array, iteratorFn) {\r\n  let i = 0;\r\n  const ret = [];\r\n  const executing = [];\r\n  const enqueue = function () {\r\n    // 当所有的异步都处理之后返回一个resolve状态的promise\r\n    if (i === array.length) {\r\n      return Promise.resolve();\r\n    }\r\n    // 每调一次enqueue，初始化一个promise\r\n    const item = array[i++];\r\n    const p = new Promise(resolve => resolve(iteratorFn(item)))\r\n    // 将当前的promise放入最终结果的数组中\r\n    ret.push(p);\r\n    // promise执行完毕，从executing数组中删除\r\n    const e = p.then(() => executing.splice(executing.indexOf(e), 1));\r\n    // 正在执行的promise插入executing数组，用于表示正在执行的数据\r\n    executing.push(e);\r\n    let r = Promise.resolve();\r\n    // 默认Promise状态为resolve，每当executing数组中promise数量大于等于poolLimit，使用Promise.race判断进行中的promise是否有完成的实例从而判断是否要实例化新的promise并执行\r\n    if (executing.length >= poolLimit) {\r\n      r = Promise.race(executing);\r\n    }\r\n    // 递归，直到遍历完array\r\n    return r.then(() => enqueue());\r\n  };\r\n\r\n  // 当所有的异步操作都处理之后才执行Promise.all\r\n  return enqueue().then(() => Promise.all(ret));\r\n}\r\n\r\n// 使用\r\nconst timeout = i => new Promise(resolve => setTimeout(() => resolve(i), i));\r\nasyncPool(2, [1000, 5000, 3000, 2000], timeout).then(results => {\r\n  console.log(results);\r\n});\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## setTimeout和setInterval\r\n### setTimeout\r\n> 在指定的毫秒数后执行指定代码(只执行一次)。\r\n\r\n```\r\n// 使用setTimeout模拟setInterval\r\nfunction tick() {\r\n  doStuff();\r\n  setTimeout(tick, 100);\r\n} \r\ntick();\r\n```\r\n### setInterval\r\n> 间隔指定的毫秒数不停地执行指定的代码（一直执行）。\r\n\r\n```\r\nfunction doStuff(){ \r\n  // 此处为需要执行一段时间T的代码\r\n} \r\nsetInterVal(doStuff, 100);\r\n```\r\n### 两种setInterval区别\r\n![setTimeout和setInterval](./img/setTimeout和setInterval.png)\r\n> setInterval每个定时器之间的间隔是100ms，而setTimeout每隔100ms执行一次doStuff，所以每个定时器之间的间隔是100 + T(doStuff执行时间为T)；T的时间不同导致的区别也不同。\r\n\r\n- 如果T可以忽略的话，两者的效果是基本相同的。\r\n- T <= 100时， setTimeout定时器间隔100+T，setInterval定时器间隔100。\r\n- T > 100时，setTimeout定时器间隔100+T，setInterval在第一次执行后定时器间隔为执行函数的时间。假设T为140ms。在0ms时，定时器1开始进入宏任务队列；100ms时，定时器1开始执行doStuff1，队列为空，定时器2进入队列；200ms时，因为定时器2(doStuff1还没执行完)在队列中，所以定时器3被跳过。**浏览器不会同时创建两个相同的间隔计时器**。300ms时，定时器2已经开始执行，队列为空，定时器4进入队列。以此类推。\r\n\r\n### setInterval效果总结\r\n- setInterval是在特定时间点将代码推入队列，如果已有定时器在队列中，则会跳过。**浏览器不会同时创建两个相同的间隔计时器**。\r\n- setInterval设置定时时间小于函数体内的执行时间时候，在第一次执行后定时器间隔为执行函数的时间。\r\n- setInterval中的异步代码不会阻塞创建新的定时器。定时器中的同步代码会直接进入队列，异步代码注册事件，当异步代码注册事件后，这个定时器就执行完了，并不是等异步代码回来后这个定时器才算结束。\r\n\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## this\r\n> this在javascript中十分常用且重要。\r\n\r\n### this的作用\r\n> 提供了一个便捷的方式传递一个隐式的引用让代码变得更加简洁同时也会让代码更好的复用。\r\n\r\n### this的指向\r\n#### 普通函数的this指向\r\n> 谁调用函数，this指向谁。\r\n\r\n- 全局调用\r\n```\r\nfunction test() {\r\n const name = \"dyx\";\r\n console.log(this.name);\r\n console.log(this);\r\n}\r\ntest(); // undefined，window。this指向调用它的那个对象，在这里相当于window.test()；所以this指向window。\r\n```\r\n- 对象的方法形式调用\r\n```\r\nconst obj = {\r\n  name: \"dyx\",\r\n  test: function() {\r\n    console.log(this.name);\r\n    console.log(this);\r\n  }\r\n}\r\nobj.test(); // dyx，obj。此时this指向的是调用函数的对象obj。\r\nconst fn = obj.test;\r\nfn(); // undefined，window。此时test的调用相当于全局调用所以this指向window。\r\n```\r\n- 深层次对象的方法调用\r\n```\r\nconst obj = {\r\n  name: \"dyx\",\r\n  innerObj: {\r\n    test: function() {\r\n      console.log(this.name);\r\n    }\r\n  },\r\n  test1: function() {\r\n    console.log(this.name);\r\n  }\r\n}\r\nobj.test1(); // dyx\r\nobj.innerObj.test(); // undefined，调用函数的对象为innerObj，在该作用域中找不到声明的name变量。\r\n```\r\n- 特殊形式\r\n```\r\nlet len = 10;\r\nfunction fn() {\r\n  console.log(this.len);\r\n}\r\nfn(); // undefined，let不会在window上添加属性。\r\n\r\nlet person = {\r\n  len: 5,\r\n  say: function() {\r\n    fn();\r\n  }\r\n}\r\nperson.say(); // undefined，调用fn的this还是指向window。\r\n```\r\n#### 构造函数的this指向\r\n> 构造函数有return的内容this指向return的内容。没有return指向new出来的新对象。\r\n\r\n- 构造函数有return的形式\r\n```\r\nfunction Test() { \r\n  this.name = 'dyx';\r\n  return {}; \r\n}\r\nvar obj = new Test(); // {}\r\nconsole.log(obj.name); // undefined，这里的this指向的是return返回的对象，是一个空对象，并没有name变量。\r\n```\r\n- 构造函数没有return的形式\r\n```\r\nfunction Test() { \r\n  this.name = 'dyx';\r\n}\r\nvar obj = new Test(); // { name: 'dyx' }\r\nconsole.log(obj.name); // dyx，这里的this指向的是new出来的新对象。\r\n```\r\n#### DOM事件绑定\r\n> onclick和addEventerListener中this默认指向绑定事件的元素。IE比较奇怪使用attachEvent里面的this默认指向window。\r\n\r\n#### 箭头函数this的指向\r\n> 箭头函数没有自己的this，如果箭头函数外层有函数，外层函数的this就是内部箭头函数的this，否则this就是window。箭头函数的this指向该函数定义时的作用域，而非指向调用函数的对象。\r\n\r\n```\r\n// 当我们创建对象的时候，是在全局作用域下创建的，而对象中的方法也是这时候创建的，所以这时候的this是指向全局的，而我们在fn2里面创建的对象，这个对象的方法的this就指向他被创建时的词法作用域obj了。\r\nvar str = 'window';   \r\nconst obj = {    \r\n  str: 'obj',    \r\n  fn: () => console.log(this.str),   \r\n  fn2: function() {\t\r\n    console.log(this.str);\r\n    return { \r\n      str: 'newObj',\t    \r\n      fn: () => console.log(this.str)\r\n    }\r\n  },  \r\n}\r\n \r\nobj.fn(); // window\r\n \r\nvar newObj = obj.fn2(); // obj\r\nnewObj.fn(); // obj\r\n```\r\n### 改变函数this的指向\r\n> call、apply、bind方法都可以改变this指向, this指向传入的第一个参数。bind方法改变后的函数想什么时候调用就什么时候调用，执行bind之后返回的是一个函数，bind方法也可以接收多个参数，并且参数可以执行的时候再次添加，但是要注意的是，参数是按照形参的顺序进行的，call和apply都是改变指向后立即调用此方法。apply的使用同call不同的是传入的参数需要是数组形式或者类数组形式。\r\n\r\n- bind\r\n> 改变之后可以自定义函数何时调用，bind方法会创建一个函数实例，this会指向传给bind方法的第一个参数。\r\n\r\n```\r\nvar obj = {\r\n name: \"dyx\",\r\n test: function(num1, num2, num3) {\r\n   console.log(this); // obj1\r\n   console.log(this.name); // douyaxing\r\n   console.log(num1, num2, num3); // 10 1 2\r\n }\r\n}\r\nvar obj1 = {\r\n  name: 'douyaxing'\r\n}\r\nvar fn = obj.test.bind(obj1, 10); // this将会指向obj1\r\nfn(1, 2);\r\n```\r\n- call\r\n> 方法立即执行，参数一个一个传入。\r\n\r\n```\r\nvar obj = {\r\n  name: \"dyx\",\r\n  test: function(c, d) {\r\n    console.log(this); // obj1\r\n    console.log(this.name); // douyaxing\r\n    console.log(c + d); // 3\r\n  }\r\n}\r\nvar obj1 = {\r\n  name: 'douyaxing'\r\n}\r\nvar fn = obj.test;\r\nfn.call(obj1, 1, 2); // 参数一个一个传入\r\n```\r\n- apply\r\n> 方法立即执行，传入一个数组或者类数组作为参数，可以直接使用函数的arguments对象作为参数传递。\r\n\r\n```\r\nvar obj = {\r\n  name: \"dyx\",\r\n  test: function(c, d) {\r\n    console.log(this); // obj1\r\n    console.log(this.name); // douyaxing\r\n    console.log(c + d); // 3\r\n  }\r\n}\r\nvar obj1 = {\r\n  name: 'douyaxing'\r\n}\r\nvar fn = obj.test;\r\nfn.apply(obj1, [1, 2]); // 参数以数组形式传入\r\n```\r\n### 示例\r\n- 加括号的形式\r\n```\r\nvar x = 10;\r\nvar foo = {\r\n  x: 20,\r\n  bar: function () {\r\n    var x = 30;\r\n    return this.x;\r\n  }\r\n};\r\n\r\nconsole.log(foo.bar());   // 20\r\nconsole.log((foo.bar)());  // 20\r\nconsole.log((foo.bar = foo.bar)()); // 10\r\nconsole.log((foo.bar, foo.bar)()); // 10\r\nconsole.log(foo.bar.call(window)); // 10\r\nconsole.log(foo.bar.call(foo)); // 20\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## var let const差异\r\n### var声明的变量会挂载在window上，而let和const声明的变量不会。\r\n```\r\nvar name = 'dyx';\r\nlet name1 = 'dyx1';\r\nconst name2 = 'dyx2';\r\nconsole.log(window.name);  // dyx\r\nconsole.log(window.name1); // undefined\r\nconsole.log(window.name2); // undefined\r\n```\r\n### var声明变量存在变量提升，let和const不存在变量提升。\r\n```\r\nconsole.log(name); // undefined \r\nvar name = 'dyx';\r\n\r\nconsole.log(name1); //  Cannot access 'name1' before initialization\r\nlet name1 = 'dyx1';\r\n\r\nconsole.log(name2); //  Cannot access 'name2' before initialization\r\nconst name2 = 'dyx2';\r\n```\r\n### let和const声明形成块作用域。\r\n```\r\nif (true) {\r\n  var name = 'dyx';\r\n  let name1 = 'dyx1';\r\n  const name2 = 'dyx2';\r\n}\r\nconsole.log(name); // dyx \r\nconsole.log(name1); // name1 is not defined\r\nconsole.log(name2); // name2 is not defined \r\n```\r\n### 同一作用域下let和const不能声明同名变量，而var可以。\r\n```\r\nvar name = 'dyx';\r\nvar name = 'dyx1';\r\nlet name1 = 'dyx2';\r\nlet name1 = 'dyx3'; // name1 has already been declared\r\nconst name2 = 'dyx4';\r\nconst name2 = 'dyx5'; // name2 has already been declared\r\n```\r\n### 暂时性死区。\r\n```\r\nvar name = 'dyx';\r\n\r\nif (true) {\r\n  // let创建的name变量创建过程被提升了，但是初始化没有提升。变量未初始化或赋值前不允许访问。\r\n  name = 'douyaxing'; // Cannot access 'name' before initialization\r\n  let name = 'dyxweb';\r\n}\r\n```\r\n### const一旦声明必须赋值，声明后不能再修改，如果声明的是复合类型数据，可以修改其属性。\r\n```\r\nconst name = 'dyx';\r\nname = 'dyx1'; // Assignment to constant variable\r\n\r\nconst info = {\r\n  name: 'dyx',\r\n}\r\ninfo.name = 'douyaxing';\r\nconsole.log(info); // { name: 'douyaxing' }\r\n```\r\n### 暂时性死区的原因\r\n- 变量的赋值可以分为三个阶段：\r\n   1. 创建变量，在内存中开辟空间。\r\n   2. 初始化变量，将变量初始化为undefined。\r\n   3. 真正赋值。\r\n- let 的「创建」过程被提升了，但是初始化没有提升。存在暂时死区，在变量未初始化或赋值前不允许访问。\r\n- var 的「创建」和「初始化」都被提升了。\r\n- function 的「创建」「初始化」和「赋值」都被提升了。"},function(r,n,e){"use strict";e.r(n),n.default="## 事件委托\r\n> 事件委托是利用了浏览器事件冒泡的机制。因为事件在冒泡过程中会上传到父节点，并且父节点可以通过事件对象获取到目标节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件，这种方式称为事件代理。\r\n\r\n```\r\n<ul id=\"parent\">\r\n  <li>1</li>\r\n  <li>2</li>\r\n  <li>3</li>\r\n  ...\r\n  <li>999</li>\r\n  <li>1000</li>\r\n</ul>\r\n\r\n<script>\r\n  let parent = document.getElementById('parent');\r\n  parent.addEventListener('click', (e) => {\r\n    // 根据e.target进行处理\r\n  })\r\n<\/script>\r\n```\r\n### 优点\r\n- 不必要为每一个子元素都绑定一个监听事件，这样减少了内存上的消耗。\r\n- 可以实现事件的动态绑定，比如说新增了一个子节点，不需要单独地为它添加一个监听事件，它所发生的事件会交给父元素中的监听函数来处理。"},function(r,n,e){"use strict";e.r(n),n.default="## [事件循环(eventLoop)](https://juejin.cn/post/6969028296893792286)\r\n> JS是单线程的，执行顺序是从上到下执行。事件循环是目前浏览器和NodeJS处理JavaScript代码的一种机制。JS的顺序执行会存在一些问题，比如当一个语句需要执行很长时间的话，如请求数据、定时器、读取文件等，后面的语句就得一直等着前面的语句执行结束后才会开始执行。所以JS将所有执行任务分为了同步任务和异步任务。每个任务都是在做两件事情，就是发起调用和得到结果。\r\n\r\n### JS是单线程的原因\r\n> 假设JS同时有两个线程，一个是操作A节点，一个是删除A节点，这时候浏览器就不知道要以哪个线程为准了。因此为了避免这类型的问题，JS从一开始就是单线程的语言。\r\n\r\n### 调用栈(执行栈)\r\n> 在JavaScript运行的时候，主线程会形成一个栈，这个栈被称为调用栈或者执行栈。具有后进先出的特性。调用栈内存放的是代码执行期间的所有执行上下文。(浏览器报错的调用栈是从下向上执行的)。\r\n\r\n- 每调用一个函数，解释器就会把该函数的执行上下文添加到调用栈并开始执行。\r\n- 正在调用栈中执行的函数，如果还调用了其他函数，那么新函数也会被添加到调用栈，并立即执行。\r\n- 当前函数执行完毕后，解释器会将其执行上下文清除调用栈，继续执行剩余执行上下文中的剩余代码。\r\n- 当分配的调用栈空间被占满，会引发“堆栈溢出”的报错。\r\n### 同步任务\r\n> 同步任务发起调用后，很快就可以得到结果。同步任务的执行会按照代码顺序调用，进入调用栈中并执行，执行结束后从调用栈移除。\r\n\r\n### 异步任务\r\n> 异步任务是无法立即得到结果，比如请求接口、定时器。异步任务的执行，首先它依旧会进入调用栈中，然后发起调用，然后解释器会将其回调任务放入一个任务队列，紧接着调用栈会将这个任务移除。当主线程清空后，即所有同步任务结束后(也就是setTimeout时间有延误的原因，当同步任务十分耗时的时候，setTimeout并不能及时执行)，解释器会读取任务队列，并依次将已完成的异步任务加入调用栈中并执行。\r\n\r\n### 异步任务回调进入任务队列\r\n> 异步任务回调进入任务队列，其实会利用到浏览器的其他线程。虽然说JavaScript是单线程语言，但是浏览器不是单线程的。而不同的线程就会对不同的事件进行处理，当对应事件可以执行的时候，对应线程就会将其放入任务队列。\r\n\r\n- js引擎线程：用于解释执行js代码、用户输入、网络请求等。\r\n- GUI渲染线程：绘制用户界面，与JS主线程互斥（因为js可以操作DOM，进而会影响到GUI的渲染结果）。\r\n- http异步网络请求线程：处理用户的get、post等请求，等返回结果后将回调函数推入到任务队列。\r\n- 定时触发器线程：setInterval、setTimeout等待时间结束后，会把执行函数推入任务队列中。\r\n- 浏览器事件处理线程：将click、mouse等UI交互事件发生后，将要执行的回调函数放入到任务队列中。\r\n```\r\n// 后者的定时器会先被推进宏任务队列，而前者会在之后再被推入宏任务队列\r\nsetTimeout(() => {\r\n  console.log('a');\r\n}, 10000);\r\n\r\nsetTimeout(() => {\r\n  console.log('b');\r\n}, 100);\r\n```\r\n### 宏任务和微任务\r\n> 在任务队列中，其实还分为宏任务队列和微任务队列，对应的里面存放的就是宏任务和微任务。\r\n\r\n- macro-task(宏任务)：包括整体js代码script，setTimeout，setInterval，setImmediate，MessageChannel，I/O 操作，UI 渲染。\r\n- micro-task(微任务)：Promise的then方法，process.nextTick，MutationObserver。\r\n#### script（整体代码块）是宏任务\r\n> 如果同时存在两个script代码块，会首先执行第一个script代码块中的同步代码，如果这个过程中创建了微任务并进入了微任务队列，第一个script同步代码执行完之后，会首先去清空微任务队列，再去开启第二个script代码块的执行。所以就可以理解script（整体代码块）是宏任务。\r\n\r\n#### [Promise.then微任务的注册和执行过程](https://juejin.cn/post/6844903987183894535)\r\n1. .then的执行顺序是先注册的先执行, .then的注册微任务队列和执行是分离的, .then对应的同步代码执行完之后则开始注册.then。\r\n2. .then的链式调用的注册时机是依赖前一个.then的执行完成的, 而非链式的调用的注册时机则是同步注册。\r\n### 事件循环流程\r\n1. 从宏任务队列中，按照入队顺序，找到第一个执行的宏任务，放入调用栈，开始执行。\r\n2. 执行完该宏任务下所有同步任务后，即调用栈清空后，该宏任务被推出宏任务队列，然后微任务队列开始按照入队顺序，依次执行其中的微任务，直至微任务队列清空为止。\r\n3. 当微任务队列清空后，一个事件循环结束。\r\n4. 接着从宏任务队列中，找到下一个执行的宏任务，开始第二次事件循环，直至宏任务队列清空为止。\r\n### 事件循环注意点\r\n- 第一次执行的时候，解释器会将整体代码script放入宏任务队列中，因此事件循环是从script这个宏任务开始的。\r\n- 一次事件循环中，宏任务永远在微任务之前执行。完成一个宏任务后，执行余下的所有微任务。\r\n- 微任务按放入队列的顺序执行，先放入的先执行，如果在执行微任务的过程中，产生新的微任务添加到微任务队列中，也需要一起清空；微任务队列没清空之前，是不会执行下一个宏任务的。\r\n### 页面渲染响应\r\n- 当一次事件循环结束后，即一个宏任务执行完成后以及微任务队列被清空后，浏览器就会进行一次页面更新渲染。\r\n\r\n```\r\n<body>\r\n  <div id=\"demo\"></div>\r\n</body>\r\n<script>\r\n  // innerText时并不会直接更新渲染当promise的then执行完alert('开始渲染！')，一次事件循环结束才会更新渲染。\r\n  const demoEl = document.getElementById('demo');\r\n  console.log('a');\r\n  setTimeout(() => {\r\n    alert('渲染完成！')\r\n    console.log('b');\r\n  }, 0)\r\n  new Promise(resolve => {\r\n    console.log('c');\r\n    resolve()\r\n  }).then(() => {\r\n    console.log('d');\r\n    alert('开始渲染！')\r\n  })\r\n  console.log('e');\r\n  demoEl.innerText = 'Hello World!';\r\n<\/script>\r\n```\r\n- 页面不再响应\r\n```\r\n// 一直在执行微任务\r\nfunction foo() {\r\n return Promise.resolve().then(foo);\r\n};\r\n```\r\n### promise.then + setTimeout\r\n- 第一轮事件循环执行script宏任务。\r\n  - setTimeout会作为第二轮的宏任务执行。\r\n  - 打印promise，promise的then方法会作为第一轮的微任务执行。\r\n  - 打印console。\r\n  - 执行第一轮的微任务打印then。\r\n- 执行第二轮的宏任务打印setTimeout。\r\n```\r\nsetTimeout(() => {\r\n  console.log('setTimeout');\r\n}, 0);\r\nnew Promise(resolve => {\r\n  console.log('promise');\r\n  resolve('dyx');\r\n}).then(res => {\r\n  console.log('then');\r\n})\r\n\r\nconsole.log('console');\r\n\r\n// 执行结果\r\n- promise\r\n- console\r\n- then\r\n- setTimeout\r\n```\r\n- 第一轮事件循环执行script宏任务。\r\n  - promise的then方法作为第一轮的微任务执行。\r\n  - setTimeout1会作为第二轮事件循环的宏任务。\r\n  - 然后执行第一轮的微任务打印promise1，然后将setTimeout2作为第三轮事件循环的宏任务（每一次事件循环只能执行一个宏任务）。\r\n- 执行第二轮的宏任务，打印setTimeout1。\r\n  - 此时将promise2作为第二轮的微任务执行，所以打印promise2。\r\n- 然后执行第三轮宏任务打印setTimeout2。\r\n\r\n```\r\nPromise.resolve().then(() => {\r\n  console.log('promise1');\r\n  setTimeout(() => {\r\n    console.log('setTimeout2');\r\n  }, 0);\r\n})\r\nsetTimeout(() => {\r\n  console.log('setTimeout1');\r\n  Promise.resolve().then(() => {\r\n    console.log('promise2');\r\n  });\r\n}, 0);\r\n\r\n// 执行结果\r\n- promise1\r\n- setTimeout1\r\n- promise2\r\n- setTimeout2\r\n```\r\n- 第一次事件循环\r\n  - 1\r\n  - 6\r\n  - 8\r\n  - 10\r\n  - 7 // 微任务\r\n- 第二次事件循环\r\n  - 2\r\n  - 3\r\n  - 5\r\n  - 4 // 微任务\r\n- 第三次事件循环\r\n  - 9\r\n```\r\nconsole.log(1);\r\n\r\nsetTimeout(() => {\r\n  console.log(2);\r\n  new Promise(resolve => {\r\n    console.log(3);\r\n    resolve(4);\r\n    console.log(5);\r\n  }).then(res => {\r\n    console.log(res);\r\n  });\r\n}, 0);\r\n\r\nnew Promise(resolve => {\r\n  console.log(6);\r\n  resolve(7);\r\n  console.log(8);\r\n}).then(res => {\r\n  console.log(res);\r\n});\r\n\r\nsetTimeout(() => {\r\n  console.log(9);\r\n}, 0);\r\nconsole.log(10);\r\n```\r\n### [async函数执行](https://juejin.cn/post/7194744938276323384)\r\n#### async函数返回值\r\n- async函数在抛出返回值时，会根据返回值类型开启不同数目的微任务。\r\n  - return结果值：非thenable、非promise（不等待）。\r\n  - return结果值：thenable（等待 1个then的时间）。\r\n  - return结果值：promise（等待 2个then的时间）。\r\n- await右值类型区别\r\n  - 接非thenable类型，会立即向微任务队列添加一个微任务then，但不需等待。\r\n  - 接thenable类型，需要等待一个then的时间之后执行。\r\n  - 接Promise类型(有确定的返回值)，会立即向微任务队列添加一个微任务then，但不需等待。（TC39对await后面是promise的情况如何处理进行了一次修改，移除了额外的两个微任务，在早期版本，依然会等待两个then的时间）。\r\n#### 例子\r\n- 类型一\r\n```\r\nconst test = () => {\r\n console.log(\"test\");\r\n return \"testFunReturn\";\r\n}\r\nconst testAsync = async() => {\r\n console.log(\"testAsync\");\r\n return Promise.resolve(\"testAsyncFunReturn\");\r\n}\r\n\r\nconst run = async() => {\r\n console.log(\"run\");\r\n const result1 = await test();\r\n console.log(result1);\r\n const result2 = await testAsync();\r\n console.log(result2);\r\n console.log(result1, result2);\r\n}\r\nrun();\r\nconst promise = new Promise(resolve => {\r\n  console.log(\"promise\");\r\n  resolve(\"promise end\");\r\n})\r\npromise.then(res => console.log(res));\r\nconsole.log(\"end\")\r\n\r\n// 执行结果\r\n- run\r\n- test\r\n- promise\r\n- end\r\n- testFunReturn\r\n- testAsync\r\n- promise end\r\n- testAsyncFunReturn\r\n- testFunReturn, testAsyncFunReturn\r\n```\r\n- 类型2\r\n```\r\n// 将test方法加async\r\nconst test = async() => {\r\n console.log(\"test\");\r\n return \"testFunReturn\";\r\n}\r\nconst testAsync = async() => {\r\n console.log(\"testAsync\");\r\n return Promise.resolve(\"testAsyncFunReturn\");\r\n}\r\n\r\nconst run = async() => {\r\n console.log(\"run\");\r\n const result1 = await test();\r\n console.log(result1);\r\n const result2 = await testAsync();\r\n console.log(result2);\r\n console.log(result1, result2);\r\n}\r\nrun();\r\nconst promise = new Promise(resolve => {\r\n  console.log(\"promise\");\r\n  resolve(\"promise end\");\r\n})\r\npromise.then(res=> console.log(res));\r\nconsole.log(\"end\")\r\n\r\n// 执行结果\r\n- run\r\n- test\r\n- promise\r\n- end\r\n- promise end\r\n- testFunReturn\r\n- testAsync\r\n- testAsyncFunReturn\r\n- testFunReturn, testAsyncFunReturn\r\n```\r\n- 类型3\r\n```\r\nconst asyncTestOne = async() => {\r\n  console.log('asyncOne start')\r\n  await asyncTestTwo()\r\n  console.log('asyncOne end')\r\n}\r\n\r\nconst asyncTestTwo = async() => {\r\n  console.log('asyncTwo start')\r\n}\r\n\r\nconsole.log('start');\r\n\r\nsetTimeout(() => {\r\n  console.log('setTimeout') \r\n}, 0)\r\n\r\nasyncTestOne();\r\n\r\nnew Promise(resolve => {\r\n  console.log('promise')\r\n  resolve('promiseResult');\r\n}).then((res) => {\r\n  console.log(res)\r\n})\r\n\r\nconsole.log('end')\r\n\r\n// 执行结果\r\n- start\r\n- asyncOne start\r\n- asyncTwo start\r\n- promise\r\n- end\r\n- promiseResult\r\n- asyncOne end\r\n- setTimeout\r\n```\r\n### node和浏览器的事件循环差异\r\n- 浏览器环境下，微任务会在宏任务之后执行。而在Node.js中，微任务会在事件循环的各个阶段之间执行，也就是一个阶段执行完毕，就会去执行微任务队列的任务。\r\n- node端的setTimeout/setInterval的宏任务有多个时会一次执行完所有的宏任务，然后再去执行微任务，并不会一次事件循环只执行一个宏任务。\r\n```\r\nconsole.log('start');\r\n\r\nsetTimeout(() => {\r\n  console.log('timer1');\r\n  Promise.resolve().then(function() {\r\n    console.log('promise1');\r\n  })\r\n}, 0);\r\n\r\nsetTimeout(() => {\r\n  console.log('timer2');\r\n  Promise.resolve().then(function() {\r\n    console.log('promise2');\r\n  })\r\n}, 0);\r\n\r\nPromise.resolve().then(function() {\r\n  console.log('promise3');\r\n})\r\nconsole.log('end');\r\n\r\n// node端执行结果\r\n1. start\r\n2. end\r\n3. promise3\r\n4. timer1\r\n5. timer2\r\n6. promise1\r\n7. promise2\r\n\r\n// 浏览器端执行结果\r\n1. start\r\n2. end\r\n3. promise3\r\n4. timer1\r\n5. promise1\r\n6. timer2\r\n7. promise2\r\n```\r\n\r\n\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## 作用域\r\n> 作用域决定了代码区块中变量和其他资源的可被访问性，作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。ES6 之前 JavaScript 没有块级作用域,只有全局作用域和函数作用域。\r\n\r\n```\r\nconsole.log(total); // undefined\r\nvar total = 0;\r\nfunction func(num1, num2) {\r\n  console.log(total); // undefined\r\n  var total = num1 + num2;\r\n  console.log(total); // 300\r\n}\r\nfunc(100 , 200);\r\nconsole.log(total); // 0\r\n// 局部的与全局的同名变量互不干扰，如果不使用var会去全局中查找该变量，如果存在即使用全局的该变量，若不存在相当于给window增加了一个属性名total，属性值是100,不会有预解析。\r\n```\r\n### 全局作用域\r\n> 块语句（大括号“｛｝”中间的语句），如 if 和 switch 条件语句或 for 和 while 循环语句，不像函数，它们不会创建一个新的作用域。\r\n\r\n- 最外层函数 和在最外层函数外面定义的变量拥有全局作用域。\r\n- 所有末定义直接赋值的变量自动声明为拥有全局作用域。\r\n- 所有window对象的属性拥有全局作用域\r\n\r\n### 函数作用域\r\n> 函数作用域,是指声明在函数内部的变量和函数的形参，和全局作用域相反，局部作用域一般只在固定的代码片段内可访问到，一般为函数内部。\r\n\r\n### 块级作用域\r\n> 使用let或const声明\r\n\r\n- 在一个函数内部\r\n- 在一个代码块（由一对花括号包裹）内部\r\n\r\n### 作用域链\r\n> 在函数作用域中，代码执行的时候，遇到了一个变量，首先需要确定它是否为私有变量，如果是私有变量，那么和外面的任何东西都没有关系，如果不是私有的，则往当前作用域的父级作用域（创建该函数的那个父级作用域）进行查找，如果父级作用域也没有则继续查找，一直查找到window为止，如果没有找到即报错 not defined，这就是作用域链。\r\n\r\n### 作用域现象\r\n```\r\n// 使用var定义的变量 i 虽然是在 for 循环代码块中被定义，但在代码块外仍可以访问 i, 属于全局作用域。定时器中的匿名函数也是执行在全局作用域中，所以每次都输出11了。\r\nfor (var i = 1; i <= 10; i++) {\r\n  setTimeout(() => {\r\n\t\tconsole.log(i);\r\n\t}, 1000);\r\n} // 输出10次11，因为setTimeout中的匿名函数执行的时候，for循环都已经结束了，此时i为11。\r\n\r\n// 让i在每次迭代的时候，都产生一个私有的作用域，在这个私有的作用域中保存当前i的值。\r\nfor (var i = 1; i <= 10; i++) {\r\n\t(function () {\r\n\t\tconst j = i;\r\n\t\tsetTimeout(function () {\r\n\t\t\tconsole.log(j);\r\n\t\t}, 1000);\r\n\t})();\r\n}\r\n\r\nfor (var i = 1; i <= 10; i++) {\r\n\t(function (j) {\r\n\t\tsetTimeout(function () {\r\n\t\t\tconsole.log(j);\r\n\t\t}, 1000);\r\n\t})(i);\r\n}\r\n\r\n// 使用es6的let const形成块级作用域。\r\nfor (let i = 1; i <= 10; i++) {\r\n  setTimeout(() => {\r\n\t\tconsole.log(i);\r\n\t}, 1000);\r\n}\r\n```\r\n### 易错现象\r\n```\r\n// 输出10个10，因为在createFun函数中返回的result的数组中是一些函数，这些函数并没有立即调用，而是在循环结束之后才调用的所以结果是10个10;\r\nfunction createFun() {\r\n var result = new Array();\r\n for (var i = 0; i < 10; i++) {\r\n   result[i] = function(){\r\n     return i;\r\n   };\r\n }\r\n return result;\r\n}\r\nvar fun = createFun();\r\nfor (var i = 0; i < fun.length; i++){\r\n console.log(fun[i]());\r\n}\r\n```\r\n\r\n```\r\n// test函数与a变量都属于全局作用域下，test2中声明的a变量属于函数作用域。\r\nvar a = 'dyx';\r\nvar test = function() {\r\n  console.log(a) // dyx\r\n}\r\nfunction test2(){\r\n  var a = null;\r\n  test();\r\n}\r\ntest2();\r\n```\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## 内存泄漏和垃圾回收机制\r\n### 内存生命周期\r\n> JavaScript是一种高级的解释执行的编程语言，是一种属于网络的高级脚本语言。所有语言第二部分都是明确的，第一和第三部分在底层语言中是明确的。但在像 JavaScript这些高级语言中，大部分都是隐含的。\r\n\r\n1. 分配你所需要的内存\r\n2. 使用分配到的内存（读、写）\r\n3. 不需要时将其释放\\归还\r\n### 内存泄漏\r\n> 程序的运行需要内存，只要程序提出要求，操作系统或者运行时（runtime）就必须供给内存。对于持续运行的服务进程，必须及时释放不再用到的内存。否则内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。不再用到的内存没有及时释放，就叫做内存泄漏（memory leak）。\r\n\r\n### 常见的内存泄漏\r\n- 减少全局变量的使用\r\n> 全局变量会一直存在于内存中，直到应用程序退出。\r\n\r\n- 意外声明的全局变量\r\n> 解释器会把变量name当作window的属性来创建（相当于window.name = 'dyx'）。在window对象上创建的属性，只要window本身不被清理就不会消失。这个问题很容易解决，只要在变量声明前头加上var、let 或 const 关键字即可，这样变量就会在函数执行完毕后离开作用域。\r\n\r\n```\r\nfunction setName() {\r\n  name = 'dyx';\r\n}\r\n```\r\n- 被遗忘的定时器\r\n> 只要定时器一直运行，回调函数中引用的name变量就不会被清理，就会一直占用内存。\r\n\r\n```\r\nlet name = 'dyx'; \r\nsetInterval(() => {\r\n  console.log(name); \r\n}, 100);\r\n```\r\n- 使用不当的闭包\r\n> 这会导致分配给name的内存被泄漏。以下代码创建了一个内部闭包，只要outer函数存在就不能清理name，因为闭包一直在引用着它。假如name的内容很大（不止是一个小字符串），那可能就是个大问题了。\r\n\r\n```\r\nlet outer = function() { \r\n  let name = 'dyx'; \r\n  return function() { \r\n    return name; \r\n  }; \r\n};\r\n\r\nlet closure = outer();\r\n// 当不再需要闭包时，解除对闭包的引用\r\nclosure = null;\r\n```\r\n- 未清理的DOM引用\r\n> DOM元素的生命周期正常情况下取决于是否挂载在DOM树上，当元素从DOM树上移除时，就可以被销毁回收了。但如果某个DOM元素在JS中也持有它的引用，想要彻底删除这个元素，就需要把两个引用都清除，这样才能正常回收它。\r\n\r\n```\r\n// 在对象中引用 DOM\r\nvar elements = {\r\n  btn: document.getElementById('btn'),\r\n}\r\nfunction doSomeThing() {\r\n  elements.btn.click()\r\n}\r\n\r\nfunction removeBtn() {\r\n  // 移除 DOM 树中的 btn\r\n  document.body.removeChild(document.getElementById('btn'));\r\n  // 但是此时全局变量elements还是保留了对btn的引用，btn还是存在于内存中，不能被回收，需要释放js对于节点的引用elements.btn = null;\r\n}\r\n```\r\n- 使用弱引用\r\n> 在ES6中引入了WeakMap和WeakSet这两个数据结构，它们可以帮助避免内存泄漏。这些数据结构使用弱引用，当对象没有其他引用时，垃圾回收机制会自动释放它们占用的内存。使用WeakMap和WeakSet可以减少手动清除引用的工作量。\r\n\r\n```\r\nlet weakMap = new WeakMap();\r\nlet key = {};\r\n\r\n// 使用弱引用方式设置键值对\r\nweakMap.set(key, \"value\");\r\n\r\n// 当不再需要key对象时它会被自动回收，WeakMap中的键值对也会被清除\r\nkey = null;\r\n```\r\n### 垃圾回收机制\r\n> JavaScript在创建变量（对象，字符串等）时自动进行了内存分配，并且在不使用它们时“自动”释放，释放的过程称为垃圾回收。垃圾回收机制会定期（周期性）找出那些不再用到的内存（变量）然后释放其内存，JavaScript的运行环境极大地依赖于垃圾回收机制。\r\n\r\n### 内存空间\r\n> JavaScript的内存空间分为栈（Stack）和堆（Heap）两部分。栈用于存储原始类型（如Number，String，Boolean，Null，Undefined，Symbol）和引用对象的内存地址，而堆用于存储引用类型的对象。\r\n\r\n### 栈回收\r\n> 函数调用的参数、返回地址和局部变量都存储在调用栈中。每当一个函数被调用时，都会创建一个新的栈帧，其中包含这些信息。而栈帧的回收则非常直接：一旦函数调用结束，其栈帧就会被立即移除。这种机制依赖于ESP（Extended Stack Pointer）指针，该指针始终指向栈的顶部，用于追踪哪些栈帧是活动的，哪些可以被安全回收。\r\n\r\n```\r\nfunction getName() {\r\n  let a = 1\r\n  let b = {\r\n    name: 'Hello World'\r\n  }\r\n  function foo() {\r\n    let c = 2\r\n    let d = {\r\n      name: 'Hello Javascript'\r\n    }\r\n  }\r\n  foo()\r\n}\r\ngetName()\r\n```\r\n### 堆回收\r\n> 与栈回收机制相比，堆回收要复杂得多。所有的对象实例都存储在堆中。这些对象的生命周期不像栈帧那样简单明了，因此需要更复杂的机制来确定何时可以安全回收这些对象的内存。主要采用标记清除算法进行垃圾回收。该算法分为两个步骤：标记阶段，V8引擎会遍历所有的对象，标记活动对象和非活动对象；清除阶段，非活动对象所占用的内存将被回收。\r\n\r\n```\r\nfunction createObject() {\r\n  let obj = new Object();\r\n  obj.value = 'Hello, World!';\r\n  return obj;\r\n}\r\n\r\nlet myObject = createObject();  // 创建对象，分配内存\r\nmyObject = null;  // 丢弃对象，垃圾回收器现在可以回收这个对象的内存\r\n```\r\n### 标记清除（常用的方法）\r\n> 垃圾回收机制在运行的时候会给存储在内存中的所有变量都加上标记（可以是任何标记方式），然后它会去掉处在环境中的变量及被环境中的变量引用的变量的标记（闭包）。而在此之后剩下的带有标记的变量被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后垃圾回收机制到下一个周期运行时，将释放这些变量的内存，回收它们所占用的空间。\r\n\r\n### 引用计数\r\n> 语言引擎有一张\"引用表\"，保存了内存里面所有资源（通常是各种值）的引用次数。如果一个值的引用次数是0，就表示这个值不再用到了，因此可以将这块内存释放。循环使用会有内存无法释放的情况。"},function(r,n,e){"use strict";e.r(n),n.default="## 前端模块化\r\n> 实现“模块”功能的奥妙就在于JavaScript是一种函数式编程语言，它支持闭包。如果我们把一段JavaScript代码用一个函数包装起来，这段代码的所有“全局”变量就变成了函数内部的局部变量。ES6模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS和AMD模块，属于运行时加载，都只能在运行时确定这些东西。\r\n\r\n### 没有模块化时的使用\r\n> 通过`<script>`标签引入各个文件，把每个文件看成是一个模块，每个模块的接口通常是暴露在全局作用域下的，也就是定义在window对象中。通过这种方式做模块化，当项目变得越来越大时，很容易造成全局变量冲突，项目也会变得越来越难以管理。\r\n\r\n```\r\n<script src=\"module1.js\"><\/script>\r\n<script src=\"module2.js\"><\/script>\r\n<script src=\"module3.js\"><\/script>\r\n```\r\n### 为什么需要模块化\r\n> 模块化的开发方式可以提供代码复用率，方便进行代码的管理。一个模块有自己的作用域，只向外暴露特定的变量和函数。有了模块，我们就可以更方便地使用别人的代码，想要什么功能，就加载什么模块。\r\n\r\n- 减少全局变量污染\r\n- 控制依赖\r\n- 增强代码的可维护性\r\n- 增加代码的复用性\r\n### CommonJS\r\n> Node.js是commonJS规范的主要实践者，使用module.exports定义当前模块对外输出的接口（不推荐直接用exports），用require加载模块。\r\n\r\n```\r\n// a.js\r\nconst name = 'Bob'\r\nfunction sayHello(name) {\r\n console.log(`Hello ${name}`)\r\n}\r\nmodule.exports.name = name\r\nmodule.exports.sayHello = sayHello\r\n\r\n// b.js\r\nconst a = require('./a')\r\nconst name = a.name\r\nconsole.log(name) // Bob\r\na.sayHello(name) // Hello Bob\r\n```\r\n#### 特点\r\n- commonJS用同步的方式加载模块。在服务端模块文件都存在本地磁盘，读取非常快，所以这样做不会有问题。但是在浏览器端，限于网络原因，更合理的方案是使用异步加载。\r\n- 加载时执行，即脚本代码在require的时候，就会全部执行。\r\n#### module.exports和exports的区别\r\n> module.exports可以直接赋值,module.exports = function() {}; exports不可以直接赋值，只能添加方法或者属性,exports.add = function() {} ;\r\n\r\n1. module.exports 初始值为一个空对象 {}\r\n2. exports 是指向的 module.exports 的引用\r\n3. require() 返回的是 module.exports 而不是 exports\r\n4. 两者的关系为var exports = module.exports = {}; 给exports直接赋值是无效的，因为赋值后，module.exports仍然是空对象{}，因为直接给exports赋值，会直接改变exports的指向，并不会改变module.exports的值，而require() 返回的是 module.exports 而不是 exports，所以给exports赋值是不允许的。但是由于exports是module.exports的一个引用，因为引用类型的特性，以添加属性的形式改变exports的值同时module.exports的值也会改变，因为两者指向同一地址，所以require返回的内容就是修改后的内容。\r\n5. 建议使用module.exports可以避免某些问题\r\n#### commonJS是值的浅拷贝\r\n- 在模块外为简单类型赋值\r\n```\r\n// a.js\r\nlet val = 1;\r\nconst setVal = (newVal) => {\r\n  val = newVal;\r\n}\r\nmodule.exports = {\r\n  val,\r\n  setVal\r\n}\r\n\r\n// b.js\r\nconst { val, setVal } = require('./a.js');\r\nconsole.log(val); // 1\r\nsetVal(101);\r\nconsole.log(val); // 1\r\n```\r\n- 在模块外为引用类型赋值\r\n```\r\n// a.js\r\nlet obj = {\r\n  val: 1\r\n};\r\nconst setVal = (newVal) => {\r\n  obj.val = newVal;\r\n}\r\nmodule.exports = {\r\n  obj,\r\n  setVal\r\n}\r\n\r\n// b.js\r\nconst { obj, setVal } = require('./a.js');\r\nconsole.log(obj); // { val: 1 }\r\nsetVal(101);\r\nconsole.log(obj); // { val: 101 }\r\n```\r\n- 在模块内导出后改变简单类型\r\n```\r\n// a.js\r\nlet val = 1;\r\nsetTimeout(() => {\r\n  val = 101;\r\n}, 100);\r\nmodule.exports = {\r\n  val\r\n}\r\n\r\n// b.js\r\nconst { val } = require('./a.js')\r\nconsole.log(val); // 1\r\nsetTimeout(() => {\r\n  console.log(val); // 1\r\n}, 200)\r\n```\r\n- 在模块内导出后用 module.exports 再导出一次\r\n```\r\n// a.js\r\nsetTimeout(() => {\r\n  module.exports = {\r\n    val: 101\r\n  }\r\n}, 100);\r\nmodule.exports = {\r\n  val: 1\r\n}\r\n\r\n// b.js\r\nconst a = require('./a.js');\r\nconsole.log(a); // { val: 1 }\r\nsetTimeout(() => {\r\n  console.log(a); // { val: 1 }\r\n}, 200);\r\n```\r\n- 在模块内导出后用 exports 再导出一次\r\n```\r\n// a.js\r\nsetTimeout(() => {\r\n  module.exports.val = 101;\r\n}, 100)\r\nmodule.exports.val = 1;\r\n\r\n// b.js\r\nconst a = require('./a.js');\r\nconsole.log(a); // { val: 1 }\r\nsetTimeout(() => {\r\n  console.log(a); // { val: 101 }\r\n}, 200)\r\n```\r\n#### 值的拷贝\r\n> 其值拷贝发生在给 module.exports 赋值的那一刻。\r\n\r\n```\r\n// 做的事情仅仅是给 module.exports 赋予了一个新的对象，在这个对象里有一个key叫做val，这个val的值是当前模块中 val 的值\r\n\r\nlet val = 1;\r\nmodule.exports = {\r\n  val\r\n}\r\n```\r\n### AMD和require.js\r\n> AMD规范采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。依赖前置，能够异步加载模块, 适合在浏览器中运行, 但是不能够按需加载, 必须提前加载模块。不过require.js从2.0开始，也改成可以延迟执行（根据写法不同，处理方式不同）。\r\n\r\n```\r\nrequire([module], callback) // 导入模块\r\ndefine(id, [depends], callback) // 导出模块\r\n\r\n// 新建 a.js, 输入以下内容\r\ndefine(function() {\r\n  let alertName = function(str) {\r\n    alert('I am ' + str)\r\n  }\r\n  let alertAge = function(num) {\r\n    alert('I am ' + num + ' years old')\r\n  }\r\n  return {\r\n    alertName: alertName,\r\n    alertAge: alertAge\r\n  }\r\n})\r\n\r\n// 在 test.html 中调用 a 模块\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n\t<head>\r\n\t  <meta charset=\"UTF-8\">\r\n\t  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n\t  <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\r\n\t  <title>Document</title>\r\n\t</head>\r\n\t<body>\r\n\t\t<script src=\"./require.js\"><\/script>\r\n\t\t<script>\r\n\t\t\trequire(['a'], function (alert) {\r\n\t\t\t\talert.alertName('JohnZhu')\r\n\t\t\t\talert.alertAge(21)\r\n\t\t\t})\r\n\t\t<\/script>\r\n\t</body>\r\n</html>\r\n```\r\n### CMD和sea.js 实现。实现了按需加载。\r\n> CMD是另一种js模块化方案，它与AMD很类似，不同点在于：AMD推崇依赖前置、提前执行，CMD推崇依赖就近、延迟执行。\r\n\r\n```\r\n// 定义模块 math.js\r\ndefine(function(require, exports, module) {\r\n  var $ = require('jquery.js');\r\n  var add = function(a, b){\r\n    return a + b;\r\n  }\r\n  exports.add = add;\r\n});\r\n\r\n// 加载模块\r\nseajs.use(['math.js'], function(math) {\r\n  var sum = math.add(1, 2);\r\n});\r\n```\r\n### CMD和AMD区别\r\n> AMD 推崇依赖前置(在定义模块的时候就要声明其依赖的模块)、提前执行(AMD 在依赖模块加载完成后就直接执行依赖模块，依赖模块的执行顺序和我们书写的顺序不一定一致)，CMD推崇依赖就近(只有在用到某个模块的时候再去 require)、延迟执行(而 CMD 在依赖模块加载完成后并不执行，只是下载而已，等到所有的依赖模块都加载好后，进入回调函数逻辑，遇到 require 语句 的时候才执行对应的模块，这样模块的执行顺序就和我们书写的顺序保持一致了)。\r\n\r\n```\r\n// AMD写法\r\ndefine([\"./a\", \"./b\"], function(a, b) { \r\n  // 等于在最前面声明并初始化了要用到的所有模块\r\n  a.doSomething();\r\n\tif (false) {\r\n\t\t// 即便没用到某个模块 b，但 b 还是提前执行了\r\n\t\tb.doSomething()\r\n\t} \r\n});\r\n\r\n// CMD写法\r\ndefine(function(require, exports, module) {\r\n  var a = require('./a');\r\n  a.doSomething();\r\n  if (false) {\r\n\t\t// 在需要使用时申明\r\n\t\tvar b = require('./b');\r\n\t\tb.doSomething();\r\n  }\r\n});\r\n```\r\n### UMD\r\n> UMD是一种JavaScript通用模块定义规范，让你的模块能在JavaScript所有运行环境中发挥作用。\r\n\r\n1. 优先判断是否存在exports方法，如果存在则采用CommonJS方式加载模块。\r\n2. 其次判断是否存在define方法，如果存在则采用AMD方式加载模块。\r\n3. 最后判断global对象上是否定义了所需依赖，如果存在则直接使用，反之则抛出异常。\r\n### ES Module\r\n> ES6在语言标准的层面上，实现了模块功能，export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。export、import命令可以出现在模块的任何位置，只要处于模块顶层就可以。如果处于块级作用域内，就会报错，这是因为处于条件代码块之中，就没法做静态优化了，违背了ES6模块的设计初衷。\r\n\r\n```\r\n// 导出\r\nexport function hello() {\r\n\r\n};\r\nexport default {\r\n  // ...\r\n};\r\n\r\n// 引入模块\r\nimport { readFile } from 'fs';\r\nimport React from 'react';\r\n```\r\n\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## 前端获取网络信息\r\n### 网络变化\r\n```\r\nwindow.addEventListener('offline', () => {\r\n  console.log('offline');\r\n});\r\n\r\nwindow.addEventListener('online', () => {\r\n  console.log('online');\r\n});\r\n```\r\n### 网络状态 \r\n```\r\nconst online = window.navigator.onLine; // true or false\r\n```\r\n### 网络连接状态(兼容性较低)\r\n```\r\nconst connection = navigator.connection || navigator.webkitConnection || navigator.mozConnection;\r\n```\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## 前端路由\r\n> 通过一定的机制，监听用户的行为动作，页面从而做出对应的变化。\r\n\r\n### hash模式\r\n- hash模式是不需要服务端配合的。\r\n- 通过window.location.href或window.location.replace改变路由。\r\n- 通过hashchange事件监听hash模式下路由变化，可以在监听事件的回调函数中执行展示和隐藏不同UI显示的功能，从而实现前端路由。\r\n```\r\nwindow.addEventListener('hashchange', (e) => {\r\n  /* 监听改变 */\r\n  const oldURL = e.oldURL; // 改变后旧的页面路径\r\n  const newURL = e.newURL; // 改变后新的页面路径\r\n});\r\n```\r\n### history模式\r\n- history模式下，如果跳转路由后再次刷新会得到404的错误，这个错误是浏览器会把整个地址当成一个可访问的静态资源路径进行访问，然后服务端并没有这个文件。所以一般情况下，我们都需要配置下nginx的try_files参数，当我们访问的路径资源不存在的时候，默认指向静态资源index.html。\r\n- 通过history.pushState或history.replaceState改变路由。\r\n```\r\nhistory.pushState(state, title, path);\r\nhistory.replaceState(state, title, path);\r\n```\r\n- 通过popstate事件监听history模式下路由变化，可以在监听事件的回调函数中执行展示和隐藏不同UI显示的功能，从而实现前端路由。\r\n  1. popstate事件只会在浏览器某些行为下触发, 比如点击后退、前进按钮或者调用history.back()、history.forward()、history.go()方法。\r\n  2. history.pushState()或者history.replaceState()改变路由不会触发popstate事件。\r\n```\r\nwindow.addEventListener('popstate', () => {\r\n  /* 监听改变 */\r\n});\r\n```\r\n### history.pushState()或者history.replaceState()不会触发popstate事件\r\n- 通过dispatchEvent改写这两个方法实现对这两个方法的监听。\r\n```\r\nconst _wr = (type) => {\r\n  const orig = history[type];\r\n  return function () {\r\n    const rv = orig.apply(this, arguments);\r\n    const e = new Event(type);\r\n    e.arguments = arguments;\r\n    window.dispatchEvent(e);\r\n    return rv;\r\n  }\r\n}\r\n\r\nhistory.pushState = _wr('pushState');\r\nhistory.replaceState = _wr('replaceState');\r\n\r\nwindow.addEventListener('pushState', () => {\r\n  /* 监听改变 */\r\n});\r\nwindow.addEventListener('replaceState', () => {\r\n  /* 监听改变 */\r\n});\r\n```\r\n- 调用history.pushState()或者history.replaceState()时手动触发页面内容更新。\r\n  1. 首先生成一个最新的location对象。\r\n  2. 然后通过window.history.pushState或者window.history.replaceState方法改变浏览器当前路由。\r\n  3. 最后手动触发组件更新，并传递当前最新的location对象。"},function(r,n,e){"use strict";e.r(n),n.default="## 原型原型链\r\n### 普通对象与函数对象\r\n> JavaScript中对象分为普通对象和函数对象。通过new Function()创建的对象都是函数对象，其他的都是普通对象。每个对象都有`__proto__`属性，但只有函数对象才有prototype属性。所有函数对象的`__proto__`都指向Function.prototype，它是一个空函数。所有函数对象都继承了Function.prototype的属性及方法，如length、call、apply、bind。\r\n\r\n### 原型\r\n> 每个函数都会创建一个prototype属性，这个属性是一个对象，这个对象就是通过调用构造函数创建的对象的原型。使用原型对象的好处是，在它上面定义的属性和方法都可以被实例共享。\r\n\r\n![原型](./img/原型.png)\r\n### 原型、原型对象、构造函数的关系\r\n> 每个构造函数都有一个原型对象(实例的原型)，原型有一个constructor属性指向构造函数，而实例有一个内部指针(在chrome、firefox、safari浏览器环境中这个指针就是`__proto__`)指向原型。构造函数构造出来的实例的constructor属性指向该构造函数。\r\n\r\n- 创建了一个空的构造函数Person。\r\n- 然后创建了一个Person的实例dyx，dyx本身是没有挂载任何属性和方法的，但是它有一个`__proto__`内置属性，这个属性是个对象，里面有name、age属性和getName函数。\r\n- Person.prototype和dyx的`__proto__`都指向同一个对象，这个对象对于Person构造函数而言叫做原型对象，对于dyx实例而言叫做原型。\r\n- 实例dyx的constructor属性指向Person构造函数。\r\n```\r\n// Person构造函数\r\nfunction Person() {}\r\n\r\n// 在Person的原型对象上挂载属性和方法\r\nPerson.prototype.name = 'dyx';\r\nPerson.prototype.age = 26;\r\nPerson.prototype.getName = function() {\r\n  return this.name;\r\n}\r\n\r\nconst dyx = new Person();\r\nconsole.log(dyx.name) // 'dyx'\r\nconsole.log(dyx.getName()); 'dyx'\r\n\r\nconsole.log(Person.prototype.constructor === Person); // true\r\nconsole.log(dyx.__proto__ === Person.prototype); // true\r\nconsole.log(dyx.constructor === Person); // true\r\n```\r\n### `__proto__`\r\n> JS 在创建对象（不论是普通对象还是函数对象）的时候，都有一个叫做`__proto__`的内置属性，用于指向创建它的构造函数的原型对象。例如对象dyx有一个 `__proto__`属性，创建它的构造函数是Person，构造函数的原型对象是Person.prototype，所以`dyx.__proto__ === Person.prototype`。\r\n\r\n### 原型链\r\n> 如果实例的原型是另一个构造函数的实例，于是该实例的原型本身又有一个内部指针(`__proto__`)指向另一个原型，相应的另一个原型也有一个指针指向另一个原型。这样，实例和原型之间形成了一条长长的链条，这就是原型链。所有普通的原型的`__proto__`都会指向内置的Object.prototype，而Object的原型对象的`__proto__`指向null。也就是说所有的普通对象都源于Object.prototype，它包含javascript中许多通用的功能。\r\n\r\n![原型链](./img/原型链.png)\r\n### 对象的属性和方法查找\r\n> 如果在对象上找不到需要的属性或者方法，引擎就会继续在`__proto__`指向的原型上查找，如果在后者也没有找到需要的东西，引擎就会继续查找它的`__proto__`指向的原型。\r\n\r\n1. 查找对象自己声明的。\r\n2. 去原型链上查找，在`__proto__`指向的原型上查找，如果在后者也没有找到需要的东西，引擎就会继续查找它的`__proto__`指向的原型。\r\n3. 去Object.prototype上查找(所有的普通对象都源于Object.prototype，它包含javascript中许多通用的功能)。\r\n### 原型对象值修改\r\n- prototype对象重新赋值\r\n> 实例化对象时，该对象的`__proto__`指向当前的构造函数的prototype，如果实例化后构造函数的prototype重新赋值，不会影响已经创建的实例。\r\n\r\n```\r\n// Person构造函数\r\nfunction Person() {}\r\n\r\n// 在Person的原型对象上挂载属性和方法\r\nPerson.prototype.name = 'dyx';\r\nPerson.prototype.age = 26;\r\nPerson.prototype.getName = function() {\r\n  return this.name;\r\n}\r\n\r\nconst dyx = new Person();\r\nconsole.log(dyx.name); // 'dyx'\r\nPerson.prototype = {\r\n  name: 'douyaxing'\r\n}\r\nconsole.log(dyx.name); // 'dyx'\r\n```\r\n- prototype对象修改属性值或添加属性\r\n> 原型对象的属性值被修改后，或者添加了新的属性，实例化对象的原型值也会发生变化。\r\n\r\n```\r\n// Person构造函数\r\nfunction Person() {}\r\n\r\n// 在Person的原型对象上挂载属性和方法\r\nPerson.prototype.name = 'dyx';\r\nPerson.prototype.age = 26;\r\nPerson.prototype.getName = function() {\r\n  return this.name;\r\n}\r\n\r\nconst dyx = new Person();\r\nconsole.log(dyx.name); // 'dyx'\r\nconsole.log(dyx.sex); // undefined\r\nPerson.prototype.name = 'douyaxing';\r\nPerson.prototype.sex = '男';\r\nconsole.log(dyx.name); // 'douyaxing'\r\nconsole.log(dyx.sex); // '男'\r\n```\r\n### 判断构造函数与实例关系\r\n- instanceof\r\n> instanceof操作符左侧是一个普通对象，右侧是一个函数。以dyx instanceof Person为例，instanceof关键字做的事情是判断dyx的原型链上是否有Person.prototype指向的对象。\r\n\r\n```\r\nfunction Person(name) {\r\n  this.name = name;\r\n}\r\n\r\nconst dyx = new Person('dyx');\r\nconst douyaxing = {\r\n  name: 'douyaxing'\r\n}\r\n\r\nconsole.log(dyx instanceof Person) // true\r\nconsole.log(douyaxing instanceof Person) // false\r\n```\r\n- isPrototypeOf()\r\n> isPrototypeOf()不关心构造函数，它只需要一个可以用来判断的对象就行。以Person.prototype.isPrototypeOf(dyx)为例，isPrototypeOf()做的事情是判断在dyx的原型链中是否出现过Person.prototype。\r\n\r\n```\r\nfunction Person(name) {\r\n  this.name = name;\r\n}\r\n\r\nconst dyx = new Person('dyx');\r\nconst douyaxing = {\r\n  name: 'douyaxing'\r\n}\r\n\r\nconsole.log(Person.prototype.isPrototypeOf(dyx)) // true\r\nconsole.log(Person.prototype.isPrototypeOf(douyaxing)) // false\r\n```\r\n### Object.getPrototypeOf\r\n> 获取实例对象的原型。\r\n\r\n```\r\n// Person构造函数\r\nfunction Person() {}\r\n\r\n// 在Person的原型对象上挂载属性和方法\r\nPerson.prototype.name = 'dyx';\r\nPerson.prototype.age = 26;\r\nPerson.prototype.getName = function() {\r\n  return this.name;\r\n}\r\n \r\nconst dyx = new Person();\r\nObject.getPrototypeOf(dyx) === Person.prototype  // true\r\n```\r\n\r\n### hasOwnProperty\r\n> for in循环将循环遍历对象本身以及它所委托的原型的所有可枚举属性，添加到原型的任何属性都是可枚举的(使用 in 操作符检查对象中是否含有某个属性时同理)。hasOwnProperty返回一个布尔值，表示对象是否具有指定的属性作为其自身的属性，而不是对象所委托的原型上的属性。\r\n\r\n```\r\nfunction Animal(name, energy) {\r\n  this.name = name;\r\n  this.energy = energy;\r\n}\r\nAnimal.prototype.eat = function(amount) {\r\n  console.log(`${this.name} is eating.`);\r\n  this.energy += amount;\r\n}\r\n \r\nconst leo = new Animal('Leo', 7);\r\nfor(let key in leo) {\r\n  console.log(key); // name、energy、eat\r\n}\r\n\r\nfor(let key in leo) {\r\n  if (leo.hasOwnProperty(key)) {\r\n    console.log(key); // name、energy\r\n  }\r\n}\r\n```\r\n"},function(r,n,e){"use strict";e.r(n),n.default='## 图像懒加载和预加载\r\n### 懒加载\r\n> 将img标签中设置一个data-src属性，它指向的是实际上我们需要加载的图像，而img的src指向一张默认的图片，如果为空的话也会向服务器发送请求。当用户访问可视区域的img元素时，将src得值替换为data-src指向的实际资源加载的图像。\r\n\r\n- 优点\r\n  - 用户可以更快地加载到内容，因为用户第一次打开网站时只需要加载一部分内容。\r\n  - 较低的资源成本，因为内容只在用户需要时才加载，而不是一次完成。\r\n- IntersectionObserver实现\r\n> 一种可以异步监听目标元素与其祖先或视窗(viewport)是否处于交叉状态的方式。\r\n\r\n```\r\n// 加载img\r\nfunction preloadImage(img) {\r\n  const src = img.dataset.src;\r\n  if (!src) {\r\n    return;\r\n  }\r\n  img.src = src;\r\n}\r\n\r\nconst config = {\r\n\trootMargin: \'0px\',\r\n\tthreshold: 0\r\n};\r\nconst observer = new IntersectionObserver((entries, self) => {\r\n  entries.forEach(entry => {\r\n    if (entry.isIntersecting) {\r\n\t\t\t// 加载图像\r\n\t\t\tpreloadImage(entry.target);\r\n\t\t\t// 解除观察\r\n\t\t\tself.unobserve(entry.target);\r\n    }\r\n  })\r\n}, config);\r\n\r\n// 监听所有img元素\r\nconst images = document.querySelectorAll(\'[data-src]\');\r\nimages.forEach(image => {\r\n  observer.observe(image);\r\n});\r\n```\r\n### 预加载\r\n> 将所有所需的资源提前请求加载到本地，这样后面在需要用到时就直接从缓存取资源。\r\n\r\n- 优点\r\n  - 减少用户等待时间，提升体验。\r\n- 使用HTML标签\r\n```\r\n<img src="http://pic26.nipic.com/20121213/61681830044449030002.jpg" style="display:none" />\r\n```\r\n- 使用Image对象\r\n```\r\nvar image= new Image();\r\nimage.src = "http://pic26.nipic.com/20121213/61681830044449030002.jpg";\r\n```\r\n- 使用ajax请求图片资源'},function(r,n,e){"use strict";e.r(n),n.default='## 创建对象\r\n### 工厂模式\r\n- 优点：解决了创建多个相似对象时，代码的复用问题。\r\n- 缺点：使用工厂模式创建的对象，没有解决对象识别的问题（就是怎样知道一个对象的类型是什么）。\r\n```\r\nfunction createPerson(name, age) {\r\n\tconst o = new Object();\r\n\to.name = name;\r\n\to.age = age;\r\n\to.sayName = function() {\r\n\t\talert(this.name);\r\n\t};\r\n\treturn o;\r\n}\r\n\r\nconst person1 = createPerson("dyx", 24);\r\nconst person2 = createPerson("douyaxing", 25);\r\n```\r\n### 构造函数\r\n- 优点：解决了工厂模式中对象类型无法识别的问题（实例对象中我们可以通过原型链来访问到constructor属性，从而判断对象的类型），并且创建自定义的构造函数意味着将来可以将它的实例标识为一种特定的类型。\r\n- 缺点：在使用构造函数创建对象时，每个方法都会在实例对象中重新创建一遍。这意味着每创建一个对象，我们就会创建一个sayName函数的实例，因此这样便会造成内存的浪费。\r\n```\r\nfunction CreatePerson(name, age) {\r\n\tthis.name = name;\r\n\tthis.age = age;\r\n\tthis.sayName = function() {\r\n\t\talert(this.name);\r\n\t};\r\n\treturn o;\r\n}\r\n\r\nconst person1 = new CreatePerson("dyx", 24);\r\nconst person2 = new CreatePerson("douyaxing", 25);\r\n```\r\n### 原型模式\r\n- 优点：解决了构造函数模式中多次创建相同函数对象的问题，所有的实例可以共享同一组属性和函数。\r\n- 缺点：原型模式省略了构造函数模式传递初始化参数的过程，所有的实例在默认情况下都会取得默认的属性值，会在一定程度上造成不方便。我们创建的实例一般都是要有属于自己的全部属性的，因此单独使用原型模式的情况是很少存在的。\r\n```\r\nfunction Person() {\r\n}\r\n\r\nPerson.prototype.name = "dyx";\r\nPerson.prototype.age = 24;\r\nPerson.prototype.sayName = function() {\r\n  alert(this.name);\r\n}\r\n\r\nconst person1 = new Person();\r\nperson1.sayName(); // "dyx"\r\n\r\nconst person2 = new Person();\r\nperson2.sayName(); // "dyx"\r\n\r\nconsole.log(person1.sayName === person2.sayName) // true\r\n```\r\n### 组合模式(构造函数与原型模式组合)\r\n- 优点：采用了构造函数模式和原型模式的优点，可以传递属于自己的参数，也可以共享。\r\n- 缺点：由于使用了两种模式，因此对于代码的封装性来说不是很好。\r\n```\r\nfunction Person(name, age) {\r\n\tthis.name = name;\r\n\tthis.age = age;\r\n}\r\n\r\nPerson.prototype = {\r\n  constructor: Person,\r\n  sayName: function() {\r\n\t\talert(this.name);\r\n\t}\r\n}\r\n\r\nconst person1 = new createPerson("dyx", 24);\r\nconst person2 = new createPerson("douyaxing", 25);\r\n\r\nconsole.log(person1.name); // "dyx"\r\nconsole.log(person2.name); // "douyaxing"\r\nconsole.log(person1.sayName === person2.sayName); // true\r\n```\r\n### 动态原型模式\r\n> 这个方法把所有信息都封装到了构造函数中，而在构造函数中通过判断只初始化一次原型。if语句中检查的可以是初始化后应该存在的任何属性或方法，不必要检查每一个方法和属性，只需要检查一个就行。\r\n\r\n- 优点：解决了组合模式中封装性的问题。\r\n```\r\nfunction Person(name, age) {\r\n\tthis.name = name;\r\n\tthis.age = age;\r\n\tif (typeof this.sayName !== "function") {\r\n\t\tPerson.prototype.sayName: function() {\r\n\t\t\talert(this.name);\r\n\t\t} \r\n\t} \r\n}\r\n\r\nconst person1 = new Person("dyx", 24);\r\nperson1.sayName(); // "dyx"\r\n```\r\n### 寄生构造函数模式\r\n> 和工厂模式基本上是一摸一样的，只不过我们是采用 new 操作符最后来创建对象。\r\n\r\n- 优点：基于一个已有的类型，在实例化时对实例化的对象进行扩展。这样既不用修改原来的构造函数，也达到了扩展对象的目的。\r\n- 缺点：和工厂模式一样的问题，不能依赖 instanceof 操作符来确定对象的类型。\r\n```\r\nfunction CreatePerson(name, age) {\r\n\tconst o = new Object();\r\n\to.name = name;\r\n\to.age = age;\r\n\to.sayName = function() {\r\n\t\talert(this.name);\r\n\t};\r\n\treturn o;\r\n}\r\n\r\nconst person1 = new CreatePerson("dyx", 24);\r\nconst person2 = new CreatePerson("douyaxing", 25);\r\n```\r\n### 稳妥构造函数模式\r\n> 稳妥对象最适合在一些安全的环境中（这些环境中会禁止使用 this 和 new）。\r\n\r\n- 优点：除了sayName方法外，没有别的方法可以访问数据成员，这就是稳妥构造函数提供的安全性。\r\n- 缺点：和寄生构造函数一样，没有办法使用 instanceof 操作符来判断对象的类型\r\n```\r\nfunction Person(name, age) {\r\n\t// 创建要返回的对象\r\n\tconst o = new Object();\r\n\r\n\t// 可以在这里定义私有变量和函数\r\n\r\n\t// 添加方法\r\n\to.sayName = function() {\r\n\t\tconsole.log(this.name);\r\n\t}\r\n\r\n\t//返回对象\r\n\treturn o;\r\n} \r\n\r\nconst person1 = Person("dyx", 25);\r\nperson1.sayName(); // "dyx"\r\n```\r\n'},function(r,n,e){"use strict";e.r(n),n.default="## 异步处理方案\r\n### callback回调函数\r\n- 优点：简单，容易理解。\r\n- 缺点：代码可读性差，不易维护，耦合度高，层层嵌套造成回调地狱。\r\n```\r\nconst funcOne = (num, callback) => {\r\n  const newNum = num + 5;\r\n  // 异步操作，使用setTimeout模拟\r\n  setTimeout(() => callback(newNum), 1000)\r\n}\r\nconst funcTwo = (num, callback) => {\r\n  const newNum = num + 10;\r\n  // 异步操作，使用setTimeout模拟\r\n  setTimeout(() => callback(newNum), 2000)\r\n}\r\nconst funcThree = (num, callback) => {\r\n  const newNum = num + 20;\r\n  // 异步操作，使用setTimeout模拟\r\n  setTimeout(() => callback(newNum), 3000)\r\n}\r\n\r\nconst start = () => {\r\n  const num = 5;\r\n  console.log(num);\r\n  funcOne(num, function(funcOneReturnvalue) {\r\n    console.log(funcOneReturnvalue);\r\n    funcTwo(funcOneReturnvalue, function(funcTwoReturnvalue) {\r\n      console.log(funcTwoReturnvalue);\r\n      funcThree(funcTwoReturnvalue, function(funcThreeReturnvalue) {\r\n        console.log(funcThreeReturnvalue);\r\n      });\r\n    });\r\n  });\r\n}\r\n\r\nstart();\r\n```\r\n### 事件监听（发布订阅模式）\r\n- 优点：更符合模块化思想，编写自己的监听器的时候可以做很多优化，从而更好的监听程序的运行。\r\n- 缺点：整个程序变成了事件驱动，或多或少影响了流程，而且每次使用都要注册事件监听器然后触发，比较麻烦。\r\n```\r\ndocument.body.addEventListener('click', function () {\r\n  console.log('click');\r\n});\r\n\r\n// 实现发布订阅\r\ntype EventHandler = (data?: any) => void;\r\n\r\nclass EventEmitter {\r\n  handlersMapping: {\r\n    [key: string]: Array<EventHandler>;\r\n  } = {};\r\n\r\n  // 注册事件和处理函数\r\n  on(type: string, handler: EventHandler) {\r\n    let handlers = this.handlersMapping[type];\r\n    if (!handlers) {\r\n      handlers = this.handlersMapping[type] = [];\r\n    }\r\n    handlers.push(handler);\r\n  }\r\n\r\n  // 销毁事件和处理函数\r\n  off(type: string, handler: EventHandler) {\r\n    let handlers = this.handlersMapping[type] || [];\r\n    if (!handler) {\r\n      // 没有传入要销毁的方法时，清空时间对应所有方法\r\n      this.handlersMapping[type] = [];\r\n    } else {\r\n      const targetIndex = handlers.findIndex((handlerItem: EventHandler) => handlerItem === handler);\r\n      if (targetIndex !== -1) {\r\n        handlers.splice(targetIndex, 1);\r\n      }\r\n    }\r\n  }\r\n\r\n  // 触发某事件所有回调并带参数\r\n  emit(type: string, payload?: any) {\r\n    let handlers = this.handlersMapping[type] || [];\r\n    handlers.forEach(handler => handler(payload));\r\n  }\r\n}\r\n\r\nexport default new EventEmitter();\r\n\r\n// 内部组件进行监听某个事件执行在内部组件中注册处理函数，在全局组件中满足条件时触发内部组件所监听的方法\r\nconst dyxtest = () => {}\r\nuseEffect(() => {\r\n  eventBus.on(\"dyxtest\", dyxtest);\r\n  return () => {\r\n    eventBus.off(\"dyxtest\", dyxtest);\r\n  };\r\n}, []);\r\n\r\n// 全局组件触发\r\neventBus.emit(\"dyxtest\");\r\n```\r\n### Promise\r\n- 优点：避免了回调函数层层嵌套，可读性更强。链式操作，可以在then中继续写Promise对象并return，然后继续调用then进行回调操作。\r\n- 缺点：Promise对象一旦创建就会立即执行，不能中途取消。\r\n```\r\nconst funcOne = num => {\r\n  return new Promise((resolve, reject) => {\r\n    const newNum = num + 5;\r\n    setTimeout(() => resolve(newNum), 1000)\r\n  })\r\n}\r\n\r\nconst funcTwo = num => {\r\n  return new Promise((resolve, reject) => {\r\n    const newNum = num + 10;\r\n    setTimeout(() => resolve(newNum), 2000)\r\n  })\r\n}\r\n\r\nconst funcThree = num => {\r\n  return new Promise((resolve, reject) => {\r\n    const newNum = num + 20;\r\n    setTimeout(() => resolve(newNum), 3000)\r\n  })\r\n}\r\n\r\nconst start = () => {\r\n  const num = 5;\r\n  console.log(num);\r\n  funcOne(num).then(resOne => {\r\n    console.log(resOne);\r\n    return funcTwo(resOne);\r\n  }).then(resTwo => {\r\n    console.log(resTwo);\r\n    return funcThree(resTwo);\r\n  }).then(resThree => {\r\n    console.log(resThree);\r\n  });\r\n}\r\n\r\nstart();\r\n```\r\n### Generator函数\r\n- 优点：优雅的流程控制方法，允许函数被中断地执行。\r\n- 缺点：Generator函数的执行必须依赖执行器，对于只做异步处理还是不太方便。\r\n```\r\nconst funcOne = () => {\r\n  return new Promise(resolve => {\r\n    setTimeout(() => console.log(1), 1000);\r\n  })\r\n}\r\n\r\nconst funcTwo = () => {\r\n  return new Promise(resolve => {\r\n    setTimeout(() => console.log(2), 2000);\r\n  })\r\n}\r\n\r\nconst funcThree = () => {\r\n  return new Promise(resolve => {\r\n    setTimeout(() => console.log(3), 3000);\r\n  })\r\n}\r\n\r\nfunction* start() {\r\n  console.log('start');\r\n  yield funcOne();\r\n  yield funcTwo();\r\n  yield funcThree();\r\n  return 'dyx';\r\n}\r\n\r\nconst startFun = start();  // 仅生成指针对象，并不执行\r\nstartFun.next() // start 1\r\nstartFun.next() // 2\r\nstartFun.next() // 3\r\n```\r\n### async函数\r\n- 优点：内置执行器，语义更好，适用性更广。\r\n- 缺点：误用await可能会导致性能问题，因为await会阻塞代码。\r\n```\r\nconst funcOne = num => {\r\n  return new Promise((resolve, reject) => {\r\n    const newNum = num + 5;\r\n    setTimeout(() => resolve(newNum), 1000)\r\n  })\r\n}\r\n\r\nconst funcTwo = num => {\r\n  return new Promise((resolve, reject) => {\r\n    const newNum = num + 10;\r\n    setTimeout(() => resolve(newNum), 2000)\r\n  })\r\n}\r\n\r\nconst funcThree = num => {\r\n  return new Promise((resolve, reject) => {\r\n    const newNum = num + 20;\r\n    setTimeout(() => resolve(newNum), 3000)\r\n  })\r\n}\r\n\r\nconst start = async () => {\r\n  const num = 5;\r\n  console.log(num);\r\n  const firstAddNum = await funcOne(num);\r\n  console.log(firstAddNum);\r\n  const secondAddNum = await funcTwo(firstAddNum);\r\n  console.log(secondAddNum);\r\n  const thirdAddNum = await funcThree(secondAddNum);\r\n  console.log(thirdAddNum);\r\n}\r\n\r\nstart();\r\n```\r\n### async/await对比promise的优缺点\r\n- 优点\r\n  1. 真正的串行的同步写法，代码阅读相对容易。\r\n  2. 对于条件语句和其他流程语句比较友好，可以直接写到判断条件里面。\r\n- 缺点\r\n  1. 无法处理promise返回的reject对象，要借助try catch。\r\n### async/await与Generator的差异\r\n- async/await自带执行器，不需要手动调用next()就能自动执行下一步。\r\n- async函数返回值是Promise对象，而Generator返回的是生成器对象。\r\n- await能够返回Promise的resolve/reject的值。\r\n### 利用Generator实现async函数\r\n> async/await实际上是对Generator（生成器）的封装，是一个语法糖。通过step函数实现Generator函数的自执行，当Generator函数的.next()执行返回done: true时表示执行完毕.\r\n\r\n```\r\nfunction asyncToGenerator(generatorFunc) {\r\n  return function() {\r\n    const gen = generatorFunc.apply(this, arguments);\r\n    return new Promise((resolve, reject) => {\r\n      function step(key, arg) {\r\n        let generatorResult;\r\n        try {\r\n          generatorResult = gen[key](arg);\r\n        } catch (error) {\r\n          return reject(error);\r\n        }\r\n        const { value, done } = generatorResult;\r\n        if (done) {\r\n          return resolve(value);\r\n        } else {\r\n          return Promise.resolve(value).then(val => step('next', val), err => step('throw', err));\r\n        }\r\n      }\r\n      step(\"next\");\r\n    })\r\n  }\r\n}\r\n```\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## javascript数据类型及判断方法\r\n> 基本数据类型在JavaScript中是按值传递的，而引用数据类型则是按引用传递的。\r\n\r\n### 基本数据类型\r\n> 存储在栈内存中，占据空间小、大小固定、读写速度快。基本数据类型变量存储的是值本身。\r\n\r\n1. undefined\r\n2. null\r\n3. Boolean\r\n4. Number\r\n5. String\r\n6. Symbol（es6新增）表示独一无二的值且不可变，一般用于对象的属性名。对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的Symbol类型。\r\n7. BigInt（es2020新增）BigInt是一种新的数据类型，当整数值大于Number数据类型支持的范围时使用。这种数据类型允许我们安全地对大整数执行算术操作。JS中的Number无法精确表示非常大的整数，它会将非常大的整数四舍五入，JS中的Number类型只能安全地表示-9007199254740991(-(2^53 - 1))和9007199254740991(2^53 - 1)，任何超出此范围的整数值都可能失去精度。\r\n### 引用数据类型\r\n> 存放在堆内存中，占据空间大、大小不固定、读写速度慢。引用数据类型变量存储的是一个指针(栈内存)，该指针指向数据实体在堆中的地址。\r\n\r\n1. Object (Array、Function、Object等)\r\n### 基础数据类型赋值\r\n> 当把变量a赋值给变量b时，会直接把变量a的值复制一份，然后赋值给变量b，这时改变变量a或者变量b的值，不会改变另外一个变量的值。\r\n\r\n```\r\nlet a = 18;\r\nlet b = a;\r\na = 20;\r\nconsole.log(a); // 20\r\nconsole.log(b); // 18\r\n```\r\n### 引用数据类型赋值\r\n> 当把变量a赋值给变量b时，是把变量a的内存地址复制一份赋值给变量b。\r\n\r\n- 改变变量a所指向的堆内存中的数据时会让另一个变量b的值改变。\r\n```\r\nlet a = {\r\n  name: 'dyx'\r\n};\r\nlet b = a;\r\na.name = 'douyaxing';\r\nconsole.log(a); // { name: 'douyaxing' }\r\nconsole.log(b); // { name: 'douyaxing' }\r\n```\r\n- 直接改变变量a的指针指向时不会让另一个变量b的值改变。\r\n```\r\nlet a = {\r\n  name: 'dyx'\r\n};\r\nlet b = a;\r\na = {\r\n  name: 'douyaxing'\r\n};\r\nconsole.log(a); // { name: 'douyaxing' }\r\nconsole.log(b); // { name: 'dyx' }\r\n```\r\n### 数据类型判断\r\n#### typeof\r\n- typeof返回一个表示数据类型的字符串，返回结果包括string、number、boolean、symbol、undefined、object、function等7种数据类型。\r\n- typeof对于基本数据类型除了null都可以显示正确的类型，typeof对于引用数据类型除了函数会显示function其它都会显示object。\r\n```\r\ntypeof '123';              // string 有效\r\ntypeof 1;                  // number 有效\r\ntypeof true;               // boolean 有效\r\ntypeof Symbol('1');        // symbol 有效\r\ntypeof undefined;          // undefined 有效\r\ntypeof null;               // object 无效\r\ntypeof {};                 // object 有效\r\ntypeof function() {};      // function 有效\r\ntypeof [];                 // object 无效\r\ntypeof new Date();         // object 无效\r\ntypeof new RegExp();       // object 无效\r\n```\r\n#### instanceof\r\n- instanceof用来判断A是否为B的实例，内部机制是检测构造函数的prototype属性是否出现在某个实例对象的原型链上。\r\n- 不能获取具体的数据类型。\r\n- instanceof可以正确的判断引用数据的类型，无法正确判断基本数据的类型。\r\n```\r\n'123' instanceof String;                // false 无效\r\n1 instanceof Number;                    // false 无效\r\ntrue instanceof Boolean;                // false 无效\r\nSymbol('1') instanceof Symbol;          // false 无效\r\n{} instanceof Object;                   // true 有效\r\nfunction() {} instanceof Function;      // true 有效\r\n[] instanceof Array;                    // true 有效\r\nnew Date() instanceof Date;             // true 有效\r\nnew RegExp() instanceof RegExp;         // true 有效\r\n```\r\n#### constructor\r\n- 当一个构造函数被定义时，构造函数会有原型对象prototype，原型对象上constructor属性指向构造函数。使用构造函数创建对象时，创建的对象继承了构造函数原型对象prototype。新创建的对象的constructor属性指向构造函数。\r\n- 不能获取具体的数据类型。\r\n- 除undefined、null两种数据类型外都可以判断正确的类型，undefined、null没有原生构造函数。\r\n- 当修改了构造函数原型对象的constructor属性值时，使用constructor判断数据类型就变得不可靠了。\r\n```\r\n('123').constructor === String;           // true\r\n(1).constructor === Number;               // true\r\n(true).constructor === Boolean;           // true\r\n(Symbol('1')).constructor === Symbol;     // true            \r\n({}).constructor === Object;              // true \r\n(function() {}).constructor === Function; // true \r\n([]).constructor === Array;               // true \r\n(new Date()).constructor === Date;        // true \r\n(new RegExp()).constructor === RegExp;    // true \r\n```\r\n#### Object.prototype.toString.call()\r\n- 使用Object原型对象上的toString方法，toString方法返回运行时this指向的对象类型，返回的类型格式为`[object,xxx]`，xxx是具体的数据类型。\r\n- 最准确的类型判断方法。适用所有的数据类型。\r\n```\r\nObject.prototype.toString.call('123');         // [object, String]\r\nObject.prototype.toString.call(1);             // [object, Number]\r\nObject.prototype.toString.call(true);          // [object, Boolean]\r\nObject.prototype.toString.call(Symbol('1'));   // [object, Symbol]\r\nObject.prototype.toString.call(undefined);     // [object, Undefined]\r\nObject.prototype.toString.call(null);          // [object, Null]\r\nObject.prototype.toString.call({});            // [object, Object]\r\nObject.prototype.toString.call(function() {}); // [object, Function]\r\nObject.prototype.toString.call([]);            // [object, Array]\r\nObject.prototype.toString.call(new Date());    // [object, Date]\r\nObject.prototype.toString.call(new RegExp());  // [object, RegExp]\r\n\r\n// 通用的判断方法\r\nconst checkType = data => {\r\n  const type = Object.prototype.toString.call(data); // 返回字符串类型的值\r\n  // 截取代表真正数据类型部分\r\n  return type.slice(8, -1);\r\n}\r\n```\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## [浏览器页面不可见时定时器是否准时](http://www.codebaoku.com/it-js/it-js-255148.html)\r\n### 浏览器可见和不可见状态\r\n> 浏览器的可见和不可见状态(浏览器切换到其他标签页或最小化)的切换会触发visibilitychange事件，可以通过监听这个事件来判别浏览器的可见状态。\r\n\r\n- hidden：页面彻底不可见，也可以使用document.hidden返回一个布尔值，为true说明当前浏览器是不可见状态。\r\n- visible：页面至少一部分可见。\r\n- prerender：页面即将或正在渲染，处于不可见状态。 \r\n```\r\ndocument.addEventListener(\"visibilitychange\", function() {\r\n  console.log(document.visibilityState);\r\n});\r\n```\r\n### setInterval\r\n- 谷歌浏览器中当页面处于不可见状态时，setInterval的最小间隔时间会被限制为1s。\r\n- 火狐浏览器和谷歌浏览器特性一致。\r\n- IE浏览器没有对不可见状态时的setInterval进行性能优化，不可见状态前后间隔时间不变。\r\n### setTimeout\r\n- 谷歌浏览器中当页面处于不可见状态时，setTimeout的间隔低于1s的会变为1s，大于等于1s的会变成N+1s的间隔值。\r\n- 火狐浏览器中当页面处于不可见状态时，setTimeout的间隔低于1s的会变为1s，大于等于1s的间隔不变。\r\n- IE浏览器在不可见状态前后间隔时间不变。\r\n### requestAnimationFrame\r\n- 谷歌浏览器中当页面处于不可见状态时，requestAnimationFrame方法停止执行。\r\n- 火狐浏览器中当页面处于不可见状态时，间隔是1s,2s,4s,8s,16s,32s...这样的顺序去执行requestAnimationFrame方法。\r\n- IE浏览器中当页面处于不可见状态时，requestAnimationFrame方法停止执行。\r\n### 解决方法\r\n- 在一些定时器小于1s的倒计时页面中，如果用户切换到了其他标签页。再切回去的时候，页面上显示的倒计时时间其实是错误的。\r\n- 使用webWorkers解决上述问题，而且webWorkers还可以解决一个页面存在多个定时器间隔时间误差较大的问题。\r\n```\r\ndocument.getElementById('btn').addEventListener('click', function() {\r\n  const w = new Worker('demo_workers.js');\r\n  w.onmessage = function(event) {\r\n    console.log(event.data);\r\n  };\r\n});\r\n\r\n// 浏览器切换事件\r\ndocument.addEventListener('visibilitychange', function() { \r\n  if (document.hidden) {\r\n    console.log('页面不可见');\r\n  }\r\n});\r\n\r\n\r\n// demo_workers.js\r\nsetInterval(function() {\r\n  const myDate = new Date();\r\n  const currentDate = myDate.getMinutes() + '分'+ myDate.getSeconds() + '秒' + myDate.getMilliseconds() + '豪秒';\r\n  postMessage(currentDate);\r\n}, 500);\r\n```\r\n\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## 浮点数精度丢失\r\n### 0.1 + 0.2 ≠ 0.3的现象\r\n> 计算机存储双精度浮点数，需要先把十进制转换为二进制的科学计数法形式，然后计算机以一定的规则存储，因为存储时有位数限制（双精度 8 字节，64 位），末位就需要取近似值（0舍1入），再转换为十进制时，就造成了误差。\r\n\r\n### 解决办法\r\n- 处理大数的bignumber.js。\r\n- 处理小数的number-precision和decimal.js。\r\n### 二进制转化\r\n#### 正整数的转换\r\n> 除二取余，然后倒序排列，高位补零。\r\n\r\n1. 65转二进制为1000001\r\n2. 高位0后为01000001。\r\n\r\n#### 负整数的转换\r\n> 将对应的正整数转换成二进制后，对二进制取反，然后对结果再加一。\r\n\r\n1. -65转二进制\r\n2. 先把65转换成二进制01000001\r\n3. 逐位取反：10111110\r\n4. 再加1：10111111\r\n#### 小数的转换\r\n> 对小数点以后的数乘以2，取整数部分，再取小数部分乘2，以此类推……，直到小数部分为0或位数足够。取整部分按先后顺序排列即可。进制小数转二进制后大概率出现无限位数。\r\n\r\n1. 123.4转二进制\r\n2. `0.4*2=0.8` ——————-> 取0\r\n3. `0.8*2=1.6` ——————-> 取1\r\n4. `0.6*2=1.2` ——————-> 取1\r\n5. `0.2*2=0.4` ——————-> 取0\r\n6. `0.4*2=0.8` ——————-> 取0\r\n7. 以此类推循环\r\n8. 按顺序写出：0.4 = 0.01100110……（0110循环）\r\n9. 整数部分123的二进制是1111011\r\n10. 则123.4的二进制表示为：1111011.011001100110……"},function(r,n,e){"use strict";e.r(n),n.default="## 浅拷贝深拷贝\r\n### 引用数据类型直接赋值\r\n- 改变变量a所指向的内存中的数据时会让另一个变量b的值改变。\r\n```\r\nlet a = {\r\n  name: 'dyx'\r\n};\r\nlet b = a;\r\na.name = 'douyaxing';\r\nconsole.log(a); // { name: 'douyaxing' }\r\nconsole.log(b); // { name: 'douyaxing' }\r\n```\r\n- 直接改变变量a的指针指向时不会让另一个变量b的值改变。\r\n```\r\nlet a = {\r\n  name: 'dyx'\r\n};\r\nlet b = a;\r\na = {\r\n  name: 'douyaxing'\r\n};\r\nconsole.log(a); // { name: 'douyaxing' }\r\nconsole.log(b); // { name: 'dyx' }\r\n```\r\n- 改变形参arr所指向的内存中的数据时也会修改变量a。\r\n```\r\nconst a = [1, 2, 3];\r\nfunction test(arr) {\r\n  arr[0] = 4; // arr形参的修改也会修改变量a，因为两个变量的值(数组)指向同一内存内容。\r\n}\r\ntest(a);\r\nconsole.log(a) // [4, 2, 3]\r\n```\r\n- 改变形参arr的指针指向时不会修改变量a。\r\n```\r\nconst a = [1, 2, 3];\r\nfunction test(arr) {\r\n  arr = [1, 2]; // 修改的是arr变量的指向，并不会影响a变量指向内存的内容\r\n}\r\ntest(a);\r\nconsole.log(a) // [1, 2, 3]\r\n```\r\n### 浅拷贝\r\n> 第二层及以下的都是浅拷贝，修改第二层及以下层级内容，另一个变量还是会跟着改变。\r\n\r\n- 扩展运算符\r\n```\r\nconst obj = {\r\n  a: 1,\r\n  b: 2,\r\n  c: [1, { name: 'dyx' }]\r\n};\r\nconst shallowCopy = {...obj};\r\n```\r\n- Object.assign\r\n```\r\nconst obj = {\r\n  a: 1,\r\n  b: 2,\r\n  c: [1, { name: 'dyx' }]\r\n};\r\nconst shallowCopy = Object.assign({}, obj);\r\n```\r\n- 自己实现\r\n```\r\nconst obj = {\r\n  a: 1,\r\n  b: 2,\r\n  c: [1, { name: 'dyx' }]\r\n};\r\n\r\nfunction shallowClone(obj) {\r\n  const newObj = Object.prototype.toString.call(obj) === '[object Array]' ? [] : {};\r\n  if (typeof obj !== 'object') {\r\n    return;\r\n  } else {\r\n    for(const name in obj) {\r\n      if(obj.hasOwnProperty(name)) {\r\n        newObj[name] = obj[name];\r\n      }\r\n    }\r\n    return newObj;\r\n  }\r\n}\r\n\r\nconst shallowCopy = shallowClone(obj);\r\n```\r\n### 深拷贝\r\n> 所有层级都可以修改，不会影响另一个变量。\r\n\r\n- JSON.parse\r\n```\r\nconst obj = {\r\n  a: 1,\r\n  b: 2,\r\n  c: [1, { name: 'dyx' }]\r\n};\r\nconst deepCopy = JSON.parse(JSON.stringify(obj));\r\n```\r\n- 使用递归自己实现，当value仍是对象数据格式时递归调用deepClone方法。\r\n```\r\nconst obj = {\r\n  a: 1,\r\n  b: 2,\r\n  c: [1, { name: 'dyx' }]\r\n};\r\nfunction deepClone(obj) {\r\n  const newObj = Object.prototype.toString.call(obj) === '[object Array]' ? [] : {};\r\n  if (typeof obj !== 'object') {\r\n    return;\r\n  } else {\r\n    for (const name in obj) {\r\n      if (obj.hasOwnProperty(name)) {\r\n        newObj[name] = typeof obj[name] === 'object' ? deepClone(obj[name]) : obj[name];\r\n      }\r\n    }\r\n  }\r\n  return newObj;\r\n}\r\n\r\nconst deepCopy = deepClone(obj);\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## 渲染大量数据\r\n> 对于大量数据的渲染，JS运算并不是性能的瓶颈，性能的瓶颈主要在于渲染阶段。JS执行要比DOM渲染快的多。\r\n\r\n### 滚动加载更多\r\n### 分页实现\r\n### 虚拟列表\r\n> 虚拟列表其实是按需显示的一种实现，只对可见区域进行渲染，对非可见区域中的数据不渲染或部分渲染的技术，从而达到极高的渲染性能。假设有1万条记录需要同时渲染，我们屏幕的可见区域的高度为500px,而列表项的高度为50px，则此时我们在屏幕中最多只能看到10个列表项，那么在首次渲染的时候，我们只需加载10条即可。当滚动发生时，可以通过计算当前滚动值得知此时在屏幕可见区域应该显示的列表项。假设滚动条距顶部的位置为150px，则我们可得知在可见区域内的列表项为第4项至第13项。\r\n\r\n- 计算当前可视区域起始数据索引。\r\n- 计算当前可视区域结束数据索引。\r\n- 计算当前可视区域的数据，并渲染到页面中。\r\n- 计算startIndex对应的数据在整个列表中的偏移位置并设置到列表上。\r\n- 监听滚动列表的scroll事件，获取滚动位置scrollTop，从而重新计算可视区域的起始数据索引、结束数据索引、可视区域的数据、以及整个列表的偏移位置。\r\n### 时间分片\r\n#### setTimeout的问题\r\n- 当使用setTimeout来拆分大量的DOM插入操作时，即使我们将延迟时间设置为0ms，但实际上由于JavaScript是单线程的，任务执行时会被放入到事件队列中，而事件队列中的任务需要等待当前任务执行完成后才能执行。所以即使设置了0ms延迟，setTimeout的回调函数也不一定会立即执行，可能会受到其他任务的阻塞。\r\n- 当setTimeout的回调函数执行的间隔超过了浏览器每帧更新的时间间隔(一般是16.7ms)，就会出现丢帧现象。丢帧指的是浏览器在更新页面时，没有足够的时间执行全部的任务，导致部分任务被跳过，从而导致页面渲染不连续，出现闪烁的情况。\r\n- 使用setTimeout实现动画在页面隐藏或最小化时，仍会在后台执行动画任务浪费cpu资源。而requestAnimationFrame不同，在页面处于未激活状态下，该页面的屏幕绘制会暂停，当页面被激活时动画从上次停留位置开始执行。\r\n#### requestAnimationFrame\r\n> requestAnimationFrame最大的优势是由系统来决定回调函数的执行时机。如果屏幕刷新率是60Hz，那么回调函数就每16.7ms被执行一次，如果刷新率是75Hz，那么这个时间间隔就变成了1000/75=13.3ms，requestAnimationFrame的步伐跟着系统的刷新步伐走。它能保证回调函数在屏幕每一次的刷新间隔中只被执行一次，这样就不会引起丢帧现象。\r\n\r\n```\r\n// 需要插入的容器\r\nconst ul = document.getElementById('container');\r\n// 插入十万条数据\r\nconst total = 100000;\r\n// 一次插入 20 条\r\nconst once = 20;\r\n// 每条记录的索引\r\nconst index = 0;\r\n// 循环加载数据\r\nfunction loop(curTotal, curIndex) {\r\n  if (curTotal <= 0) {\r\n    return false;\r\n  }\r\n  // 每页多少条\r\n  const pageCount = Math.min(curTotal, once);\r\n  window.requestAnimationFrame(function() {\r\n    for (let i = 0; i < pageCount; i++) {\r\n      const li = document.createElement('li');\r\n      li.innerText = curIndex + i;\r\n      ul.appendChild(li);\r\n    }\r\n    loop(curTotal - pageCount, curIndex + pageCount);\r\n  })\r\n}\r\nloop(total, index);\r\n```\r\n#### 使用DocumentFragment优化\r\n> 被作为一个轻量版的Document使用，用于存储已排好版的或尚未打理好格式的html片段。DocumentFragment不是真实DOM树的一部分，它的变化不会触发DOM树的重新渲染，且不会导致性能等问题。DocumentFragment是DOM节点，但并不是DOM树的一部分，可以认为是存在内存中的，所以将子元素插入到文档片段时不会引起页面回流。\r\n\r\n```\r\n// 需要插入的容器\r\nconst ul = document.getElementById('container');\r\n// 插入十万条数据\r\nconst total = 100000;\r\n// 一次插入 20 条\r\nconst once = 20;\r\n// 每条记录的索引\r\nconst index = 0;\r\n// 循环加载数据\r\nfunction loop(curTotal, curIndex) {\r\n  if (curTotal <= 0) {\r\n    return false;\r\n  }\r\n  // 每页多少条\r\n  const pageCount = Math.min(curTotal , once);\r\n  window.requestAnimationFrame(function() {\r\n    const fragment = document.createDocumentFragment();\r\n    for (let i = 0; i < pageCount; i++) {\r\n      const li = document.createElement('li');\r\n      li.innerText = curIndex + i;\r\n      fragment.appendChild(li);\r\n    }\r\n    ul.appendChild(fragment);\r\n    loop(curTotal - pageCount, curIndex + pageCount);\r\n  })\r\n}\r\nloop(total, index);\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## 箭头函数与普通函数的区别\r\n- 箭头函数语法更加简洁、清晰。\r\n- 箭头函数会使用其所在上下文的this作为自己的this值，定义的时候就确定了。\r\n- call、apply、bind不会影响箭头函数this的指向。箭头函数中的this不会指向传入的第一个参数，第一个参数被忽略，而是指向了window对象。\r\n- 箭头函数不能作为构造函数使用，也不能使用new关键字(因为箭头函数没有自己的this，它的this是继承了其所在上下文中的this，且this指向永远不会改变，构造函数的this要是指向创建的新对象)。\r\n- 不可以使用arguments对象，该对象在箭头函数体内不存在。如果要用可以用rest参数代替。\r\n- 箭头函数没有原型prototype。\r\n- 箭头函数不能用作Generator函数，不能使用yield关键字。\r\n"},function(r,n,e){"use strict";e.r(n),n.default='## js数据类型转换\r\n### 转成boolean\r\n- js在预期为布尔值的地方比如if()的语句中会自动将非布尔值参数转为布尔值;只有空字符串("")、null、undefined、+0、-0、false和 NaN 在if中转为布尔型是 false，其他的都是 true([]、{})。\r\n```\r\nif (\'abc\') {\r\n console.log(\'hello\')\r\n} // "hello"\r\n```\r\n- !非运算符会自动将非布尔值转为布尔值,利用该规则对一非布尔值去两次反会转为布尔类型\r\n- Boolean(\'abc\')可以转成布尔值，只有\'\'(空字符串)、null、undefined、0、NaN、false为false，空数组、空对象 new Boolean(false)都为true\r\n```\r\nBoolean(function(){}) // true\r\n!!() => {} // true\r\nBoolean(\'0\') // true\r\nBoolean(0) // false\r\nnew Boolean(false) // true\r\n```\r\n### 其他的数据类型转换为String\r\n- toString()方法\r\n> 调用被转换数据类型的toString()方法,该方法不会影响到原变量，它会将转换的结果返回，但是注意：null和undefined这两个值没有toString，如果调用他们的方法，会报错。采用 Number 类型的 toString() 方法的基模式，可以用不同的基输出数字，例如二进制的基是 2，八进制的基是 8，十六进制的基是 16。\r\n\r\n```\r\nvar iNum = 10;\r\nalert(iNum.toString(2)); //输出 "1010"\r\nalert(iNum.toString(8)); //输出 "12"\r\nalert(iNum.toString(16)); //输出 "A"\r\n```\r\n- String()函数\r\n> 使用String()函数做强制类型转换时，对于Number和Boolean实际上就是调用的toString()方法,但是对于null和undefined，就不会调用toString()方法,它会将null直接转换为"null",将undefined 直接转换为"undefined",String方法的参数如果是对象，返回一个类型字符串；如果是数组，返回该数组的字符串形式。\r\n\r\n```\r\nvar a = null\r\nString(a) // "null"\r\nvar b = undefined\r\nString(b) // "undefined"\r\nString({ a: 1 }) // "[object Object]"\r\nString([1, 2, 3]) // "1,2,3"\r\n```\r\n- 字符串的自动转换，主要发生在字符串的加法运算时。当一个值为字符串，另一个值为非字符串，则后者转为字符串。\r\n```\r\n5 + \'1\' // \'51\'\r\n\'5\' + true // "5true"\r\n\'5\' + false // "5false"\r\n\'5\' + {} // "5[object Object]"\r\n\'5\' + [] // "5"\r\n\'5\' + function (){} // "5function (){}"\r\n\'5\' + undefined // "5undefined"\r\n\'5\' + null // "5null"\r\n```\r\n### 其他的数据类型转换为Number\r\n- 纯数字的字符串可以直接在前面加+号转为数值型\r\n- 使用Number()函数\r\n  1. 字符串转数字\r\n  > 如果是纯数字的字符串，则直接将其转换为数字;如果字符串中有非数字的内容，则转换为NaN;如果字符串是一个空串或者是一个全是空格的字符串，则转换为0\r\n\r\n  2. 布尔值转数字:true转成1,false转成0\r\n  3. undefined转数字:转成NaN  undefined+5=NaN\r\n  4. null转数字：转成0  null+5=5\r\n  5. Number() 接受数值作为参数，此时它既能识别负的十六进制，也能识别0开头的八进制，返回值永远是十进制值\r\n  ```\r\n  Number(3.15); // 3.15\r\n  Number(023); // 19\r\n  Number(0x12); // 18\r\n  Number(-0x12); // -18\r\n  ```\r\n  6. 对象转数字\r\n  > Number方法的参数是对象时，将返回NaN，除非是包含单个数值的数组\r\n\r\n  ```\r\n  Number({ a: 1 }) // NaN\r\n  Number([1, 2, 3]) // NaN\r\n  Number([5]) // 5\r\n  ```\r\n- parseInt() & parseFloat()\r\n> 这种方式专门用来对付字符串，parseInt()一个字符串转换为一个整数,可以将一个字符串中的有效的整数内容取出来，然后转换为Number。parseFloat()把一个字符串转换为一个浮点数。parseFloat()作用和parseInt()类似，不同的是它可以获得有效的小数。\r\n\r\n```\r\n// 当可以抽取出来的数值的前面有不符合的内容时会返回NaN \r\nconsole.log(parseInt("a10")); // NaN\r\nconsole.log(parseInt(\'.21\')); // NaN\r\nconsole.log(parseInt("10.3")); // 10\r\nconsole.log(parseFloat(\'.21\')); // 0.21\r\nconsole.log(parseFloat(\'.d1\')); // NaN\r\nconsole.log(parseFloat("10.11.33")); // 10.11\r\nconsole.log(parseFloat("4.3years")); // 4.3\r\nconsole.log(parseFloat("He40.3")); // NaN\r\n```\r\n> parseInt()在没有第二个参数时默认以十进制转换数值，有第二个参数时，以第二个参数为基数转换数值，如果基数有误返回NaN\r\n\r\n```\r\nconsole.log(parseInt("13")); // 13\r\nconsole.log(parseInt("11", 2)); // 3\r\nconsole.log(parseInt("17", 8)); // 15\r\nconsole.log(parseInt("1f", 16)); // 31\r\n```\r\n- 算数运算符(+ - * /)跟非Number类型的值进行运算时，会将这些值转换为Number，然后在运算，除了字符串的加法运算\r\n```\r\ntrue + 1 // 2\r\n2 + null // 2\r\nundefined + 1 // NaN\r\n2 + NaN // NaN 任何值和NaN做运算都得NaN\r\n\'5\' - \'2\' // 3\r\n\'5\' * \'2\' // 10\r\ntrue - 1 // 0\r\n\'1\' - 1 // 0\r\n\'5\' * [] // 0\r\nfalse / \'5\' // 0\r\n\'abc\' - 1 // NaN\r\n```\r\n- Number函数将字符串转为数值，要比parseInt函数严格很多。基本上，只要有一个字符无法转成数值，整个字符串就会被转为NaN。对空字符串的处理也不一样\r\n```\r\nparseInt(\'42 cats\') // 42\r\nNumber(\'42 cats\') // NaN\r\nNumber(" "); // 0 \r\nparseInt(" "); // NaN\r\n```'},function(r,n,e){"use strict";e.r(n),n.default="## 继承\r\n> 继承是面向对象编程的三大特征之一（封装、继承、多态）。多个类中存在相同的属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只需要继承那个类即可。多个类可以称为子类，单独这个类称为父类或者超类，基类等。子类可以直接访问父类中的非私有的属性和行为。\r\n\r\n### js的继承\r\n> 在其他面向类语言中，继承意味着复制操作，子类是实实在在地将父类的属性和方法复制了过来，但javascript中的继承不是这样的。根据原型的特性，js中继承的本质是一种委托机制，对象可以将需要的属性和方法委托给原型，需要用的时候就去原型上拿，这样多个对象就可以共享一个原型上的属性和方法，这个过程中是没有复制操作的。\r\n\r\n### 原型链继承\r\n> 直接利用原型链特征实现的继承，让构造函数的prototype指向另一个构造函数的实例。当查找dyx实例的head和hand属性时，由于dyx本身并没有这两个属性，引擎就会去查找dyx的原型，还是没有，继续查找dyx原型的原型，也就是Person原型对象，结果就找到了。因此YellowPerson和Person之间通过原型链实现了继承关系。\r\n\r\n```\r\nfunction Person() {\r\n  this.head = 1;\r\n  this.hand = 2;\r\n}\r\n\r\nfunction YellowPerson() {};\r\nYellowPerson.prototype = new Person();\r\n\r\nconst dyx = new YellowPerson();\r\nconsole.log(dyx.head); // 1\r\nconsole.log(dyx.hand); // 2\r\n```\r\n![原型链继承](./img/原型链继承.png)\r\n#### 原型链继承的问题\r\n1. 创建dyx实例时不能传参，也就是YellowPerson构造函数本身不接受参数。\r\n2. 当原型上的属性是引用数据类型时，所有实例都会共享这个属性，即某个实例对这个属性重写会影响其他实例。\r\n```\r\nfunction Person() {\r\n  this.colors = ['white', 'yellow', 'black'];\r\n}\r\n\r\nfunction YellowPerson() {};\r\nYellowPerson.prototype = new Person();\r\n\r\nconst dyx = new YellowPerson();\r\ndyx.colors.push('green');\r\nconsole.log(dyx.colors); // ['white', 'yellow', 'black', 'green']\r\n\r\nconst douyaxing = new YellowPerson();\r\nconsole.log(douyaxing.colors); // ['white', 'yellow', 'black', 'green']\r\n```\r\n### 盗用构造函数继承\r\n> 盗用构造函数也叫作“对象伪装”或者“经典继承”，原理就是通过在子类中调用父类构造函数实现上下文的绑定。YellowPerson在内部使用call调用构造函数，这样在创建YellowPerson的实例时，Person就会在YellowPerson实例的上下文中执行，于是每个YellowPerson实例都会拥有自己的colors属性，而且这个过程是可以传递参数的，Person.call()接受的参数最终会赋给YellowPerson的实例。\r\n\r\n```\r\nfunction Person(eyes) {\r\n  this.eyes = eyes;\r\n  this.colors = ['white', 'yellow', 'black'];\r\n}\r\n\r\nfunction YellowPerson() {\r\n  Person.call(this, 'black'); // 调用构造函数并传参\r\n}\r\n\r\nconst dyx = new YellowPerson();\r\ndyx.colors.push('green');\r\nconsole.log(dyx.colors); // ['white', 'yellow', 'black', 'green']\r\nconsole.log(dyx.eyes); // black\r\n\r\nconst douyaxing = new YellowPerson();\r\nconsole.log(douyaxing.colors); // ['white', 'yellow', 'black']\r\nconsole.log(douyaxing.eyes); // black\r\n```\r\n![盗用构造函数继承](./img/盗用构造函数继承.png)\r\n#### 盗用构造函数继承的问题\r\n1. 必须在构造函数中定义方法，通过盗用构造函数继承的方法本质上都变成了实例自己的方法，不是公共的方法，因此失去了复用性。\r\n2. 子类不能访问父类原型上定义的方法，因此所有类型只能使用构造函数模式，原因是YellowPerson构造函数、dyx和douyaxing实例都没有和Person的原型对象产生联系。\r\n```\r\nfunction Person(eyes) {\r\n  this.eyes = eyes;\r\n  this.getEyes = function () {\r\n    return this.eyes;\r\n  }\r\n}\r\nPerson.prototype.ReturnEyes = function() {\r\n  return this.eyes;\r\n}\r\n\r\nfunction YellowPerson() {\r\n  Person.call(this, 'black');\r\n}\r\n\r\nconst dyx = new YellowPerson();\r\nconsole.log(dyx.getEyes()); // black\r\n// dyx实例能继承Person构造函数内部的方法getEyes()，对于Person原型对象上的方法，dyx实例是访问不到的\r\nconsole.log(dyx.ReturnEyes()) // TypeError: hjy.ReturnEyes is not a function\r\n```\r\n### 组合继承\r\n> 组合继承的原理就是先通过盗用构造函数实现上下文绑定和传参，然后再使用原型链继承的手段将子构造函数的prototype指向父构造函数的实例。相较于盗用构造函数继承，组合继承额外的将YellowPerson的原型对象（同时也是dyx和douyaxing实例的原型）指向了Person的原型对象，这样就集合了原型链继承和盗用构造函数继承的优点。\r\n\r\n```\r\nfunction Person(eyes) {\r\n  this.eyes = eyes;\r\n  this.colors = ['white', 'yellow', 'black'];\r\n}\r\nPerson.prototype.getEyes = function() {\r\n  return this.eyes;\r\n}\r\n\r\nfunction YellowPerson() {\r\n  Person.call(this, 'black'); // 调用构造函数并传参\r\n}\r\nYellowPerson.prototype = new Person(); // 再次调用构造函数\r\n\r\nconst dyx = new YellowPerson();\r\ndyx.colors.push('green');\r\nconst douyaxing = new YellowPerson();\r\n\r\nconsole.log(dyx.colors); // ['white', 'yellow', 'black', 'green']\r\nconsole.log(dyx.getEyes()); // black\r\nconsole.log(douyaxing.colors); // ['white', 'yellow', 'black']\r\n```\r\n![组合继承](./img/组合继承.png)\r\n#### 组合继承的缺点\r\n1. 实现的过程中调用了两次Person构造函数，有一定程度上的性能浪费。\r\n### 原型式继承\r\n> object.create()通过第二个参数新增的属性是直接挂载到新建对象本身，而不是挂载在它的原型上。原型式继承非常适合不需要单独创建构造函数，但仍然需要在对象间共享信息的场合。原型式继承和原型链继承中原型与实例之间的关系基本是一致的，不过构造函数是一个中间函数，在object.create()执行完后它就随着函数作用域一起被回收了。\r\n\r\n```\r\nconst dyx = {\r\n  eyes: 'black',\r\n  colors: ['white', 'yellow', 'black']\r\n}\r\n\r\nconst douyaxing = Object.create(dyx, {\r\n  name: {\r\n    value: 'douyaxing',\r\n    writable: false,\r\n    enumerable: true,\r\n    configurable: true\r\n  },\r\n  age: {\r\n    value: '26',\r\n    writable: true,\r\n    enumerable: true,\r\n    configurable: false\r\n  }\r\n});\r\nconsole.log(douyaxing.eyes) // black\r\nconsole.log(douyaxing.colors) // ['white', 'yellow', 'black']\r\nconsole.log(douyaxing.name) // douyaxing\r\nconsole.log(douyaxing.age) // 26\r\n```\r\n![原型式继承](./img/原型式继承.png)\r\n#### 原型式继承的缺点\r\n> 原型式继承和原型链继承的本质基本一致，那么原型式继承也有一样的缺点。\r\n\r\n- 不能传参，使用手写的object()不能传参数，但使用Object.create()是可以传参的。\r\n- 原对象中的引用类型的属性会被新对象共享。\r\n### 寄生式继承\r\n> 寄生式继承与原型式继承很接近，它的思想就是在原型式继承的基础上以某种方式增强对象，然后返回这个对象。\r\n\r\n```\r\nfunction inherit(obj) {\r\n  let clone = Object.create(obj);\r\n  clone.sayHi = function () { // 增强对象\r\n    console.log('Hi');\r\n  }\r\n  return clone;\r\n}\r\n\r\nconst dyx = {\r\n  eyes: 'black',\r\n  colors: ['white', 'yellow', 'black']\r\n}\r\nconst douyaxing = inherit(dyx)\r\n\r\nconsole.log(douyaxing.eyes); // black\r\nconsole.log(douyaxing.colors); // ['white', 'yellow', 'black']\r\ndouyaxing.sayHi(); // Hi\r\n```\r\n### 寄生式组合继承\r\n> 寄生式组合继承只调用了一次Person造函数，避免了在Person.prototype上面创建不必要、多余的属性。于此同时，原型链依然保持不变，效率非常之高效。\r\n\r\n```\r\nfunction inherit(Father, Son) {\r\n  const prototype = Object.create(Father.prototype); // 获取父类原型对象副本\r\n  prototype.constructor = Son; // 将获取的副本的constructor指向子类，以此增强副本原型对象\r\n  Son.prototype = prototype; // 将子类的原型对象指向副本原型对象\r\n}\r\n\r\nfunction Person(eyes) {\r\n  this.eyes = eyes;\r\n  this.colors = ['white', 'yellow', 'black'];\r\n}\r\nPerson.prototype.getEyes = function() {\r\n  return this.eyes;\r\n}\r\n\r\nfunction YellowPerson() {\r\n  Person.call(this, 'black'); // 调用构造函数并传参\r\n}\r\n\r\ninherit(Person, YellowPerson) // 寄生式继承，不用第二次调用构造函数\r\n\r\nconst dyx = new YellowPerson();\r\ndyx.colors.push('green');\r\nconst douyaxing = new YellowPerson();\r\n\r\nconsole.log(dyx.colors); // ['white', 'yellow', 'black']\r\nconsole.log(dyx.getEyes()); // 'black'\r\nconsole.log(douyaxing.colors); // ['white', 'yellow', 'black', 'green']\r\n```\r\n![寄生式组合继承](./img/寄生式组合继承.png)\r\n### es6 class继承\r\n> 使用关键字extends，并使用super关键字将子类的数据传参给父类,super等于调用父类的constructor，但是this指向子类。\r\n\r\n```\r\nclass Person {\t\r\n  constructor(name, age) {\r\n  \tthis.name = name;\r\n  \tthis.age = age;\t\r\n    this.nickName = 'douyaxing';\t\r\n  }\r\n  getInfo() {\r\n    console.log(this.name, this.age, nickName);\r\n  } \r\n}  \r\n\r\n\r\nclass Man extends Person {\t\r\n  constructor(name, age, sex) {\r\n    super(name, age);\r\n  \tthis.sex = sex;\t\t\r\n  }\r\n  print() {\r\n    console.log(this.sex);\r\n  } \r\n} \r\nconst dyx = new Man(\"dyx\", 25, \"男\")\r\ndyx.getInfo() // dyx 25, douyaxing  父类的nickName属性也会继承\r\ndyx.print() // 男\r\n```\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## 节流与防抖\r\n> 节流和防抖是为了限制函数触发频率而产生的，主要运用了函数的闭包，多使用三方库如lodash中的方法实现所需效果。\r\n\r\n### 节流\r\n> 指定时间段内触发多次函数，只有一次生效。固定时间内函数只执行一次，不会导致函数延迟执行。\r\n\r\n- 监听缩放、滚动等场景建议使用。\r\n```\r\n// 使用时间间隔来判断\r\nconst throttle = (fn, delay) => {\r\n  let preT = 0;\r\n  return (...rest) => {\r\n    const currT = new Date();\r\n    if(currT - preT > delay) {\r\n      fn.apply(this, rest);\r\n      preT = currT;\r\n    }\r\n  }\r\n}\r\n```\r\n### 防抖\r\n> 在函数被触发n秒后再执行，如果在这n秒内又被触发，则重新计时。会导致函数被延迟执行。使用高阶函数，返回一个被定时器包裹的新函数，此函数在指定时间内若触发多次会导致上一次的函数不执行。\r\n\r\n- input框根据输入内容变化实时搜索的时候使用较多，用户停止输入后指定时间不再输入才会调用函数，节约请求资源。\r\n```\r\nconst debounce = (fn, delay) => {\r\n  let handle = null;\r\n  return (...rest) => {\r\n    if (handle) {\r\n      // 取消之前的延时调用\r\n      clearTimeout(handle);\r\n    }\r\n    handle = setTimeout(() => {\r\n      fn.apply(this, rest);\r\n    }, delay);\r\n  }\r\n}\r\n```\r\n### 返回一个promise的防抖\r\n- 可用于antd form的自定义校验validator场景。\r\n```\r\n// 返回一个promise函数的debounce\r\nconst promiseDebounce = (fn, delay) => {\r\n  let handle = null;\r\n  return (...rest) => {\r\n    if (handle) {\r\n      // 取消之前的延时调用\r\n      clearTimeout(handle);\r\n    }\r\n    return new Promise((resolve) => {\r\n      handle = setTimeout(() => {\r\n        resolve(fn.apply(null, rest));\r\n      }, delay);\r\n    });\r\n  };\r\n}\r\n```\r\n\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## 鉴权\r\n> 因为HTTP是无状态的协议，所谓无状态就是在两次请求之间服务器并不会保存任何的数据，请求之间没有任何相关信息。请求方和响应方间无法维护状态，都是一次性的，它不知道前后的请求发生了什么。\r\n\r\n### Session-Cookie\r\n1. 客户端：向服务器发送登录信息用户名/密码来请求登录校验；\r\n2. 服务器：验证登录的信息，验证通过后自动创建 Session（将 Session 保存在内存中，也可以保存在 Redis 中），然后给这个 Session 生成一个唯一的标识字符串会话身份凭证 session_id(通常称为 sid)，并在响应头 Set-Cookie 中设置这个唯一标识符；\r\n3. 客户端：收到服务器的响应后会解析响应头，并自动将 sid 保存在本地 Cookie 中，浏览器在下次 HTTP 请求时请求头会自动附带上该域名下的 Cookie 信息；\r\n4. 服务器：接收客户端请求时会去解析请求头 Cookie 中的 sid，然后根据这个 sid 去找服务端保存的该客户端的 sid，然后判断该请求是否合法；\r\n#### Session-Cookie 的优点\r\n- Cookie 简单易用\r\n- Session 数据存储在服务端，相较于 JWT 方便进行管理，也就是当用户登录和主动注销，只需要添加删除对应的 Session 就可以了，方便管理。\r\n- 只需要后端操作即可，前端可以无感等进行操作。\r\n#### Session-Cookie 的缺点\r\n- 依赖 Cookie，一旦用户在浏览器端禁用 Cookie，就不生效；\r\n- 非常不安全，Cookie 将数据暴露在浏览器中，增加了数据被盗的风险（容易被 CSRF 等攻击）；\r\n- Session 存储在服务端，增大了服务端的开销，用户量大的时候会大大降低服务器性能；\r\n- 对移动端的支持性不友好；\r\n#### Session存储方式\r\n- Redis（推荐）：内存型数据库，以 key-value 的形式存，正合 sessionId-sessionData 的场景；且访问快。\r\n- 内存：直接放到变量里。一旦服务重启就没了。\r\n- 数据库：普通数据库。性能不高。\r\n#### Session 的分布式问题\r\n> 通常服务端是集群，而用户请求过来会走一次负载均衡，不一定打到哪台机器上。那一旦用户后续接口请求到的机器和他登录请求的机器不一致，或者登录请求的机器宕机，session就会失效。\r\n\r\n- 从存储角度，把 session 集中存储。用独立的 Redis 或普通数据库可以把 session 都存到一个库里。(优先使用此方案,从分布角度处理相当于阉割了负载均衡，而且没有解决用户请求的机器宕机的问题)\r\n- 从分布角度，让相同 IP 的请求在负载均衡时都打到同一台机器上。以 nginx 为例，可以配置 ip_hash 来实现。\r\n### Token\r\n1. 客户端：输入用户名和密码请求登录校验；\r\n2. 服务器：收到请求，去验证用户名与密码；验证成功后，服务端会签发一个 Token 并把这个 Token 发送给客户端；\r\n3. 客户端：收到 Token 以后需要把它存储起来，web 端一般会放在 localStorage 或 Cookie 中，移动端原生 APP 一般存储在本地缓存中；\r\n4. 客户端发送请求：向服务端请求 API 资源的时候，将 Token 通过 HTTP 请求头 Authorization 字段或者其它方式发送给服务端；\r\n5. 服务器：收到请求，然后去验证客户端请求里面带着的 Token ，如果验证成功，就向客户端返回请求的数据，否则拒绝返还（401）；\r\n#### Token 的优点\r\n- 服务端无状态化、可扩展性好：Token 机制在服务端不需要存储会话（Session）信息，因为 Token 自身包含了其所标识用户的相关信息，这有利于在多个服务间共享用户状态；\r\n- 支持 APP 移动端设备；\r\n- 安全性好： 有效避免 CSRF 攻击（因为不需要 Cookie）；\r\n- 支持跨程序调用：因为 Cookie 是不允许跨域访问的，而 Token 则不存在这个问题；\r\n#### Token 的缺点：\r\n- 配合：需要前后端配合处理；\r\n- 占带宽：正常情况下比 sid 更大，消耗更多流量，挤占更多宽带；\r\n- 性能问题：虽说验证 Token 时不用再去访问数据库或远程服务进行权限校验，但是需要对 Token 加解密等操作，所以会更耗性能；\r\n- 有效期短：为了避免 Token 被盗用，一般 Token 的有效期会设置的较短，所以就有了 Refresh Token；\r\n#### Refresh Token\r\n1. 客户端： 输入用户名和密码请求登录校验；\r\n2. 服务端： 收到请求，验证用户名与密码；验证成功后，服务端会签发一个 Access Token 和 Refresh Token 并返回给客户端；\r\n3. 客户端： 把 Access Token 和 Refresh Token 存储在本地；\r\n4. 客户端发送请求： 请求数据时，携带 Access Token 传输给服务端；\r\n5. 服务端：\r\n  - 验证 Access Token 有效：正常返回数据\r\n  - 验证 Access Token 过期：拒绝请求\r\n6. 客户端 (Access Token 已过期) ： 则重新传输 Refresh Token 给服务端；\r\n7. 服务端 (Access Token 已过期) ： 验证 Refresh Token ，验证成功后返回新的 Access Token 给客户端；\r\n8. 客户端： 重新携带新的 Access Token 请求接口；\r\n### Token 和 Session-Cookie 的区别\r\n> Session-Cookie 和 Token 有很多类似的地方，但是 Token 更像是 Session-Cookie 的升级改良版。\r\n\r\n- 存储地不同：Session 一般是存储在服务端；Token 是无状态的，一般由前端存储；\r\n- 安全性不同：Session 和 Token 并不矛盾，作为身份认证 Token 安全性比 Session 好，因为每一个请求都有签名还能防止监听以及重放攻击；\r\n- 支持性不同： Session-Cookie 认证需要靠浏览器的 Cookie 机制实现，如果遇到原生 NativeAPP 时这种机制就不起作用了，或是浏览器的 Cookie 存储功能被禁用，也是无法使用该认证机制实现鉴权的；而 Token 验证机制丰富了客户端类型。\r\n### JWT（JSON Web Token）鉴权\r\n> 上述的Token形式服务端验证客户端发送过来的 Token 时，需要查询数据库获取用户基本信息，然后验证 Token 是否有效；这样每次请求验证都要查询数据库，增加了查库带来的延迟等性能消耗；JWT就是登录成功后将相关用户信息组成 JSON 对象，然后对这个对象进行某种方式的加密，返回给客户端；客户端在下次请求时带上这个 Token；服务端再收到请求时校验 token 合法性，其实也就是在校验请求的合法性。\r\n\r\n#### JWT 的优点\r\n- 不需要在服务端保存会话信息（RESTful API 的原则之一就是无状态），所以易于应用的扩展，即信息不保存在服务端，不会存在 Session 扩展不方便的情况；\r\n- JWT 中的 Payload 负载可以存储常用信息，用于信息交换，有效地使用 JWT，可以降低服务端查询数据库的次数。\r\n#### JWT 的缺点\r\n- 加密问题：JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。\r\n- 到期问题：由于服务器不保存 Session 状态，因此无法在使用过程中废止某个 Token，或者更改 Token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。\r\n### JWT 和 Token的区别\r\n> jwt和token区别主要体现在接收的信息是否需要进入数据库查询信息。\r\n\r\n### 单点登录\r\n#### 同域下的 SSO（主域名相同）\r\n> 当百度网站存在两个相同主域名下的贴吧子系统 tieba.baidu.com 和网盘子系统 pan.baidu.com 时，以下为他们实现 SSO 的步骤：\r\n\r\n1. 客户端：用户访问某个子系统时（例如 tieba.baidu.com），如果没有登录，则跳转至 SSO 认证中心提供的登录页面进行登录；\r\n2. 服务端：登录认证后，服务端把登录用户的信息存储于 Session 中，并且附加在响应头的 Set-Cookie 字段中，设置 Cookie 的 Domain 为 .baidu.com ；\r\n3. 客户端：再次发送请求时，携带主域名 Domain 下的 Cookie 给服务器，此时服务端就可以通过该 Cookie 来验证登录状态了；\r\n#### 跨域下的 SSO（主域名不同）\r\n> 购物网站天猫 (tmall.com) 和淘宝 (taobao.com) 中，利用CAS（Central Authentication Service）中央授权服务只需要登录其中某一个系统，另外一个系统打开后就会默认登录。\r\n\r\n![单点登录](./img/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95.png)\r\n1. 客户端：开始访问系统 A；\r\n2. 系统A：发现用户未登录，重定向至 CAS 认证服务（sso.com），同时 URL 地址参数携带登录成功后回跳到系统 A 的页面链接（sso.com/login?redir…）\r\n3. CAS认证服务：发现请求 Cookie 中没有携带登录的票据凭证（TGC），所以 CAS 认证服务判定用户处于 未登录 状态，重定向用户页面至 CAS 的登录界面，用户在 CAS 的登录页面上进行登录操作。\r\n4. 客户端：输入用户名密码进行 CAS 系统认证；\r\n5. CAS 认证服务：校验用户信息，并且 生成 TGC 放入自己的 Session 中，同时以 Set-Cookie 形式写入 Domain 为 sso.com 的域下 ；同时生成一个 授权令牌 ST (Service Ticket) ，然后重定向至系统 A 的地址，重定向的地址中包含生成的 ST（重定向地址：www.taobao.com?token=ST-345678）\r\n6. 系统A：拿着 ST 向 CAS 认证服务发送请求，CAS 认证服务验证票据 (ST) 的有效性。验证成功后，系统 A 知道用户已经在 CAS 登录了（其中的 ST 可以保存到 Cookie 或者本地中），系统 A 服务器使用该票据 (ST) 创建与用户的会话，称为局部会话，返回受保护资源；\r\n7. 客户端：开始访问系统 B；\r\n8. 系统B：发现用户未登录，重定向至 SSO 认证服务，并将自己的地址作为参数传递，并附上在 sso.com 域下的 cookie 值是第五步生成的 TGC；\r\n9. CAS 认证服务：CAS 认证服务中心发现用户已登录，跳转回系统 B 的地址，并附上票据 (ST)；\r\n10. 系统B：拿到票据 (ST)，去 CAS 认证服务验证票据 (ST) 的有效性。验证成功后，客户端也可以跟系统 B 通信。\r\n#### CAS 一般提供四个接口：\r\n- /login：登录接口，用于登录到中央授权服务。\r\n- /logout：登出接口，用于从中央授权服务中登出。\r\n- /validate：用于验证用户是否登录中央授权服务。\r\n- /serviceValidate：用于让各个 Service 验证用户是否登录中央授权服务。\r\n### 第三方登录\r\n1. a.com 的运营者需要在微信开放平台注册账号，并向微信申请使用微信登录功能。\r\n2. 申请成功后，得到申请的 appid、appsecret。\r\n3. 用户在 a.com 上选择使用微信登录。\r\n4. 这时会跳转微信的 OAuth 授权登录，并带上 a.com 的回调地址。\r\n5. 用户输入微信账号和密码，登录成功后，需要选择具体的授权范围，如：授权用户的头像、昵称等。\r\n6. 授权之后，微信会根据拉起 a.com?code=123 ，这时带上了一个临时票据 code。\r\n7. 获取 code 之后，a.com 会拿着 code 、appid、appsecret，向微信服务器申请 token，验证成功后，微信会下发一个 token。\r\n8. 有了 token 之后，a.com 就可以凭借 token 拿到对应的微信用户头像，用户昵称等信息了。\r\n9. a.com 提示用户登录成功，并将登录状态写入 Cooke，以作为后续访问的凭证。\r\n### 唯一登录\r\n> 用户只能在一个设备上登录，禁止用户重复登录。\r\n\r\n![唯一登录](./img/%E5%94%AF%E4%B8%80%E7%99%BB%E5%BD%95.png)\r\n- 用户在客户端 A 操作：\r\n  1. 输入账号请求登录接口；\r\n  2. 后端生成对应 Token 并且返回给客户端 A，并且在服务端保存一个登录状态；\r\n  3. 客户端A 保存 Token，并且每次请求都在 header 头中携带对应的 Token；\r\n- 用户在客户端 B 操作：\r\n  1. 突然用户在客户端 B 上开始登录操作，我们会发现，步骤和在客户端A上面的操作几乎是一致的；\r\n  2. 只是后端在生成新的 Token 时，要先验证登录状态，然后再生成对应新的 Token；\r\n  3. 客户端A再操作时发现Token过期提示重新登录。\r\n### 扫码登录\r\n![扫码登录](./img/%E6%89%AB%E7%A0%81%E7%99%BB%E5%BD%95.png)\r\n- 待扫码阶段：\r\n  1. PC端：打开某个网站 (如taobao.com) 或者某个 APP (如微信) 的扫码登录入口；就会携带 PC 端的设备信息向服务端发送一个获取二维码的请求；\r\n  2. 服务端：服务器收到请求后，随机生成一个 UUID 作为二维码 ID，并将 UUID 与 PC 端的设备信息 关联起来存储在 Redis 服务器中，然后返回给 PC 端；同时设置一个过期时间，在过期后，用户登录二维码需要进行刷新重新获取。\r\n  3. PC 端：收到二维码 ID 之后，将二维码 ID 以 二维码的形式 展示，等待移动端扫码。并且此时的 PC 端开始轮询查询二维码状态，直到登录成功。\r\n如果移动端未扫描，那么一段时间后二维码会自动失效。\r\n- 已扫码待确认阶段：\r\n  1. 手机端：打开手机端对应已登录的 APP (微信或淘宝等)，开始扫描识别 PC 端展示的二维码；\r\n移动端扫描二维码后，会自动获取到二维码 ID，并将移动端登录的信息凭证（Token）和二维码 ID 作为参数发送给服务端，此时手机必须是已登录（使用扫描登录的前提是移动端的应用为已登录状态，这样才可以共享登录态）。\r\n  2. 服务端：\r\n收到手机端发来的请求后，会将 Token 与二维码 ID 关联，为什么需要关联呢？因为，当我们在使用微信时，移动端退出时，PC 端也应该随之退出登录，这个关联就起到这个作用。然后会生成一个临时 Token，这个 Token 会返回给移动端，一次性 Token 用作确认时的凭证。\r\n- 已确认阶段：\r\n  1. 手机端：收到确认信息后，点击确认按钮，移动端携带上一步中获取的 临时 Token 发送给服务端校验；\r\n  2. 服务端：服务端校验完成后，会更新二维码状态，并且给 PC 端生成一个 正式的 Token，后续 PC 端就是持有这个 Token 访问服务端。\r\n  3. PC端：轮询到二维码状态为已登录状态，并且会获取到了生成的 Token，完成登录，后续访问都基于 Token 完成。\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## 闭包\r\n> 内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，就把返回的函数和这些变量的集合称为闭包。闭包中的数据会组成一个对象，然后保存在堆空间中。\r\n\r\n```\r\n// 当fn1函数执行完毕之后，其作用域是会被销毁的，然后垃圾回收器会释放那段内存空间。而闭包却很神奇的将fn1的作用域存活了下来，fn2依然持有该作用域的引用，这个引用就是闭包。由于返回的函数在其中引用了name的值，于是name的引用计数被+1。当返回函数不被垃圾回收时，则name也会一直存在。\r\nfunction fn1() {\r\n  const name = 'dyx';\r\n  function fn2() {\r\n    console.log(name);\r\n  }\r\n  return fn2;\r\n}\r\nconst fn3 = fn1();\r\nfn3();\r\n\r\n// 通过回调函数来进行函数值得传递\r\nfunction fn1() {\r\n  const name = 'dyx';\r\n  function fn2() {\r\n    console.log(name);\r\n  }\r\n  fn3(fn2);\r\n}\r\nfunction fn3(fn) {\r\n  fn();\r\n}\r\nfn1();\r\n```\r\n### 闭包的应用\r\n- debounce的闭包应用\r\n> handle变量在函数执行完之后并没有销毁，就是使用了闭包的原理。\r\n\r\n```\r\nconst debounce = (fn, delay) => {\r\n  let handle = null;\r\n  return (...rest) => {\r\n    if (handle) {\r\n      // 取消之前的延时调用\r\n      clearTimeout(handle);\r\n    }\r\n    handle = setTimeout(() => {\r\n      fn.apply(this, rest);\r\n    }, delay);\r\n  }\r\n}\r\n```\r\n- 模拟私有属性\r\n> 在JavaScript中是没有私有属性特性的，利用闭包来隐藏变量就可以模拟出私有属性的效果。\r\n\r\n```\r\nvar counter = (function() {\r\n  var count = 0;\r\n\r\n  return {\r\n    increment: function() {\r\n      count++;\r\n      return count;\r\n    },\r\n    zero: function() {\r\n      count = 0;\r\n      return count;\r\n    },\r\n    get value() {\r\n      return count;\r\n    },\r\n  };\r\n})();\r\n\r\ncounter.increment();\r\nconsole.log(counter.value); // 输出：1\r\ncounter.increment();\r\nconsole.log(counter.value); // 输出：2\r\n\r\nconsole.log(counter.count); // 输出：undefined\r\n```\r\n### 闭包的缺点\r\n> 由于闭包会引用外部函数的变量，但是这些变量在外部函数执行完毕后没有被释放，那么这些变量会一直存在于内存中。一旦形成闭包只有在页面关闭后闭包占用的内存才会被回收，这就造成了所谓的内存泄漏。\r\n\r\n- 及时释放闭包：手动调用闭包函数，并将其返回值赋值为null，这样可以让闭包中的变量及时被垃圾回收器回收。\r\n- 使用立即执行函数：在创建闭包时，将需要保留的变量传递给一个立即执行函数，并将这些变量作为参数传递给闭包函数，这样可以保留所需的变量，而不会导致其他变量的内存泄漏。\r\n\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## [预解析](https://www.jianshu.com/p/c3276ff58c93)\r\n> 在当前作用域中，在代码执行之前，浏览器首先会默认的把所有带var和function声明的变量进行提前的声明。var声明的变量在预解析的时候只是提前的声明并没有定义，function声明的函数在预解析的时候会提前声明并且会同时定义。程序最开始的时候，只对window下的变量和函数进行预解析，只有函数执行的时候才会对函数中的变量和函数进行预解析。\r\n\r\n### 在全局作用域中声明变量带var可以进行预解析；声明变量的时候不带var的时候，不能进行预解析\r\n- num2 = 12; 相当于给window增加了一个num2的属性名，属性值是12；\r\n- var num1 = 12; 相当于给全局作用域增加了一个全局变量num1，但是不仅如此，它也相当于给window增加了一个属性名num1，属性值是12；\r\n- 同一作用域重复声明不会报错，因为遇见var a = 2；会询问作用域是否已有a，如果有会忽略var，只解释a=2，会发生值的覆盖，如果没有var，则在当前作用域生成一个a变量。\r\n### 预解析的奇葩现象\r\n- 不管条件是否成立，都要把带var的进行提前的声明，因为在ES6之前并没有块级作用域的概念所以在{}之中的变量声明相当于全局的声明\r\n```\r\nif (false) { \r\n  var num = 12;\r\n}\r\nconsole.log(num); // undefined\r\n```\r\n- 只预解析“=”左边的，右边的是指针，不参与预解析,所以函数表达式的形式不会有函数提升的现象\r\n```\r\nfn();  // Uncaught TypeError: fn is not a function\r\nvar fn = function () {\r\n  console.log('ok');\r\n}\r\nfn(); // 'ok'\r\n\r\nfn1(); // 'ok1'\r\nfunction fn1() {\r\n  console.log('ok1');\r\n}\r\n```\r\n- 自执行函数定义的那个function在全局作用域下不进行预解析，当代码执行到这个位置的时候，定义和执行一起完成了。\r\n- 函数体中return下面的代码，虽然不再执行了，但是需要进行预解析，return中的代码，都是我们的返回值，所以不进行预解析。\r\n```\r\nfunction fn() {                             \r\n  console.log(num); // undefined\r\n  return function () {                                              \r\n  };                               \r\n  var num = 100;                   \r\n}                                  \r\nfn();\r\n```\r\n- 名字已经声明过了，不需要重新的声明，但是需要重新的赋值,当方法名称和变量名称一样时，变量被覆盖，同名的变量和函数预解析只会留下一个。\r\n```\r\n// 同一名称预解析只会留下一个，然后逐行解析，找关于预解析的表达式，找到就修改预解析的值。\r\nconsole.log(a)  // function a(){console.log(2)}  函数会覆盖变量\r\nvar a=1;\r\nconsole.log(a)  // 1\r\nfunction a(){console.log(2)}\r\nconsole.log(a) // 1\r\nvar a=3;\r\nconsole.log(a) // 3\r\na() // a is not a function\r\n```\r\n### 示例\r\n```\r\nfunction a(){\r\n  var a=1;\r\n  a=2;\r\n  var b=g();\r\n  a=3;\r\n  return b;\r\n  function g(){\r\n    return a;\r\n  }\r\n}\r\nconsole.log(a()) // 2\r\n\r\n// 变量将从作用域链中去寻找，但是 依据的是函数定义时的作用域链，而不是函数执行时\r\nfunction F1() {\r\n  var a = 100\r\n  return function () {\r\n    console.log(a)\r\n  }\r\n}\r\n\r\nfunction F2(f1) {\r\n  var a = 200\r\n  console.log(f1())\r\n}\r\nvar f1 = F1()\r\nF2(f1) // 100\r\n\r\n// 即使有if在但是声明变量依然提升了，进行了变量声明\r\nfunction a(bool) {\r\n  if(bool) {\r\n    var x=10;\r\n  }\r\n  return x;\r\n}\r\nconsole.log(a(true)) // 10\r\nconsole.log(a(false)) // undefined\r\n```"},function(r,n,e){"use strict";e.r(n),n.default='## 高级函数用法\r\n### compose组合函数\r\n> 把逻辑解耦在各个函数中，通过compose的方式组合函数，将外部数据依次通过各个函数的加工，生成结果。先执行后传入的函数。\r\n\r\n#### redux源码中的中间件的处理使用的函数\r\n```\r\nfunction compose(...funcs) {\r\n\tif (funcs.length === 0) {\r\n\t\treturn arg => arg;\r\n\t}\r\n\r\n\tif (funcs.length === 1) {\r\n\t\treturn funcs[0];\r\n\t}\r\n\t\r\n\treturn funcs.reduce((a, b) => (...args) => a(b(...args)));\r\n} \r\n```\r\n#### compose组合函数使用示例\r\n```\r\nlet a = x => x + "。";\r\nlet b = x => x + "!";\r\nlet c = x => x + "?";\r\nlet combineFun = compose(a, b, c)\r\ncombineFun(\'dyx\') // dyx?!。\r\n```\r\n#### 洋葱圈模型\r\n> 通过以上的组合函数使传入的中间件函数变成(...arg) => mid1(mid2(mid3(...arg)))，最后执行的中间件mid3最先执行完，最先执行的mid1最后执行完，是符合洋葱圈模型的。\r\n\r\n### 柯里化函数\r\n> 函数使用更加灵活，可以一次传入所有参数调用也可以只传入一部分参数调用，让它返回一个函数去处理剩余的参数。\r\n\r\n```\r\nfunction curry(fn) {\r\n  let judge = (...args) => {\r\n    // 一次传递了所有参数 则直接调用\r\n    if (args.length >= fn.length) {\r\n      return fn(...args);\r\n    } \r\n    return (...arg) => judge(...args, ...arg);\r\n  }\r\n  return judge;\r\n}\r\n\r\nfunction add(a, b, c) {\r\n  return a + b + c;\r\n}\r\nadd(1, 2, 3) // 6\r\n\r\nconst addCurry = curry(add);\r\nconsole.log(addCurry(1, 2, 3)); // 6\r\nconsole.log(addCurry(1)(2)(3)); // 6\r\nconsole.log(addCurry(1, 2)(3)); // 6\r\nconsole.log(addCurry(1)(2, 3)); // 6\r\n```\r\n### 高阶函数\r\n> 高阶函数是一个接收函数作为参数或将函数作为输出返回的函数。Array.prototype.map，Array.prototype.filter 和 Array.prototype.reduce 是语言中内置的一些高阶函数。\r\n\r\n### 纯函数\r\n> 一个函数的返回结果只依赖于它的参数，并且在执行过程里面没有副作用，我们就把这个函数叫做纯函数。'},function(r,n,e){"use strict";e.r(n),n.default="## [二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree)\r\n> 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。\r\n\r\n- 遍历整个二叉树，使用allParents(Map形式数据)存储所有的叶子节点与父级的对应关系。\r\n- 找到p节点所有的父级及p节点并存储，使用someOneParents(Set形式数据)存储p节点及其所有的父级节点。\r\n- 向上查找另一个子节点q的所有父级，如果也是p节点的父级则表示是两个子节点的公共父级。\r\n```\r\n```\r\nvar lowestCommonAncestor = (root, p, q) => {\r\n  const someOneParents = new Set(); // 存储一个子节点的父级\r\n  const allParents = new Map(); // 存储叶子节点的父级\r\n  // 存储所有叶子节点的父级\r\n  const dfs = (root) => {\r\n    if (root.left != null) {\r\n      allParents.set(root.left.val, root);\r\n      dfs(root.left);\r\n    }\r\n    if (root.right != null) {\r\n      allParents.set(root.right.val, root);\r\n      dfs(root.right);\r\n    }\r\n  }\r\n  dfs(root);\r\n\r\n  // 找到所有p的父级及p并存储\r\n  while (p != null) {\r\n    someOneParents.add(p.val);\r\n    p = allParents.get(p.val);\r\n  }\r\n  \r\n  // 向上查找q的父级，如果也在p父级中则表示是两者公共的父级\r\n  while (q != null) {\r\n    if (someOneParents.has(q.val)) {\r\n      return q;\r\n    }\r\n    q = allParents.get(q.val);\r\n  }\r\n  return null;\r\n};\r\n```\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## [二叉搜索树中的搜索](https://leetcode.cn/problems/search-in-a-binary-search-tree/)\r\n> 给定二叉搜索树（左叶子节点比父节点小，右叶子节点比父节点大）的根节点 root 和一个整数值 val。你需要在二叉搜索树中找到节点值等于 val 的节点。 返回以该节点为根的子树。如果节点不存在，则返回 null。\r\n\r\n- 从根节点开始遍历，值相同则返回。\r\n- 如果节点的值大于要比较的值，则遍历当前节点的左子节点(左子节点比父节点的值小)。\r\n- 否则遍历当前节点的右子节点(右子节点比父节点的值大)。\r\n```\r\nvar searchBST = (root, val) => {\r\n  if (root === null) {\r\n    return null;\r\n  }\r\n  if (root.val === val) {\r\n    return root;\r\n  }\r\n  if (root.val > val) {\r\n    return searchBST(root.left, val);\r\n  } else if (root.val < val) {\r\n    return searchBST(root.right, val);\r\n  }\r\n};\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## [二叉树中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/)\r\n> 给定一个二叉树的根节点root ，返回它的中序遍历（左、中、右）。\r\n\r\n![二叉树中序遍历](../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/img/二叉树中序遍历.png)\r\n- 先判断是否存在左分支，存在则对左分支进行递归。\r\n- 左分支不存在时，将此时的值push进数组中。\r\n- 再判断是否存在右分支，存在则对右分支进行递归。\r\n```\r\nvar inorderTraversal = function(root, res = []) {\r\n  if (!root) return [];\r\n  if (root.left) {\r\n    inorderTraversal(root.left, res);\r\n  }\r\n  res.push(root.val);\r\n  if (root.right) {\r\n    inorderTraversal(root.right, res);\r\n  }\r\n  return res;\r\n};\r\n```\r\n- TODO:\r\n```\r\nconst inorderTraversal = (root) => {\r\n  if (!root) return [];\r\n  // 新建一个栈\r\n  const stack = [];\r\n  let point = root;\r\n  const res = [];\r\n  while (stack.length || point) {\r\n    // 栈内推入左分支节点\r\n    while (point) {\r\n      stack.push(point)\r\n      point = point.left\r\n    }\r\n    const n = stack.pop();\r\n    res.push(n.val)\r\n    point = n.right;\r\n  }\r\n  return res;\r\n}\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## [二叉树前序遍历](https://leetcode.cn/problems/binary-tree-preorder-traversal/)\r\n> 给定一个二叉树的根节点root ，返回它的前序遍历（中、左、右）。\r\n\r\n![二叉树前序遍历](../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/img/二叉树先序遍历.png)\r\n- 将当前节点的值push进数组中。\r\n- 判断是否存在左分支，存在则对左分支进行递归。\r\n- 再判断是否存在右分支，存在则对右分支进行递归。\r\n```\r\nvar preorderTraversal = function(root, res = []) {\r\n  if (!root) return [];\r\n  res.push(root.val);\r\n  if (root.left) {\r\n    preorderTraversal(root.left, res);\r\n  }\r\n  if (root.right) {\r\n    preorderTraversal(root.right, res);\r\n  }\r\n  return res;\r\n};\r\n```\r\n- 新建一个栈stack默认为根节点，遍历栈。\r\n- 将当前节点出栈并将当前节点的值push进数组中。\r\n- 判断当前节点是否存在右分支，存在则推入栈中。\r\n- 再判断当前节点是否存在左分支，存在则推入栈中(前序遍历先遍历左分支后遍历右分支，所以左分支在右分之后面push)。\r\n```\r\nvar preorderTraversal = function(root) {\r\n  if (!root) return [];\r\n  const res = []; // 存储最终结果\r\n  // 新建一个栈\r\n  const stack = [root];\r\n  while (stack.length > 0) {\r\n    const currentNode = stack.pop();\r\n    res.push(currentNode.val);\r\n    // 先遍历左分支后遍历右分支，所以左分支在右分之后面push\r\n    if (currentNode.right) {\r\n      stack.push(currentNode.right);\r\n    }\r\n    if (currentNode.left) {\r\n      stack.push(currentNode.left);\r\n    } \r\n  }\r\n  return res;\r\n};\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## [二叉树后序遍历](https://leetcode.cn/problems/binary-tree-postorder-traversal/)\r\n> 给定一个二叉树的根节点root ，返回它的前序遍历（左、右、中）。\r\n\r\n![二叉树后序遍历](../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/img/二叉树后序遍历.png)\r\n- 先判断是否存在左分支，存在则对左分支进行递归。\r\n- 再判断是否存在右分支，存在则对右分支进行递归。\r\n- 将当前节点的值push进数组中。\r\n```\r\nvar postorderTraversal = function(root, res = []) {\r\n  if (!root) return [];\r\n  if (root.left) {\r\n    postorderTraversal(root.left, res);\r\n  }\r\n  if (root.right) {\r\n    postorderTraversal(root.right, res);\r\n  }\r\n  res.push(root.val);\r\n  return res;\r\n};\r\n```\r\n- 新建一个栈stack默认为根节点，遍历栈。\r\n- 将当前节点出栈并将当前节点的值push进数组中。\r\n- 判断当前节点是否存在左分支，存在则推入栈中。\r\n- 再判断当前节点是否存在右分支，存在则推入栈中。\r\n- 上述的遍历最终push数组中的顺序是中、右、左，所以将数组reverse翻转后输出。\r\n```\r\nvar postorderTraversal = function(root) {\r\n  if (!root) return [];\r\n  const res = []; // 存储最终结果\r\n  // 新建一个栈\r\n  const stack = [root];\r\n  while (stack.length > 0) {\r\n    const currentNode = stack.pop();\r\n    res.push(currentNode.val);\r\n    if (currentNode.left) {\r\n      stack.push(currentNode.left);\r\n    }\r\n    if (currentNode.right) {\r\n      stack.push(currentNode.right);\r\n    }\r\n  }\r\n  return res.reverse();\r\n};\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## [二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)\r\n> 给定一个二叉树，找出其最大深度。最大深度是从根节点到最近叶子节点的最长路径上的节点数量。\r\n\r\n- 当根节点root不存在时，返回0。\r\n- 递归向下计算左右节点的值，返回大的值。\r\n```\r\nvar maxDepth = function(root) {\r\n  if (!root) {\r\n    return 0;\r\n  } else {\r\n    const left = maxDepth(root.left);\r\n    const right = maxDepth(root.right);\r\n    return Math.max(left, right) + 1;\r\n  }\r\n};\r\n```\r\n- 创建变量res用于存储最大深度的值。\r\n- 创建dfs方法(接受当前树节点以及目前的最大深度值两个参数)用于遍历树节点以及更行res的值。\r\n  1. 没有当前树节点直接return\r\n  2. 当前树节点没有叶子节点就更新深度值的变量res\r\n  3. 调用dfs方法传入当前树节点的左叶子节点和当前最大深度值\r\n  4. 调用dfs方法传入当前树节点的右叶子节点和当前最大深度值\r\n\r\n```\r\nvar maxDepth = function (root) {\r\n  let res = 0;\r\n  const dfs = (n, l) => {\r\n    if (!n) return;\r\n    if (!n.left && !n.right) {\r\n     // 没有叶子节点就把深度数量更新\r\n      res = Math.max(res, l);\r\n    }\r\n    dfs(n.left, l + 1)\r\n    dfs(n.right, l + 1)\r\n  }\r\n  dfs(root, 1);\r\n  return res;\r\n}\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## [二叉树的最小深度](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)\r\n> 给定一个二叉树，找出其最小深度。最小深度是从根节点到最近叶子节点的最短路径上的节点数量。\r\n\r\n- 当根节点root不存在时，返回0。\r\n- 当左右节点都不存在时，返回1。\r\n- 当右叶节点不存在时，则此时最短为左叶节点，递归向下计算。\r\n- 当左叶节点不存在时，则此时最短为右叶节点，递归向下计算。\r\n- 当左右节点都存在时，递归向下计算左右节点的值，返回小的值。\r\n```\r\nvar minDepth = (root) => {\r\n  if (!root) {\r\n    return 0;\r\n  }\r\n  if (root.right === null && root.left === null) {\r\n    return 1;\r\n  }\r\n  if (root.left && !root.right) {\r\n    return 1 + minDepth(root.left);\r\n  }\r\n  if (!root.left && root.right) {\r\n    return 1 + minDepth(root.right);\r\n  }\r\n  return 1 + Math.min(minDepth(root.left), minDepth(root.right));\r\n}\r\n```\r\n- 当根节点root不存在时，返回0。\r\n- 创建二维数组，第一项存储`[当前节点，当前节点的深度]`。\r\n- 循环此二维数组，使用shift方法获取数组的第一项，获取当前循环的节点和当前循环节点的深度。\r\n- 如果当前循环的节点没有叶子节点直接返回当前循环节点的深度为最小深度。\r\n- 如果当前循环的节点有左叶子节点则向数组中存储`[当前节点的左叶子节点，当前节点的深度 + 1]`。\r\n- 如果当前循环的节点有右叶子节点则向数组中存储`[当前节点的右叶子节点，当前节点的深度 + 1]`。\r\n```\r\nvar minDepth = function (root) {\r\n  if (!root) {\r\n    return 0;\r\n  }\r\n  // 存储根节点和根节点的深度1\r\n  const q = [[root, 1]];\r\n  while (q.length) {\r\n    // 取出当前节点\r\n    const [n, l] = q.shift();\r\n    // 如果是叶子节点直接返回深度就可\r\n    if (!n.left && !n.right) {\r\n      return l;\r\n    } \r\n    if (n.left) {\r\n      q.push([n.left, l + 1]);\r\n    }\r\n    if (n.right) {\r\n      q.push([n.right, l + 1]);\r\n    }\r\n  }\r\n}\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## [对称二叉树](https://leetcode.cn/problems/symmetric-tree)\r\n> 给你一个二叉树的根节点 root ， 检查它是否轴对称。\r\n\r\n- 递归判断左右树节点是否相同\r\n- 因为是对称二叉树，判断左右树时需要注意\r\n  1. 使用左侧树的左节点比较右侧树的右节点\r\n  2. 使用左侧树的右节点比较右侧树的左节点\r\n```\r\nvar isSymmetric = function (root) {\r\n  if (!root) {\r\n    return true;\r\n  }\r\n  const isMirror = (l, r) => {\r\n    if (!l && !r) {\r\n      return true;\r\n    }\r\n    if (\r\n      l && r \r\n      && l.val === r.val\r\n      && isMirror(l.left, r.right)\r\n      && isMirror(l.right, r.left)\r\n    ) {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n  return isMirror(root.left, root.right);\r\n};\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## [相同的树](https://leetcode.cn/problems/same-tree)\r\n> 给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。\r\n\r\n- 递归比较两棵树对应的各个节点。\r\n```\r\nvar isSameTree = function (p, q) {\r\n  if (!p && !q) {\r\n    return true;\r\n  }\r\n  if (\r\n    p && q\r\n    && p.val === q.val\r\n    && isSameTree(p.left, q.left)\r\n    && isSameTree(p.right, q.right)\r\n  ) {\r\n    return true;\r\n  }\r\n  return false;\r\n};\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## [翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/)\r\n> 给定一棵二叉树的根节点root ，翻转这棵二叉树，并返回其根节点。\r\n\r\n- 递归处理每个树节点\r\n  1. 当前树节点的val不变\r\n  2. 当前树节点的左侧节点修改成当前树节点的右侧节点\r\n  3. 当前树节点的右侧节点修改成当前树节点的左侧节点\r\n```\r\nvar invertTree = function (root) {\r\n  if (!root) return null;\r\n  return {\r\n    val: root.val,\r\n    left: invertTree(root.right),\r\n    right: invertTree(root.left)\r\n  }\r\n};\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## [两数之和](https://leetcode.cn/problems/two-sum/)\r\n> 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。\r\n\r\n- 对整数数组进行循环，创建Map，每一次循环以当前项与目标值的差值为key，当前项的下标为value进行存储。\r\n- 循环过程中Map中存在以当前项为key的值时表示已找到两个相加为目标值的数字，对应的数组下标分别是当前循环项的下标和Map中以当前项为key的值。\r\n- 注意：应该先判断Map中是否存在以当前项为key的值再进行Map的存储，从而避免数组当前项与目标值 - 当前项值相同的情况(数组当前项为3，target为6，如果先进行Map存储，此时Map中是否存在以当前项为key的值的判断会成立所以应该先判断再进行Map存储)。\r\n```\r\nvar twoSum = function(nums, target) {\r\n  const objMap = new Map();\r\n  for (let index = 0; index < nums.length; index++) {\r\n    const item = nums[index];\r\n    if (objMap.has(item)) {\r\n      return [index, objMap.get(item)];\r\n      break;\r\n    }\r\n    objMap.set(target - item, index);\r\n  }\r\n};\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## [二进制求和](https://leetcode.cn/problems/add-binary/)\r\n> 两个二进制字符串 a 和 b ，以二进制字符串的形式返回它们的和。\r\n\r\n- 使用padStart方法将两个字符串设置成相同长度，较短的字符串前面填充为0。\r\n- 设置一个变量frontAdd表示前一项是否要加一。\r\n- 从后往前遍历两个字符串，两个当前项相加如果frontAdd为true则再加一，如果相加的结果大于等于2，设置当前项为 相加的结果 - 2且frontAdd设置为true，否则设置当前项为相加的结果且frontAdd设置为false。\r\n- 遍历结束之后，如果frontAdd为true，最终的字符串的最前加一位设置为1。\r\n```\r\nvar addBinary = function(a, b) {\r\n  const maxLength = Math.max(a.length, b.length);\r\n  const newA = a.padStart(maxLength, 0);\r\n  const newB = b.padStart(maxLength, 0);\r\n  let frontAdd = false; // 前一项是否要加一\r\n  let res = ''; // 最后返回结果\r\n  for (let index = maxLength - 1; index >= 0; index--) {\r\n    const aItem = Number(newA[index]);\r\n    const bItem = Number(newB[index]);\r\n    let addItem = aItem + bItem;\r\n    if (frontAdd) {\r\n      addItem += 1;\r\n    }\r\n    if (addItem >= 2) {\r\n      res = (addItem - 2) + res;\r\n      frontAdd = true;\r\n    } else {\r\n      res = addItem + res;\r\n      frontAdd = false;\r\n    }\r\n  }\r\n  if (frontAdd) {\r\n    res = 1 + res; \r\n  }\r\n  return res;\r\n};\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## [删除有序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/)\r\n> 给你一个升序排列的数组nums，原地删除重复出现的元素，使每个元素只出现一次，返回删除后数组的新长度。元素的 相对顺序应该保持一致。\r\n\r\n- 遍历循环传入的数组，如果当前项等于下一项时，删除数组中对应当前index的值，因为删除数组元素，所以同时需要将当前循环的指针index值减一继续循环。\r\n```\r\nvar removeDuplicates = function(nums) {\r\n  for (let index = 0; index < nums.length; index++) {\r\n    const item = nums[index];\r\n    if (nums[index] === nums[index + 1]) {\r\n      nums.splice(index, 1);\r\n      index -= 1;\r\n    }\r\n  }\r\n};\r\n```\r\n- 创建快慢指针，循环数组，如果快慢指针对应值相同，则快指针+1。\r\n- 如果快慢指针对应的值不同，将慢指针加1，同时将此时慢指针的值修改为快指针对应的值。将后面较大的数值移动到前面，保持前面的数组为有序数组。\r\n- 直到快指针等于数组长度时循环结束。\r\n```\r\nconst removeDuplicates = (nums) => {\r\n  if (nums.length <= 1) return nums.length;\r\n  let slow = 0, quick = 0;\r\n  while (quick < nums.length) {\r\n    while (nums[slow] === nums[quick] && quick < nums.length) quick++;\r\n    if (nums[slow] !== nums[quick] && quick < nums.length) {\r\n      slow++;\r\n      nums[slow] = nums[quick];\r\n      quick++;\r\n    }\r\n  }\r\n  return slow + 1;\r\n};\r\n```\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## 加一\r\n> 给一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。可以假设除了整数 0 之外，这个整数不会以零开头。\r\n\r\n- 从后向前循环，如果循环的当前项不为9，直接当前项加一返回数组。\r\n- 如果循环的当前项为9，则当前项修改为0，在这里并不需要对前一位加一，因为它是向前遍历最后返回的时候第一项会加1。\r\n- 最终返回的数组为 [1, ...digits]。\r\n```\r\nvar plusOne = function(digits) {\r\n  for (let i = digits.length - 1; i >= 0; i--) {\r\n    if (digits[i] !== 9) {\r\n      digits[i]++;\r\n      return digits;\r\n    } else {\r\n      // 在这里并不需要对前一位加一，因为它是向前遍历的前面一位会自己加一\r\n      digits[i] = 0;\r\n    }\r\n  }\r\n  return [1, ...digits];\r\n};\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## [回文数](https://leetcode.cn/problems/palindrome-number/)\r\n> 一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。\r\n\r\n- 将整数转为字符串再使用split方法转为数组，转为数组之后使用reverse方法反转数组，再使用join方法生成新的字符串。\r\n- 判断新生成的字符串和传入的数字字符串是否相等\r\n```\r\nvar isPalindrome = function(x) {\r\n  const reverseString = `${x}`.split('').reverse().join('');\r\n  return `${x}` === reverseString;\r\n};\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## 搜索插入位置\r\n> 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。必须使用时间复杂度为 O(log n) 的算法。\r\n\r\n- 因为要求使用时间复杂度为 O(log n) 的算法，所以使用二分法进行查找。\r\n- 设置两个变量表示左右两个指针分别为0和数组的长度减一，取两个值的中间值作为索引与目标值比较，中间索引的值小于目标值则左指针加一，中间索引的值大于目标值则右指针减一，中间索引的值等于目标值返回当前的中间索引值。\r\n- 当左索引大于右索引时表示没有找到对应的值，此时返回左索引的值则是插入目标值的位置。\r\n```\r\nconst searchInsert = (nums, target) => {\r\n  let left = 0, right = nums.length - 1;\r\n  while (left <= right) {\r\n    let mid = Math.floor((left + right) / 2);\r\n    if(nums[mid] == target) {\r\n      return mid;\r\n    } else if(nums[mid] < target) {\r\n      left = mid + 1;\r\n    } else {\r\n      right = mid - 1;\r\n    }\r\n  }\r\n  return left;\r\n}\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## [最后一个单词长度](https://leetcode.cn/problems/length-of-last-word/)\r\n> 给一个字符串s，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中最后一个单词的长度。单词指仅由字母组成、不包含任何空格字符的最大子字符串。\r\n\r\n- 先使用trim方法将传入的字符去除头尾的空格字符\r\n- 设定一个变量finalLength初始值为0用于存储单词长度\r\n- 循环字符串，如果当前项有值则finalLength加1，否则 finalLength 重置为0。\r\n- 直到循环结束返回最终的finalLength值则是最后一个单词的长度。\r\n```\r\nvar lengthOfLastWord = function(s) {\r\n  let finalLength = 0;\r\n  const sTrim = s.trim();\r\n  for (let index = 0; index < sTrim.length; index++) {\r\n    const item = sTrim[index];\r\n    if (item.trim()) {\r\n      finalLength += 1;\r\n    } else {\r\n      finalLength = 0;\r\n    }\r\n  }\r\n  return finalLength;\r\n};\r\n```"},function(r,n,e){"use strict";e.r(n),n.default='## [最长公共前缀](https://leetcode.cn/problems/longest-common-prefix/)\r\n> 编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 ""。\r\n\r\n- 使用数组的reduce方法对当前项和下一项的字符串进行循环比较获取最长的公共前缀，将当前获取到的公共前缀返回作为当前项再与后一项进行比较，直到返回最终的公共前缀。\r\n- 当前项和下一项的字符串进行循环比较获取最长的公共前缀时一旦匹配不上需要退出循环否则会出现错误，比如`["cir","car"]`不退出循环获取到的最长公共前缀将是\'cr\'。\r\n\r\n```\r\nvar longestCommonPrefix = function(strs) {\r\n  const prefix = strs.reduce((prev, curr) => {\r\n    let currentPrefix = \'\'\r\n    for (let index = 0; index < prev.length; index++) {\r\n      if (prev[index] === curr[index]) {\r\n        currentPrefix += prev[index];\r\n      } else {\r\n        break;\r\n      }\r\n    }\r\n    return currentPrefix;\r\n  })\r\n  return prefix;\r\n};\r\n```'},function(r,n,e){"use strict";e.r(n),n.default="## 有效的括号\r\n> 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。\r\n\r\n- 维护一个所有括号类型的对象\r\n- 循环字符串使用数组模拟栈的数据结构，如果是左括号入栈，如果是右括号时判断：\r\n  1. 如果栈内没有数据，直接返回false\r\n  2. 有数据移除栈顶的元素，使用栈顶元素作为key从括号类型的对象进行匹配，如果匹配到的内容不等于当前循环的括号类型直接返回false\r\n- 循环结束之后判断栈的长度，长度为0表示完全匹配括号有效否则无效。\r\n```\r\nvar isValid = function(s) {\r\n  const pairingMap = {\r\n    '(': ')',\r\n    '[': ']',\r\n    '{': '}'\r\n  }\r\n  const stack = [];\r\n  for(let i of s) {\r\n    if (pairingMap[i]) {\r\n      // 左括号入栈\r\n      stack.push(i)\r\n    } else {\r\n      // 右括号匹配\r\n      // 1. 如果栈内没有数据，直接false\r\n      // 2. 有数据但是栈顶元素不是当前的右括号\r\n      if (!stack.length || pairingMap[stack.pop()] !== i) {\r\n        return false\r\n      }\r\n    }\r\n  }\r\n  // 栈内还有数据说明没有完全匹配\r\n  return !stack.length\r\n};\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## [爬楼梯](https://leetcode.cn/problems/climbing-stairs/)\r\n> 需要 n 阶才能到达楼顶。每次可以爬 1 或 2 个台阶。一共有多少种不同的方法可以爬到楼顶。\r\n\r\n- 定义一个数组res，定义数组的每一项值代表爬上第 i 级台阶有多少种方案。对于不同的i有不同的值。\r\n- 初始 res[0] = 1; res[1] = 1;表示爬0阶和1阶都只有一种方法。\r\n- 再将问题分成多个子问题，爬第n阶楼梯的方法数量，等于爬上 n-1 阶楼梯的方法数量和爬上 n-2 阶楼梯的方法数量。\r\n```\r\nvar climbStairs = function (n) {\r\n  const res = [];\r\n  res[0] = 1;\r\n  res[1] = 1;\r\n  for (let i = 2; i <= n; i++) {\r\n    res[i] = res[i - 1] + res[i - 2]\r\n  }\r\n  return res[n];\r\n};\r\n```\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## [移除数组元素](https://leetcode.cn/problems/remove-element/)\r\n> 一个数组 nums 和一个值 val，需要 原地 移除所有数值等于 val 的元素。\r\n\r\n- 遍历循环传入的数组，如果当前项等于传入的值时，删除数组中对应当前index的值，因为删除数组元素，所以同时需要将当前循环的指针index值减一继续循环。\r\n```\r\nvar removeElement = function(nums, val) {\r\n  for (let index = 0; index < nums.length; index++) {\r\n    const item = nums[index];\r\n    if (item === val) {\r\n      nums.splice(index, 1);\r\n      index -= 1;\r\n    }\r\n  }\r\n};\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## [罗马数字转整数](https://leetcode.cn/problems/roman-to-integer/)\r\n> 给定一个罗马数字，将其转换成整数。\r\n\r\n- 将罗马数字所对应整数的值维护在对象中，循环字符串进行匹配，根据罗马数字的规则进行不同的匹配(当前项和后一项的大小比较区分两种情况)。\r\n- 罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况。\r\n  1. I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。\r\n  2. X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 \r\n  3. C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。\r\n\r\n```\r\nvar romanToInt = function(s) {\r\n  const romanObj = {\r\n    I: 1,\r\n    V: 5,\r\n    X: 10,\r\n    L: 50,\r\n    C: 100,\r\n    D: 500,\r\n    M: 1000,\r\n    IV: 4,\r\n    IX: 9,\r\n    XL: 40,\r\n    XC: 90,\r\n    CD: 400,\r\n    CM: 900,\r\n  };\r\n  let num = 0;\r\n  for (let index = 0; index < s.length; index++) {\r\n    const item = s[index];\r\n    const nextItem = s[index + 1];\r\n    if (index + 1 <= s.length) {\r\n      if (romanObj[nextItem]) {\r\n        if (romanObj[item] >= romanObj[nextItem]) {\r\n          num += romanObj[item];\r\n        } else {\r\n          num += romanObj[`${item}${nextItem}`];\r\n          index ++;\r\n        }\r\n      } else {\r\n        num += romanObj[item];\r\n      }\r\n    }\r\n  }\r\n  return num;\r\n};\r\n```\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## [设计哈希映射](https://leetcode.cn/problems/design-hashmap)\r\n> 实现 MyHashMap 类：put(int key, int value) 向 HashMap 插入一个键值对 (key, value)。如果 key 已经存在于映射中，则更新其对应的值 value；get(int key) 返回特定的 key 所映射的 value；如果映射中不包含 key 的映射，返回 -1；remove(key) 如果映射中存在 key 的映射，则移除 key 和它所对应的 value。\r\n\r\n- 使用二维数组进行存储数据\r\n  1. put方法直接使用push方法往数组中添加内容（判断是否已有此key，有此key时更新对应的value）。\r\n  2. get方法，遍历数组获取对应相同key数据对应的value值，没有找到则返回-1。\r\n  3. remove方法，遍历数组获取对应相同key数据的index值，删除该项。\r\n```\r\n// 建立哈希表 用数组每一项存储每一个哈希值对应链表\r\nvar MyHashMap = function() {\r\n  const hash = new Array(2069);\r\n  for (var i = 0; i < hash.length; i++) {\r\n    hash[i] = [];\r\n  }\r\n  this.hash = hash;\r\n};\r\n\r\nfunction getIndex(key) {\r\n  const N = 2069;\r\n  return key % N;\r\n}\r\n\r\nMyHashMap.prototype.put = function(key, value) {\r\n  const index = getIndex(key); // 获取哈希索引\r\n  \r\n  // 如果当前索引对应的桶里面没有值， 直接放入 \r\n  if (this.hash[index].length === 0) {\r\n    this.hash[index].push([key, value]);\r\n    return;\r\n  }\r\n\r\n  // 否则先遍历该桶，判断是否已有对应的key， 如果有就更新key\r\n  for(var i = 0; i < this.hash[index].length; i++) {\r\n    let tuple = this.hash[index][i];\r\n    if (tuple[0] === key) {\r\n      tuple[1] = value;\r\n      return;\r\n    }\r\n  }\r\n  // 如果桶中没有新加的key值，那就把key加入\r\n  this.hash[index].push([key, value]);\r\n};\r\n\r\n\r\nMyHashMap.prototype.get = function(key) {\r\n  const index = getIndex(key); // 获取哈希索引\r\n\r\n  for(var i = 0; i < this.hash[index].length; i++) {\r\n    let tuple = this.hash[index][i];\r\n    if (tuple[0] === key) {\r\n      return tuple[1];\r\n    }\r\n  }\r\n  return -1;\r\n};\r\n\r\n\r\nMyHashMap.prototype.remove = function(key) {\r\n  const index = getIndex(key); // 获取哈希索引\r\n  for(var i = 0; i < this.hash[index].length; i++) {\r\n    let tuple = this.hash[index][i];\r\n    if (tuple[0] === key) {\r\n      this.hash[index].splice(i, 1);\r\n    }\r\n  }\r\n};\r\n\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## [设计哈希集合](https://leetcode.cn/problems/design-hashset)\r\n> 实现 MyHashSet 类：add(key) 向哈希集合中插入值 key。contains(key) 返回哈希集合中是否存在这个值 key 。\r\nremove(key) 将给定值 key 从哈希集合中删除。如果哈希集合中没有这个值，什么也不做。\r\n\r\n- 使用数组进行存储数据\r\n  1. add方法直接使用push方法往数组中添加内容。\r\n  2. remove方法，遍历数组删除对应的元素。\r\n  3. contains方法，使用indexOf方法判断数组中是否有此元素。\r\n```\r\nvar MyHashSet = function() {\r\n  this.arr = [];\r\n};\r\n\r\nMyHashSet.prototype.add = function(key) {\r\n  this.arr.push(key);\r\n};\r\n\r\nMyHashSet.prototype.remove = function(key) {\r\n  for (let i = 0; i < this.arr.length; i++) {\r\n    if (this.arr[i] === key) {\r\n      this.arr.splice(i, 1);\r\n      i--;\r\n    }\r\n  }\r\n};\r\n\r\nMyHashSet.prototype.contains = function(key) {\r\n  return this.arr.indexOf(key) !== -1;\r\n};\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## [二进制链表转整数](https://leetcode.cn/problems/convert-binary-number-in-a-linked-list-to-integer)\r\n> 链表中每个结点的值不是 0 就是 1。此链表是一个整数数字的二进制表示形式。请返回该链表所表示数字的十进制值 。\r\n\r\n- 循环整个链表，将链表的每一项值unshift（因为二进制转十进制从右往左计算所以使用unshift）到数组arr中。\r\n- 初始十进制数decimalNum为0，循环数组arr，当前项为1时， decimalNum += Math.pow(2, index)。\r\n```\r\nvar getDecimalValue = function(head) {\r\n  let arr = [], point = head;\r\n  // 循环链表获取链表总长度\r\n  while(point) {\r\n    arr.unshift(point.val);\r\n    point = point.next;\r\n  }\r\n  let decimalNum = 0;\r\n  arr.forEach((item, index) => {\r\n    if (item === 1) {\r\n      decimalNum += Math.pow(2, index);\r\n    }\r\n  })\r\n  return decimalNum;\r\n};\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## [从尾到头打印链表](https://leetcode.cn/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/)\r\n> 输入一个链表的头节点，从尾到头返回每个节点的值（用数组返回）。\r\n\r\n- 循环链表，将链表每一个节点的值unshift到数组中(因为要求从尾到头返回)，循环结束返回数组。\r\n```\r\nvar reversePrint = function(head) {\r\n  let arr = [], point = head;\r\n  // 循环链表获取每一个节点的值\r\n  while(point) {\r\n    arr.unshift(point.val);\r\n    point = point.next;\r\n  }\r\n  return arr;\r\n};\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## [删除中间节点](https://leetcode.cn/problems/delete-middle-node-lcci/)\r\n> 已知链表的某一个中间节点，请实现一种算法，将该节点从链表中删除。例如，传入节点 c（位于单向链表 a->b->c->d->e->f 中），将其删除后，剩余链表为 a->b->d->e->f。\r\n\r\n- 当前节点的val等于当前节点下一个节点的val。\r\n- 当前节点的next等于当前节点的下一个节点的next。\r\n- 将当前节点修改为下一个节点从而实现变相的删除当前节点。\r\n```\r\nvar deleteNode = function(node) {\r\n  node.val = node.next.val\r\n  node.next = node.next.next\r\n};\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## [删除排序链表中的重复元素](https://leetcode.cn/problems/remove-duplicates-from-sorted-list/description/)\r\n> 给定一个已排序的链表的头 head，删除所有重复的元素，使每个元素只出现一次 。返回 已排序的链表。\r\n\r\n- 创建变量currentNode初始值为链表的头部节点。\r\n- 当currentNode和currentNode.next都有值时循环链表。\r\n- 判断当前节点和当前节点的next节点值是否相同\r\n  1. 相同则将当前的节点的next指向当前节点的next.next节点。\r\n  2. 不相同则将当前节点的next节点复制给currentNode变量继续循环。\r\n- 直到循环结束\r\n```\r\nvar deleteDuplicates = function(head) {\r\n  let currentNode = head;\r\n  while(currentNode && currentNode.next) {\r\n    const nextNode = currentNode.next;\r\n    if (currentNode.val === nextNode.val) {\r\n      currentNode.next = nextNode.next;\r\n    } else {\r\n      currentNode = nextNode;\r\n    }\r\n  }\r\n  return head;\r\n};\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## [反转链表](https://leetcode.cn/problems/reverse-linked-list/)\r\n> 给定单链表的头节点 head，反转链表并返回反转后的链表。\r\n\r\n- 新建两个指针current指向头节点，prev初始为null。\r\n- 遍历链表(数据后移实现所有指针的变化)\r\n  - 获取当前current.next的节点cnext。\r\n  - current指针的.next指向prev指针对应的节点。\r\n  - prev指针指向current指针指向的节点。\r\n  - current指向cnext。\r\n```\r\nvar reverseList = function(head) {\r\n  let current = head;\r\n  let prev = null;\r\n  while (current) {\r\n    const cnext = current.next;\r\n    // 当前的next指向前一个\r\n    current.next = prev;\r\n    // 数据后移\r\n    prev = current;\r\n    current = cnext;\r\n  }\r\n  return prev;\r\n};\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## [合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/)\r\n> 将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。\r\n\r\n- 新建一个链表最为最终需要返回的链表。\r\n- 新建三个指针分别指向新建的链表和传入的两个升序链表。\r\n- 遍历传入的两个升序链表，判断对应的指针指向节点的值，将新建的链表的next指向节点值较小的节点，同时将节点值较小的链表对应的指针和新链表的指针向后移动一位。以此逻辑循环遍历，直到传入的两个链表对应指针指向的节点有其一为空时终止循环。\r\n- 如果传入的某个链表还有值，就把后面的值全部接入新链表。\r\n```\r\nvar mergeTwoLists = function(list1, list2) {\r\n  // 新建一个新链表 作为返回值\r\n  const res = {\r\n    val: 0,\r\n    next: null\r\n  }\r\n  // 指向新链表的指针\r\n  let p = res;\r\n  // 建立两个指针分别指向两个链表\r\n  let p1 = list1;\r\n  let p2 = list2;\r\n  // 遍历两个链表\r\n  while (p1 && p2) {\r\n    // 如果链表1 小于 链表2的值 就接入链表1的值\r\n    if (p1.val < p2.val) {\r\n      p.next = p1;\r\n      // 需要往后移动\r\n      p1 = p1.next;\r\n    } else {\r\n      // 否则接入链表2的值\r\n      p.next = p2;\r\n      // 需要往后移动\r\n      p2 = p2.next;\r\n    }\r\n    // p永远要往后移动一位\r\n    p = p.next;\r\n  }\r\n  // 如果链表1或者链表2还有值，就把后面的值全部接入新链表\r\n  if (p1) {\r\n    p.next = p1;\r\n  }\r\n  if (p2) {\r\n    p.next = p2;\r\n  }\r\n  return res.next;\r\n};\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## [回文链表](https://leetcode-cn.com/problems/palindrome-linked-list/)\r\n> 给定一个单链表的头节点head，判断该链表是否为回文链表。如果是返回true，否则返回false。\r\n\r\n- 创建两个字符串。\r\n- 一个向头部插入，一个向尾部插入。\r\n- 最后两个字符串一致则表示是回文链表。\r\n```\r\nvar isPalindrome = head => {\r\n  let preStr = '', afterStr = '';\r\n  while(head) {\r\n    preStr = preStr + head.val;\r\n    afterStr = head.val + afterStr;\r\n    head = head.next;\r\n  }\r\n  return preStr === afterStr;\r\n}\r\n```\r\n- 利用链表的后续遍历，使用函数调用栈作为后序遍历栈，来判断是否回文链表。\r\n```\r\nconst isPalindrome = head => {\r\n  let left = head;\r\n  function traverse(right) {\r\n    if (right == null) return true;\r\n    let res = traverse(right.next);\r\n    res = res && (right.val === left.val);\r\n    left = left.next;\r\n    return res;\r\n  }\r\n  return traverse(head);\r\n};\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## [环型链表](https://leetcode.cn/problems/linked-list-cycle/)\r\n> 判断链表中是否有环。\r\n\r\n- 首先创建两个指针slowPoint、fastPoint，同时指向这个链表的头节点，然后开始循环。\r\n- 每一次循环指针slowPoint向后移动一个节点，指针fastPoint每次向后移动两个节点。\r\n- 比较两个指针指向的节点是否相同。如果相同，则判断出链表有环，如果不同，则继续下一次循环。\r\n- 当slowPoint、fastPoint其中一个对应节点没有值时终止循环。\r\n```\r\nvar hasCycle = function(head) {\r\n  if (head && head.next) {\r\n    let slowPoint = head;\r\n    let fastPoint = head;\r\n    while (slowPoint && fastPoint) {\r\n      slowPoint = slowPoint.next;\r\n      fastPoint = fastPoint.next && fastPoint.next.next;\r\n      if (slowPoint === fastPoint) {\r\n        return true;\r\n      }\r\n    }\r\n  }\r\n  return false;\r\n};\r\n```\r\n### [为什么快慢指针会相遇，且快指针的步长选择2](https://www.pianshen.com/article/6467918110/)\r\n> 对于链表有环的情况，当快指针刚刚绕到慢指针后面时，快指针离慢指针有n步。那么，对于接下来的每一次“快指针往前走两步、慢指针往前走一步”，快指针和慢指针之间的距离由n步变成n-1步、由n-1步变成n-2步、……、由3步变成2步、由2步变成1步、由1步变成0步。所以对于有环的情况，快慢指针一定会相遇。对于链表没有环的情况，快指针最终指向NULL指针。"},function(r,n,e){"use strict";e.r(n),n.default="## [相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/)\r\n> 给出两个单链表的头节点headA和headB，找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null。\r\n\r\n- 分别遍历两个链表，获取两个链表的长度。\r\n- 如果两个链表最后的节点相同表示是相交链表。\r\n  - 根据两个链表的长度获取两个链表的长度差值。\r\n  - 先让较长的链表遍历长度的差值(对齐开始比较的节点)。\r\n  - 然后两个链表同时遍历，判断是否相等，如果相等，就是第一个相交的结点。\r\n```\r\nvar getIntersectionNode = (head1, head2) => {\r\n  if (head1 && head2) {\r\n    // 计算链表的长度\r\n    let len1 = 0, long = head1;\r\n    let len2 = 0, short = head2;\r\n    while(long.next) {\r\n      len1++;\r\n      long = long.next;\r\n    }\r\n\r\n    while(short.next) {\r\n      len2++;\r\n      short = short.next;\r\n    }\r\n\r\n    // 两条链表的终点一样表示相交\r\n    if (long === short) {\r\n      let len = 0;\r\n      if (len1 > len2) {\r\n        len = len1 - len2;\r\n        long = head1;\r\n        short = head2;\r\n      } else {\r\n        len = len2 - len1;\r\n        long = head2;\r\n        short = head1;\r\n      }\r\n      \r\n      // 对齐两个链开始比较的节点\r\n      while(len > 0) {\r\n        len--;\r\n        long = long.next;\r\n      }\r\n\r\n      while(long && short && long !== short) {\r\n        long = long.next;\r\n        short = short.next;\r\n      }\r\n      return long;\r\n    }\r\n  }\r\n  return null;\r\n}\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## [移除链表元素](https://leetcode.cn/problems/remove-linked-list-elements)\r\n> 给定一个链表的头节点 head 和一个整数 val，删除链表中所有满足 Node.val == val 的节点，并返回新的头节点。\r\n\r\n- 新建新的链表newHead、新链表的指针newHeadPoint、传入链表的指针point。\r\n- 遍历传入的链表，当当前遍历节点的val与传入的val相同时\r\n  - 如果newHead为空则将当前节点的val赋值给newHead的val，newHeadPoint指针指向newHead。\r\n  - 如果newHead不为空时将当前节点的val赋值给newHeadPoint.next节点的val，同时newHeadPoint指针向后移动。\r\n```\r\nvar removeElements = function(head, val) {\r\n  let newHead = null; // 新链表\r\n  let newHeadPoint = null; // 新链表的指针\r\n  let point = head;\r\n  while(point) {\r\n    // 遍历传入的链表，如果val相同\r\n    if (point.val !== val) {\r\n      if (newHead) {\r\n        // 初始新链表的next节点\r\n        newHeadPoint.next = {\r\n          val: point.val,\r\n          next: null,\r\n        };\r\n        newHeadPoint = newHeadPoint.next;\r\n      } else {\r\n        // 初始新链表\r\n        newHead = {\r\n          val: point.val,\r\n          next: null,\r\n        };\r\n        newHeadPoint = newHead;\r\n      }\r\n    }\r\n    point = point.next;\r\n  }\r\n  return newHead;\r\n};\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## [移除重复节点](https://leetcode.cn/problems/remove-duplicate-node-lcci/)\r\n> 移除未排序链表中的重复节点。保留最开始出现的节点。\r\n\r\n- 新建新的链表newHead、新链表的指针newHeadPoint、传入链表的指针point、uniqueMap存储链表节点值是否出现过。\r\n- 遍历传入的链表，如果值没有在uniqueMap出现过则作为链表的一个节点，uniqueMap存储当前值。\r\n  - 如果newHead为空则将当前节点的val赋值给newHead的val，newHeadPoint指针指向newHead。\r\n  - 如果newHead不为空时将当前节点的val赋值给newHeadPoint.next节点的val，同时newHeadPoint指针向后移动。\r\n```\r\nvar removeDuplicateNodes = function(head) {\r\n  const uniqueMap = new Map(); // 新建Map存储链表节点值是否出现过\r\n  let newHead = null; // 新链表\r\n  let newHeadPoint = null; // 新链表的指针\r\n  let point = head; // 遍历链表的指针\r\n  while(point) {\r\n    // 如果值没有出现过作为链表的一个节点\r\n    if (!uniqueMap.has(point.val)) {\r\n      if (newHead) {\r\n        // 初始新链表的next节点\r\n        newHeadPoint.next = {\r\n          val: point.val,\r\n          next: null,\r\n        };\r\n        newHeadPoint = newHeadPoint.next;\r\n      } else {\r\n        // 初始新链表\r\n        newHead = {\r\n          val: point.val,\r\n          next: null,\r\n        };\r\n        newHeadPoint = newHead;\r\n      }\r\n    }\r\n    // 存储当前节点的值表示出现过\r\n    uniqueMap.set(point.val, true);\r\n    point = point.next;\r\n  }\r\n  return newHead;\r\n};\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## [链表中倒数第k个节点](https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/)\r\n> 输入一个链表，输出该链表中倒数第k个节点。从1开始计数，即链表的尾节点是倒数第1个节点。\r\n\r\n- 循环链表，创建对象obj以index为key节点为value存储每个节点，直到循环结束。\r\n- 上一步循环获取到最后一个节点的index值，index - k即是倒数第k个节点的index值。最终返回obj[index - k]。\r\n```\r\nvar getKthFromEnd = function(head, k) {\r\n  let obj = {}, point = head, index = 0;\r\n  // 循环链表存储链表每个节点信息\r\n  while(point) {\r\n    obj[index] = point\r\n    index++;\r\n    point = point.next;\r\n  }\r\n  return obj[index - k];\r\n};\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## [链表的中间结点](https://leetcode.cn/problems/middle-of-the-linked-list)\r\n> 给定一个头结点为 head 的非空单链表，返回链表的中间结点。如果有两个中间结点，则返回第二个中间结点。\r\n\r\n- 循环链表获取链表总长度。\r\n- 根据获取到的总长度得到链表中间位置midPosition，按要求如果存在两个中间节点返回第二个所以使用Math.ceil向上取整。\r\n- 再次循环链获取midPosition对应的链表节点信息并返回。\r\n```\r\nvar middleNode = function(head) {\r\n  let length = 1, point = head;\r\n  let position = 1, midNode = head;\r\n  // 循环链表获取链表总长度\r\n  while(point.next) {\r\n    length++;\r\n    point = point.next;\r\n  }\r\n  // 根据要求获取链表中间位置\r\n  const midPosition = Math.ceil((length + 1) / 2);\r\n  // 循环链表获取midPosition对应的节点信息\r\n  while(position < midPosition) {\r\n    position++;\r\n    midNode = midNode.next;\r\n  }\r\n  return midNode;\r\n};\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## nginx实现IP黑白名单\r\n> 有时候某些接口只能开放给对应的合作商，或者购买/接入 API 的合作伙伴，那么此时就需要实现类似于IP白名单的功能。而有时候有些恶意攻击者或爬虫程序，被识别后需要禁止其再次访问网站，因此也需要实现IP黑名单。这些功能可直接在nginx中处理。主要是通过allow、deny配置项来实现。\r\n\r\n```\r\n# 允许指定的IP访问，可以用于实现白名单。\r\nallow xxx.xxx.xxx.xxx;\r\n\r\n# 禁止指定的IP访问，可以用于实现黑名单。\r\ndeny xxx.xxx.xxx.xxx; \r\n```\r\n### 要同时屏蔽/开放多个IP访问时，如果所有IP全部写在nginx.conf文件中是比较冗余的，可以新建两个文件BlackIP.conf、WhiteIP.conf声明黑名单和白名单。\r\n- BlackIP.conf 黑名单\r\n```\r\n# 屏蔽192.177.12.222访问\r\ndeny 192.177.12.222;  \r\n\r\n# 屏蔽192.177.44.201访问  \r\ndeny 192.177.44.201; \r\n```\r\n- WhiteIP.conf 白名单\r\n```\r\n# 允许192.177.12.222访问\r\nallow 192.177.12.222;   \r\n\r\n# 允许192.177.44.201访问\r\nallow 192.177.44.201;   \r\n\r\n# 除上述IP外，其他IP全部禁止访问 \r\ndeny all; \r\n```\r\n- 分别将要禁止/开放的IP添加到对应的文件后，可以将这两个文件在nginx.conf中导入\r\n> 如果要整站屏蔽/开放就在http中导入，如果只需要一个域名下屏蔽/开放就在sever中导入，如果只需要针对于某一系列接口屏蔽/开放就在location中导入。\r\n\r\n```\r\nhttp {  \r\n  # 屏蔽该文件中的所有IP  \r\n  include /nginx/IP/BlackIP.conf;   \r\n  server {  \r\n    location xxx {  \r\n      # 某一系列接口只开放给白名单中的IP  \r\n      include /nginx/IP/WhiteIP.conf;   \r\n    }  \r\n  }  \r\n} \r\n```"},function(r,n,e){"use strict";e.r(n),n.default='## gzip压缩\r\n> 如果静态资源的size越小，那么传输速度会越快，同时也会更节省带宽，因此我们在部署项目时，可以通过nginx对于静态资源实现压缩传输，可以节省带宽资源，也可以加快响应速度。\r\n\r\n```\r\nserver {\r\n  # 开启gzip压缩功能\r\n  gzip on;\r\n\r\n  # 指定会被压缩的文件类型\r\n  gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/json;\r\n\r\n  # 设置压缩级别，越高资源消耗越大，但压缩效果越好\r\n  gzip_comp_level 5;\r\n\r\n  # 在头部中添加Vary: Accept-Encoding（建议开启）\r\n  gzip_vary on;\r\n  \r\n  # 处理压缩请求的缓冲区数量和大小\r\n  gzip_buffers 16 8k;\r\n\r\n  # 对于不支持压缩功能的客户端请求不开启压缩机制\r\n  gzip_disable "MSIE [1-6]\\."; # 低版本的IE浏览器不支持压缩\r\n\r\n  # 设置压缩响应所支持的HTTP最低版本\r\n  gzip_http_version 1.1;\r\n\r\n  # 设置触发压缩的最小阈值\r\n  gzip_min_length 2k;\r\n\r\n  # 关闭对后端服务器的响应结果进行压缩\r\n  gzip_proxied off;\r\n}\r\n```\r\n'},function(r,n,e){"use strict";e.r(n),n.default="### location\r\n### http://ip\r\n> 访问时http://ip会返回/home/admin/build（root配置）目录下的index.html（index配置）文件。\r\n\r\n```\r\nserver {\r\n  location / {\r\n    # 指定根目录\r\n    root   /home/admin/build;\r\n    index  index.html index.htm;\r\n  }\r\n}\r\n```\r\n### http://ip/micro\r\n> 访问时http://ip/micro会返回/home/micro（root配置 + location路径）目录下的build/index.html（index配置）文件。\r\n\r\n```\r\nserver {\r\n  location /micro {\r\n    # 指定根目录\r\n    root   /home;\r\n    index  build/index.html build/index.htm;\r\n  }\r\n}\r\n```\r\n### location匹配规则\r\n> nginx的匹配优先顺序按照如下的顺序进行优先匹配，一旦某一个匹配命中直接退出，不再进行往下的匹配。剩下的前缀匹配（大小写敏感）会按照最长匹配长度优先级来匹配，谁匹配的越多就用谁。\r\n\r\n1. = 表示精确匹配。只有请求的url路径与后面的字符串完全相等时，才会命中。\r\n2. ^~ 表示如果该符号后面的字符是最佳匹配，采用该规则，不再进行后续的查找。\r\n3. ~ 表示该规则是使用正则定义的，区分大小写。\r\n4. ~* 表示该规则是使用正则定义的，不区分大小写。\r\n#### http://ip/document\r\n> 匹配702。因为正则匹配比普通匹配的优先级更高，而且正则是一旦匹配到就直接退出所以不会再匹配703。\r\n\r\n```\r\nserver {\r\n  location /document {\r\n    return 701;\r\n  }\r\n  location ~* ^/docume.*$ {\r\n    return 702;\r\n  }\r\n  location ~* ^/document$ {\r\n    return 703;\r\n  }\r\n}\r\n```\r\n#### http://ip/document\r\n> 匹配702。因为^~精确匹配比正则匹配优先级更高。\r\n\r\n```\r\nserver {\r\n  location ~* ^/docume.*$ {\r\n    return 701;\r\n  }\r\n  location ^~ /doc {\r\n    return 702;\r\n  }\r\n  location ~* ^/document$ {\r\n    return 703;\r\n  }\r\n}\r\n```\r\n#### http://ip/document\r\n> 匹配701。前缀匹配是按照最长匹配，跟顺序无关。\r\n\r\n```\r\nserver {\r\n  location /doc {\r\n    return 702;\r\n  }\r\n  location /docu {\r\n    return 701;\r\n  }\r\n}\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## nginx\r\n> nginx是一个高性能的HTTP和反向代理web服务器，其是一款轻量级的web服务器、反向代理服务器、电子邮件服务器，特点是占有内存少、体积小、并发能力强、性能高。nginx是目前负载均衡技术中的主流方案。\r\n\r\n### 反向代理\r\n> 反向代理是nginx使用最多的一种场景了，当服务请求量较大，一台服务器已经无法承载需要扩容使用多台服务器时我们就可以使用nginx把用户的请求下发到不同的服务器。无论增加多少台服务器，用户始终访问一个相同的域名，反向代理代理的是目标服务端，客户端请求代理服务器，代理服务器会进行转发到对应目标服务器，对客户端而言并不知道真正的服务器是谁。\r\n\r\n### 负载均衡\r\n> 当使用了三台服务器，为了保证性能最大化，需要将请求合理分配给不同的服务器。负载均衡就是会合理的把客户端的请求分配给服务器，默认可以等比例分配，可以理解为1:1:1，但是实际场景中，服务器配置可能不同，可能有好有坏，所以这里有一个权重的概率，可以自行配置哪台服务器多分配请求，哪一台少一点请求，这样的配置可以让服务器的性能得到最大化，合理分配请求将会使系统更为健壮稳固。\r\n\r\n### 动静分离\r\n> 真实请求过程中有的请求是需要动态的计算的，比如需要连接数据库去增删查改，这些属于动，而对于前端的一些html、css、js文件，并不需要后台处理，就可以通过动静分离的模式将其区分开，将这些静态文件进行缓存操作，这样就可以提高效率了，同时静态的资源不再需要后端进行处理，减少后端服务的并发量和服务器压力。\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## 反向代理\r\n- proxy_pass：定义后端服务器的地址。\r\n- proxy_set_header：修改从客户端传递到代理服务器的请求头。\r\n- proxy_hide_header：隐藏从代理服务器返回的响应头。\r\n- proxy_redirect：修改从代理服务器返回的响应头中的Location和Refresh头字段。\r\n### 访问http://192.168.1.1/proxy/test.html\r\n> 如果在proxy_pass后面的url加/，表示绝对根路径；如果没有/，表示相对路径，把匹配的路径部分也给代理走。\r\n\r\n- 代理到http://127.0.0.1/test.html\r\n```\r\nlocation /proxy {\r\n  proxy_pass http://127.0.0.1/;\r\n}\r\n```\r\n- 代理到http://127.0.0.1/proxy/test.html\r\n```\r\nlocation /proxy {\r\n  proxy_pass http://127.0.0.1;\r\n}\r\n```\r\n- 代理到http://127.0.0.1/aaa/test.html\r\n```\r\nlocation /proxy {\r\n  proxy_pass http://127.0.0.1/aaa/;\r\n}\r\n```\r\n- 代理到http://127.0.0.1/aaatest.html\r\n```\r\nlocation /proxy {\r\n  proxy_pass http://127.0.0.1/aaa;\r\n}\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## root和alias\r\n> alias是一个目录别名的定义，root则是最上层目录的含义。\r\n\r\n### 差异\r\n- root的处理结果是: root路径 + location路径；alias的处理结果是: 使用alias路径替换location路径。\r\n- 如果location路径是以/结尾，则alias也必须是以/结尾，root没有要求。\r\n- alias无法与try_files搭配使用，root可以与try_files搭配使用。\r\n\r\n### /home/micro/build/index.html目录\r\n- root\r\n```\r\nlocation /micro {\r\n  root   /home;\r\n  index  build/index.html build/index.htm;\r\n}\r\n```\r\n- alias\r\n```\r\nlocation /micro {\r\n  alias  /home/micro;\r\n  index  build/index.html build/index.htm;\r\n}\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## try_files\r\n> 单页应用history路由支持刷新时使用。有路由时会应用try_files规则，没有路由默认进入时不会应用try_files规则。nginx的alias和try_files互斥，不能同时使用。\r\n\r\n### 示例一\r\n> try_files设置文件查找规则为 $uri $uri/ /index.html。当访问/exer时$uri为/exer。\r\n\r\n```\r\nlocation / {\r\n  # 指定根目录\r\n  root   /home/admin/build;\r\n  index  index.html index.htm;\r\n\r\n  # 单页应用history支持刷新\r\n  try_files $uri $uri/ /index.html;\r\n}\r\n```\r\n- 首先检查/home/admin/build目录中是否存在exer文件，如果存在则返回文件，如果不存在则进行下一步。\r\n- 其次检查/home/admin/build目录中是否存在exer目录，如果存在则再检查exer目录中是否存在index.html或者index.htm文件(由index指定)，如果存在则返回该文件，如果不存在则进行下一步。\r\n- 最后检查/home/admin/build目录中是否存在index.html文件(root目录与try_files第三个规则的路径拼接)，如果存在则返回文件，如果不存在则返回404。\r\n### 示例二\r\n> 当访问/micro/exer时$uri为/micro/exer。\r\n\r\n```\r\nlocation /micro {\r\n  # 指定根目录\r\n  root   /home;\r\n  index  build/index.html build/index.htm;\r\n\r\n  try_files $uri $uri/ /micro/build/index.html;\r\n}\r\n```\r\n- 首先检查/home目录中是否存在/micro/exer文件，如果存在则返回文件，如果不存在则进行下一步。\r\n- 其次检查/home目录中是否存在/micro/exer目录，如果存在则在检查/micro/exer目录中是否存在build/index.html或者build/index.htm文件(由index指定)，如果存在则返回该文件，如果不存在则进行下一步。\r\n- 最后检查/home目录中是否存在/micro/build/index.html文件(root目录与try_files第三个规则的路径拼接)，如果存在则返回文件，如果不存在则返回404。\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## 常用命令\r\n### service nginx start   启动服务\r\n### service nginx stop    关闭服务\r\n### service nginx restart 重启服务\r\n> 快速的停止服务然后启动服务，启动的时候会造成短暂的服务中断。如果配置文件语法错误，有可能会造成更长时间的服务中断。\r\n\r\n### nginx -s reload 热重载(平滑重启服务)\r\n> 当运行reload命令时，master进程会尝试读取配置文件。\r\n\r\n- 如果配置文件没有问题\r\n> master进程会启动新的worker进程来运行新的配置文件并开始处理新请求，同时会通知老的worker进程不再继续接收、处理新的请求，并在处理完当前任务后退出。\r\n\r\n- 如果配置文件存在问题\r\n> 继续使用老的worker进程处理请求，不会导致nginx异常退出。\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## 常用配置\r\n### nginx.conf    nginx服务的主配置文件\r\n1. 全局块\r\n> 会设置一些影响nginx服务器整体运行的配置指令，主要包括配置运行nginx服务器的用户（组）、允许生成的worker process数，进程PID存放路径、日志存放路径和类型以及配置文件的引入等。\r\n\r\n```\r\n# 定义nginx运行的用户和用户组\r\nuser root;\r\n\r\n# nginx进程数，建议设置为等于CPU总核心数\r\nworker_processes auto;\r\n\r\n# 全局错误日志定义类型，[ debug | info | notice | warn | error | crit ]\r\nerror_log /var/log/nginx/error.log info;\r\n\r\n# 进程文件\r\npid /run/nginx.pid;\r\n\r\n# nginx worker最大打开文件数，可设置为系统优化后的ulimit -n的结果\r\nworker_rlimit_nofile 65535;\r\n```\r\n2. events块\r\n> 与网络连接有关的设置。\r\n\r\n```\r\nevents {\r\n  # epoll模型是Linux 2.6以上内核版本中的高性能网络I/O模型，如果跑在FreeBSD上面，就用kqueue模型\r\n  use epoll;\r\n\r\n  # 单个worker进程最大连接数（nginx最大连接数 = worker连接数 * 进程数）\r\n  worker_connections 768;\r\n}\r\n```\r\n3. http块\r\n> 代理、缓存和日志等绝大多数功能和第三方模块的配置都在这里。\r\n\r\n```\r\nhttp {\r\n  # 日志定义\r\n  access_log /var/log/nginx/access.log;\r\n  error_log /var/log/nginx/error.log;\r\n\r\n  # 引入其它配置文件\r\n  include /etc/nginx/conf.d/*.conf;\r\n}\r\n```\r\n4. server块\r\n> 虚拟主机的参数设置（一个http块可包含多个server块）。\r\n\r\n5. location块\r\n> 定义请求路由及页面处理方式。\r\n\r\n### default.conf  nginx服务默认配置文件\r\n> nginx.conf一般会引入default.conf文件中的配置，所以多数情况下会在default.conf中配置server块的相关规则。\r\n\r\n### 监听端口\r\n```\r\nlisten   80;\r\n```\r\n### 配置服务ip\r\n```\r\nserver_name  ip;\r\n```\r\n### index.html配置\r\n```\r\nlocation / {\r\n  # 指定根目录\r\n  root   /home/admin/build;\r\n  index  index.html index.htm;\r\n}\r\n```\r\n### 单页应用history路由支持刷新\r\n```\r\nlocation / {\r\n  # 指定根目录\r\n  root   /home/admin/build;\r\n  index  index.html index.htm;\r\n\r\n  # 单页应用history支持刷新\r\n  try_files $uri $uri/ /index.html;\r\n}\r\n```\r\n### 配置前端静态资源http缓存\r\n```\r\nlocation / {\r\n  # 指定根目录\r\n  root   /home/admin/build;\r\n  index  index.html index.htm;\r\n\r\n  # 单页应用history支持刷新\r\n  try_files $uri $uri/ /index.html;\r\n\r\n  # index.html使用协商缓存\r\n  add_header Cache-Control 'no-cache';\r\n\r\n  if ($request_uri ~* .*[.](js|css|map|jpg|png|svg|ico)$) {\r\n    # 非html资源强缓存1个月\r\n    add_header Cache-Control \"max-age=2592000\";\r\n  }\r\n\r\n  if ($request_filename ~* ^.*[.](html|htm)$) {\r\n    # html使用协商缓存\r\n    add_header Cache-Control \"no-cache\";\r\n  }\r\n}\r\n```\r\n### 接口请求代理\r\n```\r\nlocation /api {\r\n  proxy_pass http://ip;\r\n}\r\n```\r\n### PC端和移动端使用不同的项目文件映射\r\n```\r\n// 资源目录\r\n/home/html\r\n    ├── mobile\r\n        ├── index.html  // 移动端静态资源\r\n    ├── pc\r\n        ├── index.html  // PC端静态资源\r\n\r\nlocation / {\r\n  # 指定根目录\r\n  root /home/html/pc;\r\n  \r\n  # 移动端访问修改root\r\n  if ($http_user_agent ~* '(mobile|android|iphone|ipad|phone)') {\r\n    root /home/html/mobile;\r\n  }\r\n  index index.html index.htm;\r\n}\r\n```\r\n### nginx默认request header中包含下划线的请求头会被自动忽略\r\n```\r\n# 不忽略包含下划线_的请求头\r\nunderscores_in_headers on;\r\n```\r\n### default.conf\r\n> 可以配置两个server。\r\n\r\n```\r\nserver {\r\n  # 监听端口\r\n  listen       80;\r\n\r\n  # 配置服务ip\r\n  server_name  ip;\r\n\r\n  # nginx默认request header中包含的下划线_的请求头会自动忽略。\r\n  underscores_in_headers on;\r\n\r\n  # 配置前端静态资源及http缓存\r\n  location / {\r\n    # 指定根目录\r\n    root   /home/admin/build;\r\n    index  index.html index.htm;\r\n\r\n    # 单页应用history支持刷新\r\n    try_files $uri $uri/ /index.html;\r\n\r\n    # index.html使用协商缓存\r\n    add_header Cache-Control 'no-cache';\r\n\r\n    if ($request_uri ~* .*[.](js|css|map|jpg|png|svg|ico)$) {\r\n      # 非html资源强缓存1个月\r\n      add_header Cache-Control \"max-age=2592000\";\r\n    }\r\n\r\n    if ($request_filename ~* ^.*[.](html|htm)$) {\r\n      # html使用协商缓存\r\n      add_header Cache-Control \"no-cache\";\r\n    }\r\n  }\r\n\r\n  # 接口请求代理\r\n  location /api {\r\n    proxy_pass http://ip;\r\n  }\r\n}\r\n\r\nserver {\r\n  # 监听端口\r\n  listen       8000;\r\n\r\n  # 配置服务ip\r\n  server_name  ip;\r\n\r\n  # 配置前端静态资源\r\n  location / {\r\n    # 指定根目录\r\n    root /home/html/pc;\r\n    \r\n    # 移动端访问修改root\r\n    if ($http_user_agent ~* '(mobile|android|iphone|ipad|phone)') {\r\n      root /home/html/mobile;\r\n    }\r\n    index index.html index.htm;\r\n  }\r\n}\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## 正向代理反向代理\r\n### 正向代理\r\n> 比如VPN翻墙。正向代理代理的是客户端，客户端访问代理服务器，并且需要指定目标服务器，然后代理服务器会发送请求给目标服务器，响应之后响应内容由代理服务器返回给客户端。对目标服务器而言是不知道真正的客户端的。\r\n\r\n### 反向代理\r\n> 比如nginx的反向代理。反向代理代理的是目标服务端，客户端请求代理服务器，不需要指定什么目标服务器，代理服务器会进行转发到对应目标服务器，对客户端而言是不知道目标服务器的。\r\n\r\n### 正向代理和反向代理的区别\r\n> 反向代理隐藏了真正的服务器，正向代理隐藏了真正的客户端。\r\n\r\n- 正向代理是对客户端的代理，服务器不知道真正的客户端是谁；反向代理是对服务器的代理，客户端不知道真正的服务器是谁。\r\n- 正向代理一般是客户端架设的；反向代理一般是服务器架设的。\r\n- 正向代理主要是用来解决访问限制问题；反向代理则是提供负载均衡、安全防护等作用。二者都能提高访问速度。"},function(r,n,e){"use strict";e.r(n),n.default="## 解决跨域问题\r\n```\r\nlocation / {\r\n  # 允许跨域的请求，*表示所有  \r\n  add_header 'Access-Control-Allow-Origin' '*';  \r\n\r\n  # 允许携带cookie请求  \r\n  add_header 'Access-Control-Allow-Credentials' 'true';\r\n  \r\n  # 允许跨域请求的方法：GET,POST,OPTIONS,PUT  \r\n  add_header 'Access-Control-Allow-Methods' 'GET,POST,OPTIONS,PUT';  \r\n\r\n  # 允许请求时携带的头部信息，*表示所有  \r\n  add_header 'Access-Control-Allow-Headers' '*';  \r\n\r\n  # 允许发送按段获取资源的请求  \r\n  add_header 'Access-Control-Expose-Headers' 'Content-Length,Content-Range';\r\n\r\n  # 一定要有，否则post请求无法进行跨域\r\n  # 在发送post跨域请求前，会以options方式发送预检请求，服务器接受时才会正式请求  \r\n  if ($request_method = 'OPTIONS') { \r\n    add_header 'Access-Control-Max-Age' 1728000;  \r\n    add_header 'Content-Type' 'text/plain; charset=utf-8';  \r\n    add_header 'Content-Length' 0;\r\n\r\n    # 以下请求头必须有\r\n    add_header 'Access-Control-Allow-Origin' '*';  \r\n    add_header 'Access-Control-Allow-Credentials' 'true';\r\n    add_header 'Access-Control-Allow-Methods' 'GET,POST,OPTIONS,PUT';  \r\n    add_header 'Access-Control-Allow-Headers' '*'; \r\n\r\n    # 对于options方式的请求返回204，表示接受跨域请求  \r\n    return 204;  \r\n  }  \r\n} \r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## 负载均衡\r\n> 负载均衡是当有高并发请求访问服务器时，nginx作为入口服务器，先接受请求然后将请求分到不同的服务器中，保证服务的可用性，缓解服务压力，保证服务的响应速度，即使某一个应用服务不可用，也可以保证业务的正常进行。\r\n\r\n### 轮询(Nginx自带、默认)\r\n> 该策略是Nginx默认的负载均衡策略，每一个客户端请求按时间顺序轮流分配到不同的服务器上，如果后端服务不可以用，会自动过滤掉。\r\n\r\n```\r\nupstream my_servers {\r\n  server      ip:8000;\r\n  server      ip:8001;\r\n  server      ip:8002;\r\n}\r\n```\r\n### weight权重(Nginx自带)\r\n> 权重用于指定轮询的几率，默认权重都是1，可以手动设置调整，权重越高，被分配的次数越多，weight权重和访问比例是成正比的，用于解决后端服务器性能不均衡时，调整访问比例。\r\n\r\n```\r\nupstream my_servers {\r\n  server      ip:8000 weight=1;\r\n  server      ip:8001 weight=2;\r\n  server      ip:8002 weight=4;\r\n}\r\n```\r\n### ip_hash(Nginx自带)\r\n> 将请求按照访问ip的hash结果进行分配，这种方式可以保证同一个用户会固定访问一个后端服务器。优点：可以保证session会话，解决服务器之间session不能共享的问题。\r\n\r\n```\r\nupstream my_servers {\r\n  ip_hash;\r\n  server      ip:8000;\r\n  server      ip:8001;\r\n  server      ip:8002;\r\n}\r\n```\r\n### least_conn(Nginx自带)\r\n> 将请求转发给连接数较少的后端服务器。每个后端服务器配置可能不同，处理的请求也有可能不同，对于处理的请求有快有慢，least_conn是根据后端服务器的连接情况，动态的选择连接数量较少的一台服务器来处理当前的请求。\r\n\r\n```\r\nupstream my_servers {\r\n  least_conn;\r\n  server      ip:8000;\r\n  server      ip:8001;\r\n  server      ip:8002;\r\n}\r\n```\r\n### fair(第三方)\r\n> 是按照服务器端的响应时间来分配请求，响应时间短的服务器优先分配。第三方的负载均衡策略需要安装第三方的插件。\r\n\r\n```\r\nupstream my_servers {\r\n  fair;\r\n  server      ip:8000;\r\n  server      ip:8001;\r\n  server      ip:8002;\r\n}\r\n```\r\n### url_hash(第三方)\r\n> url_hash是根据url的hash结果进行分配请求，每一个url会固定到同一个服务器上，配合缓存使用，可以减少不必要的下载和资源时间的浪费。每次同一个url请求到达同一个服务器上，第一次加载后放入缓存，后面再次请求，直接取缓存资源。如果不采用url_hash，可能会导致请求到达不同的服务器，资源出现重新加载的情况。第三方的负载均衡策略需要安装第三方的插件。\r\n\r\n```\r\nupstream my_servers {\r\n  hash $request_uri;\r\n  server      ip:8000;\r\n  server      ip:8001;\r\n  server      ip:8002;\r\n}\r\n```\r\n### 完整配置 default.conf\r\n```\r\nupstream my_servers {\r\n  server          ip:8000 weight=1;\r\n  server          ip:8001 weight=4;\r\n  server          ip:8002 weight=2;\r\n}\r\n\r\nserver {\r\n  listen          80;\r\n  server_name     ip;\r\n\r\n  location / {\r\n    proxy_pass          http://my_servers;\r\n    proxy_set_header    Host $proxy_host;\r\n    proxy_set_header    X-Real-IP $remote_addr;\r\n    proxy_set_header    X-Forwarded-For $proxy_add_x_forwarded_for;\r\n  }\r\n}\r\n\r\n# 8000端口配置\r\nserver {\r\n  listen          8000;\r\n  server_name     ip;\r\n\r\n  location / {\r\n    root /home/html;\r\n    index 8000.html 8000.htm;\r\n  }\r\n}\r\n\r\n# 8001端口配置\r\nserver {\r\n  listen          8001;\r\n  server_name     ip;\r\n\r\n  location / {\r\n    root /home/html;\r\n    index 8001.html 8001.htm;\r\n  }\r\n}\r\n\r\n# 8002端口配置\r\nserver {\r\n  listen          8002;\r\n  server_name     ip;\r\n\r\n  location / {\r\n    root /home/html;\r\n    index 8002.html 8002.htm;\r\n  }\r\n}\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## 配置SSL证书\r\n> 网站接入HTTPS需要在nginx中配置SSL证书。\r\n\r\n1. 去CA机构或从云控制台中申请对应的SSL证书，审核通过后下载nginx版本的证书。\r\n2. 下载数字证书后，完整的文件总共有三个：.crt、.key、.pem：\r\n    - .crt：数字证书文件，.crt 是.pem 的拓展文件，因此有些人下载后可能没有。\r\n    - .key：服务器的私钥文件，及非对称加密的私钥，用于解密公钥传输的数据。\r\n    - .pem：Base64-encoded 编码格式的源证书文本文件，可自行根需求修改拓展名。\r\n3. 在nginx目录下新建certificate目录，并将下载好的证书/私钥等文件上传至该目录。\r\n4. 修改一下nginx.conf文件如下\r\n```\r\n# ----------HTTPS配置-----------  \r\nserver {  \r\n  # 监听HTTPS默认的443端口  \r\n  listen 443;\r\n\r\n  # 配置自己项目的域名  \r\n  server_name domain;  \r\n\r\n  # 打开SSL加密传输  \r\n  ssl on;  \r\n\r\n  # 输入域名后，首页文件所在的目录  \r\n  root html; \r\n\r\n  # 配置首页的文件名  \r\n  index index.html index.htm index.jsp index.ftl;  \r\n\r\n  # 配置自己下载的数字证书  \r\n  ssl_certificate  certificate/xxx.pem;  \r\n\r\n  # 配置自己下载的服务器私钥  \r\n  ssl_certificate_key certificate/xxx.key;  \r\n\r\n  # 停止通信时，加密会话的有效期，在该时间段内不需要重新交换密钥  \r\n  ssl_session_timeout 5m;  \r\n\r\n  # TLS握手时，服务器采用的密码套件  \r\n  ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;\r\n\r\n  # 服务器支持的TLS版本  \r\n  ssl_protocols TLSv1 TLSv1.1 TLSv1.2;  \r\n\r\n  # 开启由服务器决定采用的密码套件  \r\n  ssl_prefer_server_ciphers on;  \r\n\r\n  location / {  \r\n    ....  \r\n  }  \r\n}  \r\n  \r\n# ---------HTTP请求转HTTPS-------------  \r\nserver {  \r\n  # 监听HTTP默认的80端口  \r\n  listen 80;  \r\n\r\n  # 如果80端口出现访问该域名的请求  \r\n  server_name domain;  \r\n  \r\n  # 将请求重定向到HTTPS\r\n  rewrite ^/(.*)$ https://domain/$1 permanent;  \r\n} \r\n```\r\n### http请求重定向到https时非GET请求报405的问题\r\n> 设置301重定向后所有的请求方法都变成了GET方式，导致一些POST、DELETE等请求报405不能正常使用。可以针对非GET请求使用proxy_pass方法，GET请求使用rewrite\r\n\r\n```\r\nserver {\r\n  # 监听HTTP默认的80端口  \r\n  listen 80;  \r\n\r\n  # 如果80端口出现访问该域名的请求  \r\n  server_name domain;  \r\n  \r\n  location / {\r\n    # 非GET请求用proxy_pass来转发\r\n    if ($request_method ~ ^(POST|DELETE|OPTIONS)$) {\r\n      proxy_pass https://domain;\r\n      break;\r\n    }\r\n\r\n    # 将请求重定向到HTTPS\r\n    rewrite ^/(.*)$ https://domain/$1 permanent;  \r\n  }\r\n}\r\n```\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## 防盗链\r\n> 盗链即是指外部网站引入当前网站的资源对外展示。nginx的防盗链机制实现，跟一个头部字段Referer有关，该字段主要描述了当前请求是从哪儿发出的，那么在nginx中就可获取该值，然后判断是否为本站的资源引用请求，如果不是则不允许访问。\r\n\r\n### 配置项valid_referers\r\n- none：表示接受没有Referer字段的HTTP请求访问。\r\n- blocked：表示允许http://或https://以外的请求访问。\r\n- server_names：资源的白名单，这里可以指定允许访问的域名。\r\n- string：可自定义字符串，支配通配符、正则表达式写法。\r\n### 实现\r\n```\r\nlocation ~ .*\\.(html|htm|gif|jpg|jpeg|bmp|png|ico|txt|js|css) {  \r\n  # 最后面的值在上线前可配置为允许的域名地址  \r\n  valid_referers blocked 192.168.12.129;  \r\n  if ($invalid_referer) {\r\n    # 可以配置成返回一张禁止盗取的图片  \r\n    # rewrite   ^/ http://xx.xx.com/NO.jpg;  \r\n    # 也可直接返回403  \r\n    return   403;  \r\n  }  \r\n}\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## module.exports和exports的区别\r\n> module.exports可以直接赋值,module.exports = function() {}; exports不可以直接赋值，只能添加方法或者属性,exports.add = function() {} ;\r\n\r\n- module.exports 初始值为一个空对象 {}\r\n- exports 是指向的 module.exports 的引用\r\n- require() 返回的是 module.exports 而不是 exports\r\n- 两者的关系为var exports = module.exports = {}; 给exports直接赋值是无效的，因为赋值后，module.exports仍然是空对象{}，因为直接给exports赋值，会直接改变exports的指向，并不会改变module.exports的值，而require() 返回的是 module.exports 而不是 exports，所以给exports赋值是不允许的。但是由于exports是module.exports的一个引用，因为引用类型的特性，以添加属性的形式改变exports的值同时module.exports的值也会改变，因为两者指向同一地址，所以require返回的内容就是修改后的内容。\r\n- 建议使用module.exports可以避免某些问题。\r\n### exports\r\n#### 使用exports添加属性的形式\r\n```\r\n// exportFile.js\r\nconst name = 'dyx';\r\nconst sayName = name => {\r\n  console.log(name);\r\n}\r\nexports.name = name;\r\nexports.sayName = sayName;\r\n\r\n// requireFile.js\r\nconst requireData = require('./exportFile');\r\nconsole.log(requireData); // { name: 'dyx', sayName: fn }\r\nconsole.log(requireData.name); // dyx\r\n```\r\n#### 使用exports直接赋值形式\r\n```\r\n// exportFile.js\r\nconst name = 'dyx';\r\nconst sayName = name => {\r\n  console.log(name);\r\n}\r\nexports = { name: name, sayName: sayName };\r\n\r\n// requireFile.js\r\nconst requireData = require('./exportFile');\r\nconsole.log(requireData); // {} 相当于引入了module.exports的初始值{}\r\nconsole.log(requireData.name); // undefined\r\n```\r\n### module.exports\r\n#### 使用module.exports添加属性的形式\r\n```\r\n// exportFile.js\r\nconst name = 'dyx';\r\nconst sayName = name => {\r\n  console.log(name);\r\n}\r\nmodule.exports.name = name;\r\nmodule.exports.sayName = sayName;\r\n\r\n// requireFile.js\r\nconst requireData = require('./exportFile');\r\nconsole.log(requireData); // { name: 'dyx', sayName: fn }\r\nconsole.log(requireData.name); // dyx\r\n```\r\n#### 使用module.exports直接赋值形式\r\n```\r\n// exportFile.js\r\nconst name = 'dyx';\r\nconst sayName = name => {\r\n  console.log(name);\r\n}\r\nmodule.exports = { name: name, sayName: sayName };\r\n\r\n// requireFile.js\r\nconst requireData = require('./exportFile');\r\nconsole.log(requireData); // { name: 'dyx', sayName: fn }\r\nconsole.log(requireData.name); // dyx\r\n```"},function(r,n,e){"use strict";e.r(n),n.default='## node执行命令添加参数\r\n- node index.js dyx douyaxing\r\n```\r\nconsole.log(process.argv) // 输出数组。第三个值是dyx 第四个值是douyaxing\r\n```\r\n- package.json的命令使用\r\n```\r\n"scripts": {\r\n  "create": "node index.js"\r\n},\r\n\r\n// npm run create dyx douyaxing  输出数组。第三个值是dyx 第四个值是douyaxing\r\n// 直接在script命令后添加参数即可，每个参数使用空格分开\r\n```'},function(r,n,e){"use strict";e.r(n),n.default="## nvm node版本管理工具\r\n> 在安装之前要将现有的node以及目录下的npm文件等全部删除，然后按照步骤安装即可，使用nvm命令检查是否安装成功，在已有一个版本的情况下，安装新的版本，使用nvm use切换即可，当前版本全局安装的内容只作用于当前版本。\r\n\r\n### 常用命令\r\n- nvm ls 查看已安装的版本\r\n- nvm install 6.10.0 安装指定版本\r\n- nvm uninstall 6.10.0 卸载指定版本\r\n- nvm use 6.10.0 使用指定版本\r\n\r\n### nvm安装node之后 npm找不到\r\n> 打开nvm文件夹下的settings.txt文件，在最后添加以下代码。\r\n\r\n```\r\nnode_mirror: https://npm.taobao.org/mirrors/node/\r\nnpm_mirror: https://npm.taobao.org/mirrors/npm/\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## 运行 npm run xxx 的时候发生了什么\r\n### 简短方便的执行命令\r\n> npm run xxx的时候，首先会去项目的package.json文件的scripts里找对应的命令，然后执行对应的命令，例如启动vue项目 npm run serve 的时候，实际上就是执行了vue-cli-service serve这条命令。\r\n\r\n### 直接执行package.json中对应的命令时系统并不存在此命令\r\n> 直接执行 vue-cli-service serve 会报错，因为操作系统中没有存在vue-cli-service这一条指令。\r\n\r\n### npm run xxx 的时候为什么不报指令不存在的错误\r\n- 安装依赖的时候，是通过 npm i xxx 来执行的，例如 npm i @vue/cli-service，npm在安装这个依赖的时候，就会node_modules/.bin/ 目录中创建好 vue-cli-service 为名的几个可执行文件了。.bin目录不是任何一个npm包。目录下的文件表示这是一个个软链接，打开文件可以看到文件顶部写着 #!/bin/sh ，表示这是一个脚本。\r\n- 当使用 npm run serve 执行 vue-cli-service  serve 时，虽然没有安装 vue-cli-service的全局命令，但是 npm 会到 ./node_modules/.bin 中找到 vue-cli-service 文件作为  脚本来执行，则相当于执行了 ./node_modules/.bin/vue-cli-service serve（最后的 serve 作为参数传入）。\r\n- 所以在 npm install 时，npm 读到该配置后，就将该文件软链接到 ./node_modules/.bin 目录下，而 npm 还会自动把node_modules/.bin加入$PATH，这样就可以直接作为命令运行依赖程序和开发依赖程序，不用全局安装了。\r\n假如我们在安装包时，使用 npm install -g xxx 来安装，那么会将其中的 bin 文件加入到全局，比如 create-react-app 和 vue-cli ，在全局安装后，就可以直接使用如 vue-cli projectName 这样的命令来创建项目了。\r\n### 为什么node_modules/bin中有三个vue-cli-service文件\r\n> 如果我们在 cmd 里运行的时候，windows一般是调用了 vue-cli-service.cmd 这个文件。所以当我们运行vue-cli-service serve这条命令的时候，就相当于运行 node_modules/.bin/vue-cli-service.cmd serve。\r\n然后这个脚本会使用 node 去运行 vue-cli-service.js这个 js 文件。\r\n\r\n```\r\n# unix 系默认的可执行文件，必须输入完整文件名\r\nvue-cli-service\r\n\r\n# windows cmd 中默认的可执行文件，当我们不添加后缀名时，自动根据 pathext 查找文件\r\nvue-cli-service.cmd\r\n\r\n# Windows PowerShell 中可执行文件，可以跨平台\r\nvue-cli-service.ps1\r\n```\r\n### 整体流程\r\n- 运行 npm run xxx的时候，npm 会先在当前目录的 node_modules/.bin 查找要执行的程序，如果找到则运行。\r\n- 没有找到则从全局的 node_modules/.bin 中查找，npm i -g xxx就是安装到到全局目录。\r\n- 如果全局目录还是没找到，那么就从 path 环境变量中查找有没有其他同名的可执行程序。\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## npm源管理(nrm)\r\n> nrm是用来管理npm源地址的。\r\n\r\n- npm install nrm -g  全局安装nrm\r\n- nrm ls 查看npm源地址列表  *为当前使用的\r\n- nrm add taobao https://registry.npm.taobao.org/  添加新的源\r\n- nrm use taobao  使用对应的源"},function(r,n,e){"use strict";e.r(n),n.default='## npm版本符号\r\n### 第一位为大版本，第二位为小版本 第三位为补丁版本\r\n- "1.2.3" 精确版本号。在一些比较重要的线上项目中，建议使用这种方式锁定版本。\r\n- "^1.2.3" 表示从左侧开始第一个不为0的版本不可以变，其右侧的小版本可以变化。\r\n```\r\n"^1.2.3" 等价于 ">= 1.2.3 < 2.0.0"。\r\n"^0.2.3" 等价于 ">= 0.2.3 < 0.3.0"。因为最左侧的是 "0"，那么只要第二位 "2" 不变，其他的都兼容，比如 "0.2.4" 和 "0.2.99"。\r\n"^0.0.3" 等价于 ">= 0.0.3 < 0.0.4"。大版本号和小版本号都为 "0" ，所以也就等价于精确的 "0.0.3"。\r\n```\r\n- "~1.2.3" 如果列出了小版本号（第二位），则只兼容补丁（第三位）的修改；如果没有列出小版本号，则兼容第二和第三位的修改。\r\n```\r\n"~1.2.3" 列出了小版本号 "2"，因此只兼容第三位的修改，等价于 ">= 1.2.3 < 1.3.0"。\r\n\r\n"~1.2" 也列出了小版本号 "2"，因此和上面一样兼容第三位的修改，等价于 ">= 1.2.0 < 1.3.0"。\r\n\r\n"~1" 没有列出小版本号，可以兼容第二第三位的修改，因此等价于 ">= 1.0.0 < 2.0.0"\r\n```\r\n- "*1.2.3" 安装最新版本的依赖包，会匹配 x.x.x 。\r\n### 使用场景\r\n> 可以指定特定的版本号，直接写1.2.3，但是如果依赖包发布新版本修复了一些小bug，那么需要手动修改package.json文件。使用 ~ 和 ^ 则可以解决这个问题。但是需要注意 ^ 版本更新可能比较大，会造成项目代码错误，所以建议使用 ~ 来标记版本号，这样可以保证项目不会出现大的问题，也能保证包中的小bug可以得到修复。版本号写 *，这意味着安装最新版本的依赖包，但也可能会造成版本不兼容，不建议使用。\r\n'},function(r,n,e){"use strict";e.r(n),n.default="## package-lock.json\r\n> 为了保证不同人电脑安装的所有依赖版本都是一致的，确保项目代码所执行的运行结果都一样。\r\n\r\n1. 在一个项目中npm install时候，会自动生成一个package-lock.json文件，和package.json在同一级目录下。package-lock.json记录了项目的一些信息和所依赖的模块。这样在每次安装都会出现相同的结果. 不管你在什么机器上面或什么时候安装。当我们下次再npm install时候，npm 发现如果项目中有 package-lock.json 文件，会根据 package-lock.json 里的内容来处理和安装依赖而不再根据 package.json。\r\n2. 如果 package.json 的 semver-range version(指定版本的区间范围) 和 package-lock.json 中版本兼容(package-lock.json 版本在 package.json 指定的版本范围内)，即使此时 package.json 中有新的版本，执行 npm install 也还是会根据 package-lock.json 下载。\r\n3. 如果手动修改了 package.json 的 version ranges，且和 package-lock.json 中版本不兼容，那么执行 npm install 时 package-lock.json 将会更新到兼容 package.json 的版本。\r\n### 不同人安装版本不同的问题\r\n> 假设在项目中的package.json 的 vue 版本是  vue: ^3.0.0, 我们电脑安装的vue版本就是 3.0.0 版本，我们把项目代码提交后，过了一段时间，vue 发布了新版本 3.0.1，这时其他同事执行 npm install安装的时候，在他电脑的vue版本就是 3.0.1了，因为我们的版本没有锁死，这样我们电脑中的vue版本就会不一样，我们的应用程序也许会产生不同的结果。如果我们在package.json上面锁死依赖包的版本号直接写 vue: 3.0.0，这样大家安装vue的版本都是3.0.0版本了。但是这样只能控制你自己的项目锁死版本号，那你项目中使用的依赖包的依赖包是无法控制版本号无法锁死版本号的。\r\n\r\n### cnpm的差异\r\n> 用cnpm install时候，并不会生成 package-lock.json 文件，也不会根据 package-lock.json 来安装依赖包，还是会使用 package.json 来安装。"},function(r,n,e){"use strict";e.r(n),n.default="## package.json\r\n> package.json 用来描述项目及项目所依赖的模块信息。帮我们管理项目中的依赖包。"},function(r,n,e){"use strict";e.r(n),n.default="## Immutable Data\r\n### JavaScript中的对象是可变的\r\n- JavaScript中的对象一般是可变的(Mutable)，因为使用了引用赋值，新的对象简单的引用了原始对象，改变新的对象将影响到原始对象。\r\n- 引用赋值可以节约内存，但当应用复杂后这就造成了非常大的隐患，Mutable带来的优点变得得不偿失。\r\n- 为了解决Mutable带来的隐患，一般的做法是使用shallowCopy(浅拷贝)或deepCopy(深拷贝)来避免原始对象被修改，但这样做造成了CPU和内存的浪费。\r\n- Immutable Data可以很好的解决JavaScript中对象是可变带来的问题。\r\n### Immutable Data\r\n- Immutable Data是一种一旦创建就不能再被更改的数据，对Immutable Data的任何修改或添加删除操作都会返回一个新的Immutable Data。\r\n- 主要原理是采用Persistent Data Structure(持久化数据结构)，当每次修改后我们都会得到一个新的版本，且旧版本可以完好保留。\r\n- 使用旧数据创建新数据时可以保证旧数据同时可用且不变。同时为了避免deepCopy把所有节点都复制一遍带来的性能损耗，Immutable Data使用了Structural Sharing(结构共享)，对于本次操作没有修改的部分会直接共享避免内存浪费。\r\n- Immutable Data内部采用是多叉树的结构，凡是有节点被改变，那么它和与它相关的所有上级节点都更新，并且更新后返回了一个全新的引用，即使是浅比对也能感知到数据的改变。\r\n### Immutable Data优点\r\n- 降低复杂度，避免副作用\r\n```\r\n// 如果不查看fn的代码是不能确定打印的结果的，因为不确定它对data做了什么。但如果data是Immutable Data的，是可以确定打印的结果是value。\r\nfunction andLog(fn) {\r\n  let data = { key: 'value' };\r\n  fn(data);\r\n  console.log(data.key);\r\n}\r\n```\r\n- 节省内存，Immutable Data采用了结构共享机制，所以会尽量复用内存。\r\n```\r\n// a和b共享了没有变化的info节点\r\nimport { produce } from 'immer';\r\nconst a = {\r\n  name: 'dyx',\r\n  info: { age: 26 }\r\n}\r\nconst b = produce(a, draft => {\r\n  draft.name = 'douyaxing';\r\n});\r\n\r\na === b; // false\r\na.info === b.info; // true\r\n```\r\n- 方便回溯，Immutable Data每次修改都会创建一个新对象，那么变更的记录就能够被保存下来，应用的状态变得可控、可追溯，方便撤销和重做功能的实现。\r\n### react强调使用Immutable Data\r\n- React中组件重新渲染是判断state或props是否变化，而React中对state或props是否变化的判断是浅比较shallowCompare，如果直接修改引用类型数据的属性值，那么该引用类型数据的引用地址没有改变所以浅比较判断未发生改变，组件也就不会实时更新。\r\n### 在react中使用Immutable Data的好处\r\n- 修改引用类型数据，当属性值没有变化时不会生成新的引用，组件不会重新渲染，减少不必要的渲染。\r\n- 判断组件是否要更新时，对于引用类型数据比较不再需要深比较，提升性能。\r\n- 操作引用类型数据，不需要再浅拷贝或者深拷贝，提升性能。\r\n- 操作引用类型数据，简化修改引用类型数据的写法，尤其层次比价深的情况。\r\n### PureComponent(React.memo)进行浅比较\r\n- 当引用类型数据的属性值变化，但是引用没有变化时，浅比较无法识别变化，导致不更新。\r\n- 当引用类型数据的属性值没有变化，但是引用变化时，浅比较会识别出变化，导致多余更新。\r\n### shouldComponentUpdate中进行深比较\r\n- 把引用类型数据的所有属性和值进行递归比较，当引用类型数据层次比较复杂时比较浪费性能。\r\n### Immutable Data + PureComponent(React.memo)浅比较\r\n- 使用Immutable Data凡是有节点被改变，那么它和与它相关的所有上级节点都更新，并且更新后返回了一个全新的引用，即使是浅比对也能感知到数据的改变。\r\n### 使用immer减少因为引用类型数据的引用变化但是数据值没有变化造成的重复render\r\n- 每一次触发change方法组件都会重新render，因为每一次触发change方法即使age没有变化也都生成了一个新的对象。\r\n```\r\nconst [data, setData] = useState({\r\n  name: 'dyx',\r\n  info: { age: 26 }\r\n});\r\nconst change = () => {\r\n  const newData = {...data, info: {...data.info, age: 27}};\r\n  setData(newData);\r\n}\r\n```\r\n- 使用immer后只有age变化时才会生成新的对象，组件才会重新render。\r\n```\r\nimport produce from 'immer';\r\n\r\nconst [data, setData] = useState({\r\n  name: 'dyx',\r\n  info: { age: 26 }\r\n});\r\nconst change = () => {\r\n  const newData = produce(data, draft => {\r\n    draft.info.age = 27;\r\n  });\r\n  setData(newData);\r\n}\r\n```\r\n### 在shouldComponentUpdate中判断组件是否需要更新不再需要deepCompare，只需要使用===判断即可，相较于deepCompare可以极大提高性能。\r\n```\r\nshouldComponentUpdate(nextProps = {}, nextState = {}) {\r\n  const thisProps = this.props || {}, thisState = this.state || {};\r\n\r\n  if (Object.keys(thisProps).length !== Object.keys(nextProps).length ||\r\n    Object.keys(thisState).length !== Object.keys(nextState).length\r\n  ) {\r\n    return true;\r\n  }\r\n\r\n  for (const key in nextProps) {\r\n    if (thisProps[key] !== nextProps[key]) {\r\n      return true;\r\n    }\r\n  }\r\n\r\n  for (const key in nextState) {\r\n    if (thisState[key] !== nextState[key]) {\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n}\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## [reactApi](https://juejin.cn/post/6950063294270930980)\r\n### 组件类\r\n#### Component\r\n- 类组件的基础。\r\n#### PureComponent\r\n- PureComponent会对类组件的State和Props进行浅比较，只有当State和Props发生变化时组件才会重新渲染。\r\n#### memo\r\n- React.memo会对函数组件的Props进行浅比较，只有当Props发生变化时组件才会重新渲染。支持第二个参数传入一个函数，如果组件需要更新就返回false，不需要更新就返回true。和shouldComponentUpdate正好相反。\r\n#### forwardRef\r\n- 想要获取深层次组件(例如孙组件)的dom元素\r\n- 高阶组件，使用ref拿到原始组件的实例\r\n#### lazy + Suspense\r\n- 构建异步渲染组件，两者要配合使用，不支持服务端渲染，服务端渲染可以使用loadable。实现代码分割，动态加载。\r\n- React.lazy接受一个函数，这个函数需要动态调用import()。它必须返回一个Promise，该Promise需要resolve一个default export的React组件。\r\n- Suspense让组件“等待”某个异步操作，直到该异步操作结束即可渲染，等待加载lazy组件时做UI层面的优雅降级(如loading显示等)。\r\n```\r\nimport React, { Suspense } from 'react';\r\n\r\nconst OtherComponent = React.lazy(() => import('./OtherComponent'));\r\n\r\nfunction MyComponent() {\r\n  return (\r\n    <div>\r\n      <Suspense fallback={<div>Loading...</div>}>\r\n        <OtherComponent />\r\n      </Suspense>\r\n    </div>\r\n  );\r\n}\r\n```\r\n#### Fragment\r\n- react不允许一个组件返回多个节点元素，为了避免增加额外的dom节点，使用Fragment元素包裹即可。\r\n- 相较于<></>形式Fragment可以支持key属性。\r\n- map遍历后的元素，react底层会处理，默认在外部嵌套一个Fragment元素\r\n#### Profiler\r\n- 用于开发阶段性能检测，检测一次react组件渲染用时性能开销。\r\n- 第一个参数是id，用于表识唯一性的，第二个参数是onRender回调函数，用于渲染完成，接受渲染参数。\r\n#### StrictMode\r\n- 严格模式，用于检测react项目中的潜在的问题，严格模式检查仅在开发模式下运行，不会影响生产构建。\r\n- 识别不安全的生命周期。\r\n- 关于使用过时的字符串ref API的警告。\r\n- 关于使用废弃的findDOMNode方法的警告。\r\n- 检测使用过时的Context API。\r\n- 检测意外的副作用。\r\n### 工具类\r\n#### createElement\r\n- JSX最终会被babel用createElement编译成React元素形式。\r\n- 第一个参数如果是组件类型传入组件，如果是dom元素类型传入元素类型的字符串。\r\n- 第二个参数为一个对象，在dom类型中为属性，在组件类型中为Props。\r\n- 其他参数为children，根据顺序排列。\r\n#### cloneElement\r\n- cloneElement的作用是以element元素为样板克隆并返回新的React元素。返回新的React元素可以在原基础上添加新的属性。\r\n#### createContext\r\n- createContext用于创建一个Context对象，createContext对象中包括用于传递Context对象值value的Provider，和接受value变化订阅的Consumer。\r\n#### createFactory\r\n- 返回用于生成指定类型React元素的函数，api将要被废弃，如果想要达到同样的效果，可以使用createElement。\r\n#### createRef\r\n- createRef可以创建一个ref元素。\r\n#### isValidElement\r\n- 可以用来检测是否为React element元素，接受待验证对象，返回true或者false。\r\n#### React.Children提供了用于处理this.props.children不透明数据结构的实用方法\r\n- 当children的元素的数据结构使用数组的map等方法不是很适用时，就要使用react.Chidren的方法来处理。\r\n- Children.map 遍历并返回新的数组\r\n- Children.forEach 仅遍历\r\n- Children.count 获取children中的组件总数量\r\n- Children.toArray 返回children扁平化后的结果\r\n- Children.only 验证children是否只有一个子节点，如果有则返回它，否则此方法会抛出错误。Children.only不接受Children.map的返回值，因为它是一个数组而并不是React元素\r\n### react-dom\r\n#### render\r\n- 用于渲染react元素\r\n#### hydrate\r\n- 服务端渲染使用的方法，用法同render\r\n#### createPortal\r\n- createPortal可以把当前组件或element元素的子节点，渲染到组件之外的其他地方。例如弹窗组件。\r\n#### unstable_batchedUpdates\r\n- 正常情况下react的state更新会批量更新state减少渲染次数，当在异步函数或原生事件中使用不再有此效果，想要依然实现批量更新的效果可以使用unstable_batchedUpdates方法。\r\n```\r\nhanderClick = () => {\r\n  Promise.resolve().then(() => {\r\n    ReactDOM.unstable_batchedUpdates(() => {\r\n      this.setState({ number: this.state.number + 1 });\r\n      console.log(this.state.number);\r\n      this.setState({ number: this.state.number + 1 });\r\n      console.log(this.state.number);\r\n      this.setState({ number: this.state.number + 1 });\r\n      console.log(this.state.number);\r\n    }) \r\n  })\r\n}\r\n\r\n```\r\n#### flushSync\r\n- 可以将更新任务放在一个较高的优先级。\r\n```\r\n// 打印 0 3 4 1  因为3设定了一个高优先级的更新，所以3先被打印，2 4被批量更新为4，最后打印1(setTimeout在下一轮的宏任务中执行)\r\nclass Home extends React.Component {\r\n  state = { number: 0 }\r\n\r\n  handerClick = () => {\r\n    setTimeout(() => {\r\n      this.setState({ number: 1  })\r\n    })\r\n    this.setState({ number: 2  })\r\n    ReactDOM.flushSync(() => {\r\n      this.setState({ number: 3  })\r\n    })\r\n    this.setState({ number: 4  })\r\n  }\r\n\r\n  render() {\r\n    const { number } = this.state\r\n    console.log(number)\r\n    return (\r\n      <div>\r\n        <div>{ number }</div>\r\n        <button onClick={this.handerClick} >测试flushSync</button>\r\n      </div>\r\n    )\r\n  }\r\n}\r\n```\r\n#### findDOMNode\r\n- 用于访问组件DOM元素节点，推荐使用ref获取。\r\n#### unmountComponentAtNode\r\n- 从DOM中卸载组件，会将其事件处理器和state一并清除。\r\n- 如果指定容器上没有对应已挂载的组件，这个函数什么也不会做。如果组件被移除将会返回true，如果没有组件可被移除将会返回false。 "},function(r,n,e){"use strict";e.r(n),n.default="## class组件的super\r\n- 在JS中，super引用的是父类构造函数。在React中引用的是React.Component。\r\n- JS强制在构造函数中先调用super()才能使用this。这一限制也被应用到了React组件。\r\n- 我们可以在class组件中省略构造函数，使用实例属性形式定义state。\r\n- 在class组件中一旦写了constructor就要写super()，只有写了super()才会有自己的this，否则后续使用的时候会报错。\r\n### super(props)\r\n- 调用super()时没有传入props参数，依然能够在render和其它方法中访问this.props，这是因为React在调用构造函数之后，会把props赋值给刚刚创建的实例对象。\r\n- super()中传递props才能在constructor中使用this.props。如上述React在调用构造函数之后才给实例设置props，所以super()中不传递props不能在constructor中使用this.props。"},function(r,n,e){"use strict";e.r(n),n.default="## diff\r\n> Diff操作本身也会带来性能损耗，React文档中提到，即使在最前沿的算法中，将前后两棵树完全比对的算法的复杂程度为O(n^3)，其中n是树中元素的数量。如果在React中使用了该算法，那么展示1000个元素所需要执行的计算量将在十亿的量级范围。这个开销实在是太过高昂，无法接受。\r\n\r\n### 降低算法复杂度，React的diff会预设三个限制\r\n1. 只对同级元素进行Diff，不做跨级比较。如果一个DOM节点在前后两次更新中跨越了层级，那么React不会尝试复用它，React只会简单地考虑同层级节点的位置变换，而对于不同层级的节点，只有创建和删除操作。\r\n2. 两个不同类型的元素会产生出不同的树。如果元素由div变为p，React会销毁div及其子孙节点，并新建p及其子孙节点。\r\n3. 开发者可以通过key属性来告诉react哪些子元素在不同的渲染下能保持稳定。\r\n### O(n^3) => O(n)\r\n- 每个节点都要去和另一棵树的全部节点对比一次，这就是 n 了，如果找到有变化的节点，执行插入、删除、修改也是 n 的复杂度。所有的节点都是这样，再乘以 n，所以是 O(n * n * n) 的复杂度。\r\n- 有了上述的限制这样只要遍历一遍，对比一下 type 就行了，是 O(n) 的复杂度，而且 type 变了就不再对比子节点。因为 vdom 中记录了关联的 dom 节点，执行 dom 的增删改也不需要遍历，是 O(1)的，整体的 diff 算法复杂度就是 O(n) 的复杂度。\r\n### diff的思路\r\n1. 当根节点为不同类型的元素时，React会拆卸原有的树并且建立起新的树，这大大减少了Diff过程中冗余的递归操作。\r\n2. 当对比两个相同类型的React元素时，React会保留DOM节点，仅比对及更新有改变的属性。\r\n3. 列表形式的子元素比较，React引入了key属性。当子元素拥有key时，React使用key来匹配原有树上的子元素以及最新树上的子元素，如果key不同则会拆卸原有的 key节点并且建立起新的key节点。\r\n### Diff算法是一种对比算法\r\n> 对比两者是旧虚拟DOM和新虚拟DOM，对比出是哪个虚拟节点更改了，找出这个虚拟节点，并只更新这个虚拟节点所对应的真实节点，而不用更新其他数据没发生改变的节点，实现精准地更新真实DOM，进而提高效率。\r\n\r\n- 使用虚拟DOM算法的损耗计算\r\n> 总损耗 = 虚拟DOM增删改(与Diff算法效率有关) + 真实DOM差异增删改 + (较少的节点)排版与重绘\r\n\r\n- 直接操作真实DOM的损耗计算\r\n> 总损耗 = 真实DOM完全增删改 + (可能较多的节点)排版与重绘\r\n\r\n### 为什么虚拟DOM快\r\n> 减弱频繁的大面积重绘引发的性能问题。\r\n\r\n- 虚拟DOM进行频繁修改，然后**一次性比较并修改**真实DOM中需要改的部分，最后在真实DOM中进行排版与重绘，减少排版重绘的次数，真实DOM频繁排版与重绘的效率是相当低的。\r\n- 虚拟DOM有效降低大面积(真实DOM节点)的重绘与排版，因为最终与真实DOM比较差异，可以只渲染局部。\r\n### 视图更新流程\r\n- 组件渲染生成一棵新的虚拟dom树(render方法)。\r\n- 新旧虚拟dom树对比，找出变动的部分(常说的diff算法)。\r\n- 根据改变的虚拟dom树更新到真实dom上。\r\n### vue与react的diff比较\r\n- vue和react的diff算法，都是忽略跨级比较，只做同级比较。\r\n- vue和react的diff算法，两个不同类型的元素会产生出不同的树，不会尝试复用。\r\n- vue对比节点。当节点元素相同，但是classname不同，认为是不同类型的元素，删除重建，而react认为是同类型节点，只是修改节点属性。\r\n- vue的列表对比，采用的是两端到中间比对的方式，而react采用的是从左到右依次对比的方式。当一个集合只是把最后一个节点移到了第一个，react会把前面的节点依次移动，而vue只会把最后一个节点移到第一个。\r\n\r\n\r\n"},function(r,n,e){"use strict";e.r(n),n.default='## fiber\r\n- react fiber不会让比较的时间缩短，但它使得diff的过程被分成一小段一小段的，因为它有了“保存工作进度”的能力。js会比较一部分虚拟dom，然后让渡主线程，给浏览器去做其他工作，然后继续比较，依次往复，等到最后比较完成，一次性更新到视图上。\r\n- 新的架构中，每个节点有三个指针：分别指向第一个子节点、下一个兄弟节点、父节点。这种数据结构就是fiber，它的遍历规则为从根节点开始，依次遍历该节点的子节点、兄弟节点，如果两者都遍历了，则回到它的父节点；当遍历发生中断时，只要保留下当前节点的索引，断点是可以恢复的——因为每个节点都保持着对其父节点的索引。\r\n### 组件diff的工作拆分为小段任务的操作且可中断\r\n- 主流浏览器刷新频率为60Hz，即每(1000ms / 60Hz)16.6ms浏览器刷新一次。\r\n- JS可以操作DOM，GUI渲染线程与JS线程是互斥的。所以JS脚本执行和浏览器布局、绘制不能同时执行。在每16.6ms时间内，需要完成如下工作：JS脚本执行 => 样式布局 => 样式绘制。\r\n- 当JS执行时间过长，超出了16.6ms，这次刷新就没有时间执行样式布局和样式绘制了，导致页面掉帧，造成卡顿。\r\n- 在浏览器每一帧的时间中，预留一些时间给JS线程，React利用这部分时间更新组件，当预留的时间不够用时，React将线程控制权交还给浏览器使其有时间渲染UI，React则等待下一帧时间到来继续被中断的工作。\r\n- 这种将长任务分拆到每一帧中，一次执行一小段任务的操作，被称为时间切片。而时间切片的关键是将同步的更新变为可中断的异步更新。\r\n### react16之前\r\n- 在react16引入Fiber架构之前，react会采用递归对比虚拟DOM树，找出需要变动的节点，然后同步更新它们，这个过程react称为reconcilation(协调阶段)。\r\n- 在reconcilation期间，react会一直占用浏览器资源，会导致用户触发的事件得不到响应。\r\n### react16将同步的更新变为可中断的异步更新，如何解决中断更新时DOM渲染不完全的问题\r\n- 在React16中，Reconciler与Renderer不再是交替工作。当Scheduler将任务交给Reconciler后，Reconciler会为变化的虚拟DOM打上代表增/删/更新的标记。\r\n- 整个Scheduler与Reconciler的工作都在内存中进行，不会更新页面上的DOM，所以即使反复中断，用户也不会看见更新不完全的DOM。只有当所有组件都完成Reconciler的工作，才会统一交给Renderer。Renderer根据Reconciler为虚拟DOM打的标记，同步执行对应的真实DOM操作。\r\n### 多个Fiber节点是树的结构，但是以链表数据结构存储\r\n> 依靠三个属性，父节点(return，使用return没有使用parent是因为当子节点和子节点的兄弟节点完成工作后会返回父节点，具体实现可参考简单react实现文件中)、子节点(child)、兄弟节点(sibling)的关联生成一个树状的结构。\r\n\r\n### 双缓存\r\n> 在内存中构建并直接替换，React使用“双缓存”来完成Fiber树的构建与替换——对应着虚拟DOM树的创建与更新。\r\n\r\n### fiber树\r\n- 在React中最多会同时存在两棵Fiber树。当前屏幕上显示内容对应的Fiber树称为current Fiber树，正在内存中构建的Fiber树称为workInProgress Fiber树。\r\n- current Fiber树中的Fiber节点被称为current fiber，workInProgress Fiber树中的Fiber节点被称为workInProgress fiber，他们通过alternate属性连接，在处理workInProgress Fiber树的时候，能够获得current Fiber树的信息。\r\n### Fiber出来之后，vdom的作用只是作为蓝本进行构建Fiber树。\r\n### 示例\r\n```\r\nimport React from "react";\r\n\r\nexport default class App extends React.Component {\r\n  constructor(...props) {\r\n    super(...props);\r\n    this.state = {\r\n      count: 1\r\n    };\r\n  }\r\n  onClick() {\r\n    this.setState({\r\n      count: this.state.count + 1\r\n    });\r\n  }\r\n  render() {\r\n    return (\r\n      <ul>\r\n        <button onClick={() => this.onClick()}>乘以{this.state.count}</button>\r\n        <li>{1 * this.state.count}</li>\r\n        <li>{2 * this.state.count}</li>\r\n        <li>{3 * this.state.count}</li>\r\n      </ul>\r\n    );\r\n  }\r\n}\r\n```\r\n- 同步更新(react15) 点击button将count从1变为2之后\r\n![同步更新](./img/v15同步更新.png)\r\n- 如果中断进行中的更新，将会看到不完全的dom\r\n![中断更新](./img/v15中断更新.png)\r\n- 异步可中断更新(react16)\r\n> 其中红框中的步骤随时可能由于以下原因被中断：有其他更高优任务需要先更新，当前帧没有剩余时间。由于红框中的工作都在内存中进行，不会更新页面上的DOM，所以即使反复中断，用户也不会看见更新不完全的。\r\n\r\n![异步中断更新](./img/v16异步更新.png)\r\n### 总结\r\n- React Fiber是React 16提出的一种更新机制，使用链表取代了树，将虚拟dom连接，使得组件diff的流程可以被中断恢复。\r\n- 它把组件diff的工作分片，到时会主动让出渲染主线程。\r\n- react fiber这种数据结构(链表)使得节点可以回溯到其父节点，只要保留下中断的节点索引，就可以恢复之前的工作进度。\r\n### Vue没有Fiber的原因\r\n- react中组件更新，会自顶向下重新渲染组件，自顶向下的含义是该组件以及它的子组件全部需要渲染，由于无法做到精确更新，所以需要使用到Fiber将组件渲染工作分割为多个小任务，可以中断和恢复，不阻塞主进程执行高优先级的任务。\r\n- Vue是基于template和watcher的组件级更新，可以做到精准更新，把每个更新任务分割得足够小，不需要使用到Fiber架构将任务进行更细粒度的拆分。\r\n'},function(r,n,e){"use strict";e.r(n),n.default="## hooks\r\n- React规定我们必须把hooks写在函数的最外层，不能写在if else条件语句中或内部函数中，来确保hooks的调用顺序在每次渲染中都是相同的。\r\n- 只在React函数组件中调用hooks，而不在普通函数中调用hooks。\r\n## useState(useState内部是基于useReducer实现的)\r\n- 第一次渲染会读取设置的初始值，之后渲染时则会忽略设置的初始值。\r\n- useState改变状态依然不是立即改变的，修改后无法实时获取到改变之后最新的值。\r\n- 传入useState参数后返回一个带有默认状态和改变状态函数(如下setInfo)的数组; \r\n```\r\nconst [info, setInfo] = useState({\r\n  name: 'dyx',\r\n  age: 24,\r\n});\r\n```\r\n- setState是非覆盖式更新状态，具备浅合并功能，只会更新传入的值，而useState是覆盖式更新状态。\r\n```\r\nconst [info, setInfo] = useState({\r\n  name: 'dyx',\r\n  age: 24,\r\n});\r\nconst changeInfo = addAge => {\r\n  setInfo({\r\n    ...info,\r\n    age: info.age + addAge,\r\n  });\r\n}\r\n```\r\n- 使用useState更新值时获取更新前的值\r\n```\r\nconst [num, setNum] = useState(2);\r\n\r\nsetNum((oldNum) => {\r\n  return oldNum + 2;\r\n})\r\n```\r\n- setState只要设置状态就会更新即使设置的值相同，useState设置相同的值不会更新。\r\n- 修改引用类型数据，必须重新返回一个新的引用。直接的修改引用类型的属性值，这样破坏了不可变值的规矩，应该通过Object.assign或者扩展运算符来重新创建一个对象进行设置。React内部会针对传入的参数进行浅比较，引用类型的数据浅比较的是其引用指向的地址而不是内容值，所以只有内容值变化引用不变化不会更新。简单类型的浅比较是比较的内容值。\r\n```\r\nconst [info, setInfo] = useState({\r\n  name: 'dyx',\r\n  age: 24,\r\n});\r\n\r\n// 页面会更新\r\nconst changeInfo = addAge => {\r\n  setInfo((oldInfo) => {\r\n    return {\r\n      ...oldInfo,\r\n      age: oldInfo.age + addAge,\r\n    }\r\n  });\r\n}\r\n\r\nconst changeInfoCopy = addAge => {\r\n  setInfo((oldInfo) => {\r\n    oldInfo.age += addAge;\r\n    // return oldInfo;  这样不会触发页面更新，引用类型数据的浅比较的是其指向的地址。\r\n    return {...oldInfo}; // 这样会更新\r\n  });\r\n}\r\n\r\n\r\n// 简单类型数据可以触发更新，简单类型的浅比较是比较的内容值。\r\nconst [num, setNum] = useState(2);\r\nconst changeNum = addNum => {\r\n  setNum((oldNum) => {\r\n    oldNum += addNum;\r\n    return oldNum;\r\n  });\r\n}\r\n```\r\n## useEffect\r\n- useEffect第二个参数中数组没有传值时代表不监听任何参数变化，只有在组件初始化时才会触发，用来代替componentDidMount\r\n```\r\nuseEffect(() => {\r\n  console.log('componentDidMount');\r\n}, [])\r\n```\r\n- 如果第二个参数中的值改变则触发第一个参数中的方法，组件初始化也会触发此方法，引用类型数据也可以监听到\r\n```\r\nconst [info, setInfo] = useState({ name: 'dyx', age: 24 });\r\nuseEffect(() => {\r\n  console.log(info); // 改变后的值\r\n}, [info]);\r\n``` \r\n- 第二个参数可以监听多个参数，有其一改变就会触发\r\n```\r\nconst [info, setInfo] = useState({ name: 'dyx', age: 24 });\r\nconst [num, setNum] = useState(2);\r\n// 只要num和info有一个变化就会触发\r\nuseEffect(() => {\r\n  console.log(info);\r\n  console.log(num);\r\n}, [info, num]);\r\n``` \r\n- 没有第二个参数时类似于componentDidMount和componentDidUpdate, 每一次渲染都会触发\r\n```\r\nuseEffect(() => {\r\n  console.log('render');\r\n})\r\n```\r\n- componentDidMount注册事件，componentWillUnmount销毁事件\r\n```\r\nconst func = () => {\r\n  console.log('func');\r\n}\r\n\r\nuseEffect(() => {\r\n  document.addEventListener('click', func);\r\n  return () => {\r\n    document.removeEventListener('click', func);\r\n  };\r\n}, []);\r\n\r\n// componentWillUnmount功能\r\nuseEffect(() => {\r\n  return () => {\r\n    console.log('componentWillUnmount');\r\n  }\r\n}, [])\r\n```\r\n- 监听props的改变，可以监听整个props或者监听某个或多个props值\r\n```\r\n// 监听props\r\nuseEffect(() => {\r\n  console.log(props);\r\n}, [props]);\r\n```\r\n## useLayoutEffect\r\n- useLayoutEffect中的代码以及其中任何计划的状态更新都会在浏览器重新绘制之前得到处理。\r\n- useLayoutEffect可能会影响性能，尽可能使用useEffect。\r\n## useRef\r\n- createRef每次渲染都会返回一个新的引用，而useRef每次都会返回相同的引用。\r\n- 创建useRef时候，会创建一个原始对象，只要函数组件不被销毁，原始对象就会一直存在，可以利用这个特性，来通过useRef保存一些数据。ref在所有的render中保持着唯一引用，因此所有对ref的赋值或取值，拿到的都是一个最终状态，不会在每个render间存在隔离。\r\n```\r\n// ref的值需要手动更新, 当无法在某一场景获取到最新的props时可以定义ref为最新的props值\r\nconst queryRef = useRef(props);\r\nuseEffect(() => {\r\n  queryRef.current = props;\r\n}, [props])\r\n```\r\n- 将ref对象传入元素，ref对象的.current属性将是当前的DOM节点。\r\n```\r\n/**\r\n * ref绑定元素的使用\r\n */\r\nimport React, { useRef } from 'react';\r\n\r\nconst DemoOne = () => {\r\n  const refEle = useRef();\r\n\r\n  const clickToFocus = () => {\r\n    refEle && refEle.current && refEle.current.focus();\r\n  }\r\n\r\n  return (\r\n    <div>\r\n      <input ref={refEle} type=\"text\" />\r\n      <button onClick={clickToFocus}>click</button>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default DemoOne;\r\n```\r\n## useImperativeHandleref\r\n> useImperativeHandle可以配合forwardRef自定义暴露给父组件的实例值。子组件如果是class类组件，我们可以通过ref获取类组件的实例，但是在子组件是函数组件的情况，我们需要使用useImperativeHandle和forwardRef配合达到获取组件实例的效果。\r\n\r\n```\r\n/**\r\n * 父组件调用子组件方法的 父组件\r\n */\r\nimport React from 'react';\r\nimport Child from './child';\r\n\r\nconst Demo = () => {\r\n  let childRef = null\r\n  const getChild = () => {\r\n    console.log(childRef); // 子组件useImperativeHandle返回的值\r\n    childRef && childRef.childFunc(3);\r\n  }\r\n  \r\n  return (\r\n    <div>\r\n      <Child ref={ref => childRef = ref} />\r\n      <button onClick={getChild}>触发子组件方法</button>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default Demo;\r\n\r\n/**\r\n * 父组件调用子组件方法的 子组件\r\n */\r\nimport React, { useState, useImperativeHandle, forwardRef } from 'react';\r\n\r\n// props子组件中需要接受ref\r\nconst Child = (props, ref) => {\r\n  const [val, setVal] = useState(1);\r\n\r\n  const changeVal = val => {\r\n    setVal(val);\r\n  }\r\n  \r\n  // useImperativeHandle方法的的第一个参数是目标元素的ref引用\r\n  useImperativeHandle(ref, () => ({\r\n    // childFunc 就是暴露给父组件的方法\r\n    childFunc: (newVal) => {\r\n      changeVal(val + newVal);\r\n    }\r\n  }));\r\n\r\n  return (\r\n    <div>{val}</div>\r\n  );\r\n}\r\n\r\nexport default forwardRef(Child);\r\n```\r\n## useMemo\r\n- 只有依赖项改变才会调用某一个方法时可以使用useMemo，避免在每次渲染时都进行高开销的计算。返回的是函数运行的结果。\r\n```\r\n// 父组件\r\nimport React, { useState } from 'react';\r\nimport DemoOne from './demoOne';\r\n\r\nconst UseMemoDemo = (props) => {\r\n  const [count, setCount] = useState(0);\r\n  const [count1, setCount1] = useState(1);\r\n  return (\r\n    <div>\r\n      <DemoOne {...props} count={count} count1={count1} />\r\n      <button onClick={() => setCount(count + 1)}>count</button>\r\n      <button onClick={() => setCount1(count1 + 1)}>count1</button>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default UseMemoDemo;\r\n\r\n\r\n// 子组件\r\nimport React, { useState, useMemo } from 'react';\r\n\r\nconst DemoOne = (props) => {\r\n  const [num, setNum] = useState(100);\r\n  const { count, count1 } = props;\r\n\r\n  const operationProps = (props) => {\r\n    console.log('propsChange')\r\n    return {\r\n      newcount: props.count + 10,\r\n      newcount1: props.count1 + 10,\r\n    }\r\n  }\r\n\r\n  // 如果不使用useMemo在组件内部状态改变时也会重新调用operationProps方法，使用之后只有在props改变时才会重新调用operationProps方法\r\n  const { newcount, newcount1 } = useMemo(() => operationProps(props), [props]);\r\n  return (\r\n    <div>\r\n      <div>\r\n        props count: {count}  count1: {count1}\r\n      </div>\r\n      <div>\r\n        new count: {newcount}  count1: {newcount1}\r\n      </div>\r\n      <div>\r\n        num {num}\r\n        <button onClick={() => setNum(num + 1)}>changeNum</button>\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default DemoOne;\r\n```\r\n- 没有依赖项时在第一次渲染时调用方法，可以用于debounce方法的声明\r\n```\r\nimport { debounce } from 'lodash';\r\nconst onChange = () => {\r\n  console.log('onChange');\r\n}\r\n\r\nconst debounceOnChange = useMemo(() => {\r\n  return debounce(onChange, 600);\r\n}, [])\r\n```\r\n## useCallback\r\n> 返回的是函数。父组件重新渲染时，声明的函数也会重新定义，如果此函数传递给子组件，那么子组件会重新render，使用useCallback对函数进行包裹，可以避免子组件不必要的重新渲染，子组件使用React.memo包裹。\r\n\r\n```\r\n// 父组件\r\nimport React, { useState, useCallback } from 'react';\r\nimport DemoOne from './demoOne';\r\n\r\nconst UseMemoDemo = () => {\r\n  const [count, setCount] = useState(0);\r\n  const [count1, setCount1] = useState(1);\r\n\r\n  const clickCount= () => {\r\n    setCount(count + 1);\r\n  };\r\n\r\n  const clickCount1 = useCallback(() => {\r\n    setCount1(count1 + 1);\r\n  }, [count1]);\r\n\r\n  return (\r\n    <div>\r\n      <div>count: {count}, count1: {count1}</div>\r\n      <DemoOne clickCount={clickCount}>普通函数形式</DemoOne>\r\n      <DemoOne clickCount={clickCount1}>useCallback函数形式</DemoOne>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default UseMemoDemo;\r\n\r\n\r\n/**\r\n * 避免父组件重新渲染，导致传递的方法重新定义导致子组件重新渲染\r\n */\r\nimport React from 'react';\r\n\r\nconst DemoOne = (props) => {\r\n  console.log(props.children)\r\n  return (\r\n    <div>\r\n      <div>\r\n        {props.children}\r\n      </div>\r\n      <button onClick={props.clickCount}>调用父组件方法</button>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default React.memo(DemoOne);\r\n```\r\n## useContext\r\n```\r\n// colorContext.js\r\nimport { createContext } from 'react';\r\nconst ColorContext = createContext();\r\n\r\nexport default ColorContext;\r\n\r\n\r\n// useContextDemo.js\r\nimport React from 'react';\r\nimport DemoOne from './demoOne';\r\nimport ColorContext from './colorContext'\r\n\r\nconst UseContextDemo = () => {\r\n  return (\r\n    // 此处的value才是子孙组件读取到的值\r\n    <ColorContext.Provider value=\"red\">\r\n      <DemoOne />\r\n    </ColorContext.Provider>\r\n  );\r\n}\r\n\r\nexport default UseContextDemo;\r\n\r\n// demoOne.js\r\nimport React from 'react';\r\nimport DemoTwo from './demoTwo';\r\n\r\nconst DemoOne = () => {\r\n  return (\r\n    <DemoTwo />\r\n  );\r\n}\r\n\r\nexport default DemoOne;\r\n\r\n// demoTwo.js\r\nimport React, { useContext } from 'react';\r\nimport ColorContext from './colorContext'\r\n\r\nconst DemoTwo = () => {\r\n  const color = useContext(ColorContext);\r\n  return (\r\n    <div style={{ color }}>\r\n      {color}\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default DemoTwo;\r\n```\r\n## useReducer\r\n> useReducer接受的第一个参数是一个函数，我们可以认为它就是一个reducer，reducer的参数就是常规reducer里面的state和action，返回改变后的state，useReducer第二个参数为state的初始值。返回一个数组，数组的第一项就是更新之后state的值，第二个参数是派发更新的dispatch函数。\r\n\r\n```\r\nimport React, { useReducer } from 'react';\r\n\r\nconst UseReducerDemo = () => {\r\n  /* count为更新后的state值,  dispatchCount 为当前的派发函数 */\r\n  const [count, dispatchCount] = useReducer((state, action) => {\r\n    const { payload, type } = action\r\n    /* return的值为新的state */\r\n    switch(type) {\r\n      case 'add':\r\n\t      return state + 1\r\n      case 'sub':\r\n        return state - 1 \r\n      case 'reset':\r\n        return payload       \r\n    }\r\n    return state\r\n  }, 0)\r\n\r\n  return (\r\n    <div>\r\n     <div>{ count }</div>\r\n      <button onClick={() => dispatchCount({ type:'add' })}>add</button>\r\n      <button onClick={() => dispatchCount({ type:'sub' })}>sub</button>\r\n      <button onClick={() => dispatchCount({ type:'reset', payload: 123 })}>reset</button>\r\n    </div>\r\n  )\r\n}\r\n\r\nexport default UseReducerDemo\r\n```\r\n## Capture Value(函数组件执行，就会形成一个闭包)\r\n- 每次render的内容都会形成一个快照并保留下来，当re-render的时候就形成了n个render状态，而每个render状态都拥有自己固定不变的props和state。\r\n- useState中定义的变量在每一次render的时候都是一个固定的常量，只是不同的render时机，对应的常量的值可能不同。\r\n- 每次render都有自己的事件处理\r\n> 如下示例中如果将console的值由内部的状态改为父组件传过来的props，如果在3秒内父组件的props发生变化，console的值还是原来的值，不是最新的值。但是class形式组件是最新的值，虽然props是不可变的，但是this在class形式组件中是可变的，因此this.props形式的调用每次都访问最新的props。而函数组件不存在this.props的语法，因此props在一次render中时固定不变的。\r\n\r\n```\r\nimport React, { useState } from 'react';\r\n\r\nconst CaptureValueDemo = () => {\r\n  const [num, setNum] = useState(0);\r\n\r\n  const log = () => {\r\n    setTimeout(() => {\r\n      // 每一次console的值都是执行setNum之前的值\r\n      // 在log函数执行的那个render中，num的值还是执行setNum之前的值\r\n      // 执行setNum()之后会交由一个全新的render中，新的render中不会执行log函数。\r\n      // 而三秒后执行的内容是由setNum前的那个render执行的，所以console的num自然也是setNum前的那个render中的num值\r\n      // num、log都拥有Capture Value特性\r\n      console.log(num);\r\n    }, 3000);\r\n  };\r\n\r\n  return (\r\n    <div>\r\n      {num}\r\n      <button\r\n        onClick={() => {\r\n          setNum(num + 1);\r\n          log();\r\n        }}\r\n      >\r\n        click\r\n      </button>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default CaptureValueDemo;\r\n```\r\n- useRef没有Capture Value特性。ref在所有的render中保持着唯一引用，因此所有对ref的赋值或取值，拿到的都是一个最终状态，不会在每个render间存在隔离。\r\n- useEffect也一样具有Capture Value的特性\r\n```\r\n// Capture Value特性\r\nconst [num, setNum] = useState(0);\r\n\r\nuseEffect(() => {\r\n  // 由于useEffect的Capture Value的特性，拿到的num值永远是初始化的0。\r\n  // setInterval永远在num为0基础上加一，setInterval在一直循环但是后续的setNum没有什么作用\r\n  const intervalId = setInterval(() => {\r\n    setNum(num + 1);\r\n  }, 1000);\r\n  return () => clearInterval(intervalId);\r\n}, []);\r\n\r\nreturn (\r\n  <div>{num}</div>\r\n);\r\n\r\n// 监听状态\r\nconst [num, setNum] = useState(0);\r\n\r\nuseEffect(() => {\r\n  // useEffect监听num的变化可以拿到了最新的num。\r\n  // 但是计时器不准了，因为每次count变化时都会销毁并重新计时。计时器频繁的挂载和销毁 定时器带来了一定性能负担。\r\n  const intervalId = setInterval(() => {\r\n    setNum(num + 1);\r\n  }, 1000);\r\n  return () => clearInterval(intervalId); \r\n}, [num]);\r\n\r\nreturn (\r\n  <div>{num}</div>\r\n);\r\n\r\n// 不依赖外部变量(依赖useState的回调形式进行更新操作)\r\nconst [num, setNum] = useState(0);\r\n\r\nuseEffect(() => {\r\n  const intervalId = setInterval(() => {\r\n    setNum(oldNum => oldNum + 1);\r\n  }, 1000);\r\n  return () => clearInterval(intervalId);\r\n}, []);\r\n\r\nreturn (\r\n  <div>{num}</div>\r\n);\r\n```\r\n## [hooks 闭包问题](https://juejin.cn/post/7051535411042058271)\r\n> 每一个Function的执行都有与之相应的Scope，对于面向对象来说，this引用即是连接了所有Scope的Context(当然前提是在同一个Class下)，在React Hooks中每一次的render由彼时的State决定，render完成Context即刷新。useRef是可以横跨多次render生成的Scope，它能保留下已执行的渲染逻辑，却也能使已渲染的Context 得不到释放，如果说this引用是面向对象中最主要的副作用，那么useRef亦同。\r\n\r\n\r\n- [延迟调用会存在闭包问题，使用useRef会避免此问题。](https://juejin.cn/post/7046358484610187277)\r\n> useRef仅在Mount时期初始化对象，而Update时期返回Mount时期的结果(memoizedState)。这意味着一次完整的生命周期中，useRef​保留的引用始终不会改变。\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## hooks中使用防抖节流\r\n### class形式组件中使用形式\r\n```\r\nimport React, { Component } from \"react\";\r\nimport { debounce } from \"lodash\";\r\n\r\nexport default class Home extends Component {\r\n  state = {\r\n    value: ''\r\n  }\r\n\r\n  debounceSearch = debounce((value) => {\r\n    console.log(value);\r\n  }, 600);\r\n\r\n  onChange = (e) => {\r\n    const value = e.target.value;\r\n    this.setState({\r\n      value\r\n    });\r\n    this.debounceSearch(value);\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <input onChange={this.onChange} value={this.state.value} />\r\n    )\r\n  }\r\n}\r\n```\r\n### 沿用class的使用形式在hooks中使用\r\n- debounceSearch方法没有达到防抖的效果。\r\n- debounceSearch函数每次调用前都执行了setValue导致重新渲染，这使得每一次调用的debounceSearch都被重建了，每次调用的debounceSearch都是一个新函数，并且失去了之前的记忆，所以达不到防抖的效果。\r\n```\r\nimport React, { useState } from \"react\";\r\nimport { debounce } from \"lodash\";\r\n\r\nconst Home = () => {\r\n  const [value, setValue] = useState('');\r\n\r\n  const debounceSearch = debounce((value) => {\r\n    console.log(value);\r\n  }, 600);\r\n\r\n  const onChange = (e) => {\r\n    const inputValue = e.target.value;\r\n    setValue(inputValue);\r\n    debounceSearch(inputValue);\r\n  }\r\n\r\n  return (\r\n    <input onChange={onChange} value={value} />\r\n  )\r\n}\r\n\r\nexport default Home;\r\n```\r\n### 缓存debounceSearch函数，避免每一次重新渲染时debounceSearch函数重建\r\n- 使用useCallback\r\n```\r\nconst debounceSearch = useCallback(\r\n  debounce((value) => {\r\n    console.log(value);\r\n  }, 600),\r\n[])\r\n```\r\n- 使用useRef\r\n```\r\nconst debounceSearch = useRef(\r\n  debounce((value) => {\r\n    console.log(value);\r\n  }, 600)\r\n).current\r\n```\r\n- 使用useMemo\r\n```\r\nconst debounceSearch = useMemo(() => {\r\n  return debounce((value) => {\r\n    console.log(value);\r\n  }, 600)\r\n}, [])\r\n```\r\n### useDebounce\r\n```\r\nimport { useCallback } from 'react';\r\nimport { debounce } from 'lodash';\r\n\r\nexport const useDebounce = (fun, deps = [], time = 600) => useCallback(debounce(fun, time), deps);\r\n```\r\n### useThrottle\r\n```\r\nimport { useCallback } from 'react';\r\nimport { throttle } from 'lodash';\r\n\r\nexport const useThrottle = (fun, deps = [], time = 600) => useCallback(throttle(fun, time), deps);\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## hooks的作用\r\n1. 函数组件中可以有状态和生命周期。\r\n2. 更好的状态复用。可以把组件的状态逻辑抽离成自定义hooks，从而实现状态逻辑在不同组件之间复用。\r\n3. 比class组件更易用，没有了class组件的this绑定问题。\r\n4. 友好的渐进式，依然可以在项目里一边写class组件，一边写hooks组件，可以一点点深入使用。\r\n### hooks的局限\r\n1. hooks在使用层面有着严格的规则约束，不能写在判断语句中。\r\n2. 函数组件给了我们一定程度的自由，却也对开发者的水平提出了更高的要求(闭包的问题)。\r\n3. hooks还不能完整的为函数组件提供类组件的能力。\r\n### hooks不能写在判断语句中\r\n- hooks信息都会以链表的形式保存在current fiber的memoizedState中。\r\n- 更新渲染时每次构建对应的是函数组件的workingProgress fiber时，都会从对应的current fiber中延续这个以链表结构存储的hooks信息。如果有hooks写在判断语句中那么就会破坏延续的顺序，所以hooks不能写在判断语句中。\r\n### mixin(状态复用)\r\n- mixins虽然提供了状态复用的能力，但弊端太多。\r\n```\r\n// 混入文件：name-mixin.js\r\nexport default {\r\n  data() {\r\n    return {\r\n      name: genRandomName() // 假装它能生成随机的名字\r\n    }\r\n  },\r\n  methods: {\r\n    setName(name) {\r\n      this.name = name\r\n    }\r\n  }\r\n}\r\n\r\n// 组件：my-component.vue\r\n<template>\r\n  <div>{{ name }}</div>\r\n<template>\r\n<script>\r\n  import nameMixin from './name-mixin';\r\n  export default {\r\n    mixins: [nameMixin],\r\n    // 通过mixins, 你可以直接获得 nameMixin 中所定义的状态、方法、生命周期中的事件等\r\n    mounted() {\r\n      setTimeout(() => {\r\n        this.setName('Tom')\r\n      }, 3000)\r\n    }\r\n  }\r\n<script>\r\n```\r\n- 难以追溯的方法与属性\r\n```\r\nexport default {\r\n  mixins: [ a, b, c, d, e, f, g ], // 表示它混入了很多能力\r\n  mounted() {\r\n    console.log(this.name)\r\n    // 这个 this.name 来自于谁？\r\n  }\r\n}\r\n```\r\n- 覆盖、同名问题\r\n> 当同时混入mixin-a.js和mixin-b.js以同时获得它们能力的时候，当这两个mixin都定义了this.name作为属性时就会有问题\r\n\r\n- 重复使用时，需要扩展代码无法像hooks一样定义别名。\r\n### renderProps渲染属性\r\n> 渲染属性指的是使用一个值为函数的props来传递需要动态渲染的节点或组件。\r\n\r\n### 高阶组件\r\n> 一个函数接受一个组件作为参数，经过一系列加工后，最后返回一个新的组件。\r\n\r\n### hooks相对的好处\r\n> 代码以及组件的嵌套层级不会很复杂。\r\n"},function(r,n,e){"use strict";e.r(n),n.default='## JSX\r\n- 只要使用了JSX就需要引用React(React17版本之前)，因为JSX本质就是React.createElement。\r\n- JSX只是为React.createElement方法提供的语法糖，所有的JSX代码最后都会转换成React.createElement(...)，最后再转化成常规的JS对象，Babel帮助我们完成了这个转换的过程。\r\n- 在编译时会判断JSX中组件的首字母，当首字母为小写时，其被认定为原生DOM标签，React.createElement的第一个变量被编译为字符串。当首字母为大写时，其被认定为自定义组件，React.createElement的第一个变量被编译为对象。\r\n- React.createElement函数对key和ref等特殊的props进行处理，并获取defaultProps对默认props进行赋值，并且对传入的子节点进行处理，最终构造成一个ReactElement对象(虚拟DOM)。\r\n- ReactDOM.render将生成好的虚拟DOM渲染到指定容器上，最终转换为真实DOM。\r\n### JSX转换为React.createElement\r\n```\r\n// 实际开发中使用JSX来创建虚拟dom\r\nconst element = (\r\n  <div id=\'foo\'>\r\n    <a>bar</a>\r\n    <b></b>\r\n  </div>\r\n)\r\n\r\n// 使用React.createElement创建虚拟dom\r\nconst element = React.createElement(\r\n  "div", \r\n  { id: "foo" },\r\n  React.createElement("a", null, "bar"),\r\n  React.createElement("b", null)\r\n);\r\n```\r\n### JSX转换成真实DOM的过程\r\n- JSX代码编写，使用JSX语法编写React组件的界面结构。JSX允许使用类似HTML的标记来描述UI层次结构。\r\n```\r\nconst element = <div>Hello, React!</div>;\r\n```\r\n- Babel转换，JSX语法并不是浏览器原生支持的，所以需要使用工具将JSX代码转换为浏览器可识别的JavaScript代码。通常会使用Babel这样的工具来进行转换。\r\n```\r\nconst element = React.createElement("div", null, "Hello, React!");\r\n```\r\n- 创建虚拟DOM，在转换后的JavaScript代码中，React.createElement函数会创建一个称为虚拟DOM的JavaScript对象。虚拟DOM是React内部用来表示界面结构的一种轻量级表示形式。\r\n- 虚拟DOM对比，当状态发生变化导致界面需要更新时，React会使用虚拟DOM来比较前后两次状态的差异。这个过程被称为协调。\r\n- 生成真实DOM更新，通过协调过程React能够计算出哪些部分的DOM需要被更新。然后针对实际需要更新的部分生成一系列真实DOM操作，然后将其应用于浏览器的真实DOM上。React会尽量最小化真实DOM操作的次数，以提高性能。\r\n### JSX与JS的区别\r\n- JS可以被打包工具直接编译不需要额外转换，JSX需要通过babel编译，它是React.createElement的语法糖，使用JSX等价于使用React.createElement。\r\n- JSX是JS的语法扩展，允许在html中写JS。JS是原生写法，需要通过script标签引入。\r\n### Fragment\r\n- Fragment碎片概念，能够让一个组件返回多个元素，React.Fragment等价于空标签。\r\n- React.Fragment实际上是没有节点的，会被编译为React.createElement(React.Fragment, null, "")这样的形式。\r\n- Fragment允许有key，而空标签无法添加key。\r\n### React中元素和组件的区别\r\n- react组件有类组件、函数组件。\r\n- react元素是通过JSX创建的。\r\n### 由于JSX提前要被Babel编译，所以JSX是不能在运行时动态选择类型的\r\n```\r\n// 错误\r\nfunction App(props) {\r\n  return <components[props.type] data={props.data} />;\r\n}\r\n\r\n// 正确\r\nfunction App(props) {\r\n  const CurrenCom = components[props.type];\r\n  return <CurrenCom data={props.data} />;\r\n}\r\n```\r\n'},function(r,n,e){"use strict";e.r(n),n.default='## jsx转换的变化\r\n### React16版本及之前\r\n- 使用jsx语法必须显式的将React引入。\r\n- 在React16版本及之前，应用程序通过@babel/preset-react将jsx语法转换为React.createElement的js代码，因此需要显式将React引入才能正常调用createElement方法。\r\n- babel编译前\r\n```\r\nexport default class App extends Component {\r\n  render() {\r\n    return <div>dyx</div>\r\n  }\r\n}\r\n\r\nReactDom.render(<App />, document.getElementById(\'root\'));\r\n```\r\n- babel编译后\r\n```\r\nexport default class App extends Component {\r\n  render() {\r\n    return /*#__PURE__*/React.createElement("div", null, "dyx");\r\n  }\r\n}\r\n\r\nReactDom.render( /*#__PURE__*/React.createElement(App, null), document.getElementById(\'root\'));\r\n```\r\n### React17版本及之后\r\n- 只使用jsx语法不使用其它React提供的api，可以不引入React应用程序依然能够正常运行。\r\n- 在React17版本及之后，官方与babel进行了合作，直接通过react/jsx-runtime对jsx语法进行了新的转换而不依赖React.createElement，转换的结果便是可直接供ReactDOM.render使用的ReactElement对象。\r\n- 新的jsx转换不会将jsx转换为React.createElement，而是自动从React的package中引入新的入口函数并调用。\r\n- babel编译前\r\n```\r\nexport default class App extends Component {\r\n  render() {\r\n    return <div>dyx</div>\r\n  }\r\n}\r\n\r\nReactDom.render(<App />, document.getElementById(\'root\'));\r\n```\r\n- babel编译后\r\n```\r\nimport { jsx as _jsx } from "react/jsx-runtime";\r\nexport default class App extends Component {\r\n  render() {\r\n    return /*#__PURE__*/_jsx("div", {\r\n      children: "dyx"\r\n    });\r\n  }\r\n}\r\n\r\nReactDom.render( /*#__PURE__*/_jsx(App, {}), document.getElementById(\'root\'));\r\n```\r\n### 升级至新的jsx转化\r\n- 更新至支持新的jsx转换的React版本(v17以上)\r\n- 修改babel配置\r\n```\r\n// 如果使用的是@babel/preset-react\r\n{\r\n  "presets": [\r\n    [\r\n      "@babel/preset-react",\r\n      {\r\n        "runtime": "automatic"\r\n      }\r\n    ]\r\n  ]\r\n}\r\n\r\n// 如果使用的是@babel/plugin-transform-react-jsx\r\n{\r\n  "plugins": [\r\n    [\r\n      "@babel/plugin-transform-react-jsx",\r\n      {\r\n        "runtime": "automatic"\r\n      }\r\n    ]\r\n  ]\r\n}\r\n```\r\n- 修改tsconfig.json配置\r\n```\r\n{\r\n  "compilerOptions": {\r\n    // "jsx": "react",\r\n    "jsx": "react-jsx",\r\n  },\r\n}\r\n```\r\n'},function(r,n,e){"use strict";e.r(n),n.default="## key\r\n- key只是针对同一层级的节点进行了diff比较优化，而跨层级的节点互相之间的key值没有影响。\r\n- 建议不要用遍历的index作为节点的key属性值。\r\n- key值在比较之前都会被执行toString()操作，所以尽量不要使用object类型的值作为key。\r\n### key的作用\r\n> 当同一层级的某个节点添加了对于其它同级节点唯一的key属性，当它在当前层级的位置发生了变化后，react Diff算法通过新旧节点比较后，如果发现了key值相同的新旧节点，就会执行移动操作(若虚拟DOM中的内容没变，则直接使用之前的真实DOM，若虚拟DOM中的内容变了，则生成新的真实DOM，随后替换掉页面中之前的真实DOM)，而不会执行原策略的删除旧节点，创建新节点的操作。这无疑大大提高了React性能和渲染效率。\r\n\r\n### key的具体执行过程\r\n> 对新集合中的节点进行循环遍历，通过唯一的key判断新旧集合中是否存在相同的节点，如果存在相同节点，判断当前节点在旧集合中的位置与lastIndex(类似浮标)进行判断如果当前节点在旧集合中的位置(index)小于lastIndex则进行移动操作，否则不执行移动操作操作。\r\n\r\n#### 同一层级的所有节点只发生了位置变化： A、B、C、D 更新为 B、A、D、C\r\n1. B在新集合中 lastIndex(类似浮标) = 0, 在旧集合中 index = 1，index > lastIndex 就认为 B 对于集合中其他元素位置无影响，不进行移动，之后lastIndex = max(index, lastIndex) = 1\r\n2. A在旧集合中 index = 0， 此时 lastIndex = 1, 满足 index < lastIndex, 则对A进行移动操作，此时 lastIndex = max(index, lastIndex) = 1\r\n3. D和B操作相同，同第一步，不进行移动，此时lastIndex = max(index, lastIndex) = 3\r\n4. C和A操作相同，同第二步，进行移动，此时lastIndex = max(index, lastIndex) = 3\r\n#### 同一层级的所有节点发生了节点增删和节点位置变化： A、B、C、D 更新为 B、E、C、A\r\n1. B在新集合中 lastIndex(类似浮标) = 0, 在旧集合中 index = 1，index > lastIndex 就认为 B 对于集合中其他元素位置无影响，不进行移动，之后lastIndex = max(index, lastIndex) = 1\r\n2. 新集合中有E，发现旧集合中不存在E，在 lastIndex处创建E，lastIndex++\r\n3. 在旧集合中取到C，C不移动，lastIndex=2\r\n4. 在旧集合中取到A，A移动到新集合中的位置，lastIndex=2\r\n5. 完成新集合中所有节点diff后，对旧集合进行循环遍历，寻找新集合中不存在但旧集合中有的节点(此例中为D)，删除D节点。\r\n### 使用index作为key的问题\r\n> 遍历数组的时候使用index作为key，在只涉及到数据展示的时候并不会出现什么问题，但是当我们在操作数据时候，很容易出现问题。\r\n\r\n- 删除某一项\r\n> 3个input输入框依次输入随机内容，使用 index 作为 key 的时候，点击删除第一项按钮，左侧文字正确改变，但是input的内容显示不对，input输入框最后一项没了。当我们使用 index 作为 key 时，此时 key 为 0、1、2，删掉第一项后 key 变为 0、1，此时 react 在执行 diff 算法过程中，key = 0 存在，只需要更新子节点的值，所以左侧的 name 成功改变，而 input 的值非受控不会更新。同时在对比计算中少了 key = 2 这项，删除了最后一项。当我们使每一项的值作为 key 时，此时 key 为 name1、name2、name3，删掉第一项后 key 变为 name2、name3，根据 react 的 diff 算法，react 计算出删除一个节点即可。\r\n\r\n```\r\nconst Test = () => {\r\n  const [data, setData] = useState(['name1', 'name2', 'name3']);\r\n\r\n  const deleteFirstItem = () => {\r\n    const newData = [...data];\r\n    newData.shift();\r\n    setData(newData);\r\n  }\r\n\r\n  return (\r\n    <div>\r\n      {data.map((item, index) => {\r\n        return (\r\n          <div key={index}>\r\n            {item}\r\n            <input type=\"value\" />\r\n          </div>\r\n        );\r\n      })}\r\n      <button onClick={deleteFirstItem}>删除第一项</button>\r\n    </div>\r\n  )\r\n}\r\n```\r\n- 修改顺序\r\n> 效果类似于上述的删除第一项，左侧文字正常改变，input的值不会发生变化。\r\n\r\n```\r\nconst Test = () => {\r\n  const [data, setData] = useState(['name1', 'name2', 'name3']);\r\n\r\n  const reverse = () => {\r\n    setData(['name3', 'name2', 'name1']);\r\n  }\r\n\r\n  return (\r\n    <div>\r\n      {data.map((item, index) => {\r\n        return (\r\n          <div key={index}>\r\n            {item}\r\n            <input type=\"value\" />\r\n          </div>\r\n        );\r\n      })}\r\n      <button onClick={reverse}>修改顺序</button>\r\n    </div>\r\n  )\r\n}\r\n```\r\n### key机制的缺点\r\n> A、B、C、D 更新为 D、A、B、C，与旧集合相比只有 D 节点移动，而 A、B、C 仍然保持原有的顺序，理论上 diff 应该只需对 D 执行移动操作，然而由于 D 在旧集合中的位置是最大的，导致其他节点的 index < lastIndex，造成 D 没有执行移动操作，而是 A、B、C 全部移动到 D 节点后面的现象。尽量减少类似将最后一个节点移动到列表首部的操作。当节点数量过大或更新操作过于频繁时，这在一定程度上会影响 React 的渲染性能。"},function(r,n,e){"use strict";e.r(n),n.default="## re-render\r\n> 已经在页面上渲染的组件进行第二次或后续多次渲染。\r\n\r\n### State更改\r\n- 当组件的State发生变化时，组件会重新渲染。\r\n### Props更改\r\n- 当组件的Props发生变化时，组件会重新渲染。\r\n### 父组件重新渲染\r\n- 如果组件的父组件重新渲染，组件也会重新渲染。\r\n- 子组件的重新渲染不会触发父组件的重新渲染。\r\n### 组件依赖的上下文(context)发生变化\r\n- 如果上下文(context)的值发生变化，React会自动重新渲染订阅了该上下文(context)的所有组件。\r\n### forceUpdate强制更新\r\n### 组件依赖的自定义hooks发生变化\r\n- 自定义hooks发生的一切都 “属于” 使用它的组件。\r\n- 组件使用自定义hooks可以理解为组件只是调用了自定义hooks中的useState和useEffect，所以自定义hooks中的状态改变，使用自定义hooks的组件也会重新render。\r\n- 自定义hooks内部的状态变化，组件会重新渲染。\r\n- 如果自定义hooks有依赖的上下文(context)，并且依赖的上下文(context)值发生变化，组件会重新渲染。"},function(r,n,e){"use strict";e.r(n),n.default="## react-intl国际化\r\n### 安装依赖\r\n```\r\nyarn add react-intl\r\n```\r\n### 添加国际化语言配置\r\n- en_US.js\r\n```\r\nconst en_US = {\r\n  search: 'Search'\r\n};\r\n\r\nexport { en_US };\r\n```\r\n- zh_CN.js\r\n```\r\nconst zh_CN = {\r\n  search: '搜索'\r\n};\r\n\r\nexport { zh_CN };\r\n```\r\n- index.ts\r\n```\r\nimport zhCN from 'antd/lib/locale/zh_CN';\r\nimport enUS from 'antd/lib/locale/en_US';\r\nimport { zh_CN } from './zh_CN';\r\nimport { en_US } from './en_US';\r\n\r\nexport const getLocale = (lang: string) => {\r\n  let locale = null;\r\n  let antLocale = null;\r\n  let messages = null;\r\n  switch (lang) {\r\n    case 'en-US':\r\n      locale = 'en-US';\r\n      antLocale = enUS;\r\n      messages = en_US;\r\n      break;\r\n    case 'zh-CN':\r\n      locale = 'zh-CN';\r\n      antLocale = zhCN;\r\n      messages = zh_CN;\r\n      break;\r\n    default:\r\n      locale = 'zh-CN';\r\n      antLocale = zhCN;\r\n      messages = zh_CN;\r\n      break;\r\n  }\r\n  // 语言环境、Ant Design组件库的语言环境、国际化语言内容\r\n  return { locale, antLocale, messages };\r\n};\r\n```\r\n### redux中存储当前的语言环境\r\n```\r\n// reducer.ts\r\ninterface PayloadDataType {\r\n  locale: string;\r\n}\r\n\r\ninterface ActionType {\r\n  type: string;\r\n  payload?: PayloadDataType;\r\n}\r\nconst initState = {\r\n  locale: localStorageUtil.getItem('locale') || 'zh-CN' // locale\r\n};\r\n\r\nexport const configStore = (state = initState, action: ActionType) => {\r\n  const { type, payload } = action;\r\n  switch (type) {\r\n    case 'changeLocale':\r\n      localStorageUtil.setItem('locale', payload?.locale);\r\n      return {\r\n        locale: payload?.locale\r\n      };\r\n    default:\r\n      return state;\r\n  }\r\n};\r\n```\r\n### 入口文件配置\r\n```\r\nimport React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport { Provider } from 'react-redux';\r\nimport { IntlProvider } from 'react-intl';\r\nimport { ConfigProvider } from 'antd';\r\nimport 'antd/dist/antd.css';\r\nimport Routes from './routes';\r\nimport store from './store';\r\nimport { getLocale } from '@/assets/locale';\r\nimport './index.css';\r\n\r\nconst App = () => {\r\n  // 获取语言信息\r\n  const currentLocale = store.getState().configStore.locale;\r\n  const { locale, antLocale, messages } = getLocale(currentLocale);\r\n\r\n  return (\r\n    <Provider store={store}>\r\n      <IntlProvider locale={locale} messages={messages}>\r\n        <ConfigProvider locale={antLocale}>\r\n          <Routes />\r\n        </ConfigProvider>\r\n      </IntlProvider>\r\n    </Provider>\r\n  );\r\n};\r\n\r\nReactDOM.render(<App />, document.getElementById('root'));\r\n```\r\n### 组件中使用\r\n```\r\nimport { FormattedMessage } from 'react-intl';\r\n\r\n<FormattedMessage id=\"search\" />\r\n```\r\n### 切换语言\r\n```\r\n// 修改语言\r\nconst onChangeLocale = () => {\r\n  dispatch({\r\n    type: 'changeLocale',\r\n    payload: { locale: locale === 'zh-CN' ? 'en-US' : 'zh-CN' }\r\n  });\r\n  window.location.reload();\r\n};\r\n```\r\n### 非组件中使用国际化\r\n- 使用createIntl创建intl实例导出。\r\n```\r\nimport { createIntl, createIntlCache } from 'react-intl';\r\nimport zhCN from 'antd/lib/locale/zh_CN';\r\nimport enUS from 'antd/lib/locale/en_US';\r\nimport { zh_CN } from './zh_CN';\r\nimport { en_US } from './en_US';\r\n\r\nexport const getLocale = (lang: string) => {\r\n  let locale = null;\r\n  let antLocale = null;\r\n  let messages = null;\r\n  switch (lang) {\r\n    case 'en-US':\r\n      locale = 'en-US';\r\n      antLocale = enUS;\r\n      messages = en_US;\r\n      break;\r\n    case 'zh-CN':\r\n      locale = 'zh-CN';\r\n      antLocale = zhCN;\r\n      messages = zh_CN;\r\n      break;\r\n    default:\r\n      locale = 'zh-CN';\r\n      antLocale = zhCN;\r\n      messages = zh_CN;\r\n      break;\r\n  }\r\n  return { locale, antLocale, messages };\r\n};\r\n\r\n// 导出intl实例\r\nexport const getIntl = (lang: string) => {\r\n  const cache = createIntlCache();\r\n  const { locale, messages } = getLocale(lang);\r\n\r\n  return createIntl(\r\n    {\r\n      locale,\r\n      messages\r\n    },\r\n    cache\r\n  );\r\n};\r\n```\r\n- 非组件中使用\r\n```\r\nimport { getIntl } from '@/assets/locale';\r\n\r\nmessage.success(\r\n  getIntl(store.getState().configStore.locale).formatMessage({\r\n    id: 'search'\r\n  })\r\n);\r\n```\r\n### 国际化支持参数传递\r\n- en_US.js\r\n```\r\nconst en_US = {\r\n  search: 'Search {content}'\r\n};\r\n\r\nexport { en_US };\r\n```\r\n- zh_CN.js\r\n```\r\nconst zh_CN = {\r\n  search: '搜索 {content}'\r\n};\r\n\r\nexport { zh_CN };\r\n```\r\n- 组件中使用\r\n```\r\nimport { FormattedMessage } from 'react-intl';\r\n\r\n<FormattedMessage id=\"search\" values={{ content: 'dyx' }} />\r\n```\r\n- 非组件中使用\r\n```\r\nimport { getIntl } from '@/assets/locale';\r\n\r\nmessage.success(\r\n  getIntl(store.getState().configStore.locale).formatMessage(\r\n    { id: 'search' },\r\n    { content: 'dyx' }\r\n  )\r\n);\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## react-router4 Prompt实现路由跳转前的提示\r\n[Demo地址](https://github.com/dyxweb/RouterPrompt)\r\n> Prompt组件是react-router4提供的组件，主要作用于路由跳转前的阻止、提示等操作，常使用于提示用户未保存等提示。\r\n\r\n### when\r\n> 当Prompt的when属性为true时，渲染Prompt该组件。\r\n\r\n### message\r\n> 阻止时的提示框的文字内容(string)，也可以使用函数形式的属性值，动态返回message值，也可以通过函数形式实现自定义提示组件。\r\n\r\n### 简单形式\r\n> 默认的Prompt提示样式。\r\n\r\n```\r\n/**\r\n * 使用Prompt的默认提示框阻止跳转\r\n */\r\nimport React, { Component } from 'react';\r\nimport { Prompt, Link } from 'react-router-dom';\r\n\r\nexport default class DefaultPrompt extends Component {\r\n  render() {\r\n    return (\r\n      <div>\r\n        <Link to=\"/function/message\">跳转到function形式的message的页面</Link>\r\n        {/* when为true时表示阻止默认的跳转行为 */}\r\n        <Prompt when={true} message='确认离开此页面？' />\r\n        <h1>\r\n          使用Prompt的默认提示框阻止跳转\r\n        </h1>\r\n      </div>\r\n    )\r\n  }\r\n}\r\n```\r\n### 使用Prompt的message的function形式实现自定义的提示样式\r\n> 可以实现自定义样式，如使用常用UI组件库的弹窗提示等，只能作用于当前组件的跳转时的自定义样式，优先级高于Router的getUserConfirmation方法。\r\n\r\n```\r\n/**\r\n * 使用Prompt的message的function形式实现自定义的提示样式\r\n */\r\nimport React, { Component } from 'react';\r\nimport { Prompt, Link } from 'react-router-dom';\r\nimport { Modal } from 'antd';\r\n\r\nexport default class FunctionMessage extends Component {\r\n  state = {\r\n    isBlock: true, // 是否阻止离开此页面\r\n  };\r\n\r\n  // 确认离开时的方法\r\n  onConfirmLeave = pathname => {\r\n    // 将isBlock设置为false，不再阻止跳转行为，并手动进行路由跳转\r\n    this.setState({\r\n      isBlock: false,\r\n    }, () => this.props.history.push(pathname));\r\n  }\r\n\r\n  render() {\r\n    const { isBlock } = this.state;\r\n    return (\r\n      <div>\r\n        <Link to=\"/default/prompt\">跳转到默认提示的页面</Link>\r\n        <Prompt\r\n          when={isBlock}\r\n          message={location => {\r\n            Modal.confirm({\r\n              title: '确认离开此页面？',\r\n              onOk: () => this.onConfirmLeave(location),\r\n            })\r\n            return false;\r\n          }}\r\n        />\r\n        <h1>\r\n          使用Message的function的用法实现自定义阻止效果\r\n        </h1>\r\n      </div>\r\n    )\r\n  }\r\n}\r\n```\r\n### 使用Router的getUserConfirmation实现自定义提示样式\r\n> 可以作用于所有使用Prompt组件的路由页面。\r\n\r\n```\r\nimport React, { Component } from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport {BrowserRouter as Router, Route, Switch, Redirect} from 'react-router-dom';\r\nimport { Modal } from 'antd';\r\nimport FunctionMessage from './FunctionMessage';\r\nimport DefaultPrompt from './DefaultPrompt';\r\n\r\nexport default class App extends Component {\r\n  // 提示框的确认的方法(移除挂载自定义提示组件的dom)\r\n  onOk = callback => {\r\n    callback(true);\r\n    const routerDom = document.getElementById('router-dom');\r\n    document.getElementsByTagName('body')[0].removeChild(routerDom);\r\n    ReactDOM.unmountComponentAtNode(routerDom);\r\n  };\r\n\r\n  // 提示框的取消的方法(移除挂载自定义提示组件的dom)\r\n  onCancel = callback => {\r\n    callback(false);\r\n    const routerDom = document.getElementById('router-dom');\r\n    document.getElementsByTagName('body')[0].removeChild(routerDom);\r\n    ReactDOM.unmountComponentAtNode(routerDom);\r\n  };\r\n\r\n  // getUserConfirmation自定义提示，message就是对应路由页面的message信息\r\n  getConfirmation = (message, callback) => {\r\n    // 在body下添加新的节点用于挂载自定义提示组件\r\n    const routerDom = document.createElement('div');\r\n    routerDom.setAttribute('id', 'router-dom');\r\n    document.getElementsByTagName('body')[0].appendChild(routerDom);\r\n    const ConFirmComponent = () => (\r\n      <Modal\r\n        title=\"使用getUserConfirmation实现自定义离开样式\"\r\n        visible={true}\r\n        onOk={() => this.onOk(callback)}\r\n        onCancel={() => this.onCancel(callback)}\r\n      >\r\n        {message}\r\n      </Modal>\r\n    )\r\n    ReactDOM.render(\r\n      <ConFirmComponent />,\r\n      document.getElementById('router-dom')\r\n    )\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <Router getUserConfirmation={this.getConfirmation}>\r\n        <Switch>\r\n          <Route path=\"/default/prompt\" component={DefaultPrompt} />\r\n          <Route path=\"/function/message\" component={FunctionMessage} />\r\n          <Redirect to=\"/default/prompt\" />\r\n        </Switch>\r\n      </Router>\r\n    )\r\n  }\r\n};\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## react\r\n> React是一个UI库，它的核心思想是数据驱动视图UI = F(data), 即界面的呈现是由函数传入的参数决定的。开发者不再需要关心界面时如何渲染的，只要关心数据的生成和传递。\r\n\r\n### react设计思想\r\n- 数据驱动试图，要渲染界面，不应该直接操作DOM，而是通过修改数据(State或Props)。\r\n- 通过虚拟DOM修改真实DOM，虚拟DOM是对真实DOM的映射，通过新旧虚拟DOM对比，得到需要更新的部分，实现数据的增量更新。\r\n- 组件化，不同组件可以通过Props(单项数据流)进行数据交互。\r\n- 使用类似HTML的JSX语法来描述视图。\r\n- 通过setState修改数据。\r\n- 在不同的生命周期阶段做不同的事。\r\n- 源码底层对真实DOM事件进行封装，使用事件委托的方式来捕获DOM事件。\r\n### 状态管理\r\n- jQuery时代是手动把数据渲染到视图和执行数据变化之后的逻辑的，它可能没有明确的状态这一层，而是直接把数据渲染成DOM，下次需要数据也是从DOM获取来的。\r\n- Vue、React前端框架的时代不需要手动操作DOM和执行数据变化之后的逻辑，只要管理好状态，由前端框架负责状态变化之后的处理。\r\n\r\n"},function(r,n,e){"use strict";e.r(n),n.default='## react18变化\r\n### setState自动批处理\r\n- 自动批处理是指React将多次setState会被合并为1次执行。\r\n- 在React 18之前，React只会在合成事件和生命周期钩子函数中使用批处理，而在Promise、setTimeout、setInterval、原生事件是不会自动批处理的。\r\n- 在React 18中所有的状态更新都会自动使用批处理。如果在某种场景下不想使用批处理，可以通过flushSync来强制立即执行(比如需要在状态更新后，立刻读取新DOM上的数据等)\r\n```\r\nimport React, { useState } from "react";\r\nimport { flushSync } from "react-dom";\r\n\r\nconst App = () => {\r\n  const [count, setCount] = useState(0);\r\n  const [count2, setCount2] = useState(0);\r\n\r\n  return (\r\n    <div className="App">\r\n      <button\r\n        onClick=(() => {\r\n          // 第一次更新\r\n          flushSync(()=>{\r\n            setCount(count => count + 1);\r\n          })\r\n          // 第二次更新\r\n          flushSync(() => {\r\n            setCount2(count2 => count2 + 1);\r\n          })\r\n        })\r\n      >\r\n        点击\r\n      </button>\r\n      <span>count:{count}</span>\r\n      <span>count2:{count2}</span>\t\r\n    </div>\t\r\n  )\r\n}\r\nexport default App;\r\n```\r\n### React 18提供了更合理的初始化API，使用该API会自动启用concurrent(并发)模式。\r\n- React 18之前\r\n```\r\nimport React from "react";\r\nimport ReactDOM from "react-dom";\r\nimport App from "./App";\r\n\r\nconst root = document.getElementById("root");\r\nReactDOM.render(root, <App />);\r\n\r\n// 卸载组件\r\nReactDOM.unmountComponentAtNode(root);\r\n```\r\n- React 18\r\n```\r\nimport React from "react";\r\nimport ReactDOM from "react-dom/client";\r\nimport App from "./App";\r\n\r\nconst root = ReactDOM.createRoot(document.getElementById("root"));\r\nroot.render(<App />);\r\n\r\n// 卸载组件\r\nroot.unmount(); \r\n```\r\n### Concurrent Mode(并发模式)\r\n- 并发模式不是一个功能，而是一个底层设计。它可以帮助应用保持响应，根据用户的设备性能和网速进行调整，它通过渲染可中断来修复阻塞渲染机制。\r\n- 在concurrent模式中，React可以同时更新多个状态，区别就是使同步不可中断更新变成了异步可中断更新。\r\n- useDeferredValue和startTransition用来标记一次非紧急更新。\r\n### 去掉了对IE浏览器的支持\r\n- react18引入的新特性全部基于现代浏览器，如需支持需要退回到react17版本。\r\n### react组件返回值更新\r\n- 在react17中，返回空组件只能返回null，显式返回undefined会报错。\r\n- 在react18中，支持null和undefined返回。\r\n### strict mode更新\r\n- 当使用严格模式时，React会对每个组件返回两次渲染，以便观察一些意想不到的结果。\r\n- 在react17中去掉了一次渲染的控制台日志，以便让日志容易阅读。react18取消了这个限制，第二次渲染会以浅灰色出现在控制台日志。\r\n### Suspense不再需要fallback捕获\r\n### 支持useId\r\n- 在服务器和客户端生成相同的唯一id，避免hydrating的不兼容。\r\n### useSyncExternalStore\r\n- 用于解决外部数据撕裂问题。\r\n### useInsertionEffect\r\n- 这个hooks只建议在css in js库中使用，这个hooks执行时机在DOM生成之后，useLayoutEffect执行之前，它的工作原理大致与useLayoutEffect相同，此时无法访问DOM节点的引用，一般用于提前注入脚本。\r\n\r\n\r\n'},function(r,n,e){"use strict";e.r(n),n.default='## Concurrent Mode (并发模式)\r\n> 在并发模式下，React在执行过程中每执行一个Fiber都会看看有没有更高优先级的更新，如果有则当前低优先级的的更新会被暂停，待高优先级任务执行完之后，再继续执行或重新执行。\r\n\r\n### React 的状态更新可以分为两类\r\n> 并发模式只是提供了可中断的能力，并不会自动帮我们区分不同优先级的更新。默认情况下，所有的更新都是紧急更新。\r\n\r\n1. 紧急更新(Urgent updates)：比如打字、点击、拖动等，需要立即响应的行为，如果不立即响应会给人很卡，或者应用出问题的感觉。\r\n2. 过渡更新(Transition updates)：将UI从一个视图过渡到另一个视图，不需要即时响应，有些延迟是可以接受的。\r\n### startTransition\r\n> 会在高优先级更新渲染完成之后，才会启动低优先级更新渲染，并且低优先级渲染随时可被其它高优先级更新中断。通过startTransition标记了非紧急更新，让树的更新变成低优先级的，可以被随时中止，保证了高优先级的Slider的体验。\r\n\r\n```\r\nconst [treeLeanInput, setTreeLeanInput] = useState(0); // Slider的控制\r\nconst [treeLean, setTreeLean] = useState(0); // 绘制树的控制\r\n\r\nfunction changeTreeLean(event) {\r\n  const value = Number(event.target.value);\r\n  setTreeLeanInput(value)\r\n\r\n  // 将 treeLean 的更新用 startTransition 包裹\r\n  React.startTransition(() => {\r\n    setTreeLean(value);\r\n  });\r\n}\r\n\r\nreturn (\r\n  <>\r\n    <input type="range" value={treeLeanInput} onChange={changeTreeLean} />\r\n    <Pythagoras lean={treeLean} />\r\n  </>\r\n)\r\n```\r\n- input 更新\r\n  1. treeLeanInput 状态变更\r\n  2. 准备新的 DOM\r\n  3. 渲染 DOM\r\n- 树更新（这一次更新是低优先级的，随时可以被中止）\r\n  1. treeLean 状态变更\r\n  2. 准备新的 DOM\r\n  3. 渲染 DOM\r\n### useTransition\r\n> 在低优先状态等待更新过程中，有一个Loading的状态。\r\n\r\n```\r\nconst [treeLeanInput, setTreeLeanInput] = useState(0);\r\nconst [treeLean, setTreeLean] = useState(0);\r\n\r\n// 实时监听 transition 状态\r\nconst [isPending, startTransition] = useTransition();\r\n\r\nfunction changeTreeLean(event) {\r\n  const value = Number(event.target.value);\r\n  setTreeLeanInput(value)\r\n\r\n  // 将 treeLean 的更新用 startTransition 包裹\r\n  startTransition(() => {\r\n    setTreeLean(value);\r\n  });\r\n}\r\n\r\nreturn (\r\n  <>\r\n    <input type="range" value={treeLeanInput} onChange={changeTreeLean} />\r\n    // 等待更新过程添加loading效果\r\n    <Spin spinning={isPending}>\r\n      <Pythagoras lean={treeLean} />\r\n    </Spin>\r\n  </>\r\n)\r\n```'},function(r,n,e){"use strict";e.r(n),n.default="## react为什么需要一个根标签包裹\r\n### react能创建多个根元素\r\n- react的组件渲染的不是根元素，只有ReactDOM.render、React.createRoot才会创建根元素。\r\n- 在应用内可以多次使用ReactDOM.render，所以react能创建多个根元素。\r\n```\r\nReactDOM.render(<App />, document.getElementById('root'));\r\nReactDOM.render(<App1 />, document.getElementById('root1'));\r\n```\r\n- 很多组件库的toast、modal其实都用到创建多个根元素的技术。\r\n### react根元素能渲染多个组件\r\n- 使用数组包裹多个组件\r\n```\r\nReactDOM.render(\r\n  [<App />, <App1 />],\r\n  document.getElementById('root')\r\n);\r\n```\r\n- 使用Fragment包裹多个组件\r\n```\r\nReactDOM.render(\r\n  <Fragment>\r\n    <App />\r\n    <App1 />\r\n  </Fragment>,\r\n  document.getElementById('root')\r\n);\r\n```\r\n### react组件能渲染多个元素\r\n- 组件的返回值使用JSX的方式是可以返回多个element的。\r\n- 使用数组包裹多个element\r\n```\r\nconst App = () => {\r\n  return ([\r\n    <div>Hello</div>,\r\n    <div>World</div>\r\n  ]);\r\n};\r\n```\r\n- 使用Fragment包裹多个element\r\n```\r\nconst App = () => {\r\n  return (\r\n    <Fragment>\r\n      <div>Hello</div>\r\n      <div>World</div>\r\n    </Fragment>\r\n  );\r\n};\r\n```\r\n- 不能使用如下写法\r\n  1. 因为JSX最后会被编译为React.createElement(...)的表达式。\r\n  2. 一个函数不能返回多个表达式，可以通过数组或Fragment包裹的方式将多个表达式包裹成一个表达式。\r\n```\r\nconst App = () => {\r\n  return (\r\n    <div>Hello</div>\r\n    <div>World</div>\r\n  );\r\n};\r\n```\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## [react事件机制](https://mp.weixin.qq.com/s/DI0oQI7Q-v5vrySRkD1ckw)\r\n### 事件传播机制\r\n> 一般的事件触发都会经历三个阶段。如果想阻止事件的传播，可以在指定节点的事件监听器通过event.stopPropagation()或event.cancelBubble = true阻止事件传播。有些事件是没有冒泡阶段的，如scroll、blur、及各种媒体事件等。\r\n\r\n1. 捕获阶段，事件从 window 开始，自上而下一直传播到目标元素的阶段。\r\n2. 目标阶段，事件真正的触发元素处理事件的阶段。\r\n3. 冒泡阶段，从目标元素开始，自下而上一直传播到 window 的阶段。\r\n### 绑定事件的方法\r\n- 行内 HTML 事件绑定。\r\n> js 和 html 代码耦合。\r\n\r\n```\r\n<div onclick=\"handleClick()\">test</div>\r\n<script>\r\n  let handleClick = function(){\r\n    // ...\r\n  }\r\n\r\n  // 移除事件\r\n  handleClick = function(){}\r\n<\/script>\r\n```\r\n- 事件处理器属性(DOM0)。\r\n> 作为属性使用，一次只能绑定一个事件，多次赋值会覆盖，只能处理冒泡阶段。\r\n\r\n```\r\n<div id=\"test\">test</div>\r\n<script>\r\n  let target = document.getElementById('test')\r\n  // 绑定事件\r\n  target.onclick = function(){\r\n    // ...\r\n  }\r\n  target.onclick = function(){\r\n    // ...会覆盖上面的方法\r\n  }\r\n  // 移除事件\r\n  target.onclick = null;\r\n<\/script>\r\n```\r\n- addEventListener(DOM2)\r\n> 就是为了绑定事件而生的 api，拓展性最强，现在开发者一般都用 addEventListener 绑定事件监听器。\r\n\r\n```\r\n<div id=\"test\">test</div>\r\n<script>\r\n  let target = document.getElementById('test');\r\n  // 绑定事件\r\n  let funcA = function(){\r\n    // ...\r\n  }\r\n  let funcB = function(){\r\n    // ...\r\n  }\r\n  // 添加冒泡阶段监听器\r\n  target.addEventListener('click', funcA, false);\r\n  // 添加捕获阶段监听器\r\n  target.addEventListener('click', funcB, true);\r\n  // 移除监听器\r\n  target.removeEventListener('click', funcA);\r\n<\/script>\r\n```\r\n### 事件委托\r\n> 当节点的数量较多时，如果给每个节点都进行事件绑定的话，内存消耗大，可将事件绑定到其父节点上统一处理，减少事件绑定的数量。\r\n\r\n```\r\n<ul id=\"parent\">\r\n  <li>1</li>\r\n  <li>2</li>\r\n  <li>3</li>\r\n  ...\r\n  <li>999</li>\r\n  <li>1000</li>\r\n</ul>\r\n<script>\r\n  let parent = document.getElementById('parent');\r\n  parent.addEventListener('click', (e) => {\r\n    // 根据e.target进行处理\r\n  })\r\n<\/script>\r\n```\r\n### 浏览器事件差异\r\n> 由于浏览器厂商的实现差异，在事件的属性及方法在不同浏览器及版本上略有不同，开发者为兼容各浏览器及版本之间的差异，需要编写兼容代码。\r\n\r\n```\r\n// 阻止事件传播\r\nfunction stopPropagation(e) {\r\n  if (typeof e.stopPropagation === 'function') {\r\n    e.stopPropagation();\r\n  } else {\r\n    // 兼容ie\r\n    e.cancelBubble = true;\r\n  }\r\n}\r\n\r\n// 阻止默认事件\r\nfunction preventDefault(e) {\r\n  if (typeof e.preventDefault === 'function') {\r\n    e.preventDefault();\r\n  } else {\r\n    // 兼容ie\r\n    e.returnValue = false;\r\n  }\r\n}\r\n\r\n// 获取事件触发元素\r\nfunction getEventTarget(e) {\r\n  let target = e.target || e.srcElement || window;\r\n}\r\n```\r\n### react中的事件类型\r\n- 原生事件: 在componentDidMount生命周期里边通过addEventListener绑定的事件。\r\n- 合成事件: 通过JSX方式绑定的事件，比如onClick={() => this.handle()}。\r\n- 当事件在具体的DOM节点上被触发后，最终都会冒泡到document上，document上所绑定的统一事件处理程序会将事件分发到具体的组件实例。\r\n### 为什么 React 实现自己的事件机制\r\n- 将事件都代理到了根节点上，减少了事件监听器的创建，节省了内存。\r\n- 磨平浏览器差异，开发者无需兼容多种浏览器写法。如想阻止事件传播时需要编写event.stopPropagation() 或 event.cancelBubble = true，在 React 中只需编写event.stopPropagation()即可。\r\n- 对开发者友好。只需在对应的节点上编写如onClick、onClickCapture等代码即可完成click事件在该节点上冒泡节点、捕获阶段的监听，统一了写法。\r\n### React自己事件机制实现步骤\r\n#### 事件分类\r\n> React 对在 React 中使用的事件进行了分类，具体通过各个类型的事件处理插件分别处理。\r\n\r\n1. 这里的分类是对 React 事件进行分类的，简单事件如onClick和onClickCapture，它们只依赖了原生事件click。而有些事件是由 React 统一包装给用户使用的，如onChange，它依赖了['change','click','focusin','focusout','input','keydown','keyup','selectionchange']，这是 React 为了兼容不同表单的修改事件收集，如对于`<input type=\"checkbox\" />`和`<input type=\"radio\" />`开发者原生需要使用click事件收集表单变更后的值，而在 React 中可以统一使用onChange来收集。\r\n2. 分类并不代表依赖的原生事件之间没有交集。 如简单事件中有onKeyDown，它依赖于原生事件keydown。输入前事件有onCompositionStart，它也依赖了原生事件keydown。表单修改事件onChange，它也依赖了原生事件keydown。\r\n\r\n- SimpleEventPlugin简单事件，代表事件onClick。\r\n- BeforeInputEventPlugin输入前事件，代表事件onBeforeInput。\r\n- ChangeEventPlugin表单修改事件，代表事件onChange。\r\n- EnterLeaveEnventPlugin鼠标进出事件，代表事件onMouseEnter。\r\n- SelectEventPlugin选择事件，代表事件onSelect。\r\n#### 事件收集\r\n> React 需要对所有的事件做代理委托，所以需要事先知道浏览器支持的所有事件，这些事件都是硬编码在 React 源码的各个事件插件中的。而对于所有需要代理的原生事件，都会以原生事件名字符串的形式存储在一个名为allNativeEvents的集合中，并且在registrationNameDependencies中存储 React 事件名到其依赖的原生事件名数组的映射。\r\n\r\n1. 事件的收集是通过各个事件处理插件各自收集注册的，在页面加载时，会执行各个插件的registerEvents，将所有依赖的原生事件都注册到allNativeEvents中去，并且在registrationNameDependencies中存储映射关系。\r\n2. 对于原生事件不支持冒泡阶段的事件，硬编码的形式存储在了nonDelegatedEvents集合中，原生不支持冒泡阶段的事件在后续的事件代理环节有不一样的处理方式。\r\n```\r\n// React代码加载时就会执行以下js代码\r\nSimpleEventPlugin.registerEvents();\r\nEnterLeaveEventPlugin.registerEvents();\r\nChangeEventPlugin.registerEvents();\r\nSelectEventPlugin.registerEvents();\r\nBeforeInputEventPlugin.registerEvents();\r\n\r\n// 上述代码执行完后allNativeEvents集合中就会有cancel、click等80种事件\r\nallNativeEvents = ['cancel','click', ...]\r\n\r\n// nonDelegatedEvents有cancel、close等29种事件\r\nnonDelegatedEvents = ['cancel','close'，...]\r\n\r\n// registrationNameDependencies保存react事件和其依赖的事件的映射\r\nregistrationNameDependencies = {\r\n  onClick: ['click'],\r\n  onClickCapture: ['click'],\r\n  onChange: ['change','click','focusin','focusout','input','keydown','keyup','selectionchange'],\r\n  ...\r\n}\r\n```\r\n#### 事件代理\r\n- 原生事件支持冒泡的可代理事件。\r\n  1. 将事件委托代理到根元素的操作发生在ReactDOM.render(element, container)时。在ReactDOM.render的实现中，在创建了fiberRoot后，在开始构造fiber树前，会调用listenToAllSupportedEvents进行事件的绑定委托。\r\n  > 首先会判断根元素上的事件监听器相关的字段是否已标记完成过监听，如果没有完成，则将根标记为已监听过，并遍历allNativeEvents进行事件的委托绑定。是否完成监听的判断是避免多次调用ReactDOM.render(element, container)是对同一个container重复委托事件。listenToNativeEvent即对元素进行事件绑定的方法，第二个参数的含义是是否将监听器绑定在捕获阶段。对于不存在冒泡阶段的事件，React 只委托了捕获阶段的监听器，而对于其他的事件，则对于捕获阶段和冒泡阶段都委托了监听器。\r\n\r\n  ```\r\n  const listeningMarker =\r\n    '_reactListening' +\r\n    Math.random()\r\n      .toString(36)\r\n      .slice(2);\r\n\r\n  export function listenToAllSupportedEvents(rootContainerElement: EventTarget) {\r\n    if (enableEagerRootListeners) {\r\n      if ((rootContainerElement: any)[listeningMarker]) {\r\n        // 避免重复初始化\r\n        return;\r\n      }\r\n      // 将该根元素标记为已初始化事件监听\r\n      (rootContainerElement: any)[listeningMarker] = true;\r\n      allNativeEvents.forEach(domEventName => {\r\n        if (!nonDelegatedEvents.has(domEventName)) {\r\n          listenToNativeEvent(\r\n            domEventName,\r\n            false,\r\n            ((rootContainerElement: any): Element),\r\n            null,\r\n          );\r\n        }\r\n        listenToNativeEvent(\r\n          domEventName,\r\n          true,\r\n          ((rootContainerElement: any): Element),\r\n          null,\r\n        );\r\n      });\r\n    }\r\n  }\r\n  ```\r\n  2. listenToNativeEvent的内部会将绑定了入参的dispatchEvent使用addEventListener绑定到根元素上。\r\n  > 原生事件支持冒泡的可代理事件在根元素上绑定了捕获和冒泡阶段的回调，原生事件不支持冒泡的非代理事件在根元素上只绑定了捕获阶段的回调。\r\n\r\n  ```\r\n  export function dispatchEvent(\r\n    domEventName: DOMEventName, // 原生事件名\r\n    eventSystemFlags: EventSystemFlags, // 事件标记，如是否捕获阶段\r\n    targetContainer: EventTarget, // 绑定事件的根\r\n    nativeEvent: AnyNativeEvent, // 实际触发时传入的真实事件对象\r\n  ): void {\r\n      // ... 前三个参数在绑定到根上时已传入\r\n  }\r\n\r\n  // 提前绑定入参\r\n  const listener = dispatchEvent.bind(\r\n    null,\r\n    targetContainer,\r\n    domEventName,\r\n    eventSystemFlags,\r\n  )\r\n  if (isCapturePhaseListener) {\r\n    addEventCaptureListener(targetContainer, domEventName, listener)\r\n  } else {\r\n    addEventBubbleListener(targetContainer, domEventName, listener)\r\n  }\r\n\r\n  // 添加冒泡事件监听器\r\n  export function addEventBubbleListener(\r\n    target: EventTarget,\r\n    eventType: string,\r\n    listener: Function,\r\n  ): Function {\r\n    target.addEventListener(eventType, listener, false);\r\n    return listener;\r\n  }\r\n\r\n  // 添加捕获事件监听器\r\n  export function addEventCaptureListener(\r\n    target: EventTarget,\r\n    eventType: string,\r\n    listener: Function,\r\n  ): Function {\r\n    target.addEventListener(eventType, listener, true);\r\n    return listener;\r\n  }\r\n  ```\r\n- 原生事件不支持冒泡的非代理事件。实际上 React 对这些不可冒泡的事件都进行了冒泡模拟。\r\n> 对于非代理事件nonDelegatedEvents，由于这些事件不存在冒泡阶段，在根部代理他们的冒泡阶段监听器也不会触发，所以需要特殊处理。这些事件的代理发生在 DOM 实例的创建阶段，也就是render阶段的completeWork阶段。通过调用finalizeInitialChildren为 DOM 实例设置属性时，判断 DOM 节点类型来添加响应的冒泡阶段监听器。如为`<img />`和`<link />`标签对应的 DOM 实例添加error和load的监听器。\r\n\r\n```\r\nexport function setInitialProperties(\r\n  domElement: Element,\r\n  tag: string,\r\n  rawProps: Object,\r\n  rootContainerElement: Element | Document,\r\n): void {\r\n  // ...\r\n  switch (tag) {\r\n    // ...\r\n    case 'img':\r\n    case 'image':\r\n    case 'link':\r\n        listenToNonDelegatedEvent('error', domElement);\r\n        listenToNonDelegatedEvent('load', domElement);\r\n        break;\r\n    // ...\r\n  }\r\n  // ...\r\n}\r\n\r\n// 非代理事件监听器绑定\r\nexport function listenToNonDelegatedEvent(\r\n  domEventName: DOMEventName,\r\n  targetElement: Element,\r\n): void {\r\n  // 绑定在目标/冒泡阶段\r\n  const isCapturePhaseListener = false;\r\n  const listenerSet = getEventListenerSet(targetElement);\r\n  const listenerSetKey = getListenerSetKey(\r\n    domEventName,\r\n    isCapturePhaseListener,\r\n  );\r\n  if (!listenerSet.has(listenerSetKey)) {\r\n    addTrappedEventListener(\r\n      targetElement,\r\n      domEventName,\r\n      IS_NON_DELEGATED, // 非代理事件\r\n      isCapturePhaseListener, // 目标/冒泡阶段\r\n    );\r\n    listenerSet.add(listenerSetKey);\r\n  }\r\n}\r\n```\r\n### 合成事件\r\n> 合成事件SyntheticEvent是 React 事件系统对于原生事件跨浏览器包装器。它除了兼容所有浏览器外，它符合W3C规范，包括事件触发、事件冒泡、事件捕获、事件合成和事件派发等，它还拥有和浏览器原生事件相同的接口，包括 stopPropagation() 和 preventDefault()。当需要使用浏览器的底层事件时，只需要使用 nativeEvent 属性来获取即可。\r\n\r\n#### 合成事件作用\r\n- 在底层磨平不同浏览器的差异，React实现了统一的事件机制，不再需要处理浏览器事件机制方面的兼容问题，在上层面向开发者暴露稳定、统一的、与原生事件相同的事件接口。\r\n- React16的事件绑定在document上，React17以后事件绑定在挂载的dom上。而不是绑定在React组件对应的DOM(减少内存开销就是因为所有的事件都绑定在document上，其他节点没有绑定事件)。\r\n- React把握了事件机制的主动权，实现了对所有事件的中心化管控。\r\n- React引入事件池避免垃圾回收，在事件池中获取或释放事件对象，避免频繁的创建和销毁。\r\n#### 合成事件和原生事件的区别\r\n- 合成事件不是原生DOM事件，但它包含了原生DOM事件的引用，可以通过e.nativeEvent访问。\r\n- 合成事件无法获取到真实DOM，但可以通过React提供refAPI进行获取。\r\n#### 合成事件的使用\r\n> React 事件的命名采用小驼峰式（camelCase），而不是纯小写。以 click 事件为例，冒泡阶段用onClick，捕获阶段用onClickCapture。使用 JSX 语法需要传入一个函数作为事件处理函数，而不是一个字符串。在 React 事件中不通过返回 false 阻止默认行为，必须显示调用event.preventDefault()。由于 React 事件执行回调时的上下文并不在组件内部，所以还需要注意 this 的指向问题。\r\n\r\n```\r\n// 传统html绑定事件\r\n<button onclick=\"activateLasers()\">\r\n  test\r\n</button>\r\n\r\n// 在React中绑定事件\r\n<button onClick={activateLasers}>\r\n  test\r\n</button>\r\n```\r\n#### 磨平浏览器差异\r\n- React 通过事件normalize以让他们在不同浏览器中拥有一致的属性。React 声明了各种事件的接口，以此来磨平浏览器中的差异。\r\n  1. 如果接口中的字段值为 0，则直接使用原生事件的值。\r\n  2. 如果接口中字段的值为函数，则会以原生事件作为入参，调用该函数来返回磨平了浏览器差异的值。\r\n  ```\r\n  // 基础事件接口，timeStamp需要磨平差异\r\n  const EventInterface = {\r\n    eventPhase: 0,\r\n    bubbles: 0,\r\n    cancelable: 0,\r\n    timeStamp: function(event) {\r\n      return event.timeStamp || Date.now();\r\n    },\r\n    defaultPrevented: 0,\r\n    isTrusted: 0,\r\n  };\r\n  // UI事件接口，继承基础事件接口\r\n  const UIEventInterface: EventInterfaceType = {\r\n    ...EventInterface,\r\n    view: 0,\r\n    detail: 0,\r\n  };\r\n  // 鼠标事件接口，继承UI事件接口，getModifierState，relatedTarget、movementX、movementY等字段需要磨平差异\r\n  const MouseEventInterface: EventInterfaceType = {\r\n    ...UIEventInterface,\r\n    screenX: 0,\r\n    screenY: 0,\r\n    clientX: 0,\r\n    clientY: 0,\r\n    pageX: 0,\r\n    pageY: 0,\r\n    ctrlKey: 0,\r\n    shiftKey: 0,\r\n    altKey: 0,\r\n    metaKey: 0,\r\n    getModifierState: getEventModifierState,\r\n    button: 0,\r\n    buttons: 0,\r\n    relatedTarget: function(event) {\r\n      if (event.relatedTarget === undefined)\r\n        return event.fromElement === event.srcElement\r\n          ? event.toElement\r\n          : event.fromElement;\r\n\r\n      return event.relatedTarget;\r\n    },\r\n    movementX: function(event) {\r\n      if ('movementX' in event) {\r\n        return event.movementX;\r\n      }\r\n      updateMouseMovementPolyfillState(event);\r\n      return lastMovementX;\r\n    },\r\n    movementY: function(event) {\r\n      if ('movementY' in event) {\r\n        return event.movementY;\r\n      }\r\n      // Don't need to call updateMouseMovementPolyfillState() here\r\n      // because it's guaranteed to have already run when movementX\r\n      // was copied.\r\n      return lastMovementY;\r\n    },\r\n  };\r\n  // 指针类型，继承鼠标事件接口。还有很多其他事件类型接口...\r\n  const PointerEventInterface = {\r\n    ...MouseEventInterface,\r\n    pointerId: 0,\r\n    width: 0,\r\n    height: 0,\r\n    pressure: 0,\r\n    tangentialPressure: 0,\r\n    tiltX: 0,\r\n    tiltY: 0,\r\n    twist: 0,\r\n    pointerType: 0,\r\n    isPrimary: 0,\r\n  };\r\n  ```\r\n- 由于不同的类型的事件其字段有所不同，所以 React 实现了针对事件接口的合成事件构造函数的工厂函数。 通过传入不一样的事件接口返回对应事件的合成事件构造函数，然后在事件触发回调时根据触发的事件类型判断使用哪种类型的合成事件构造函数来实例化合成事件。\r\n> 合成事件的实例，其实就是根据事件类型对原生事件的属性做浏览器的磨平，以及关键方法的包装。\r\n\r\n```\r\n// 辅助函数，永远返回true\r\nfunction functionThatReturnsTrue() {\r\n  return true;\r\n}\r\n// 辅助函数，永远返回false\r\nfunction functionThatReturnsFalse() {\r\n  return false;\r\n}\r\n// 合成事件构造函数的工厂函数，根据传入的事件接口返回对应的合成事件构造函数\r\nfunction createSyntheticEvent(Interface: EventInterfaceType) {\r\n\r\n  // 合成事件构造函数\r\n  function SyntheticBaseEvent(\r\n    reactName: string | null,\r\n    reactEventType: string,\r\n    targetInst: Fiber,\r\n    nativeEvent: {[propName: string]: mixed},\r\n    nativeEventTarget: null | EventTarget,\r\n  ) {\r\n    // react事件名\r\n    this._reactName = reactName;\r\n    // 当前执行事件回调时的fiber\r\n    this._targetInst = targetInst;\r\n    // 真实事件名\r\n    this.type = reactEventType;\r\n    // 原生事件对象\r\n    this.nativeEvent = nativeEvent;\r\n    // 原生触发事件的DOM target\r\n    this.target = nativeEventTarget;\r\n    // 当前执行回调的DOM\r\n    this.currentTarget = null;\r\n\r\n    // 下面是磨平字段在浏览器间的差异\r\n    for (const propName in Interface) {\r\n      if (!Interface.hasOwnProperty(propName)) {\r\n        // 该接口没有这个字段，不拷贝\r\n        continue;\r\n      }\r\n      // 拿到事件接口对应的值\r\n      const normalize = Interface[propName];\r\n      // 如果接口对应字段函数，进入if分支，执行函数拿到值\r\n      if (normalize) {\r\n        // 获取磨平了浏览器差异后的值\r\n        this[propName] = normalize(nativeEvent);\r\n      } else {\r\n        // 如果接口对应值是0，则直接取原生事件对应字段值\r\n        this[propName] = nativeEvent[propName];\r\n      }\r\n    }\r\n    // 磨平defaultPrevented的浏览器差异，即磨平e.defaultPrevented和e.returnValue的表现\r\n    const defaultPrevented =\r\n      nativeEvent.defaultPrevented != null\r\n        ? nativeEvent.defaultPrevented\r\n        : nativeEvent.returnValue === false;\r\n    if (defaultPrevented) {\r\n      // 如果在处理事件时已经被阻止默认操作了，则调用isDefaultPrevented一直返回true\r\n      this.isDefaultPrevented = functionThatReturnsTrue;\r\n    } else {\r\n      // 如果在处理事件时没有被阻止过默认操作，则先用返回false的函数\r\n      this.isDefaultPrevented = functionThatReturnsFalse;\r\n    }\r\n    // 默认执行时间时，还没有被阻止继续传播，所以调用isPropagationStopped返回false\r\n    this.isPropagationStopped = functionThatReturnsFalse;\r\n    return this;\r\n  }\r\n  // 合成事件重要方法的包装\r\n  Object.assign(SyntheticBaseEvent.prototype, {\r\n    preventDefault: function() {\r\n      // 调用后设置defaultPrevented\r\n      this.defaultPrevented = true;\r\n      const event = this.nativeEvent;\r\n      if (!event) {\r\n        return;\r\n      }\r\n      // 下面是磨平e.preventDefault()和e.returnValue=false的浏览器差异，并在原生事件上执行\r\n      if (event.preventDefault) {\r\n        event.preventDefault();\r\n        // $FlowFixMe - flow is not aware of `unknown` in IE\r\n      } else if (typeof event.returnValue !== 'unknown') {\r\n        event.returnValue = false;\r\n      }\r\n      // 然后后续回调判断时都会返回true\r\n      this.isDefaultPrevented = functionThatReturnsTrue;\r\n    },\r\n\r\n    stopPropagation: function() {\r\n      const event = this.nativeEvent;\r\n      if (!event) {\r\n        return;\r\n      }\r\n      // 磨平e.stopPropagation()和e.calcelBubble = true的差异，并在原生事件上执行\r\n      if (event.stopPropagation) {\r\n        event.stopPropagation();\r\n        // $FlowFixMe - flow is not aware of `unknown` in IE\r\n      } else if (typeof event.cancelBubble !== 'unknown') {\r\n        // The ChangeEventPlugin registers a \"propertychange\" event for\r\n        // IE. This event does not support bubbling or cancelling, and\r\n        // any references to cancelBubble throw \"Member not found\".  A\r\n        // typeof check of \"unknown\" circumvents this issue (and is also\r\n        // IE specific).\r\n        event.cancelBubble = true;\r\n      }\r\n      // 然后后续判断时都会返回true，已停止传播\r\n      this.isPropagationStopped = functionThatReturnsTrue;\r\n    },\r\n    /**\r\n     * We release all dispatched `SyntheticEvent`s after each event loop, adding\r\n     * them back into the pool. This allows a way to hold onto a reference that\r\n     * won't be added back into the pool.\r\n     */\r\n    // react16的保留原生事件的方法，react17里已无效\r\n    persist: function() {\r\n      // Modern event system doesn't use pooling.\r\n    },\r\n\r\n    /**\r\n     * Checks if this event should be released back into the pool.\r\n     *\r\n     * @return {boolean} True if this should not be released, false otherwise.\r\n     */\r\n    isPersistent: functionThatReturnsTrue,\r\n  });\r\n  // 返回根据接口类型包装的合成事件构造器\r\n  return SyntheticBaseEvent;\r\n}\r\n// 使用通过给工厂函数传入鼠标事件接口获取鼠标事件合成事件构造函数\r\nexport const SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface);\r\n```\r\n### 事件触发\r\n> 当页面上触发了特定的事件时，如点击事件 click，就会触发绑定在根元素上的事件回调函数，也就是之前绑定了参数的dispatchEvent，而dispatchEvent在内部最终会调用dispatchEventsForPlugins。\r\n\r\n- dispatchEventsForPlugins\r\n```\r\nfunction dispatchEventsForPlugins(\r\n  domEventName: DOMEventName, // dispatchEvent中绑定的事件名\r\n  eventSystemFlags: EventSystemFlags, // dispatchEvent绑定的事件标记\r\n  nativeEvent: AnyNativeEvent, // 事件触发时回调传入的原生事件对象\r\n  targetInst: null | Fiber, // 事件触发目标元素对应的fiber\r\n  targetContainer: EventTarget, // 绑定事件的根元素\r\n): void {\r\n  // 磨平浏览器差异，拿到真正的target\r\n  const nativeEventTarget = getEventTarget(nativeEvent);\r\n  // 要处理事件回调的队列\r\n  const dispatchQueue: DispatchQueue = [];\r\n  // 将fiber树上的回调收集\r\n  extractEvents(\r\n    dispatchQueue,\r\n    domEventName,\r\n    targetInst,\r\n    nativeEvent,\r\n    nativeEventTarget,\r\n    eventSystemFlags,\r\n    targetContainer,\r\n  );\r\n  // 根据收集到的回调及事件标记处理事件\r\n  processDispatchQueue(dispatchQueue, eventSystemFlags);\r\n}\r\n```\r\n- extractEvents 收集事件对应回调\r\n  1. 回调的收集也是根据事件的类型分别处理的，将extractEvents的入参分别给各个事件处理插件的extractEvents进行分别处理。\r\n  ```\r\n  function extractEvents(\r\n    dispatchQueue: DispatchQueue,\r\n    domEventName: DOMEventName,\r\n    targetInst: null | Fiber,\r\n    nativeEvent: AnyNativeEvent,\r\n    nativeEventTarget: null | EventTarget,\r\n    eventSystemFlags: EventSystemFlags,\r\n    targetContainer: EventTarget,\r\n  ) {\r\n    // 抽出简单事件\r\n    SimpleEventPlugin.extractEvents(\r\n      dispatchQueue,\r\n      domEventName,\r\n      targetInst,\r\n      nativeEvent,\r\n      nativeEventTarget,\r\n      eventSystemFlags,\r\n      targetContainer,\r\n    );\r\n    const shouldProcessPolyfillPlugins =\r\n      (eventSystemFlags & SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS) === 0;\r\n    if (shouldProcessPolyfillPlugins) {\r\n      EnterLeaveEventPlugin.extractEvents(\r\n        dispatchQueue,\r\n        domEventName,\r\n        targetInst,\r\n        nativeEvent,\r\n        nativeEventTarget,\r\n        eventSystemFlags,\r\n        targetContainer,\r\n      );\r\n      ChangeEventPlugin.extractEvents(\r\n        dispatchQueue,\r\n        domEventName,\r\n        targetInst,\r\n        nativeEvent,\r\n        nativeEventTarget,\r\n        eventSystemFlags,\r\n        targetContainer,\r\n      );\r\n      SelectEventPlugin.extractEvents(\r\n        dispatchQueue,\r\n        domEventName,\r\n        targetInst,\r\n        nativeEvent,\r\n        nativeEventTarget,\r\n        eventSystemFlags,\r\n        targetContainer,\r\n      );\r\n      BeforeInputEventPlugin.extractEvents(\r\n        dispatchQueue,\r\n        domEventName,\r\n        targetInst,\r\n        nativeEvent,\r\n        nativeEventTarget,\r\n        eventSystemFlags,\r\n        targetContainer,\r\n      );\r\n    }\r\n  }\r\n  ```\r\n  2. 以SimpleEventPlugin.extractEvents为例查看如何收集事件回调\r\n    - 根据原生事件名，得到对应的 React 事件名。\r\n    - 根据原生事件名，判断需要使用的合成事件构造函数。\r\n    - 根据绑定的事件标记得出事件是否捕获阶段。\r\n    - 判断事件名是否为 scoll 且不是捕获阶段，如果是则只收集事件触发节点。\r\n    - 从触发事件的 DOM 实例对应的 fiber 节点开始，向上遍历 fiber 树，判断遍历到的 fiber 是否宿主类型 fiber 节点，是的话判断在其 props 上是否存在 React 事件名同名属性，如果存在，则 push 到数组中，遍历结束即可收集由叶子节点到根节点的回调函数。\r\n    - 如果收集的回调数组不为空，则实例化对应的合成事件，并与收集的回调函数一同收集到dispatchQueue中。\r\n  ```\r\n  // SimpleEventPlugin.js\r\n  function extractEvents(\r\n    dispatchQueue: DispatchQueue,\r\n    domEventName: DOMEventName,\r\n    targetInst: null | Fiber,\r\n    nativeEvent: AnyNativeEvent,\r\n    nativeEventTarget: null | EventTarget,\r\n    eventSystemFlags: EventSystemFlags,\r\n    targetContainer: EventTarget,\r\n  ): void {\r\n    // 根据原生事件名拿到React事件名\r\n    const reactName = topLevelEventsToReactNames.get(domEventName);\r\n    if (reactName === undefined) {\r\n      // 如果是没对应的React事件就不处理\r\n      return;\r\n    }\r\n    // 默认的合成事件构造函数，下面根据事件名重新赋值对应的合成事件构造函数\r\n    let SyntheticEventCtor = SyntheticEvent;\r\n    let reactEventType: string = domEventName;\r\n    // 根据事件名获取对应的合成事件构造函数\r\n    switch (domEventName) {\r\n      case 'keypress':\r\n      case 'keydown':\r\n      case 'keyup':\r\n        SyntheticEventCtor = SyntheticKeyboardEvent;\r\n        break;\r\n      case 'focusin':\r\n        reactEventType = 'focus';\r\n        SyntheticEventCtor = SyntheticFocusEvent;\r\n        break;\r\n      case 'focusout':\r\n        reactEventType = 'blur';\r\n        SyntheticEventCtor = SyntheticFocusEvent;\r\n        break;\r\n      case 'beforeblur':\r\n      case 'afterblur':\r\n        SyntheticEventCtor = SyntheticFocusEvent;\r\n        break;\r\n      case 'click':\r\n        // Firefox creates a click event on right mouse clicks. This removes the\r\n        // unwanted click events.\r\n        if (nativeEvent.button === 2) {\r\n          return;\r\n        }\r\n      /* falls through */\r\n      case 'auxclick':\r\n      case 'dblclick':\r\n      case 'mousedown':\r\n      case 'mousemove':\r\n      case 'mouseup':\r\n      // TODO: Disabled elements should not respond to mouse events\r\n      /* falls through */\r\n      case 'mouseout':\r\n      case 'mouseover':\r\n      case 'contextmenu':\r\n        SyntheticEventCtor = SyntheticMouseEvent;\r\n        break;\r\n      // ...这里省略了很多case\r\n      default:\r\n        // Unknown event. This is used by createEventHandle.\r\n        break;\r\n    }\r\n    // 判断是捕获阶段还是冒泡阶段\r\n    const inCapturePhase = (eventSystemFlags & IS_CAPTURE_PHASE) !== 0;\r\n    if (\r\n      enableCreateEventHandleAPI &&\r\n      eventSystemFlags & IS_EVENT_HANDLE_NON_MANAGED_NODE\r\n    ) {\r\n      // 这个分支不看\r\n    } else {\r\n      // Some events don't bubble in the browser.\r\n      // In the past, React has always bubbled them, but this can be surprising.\r\n      // We're going to try aligning closer to the browser behavior by not bubbling\r\n      // them in React either. We'll start by not bubbling onScroll, and then expand.\r\n      // 如果不是捕获阶段且事件名为scroll，则只处理触发事件的节点\r\n      const accumulateTargetOnly =\r\n        !inCapturePhase &&\r\n        // TODO: ideally, we'd eventually add all events from\r\n        // nonDelegatedEvents list in DOMPluginEventSystem.\r\n        // Then we can remove this special list.\r\n        // This is a breaking change that can wait until React 18.\r\n        domEventName === 'scroll';\r\n      // 在fiber树上收集事件名对应的props\r\n      const listeners = accumulateSinglePhaseListeners(\r\n        targetInst,\r\n        reactName,\r\n        nativeEvent.type,\r\n        inCapturePhase,\r\n        accumulateTargetOnly,\r\n      );\r\n      // 如果存在监听该事件props回调函数\r\n      if (listeners.length > 0) {\r\n        // Intentionally create event lazily.\r\n        // 则构建一个react合成事件\r\n        const event = new SyntheticEventCtor(\r\n          reactName,\r\n          reactEventType,\r\n          null,\r\n          nativeEvent,\r\n          nativeEventTarget,\r\n        );\r\n        // 并收集到队列中\r\n        dispatchQueue.push({event, listeners});\r\n      }\r\n    }\r\n  }\r\n  // 遍历fiber树的收集函数\r\n  export function accumulateSinglePhaseListeners(\r\n    targetFiber: Fiber | null,\r\n    reactName: string | null,\r\n    nativeEventType: string,\r\n    inCapturePhase: boolean,\r\n    accumulateTargetOnly: boolean,\r\n  ): Array<DispatchListener> {\r\n    const captureName = reactName !== null ? reactName + 'Capture' : null;\r\n    const reactEventName = inCapturePhase ? captureName : reactName;\r\n    const listeners: Array<DispatchListener> = [];\r\n\r\n    let instance = targetFiber;\r\n    let lastHostComponent = null;\r\n\r\n    // Accumulate all instances and listeners via the target -> root path.\r\n    while (instance !== null) {\r\n      const {stateNode, tag} = instance;\r\n      // Handle listeners that are on HostComponents (i.e. <div>)\r\n      if (tag === HostComponent && stateNode !== null) {\r\n        lastHostComponent = stateNode;\r\n        // Standard React on* listeners, i.e. onClick or onClickCapture\r\n        if (reactEventName !== null) {\r\n          // 拿到DOM节点类型上对应事件名的props\r\n          const listener = getListener(instance, reactEventName);\r\n          if (listener != null) {\r\n            // 如果这个同名props存在，则收集起来\r\n            listeners.push(\r\n              createDispatchListener(instance, listener, lastHostComponent),\r\n            );\r\n          }\r\n        }\r\n      }\r\n      // If we are only accumulating events for the target, then we don't\r\n      // continue to propagate through the React fiber tree to find other\r\n      // listeners.\r\n      // 对于只收集当前节点的事件，收集完当前节点就退出了\r\n      if (accumulateTargetOnly) {\r\n        break;\r\n      }\r\n      // 向上遍历\r\n      instance = instance.return;\r\n    }\r\n    // 返回该事件名对应收集的监听器\r\n    return listeners;\r\n  }\r\n  ```\r\n- 处理回调\r\n> 对于回调的处理，就是简单地根据收集到的回调数组，判断事件的触发是处于捕获阶段还是冒泡阶段来决定是顺序执行还是倒序执行回调数组。并且通过event.isPropagationStopped()来判断事件是否执行过event.stopPropagation()以决定是否继续执行。\r\n\r\n```\r\n// 分别处理事件队列\r\nexport function processDispatchQueue(\r\n  dispatchQueue: DispatchQueue,\r\n  eventSystemFlags: EventSystemFlags,\r\n): void {\r\n  const inCapturePhase = (eventSystemFlags & IS_CAPTURE_PHASE) !== 0;\r\n  for (let i = 0; i < dispatchQueue.length; i++) {\r\n    const {event, listeners} = dispatchQueue[i];\r\n    processDispatchQueueItemsInOrder(event, listeners, inCapturePhase);\r\n  }\r\n}\r\n\r\n// 根据事件是捕获阶段还是冒泡阶段，来决定是顺序执行还是倒序执行\r\n// 并且如果事件被调用过event.stopPropagation则退出执行\r\nfunction processDispatchQueueItemsInOrder(\r\n  event: ReactSyntheticEvent,\r\n  dispatchListeners: Array<DispatchListener>,\r\n  inCapturePhase: boolean,\r\n): void {\r\n  let previousInstance;\r\n  if (inCapturePhase) {\r\n    // 捕获阶段逆序执行\r\n    for (let i = dispatchListeners.length - 1; i >= 0; i--) {\r\n      const {instance, currentTarget, listener} = dispatchListeners[i];\r\n      if (instance !== previousInstance && event.isPropagationStopped()) {\r\n        // 如果被阻止过传播，则退出\r\n        return;\r\n      }\r\n      // 执行\r\n      executeDispatch(event, listener, currentTarget);\r\n      previousInstance = instance;\r\n    }\r\n  } else {\r\n    for (let i = 0; i < dispatchListeners.length; i++) {\r\n      const {instance, currentTarget, listener} = dispatchListeners[i];\r\n      if (instance !== previousInstance && event.isPropagationStopped()) {\r\n        return;\r\n      }\r\n      executeDispatch(event, listener, currentTarget);\r\n      previousInstance = instance;\r\n    }\r\n  }\r\n}\r\n\r\n// 执行事件回调\r\nfunction executeDispatch(\r\n  event: ReactSyntheticEvent,\r\n  listener: Function,\r\n  currentTarget: EventTarget,\r\n): void {\r\n  const type = event.type || 'unknown-event';\r\n  // 设置合成事件执行到当前DOM实例时的指向\r\n  event.currentTarget = currentTarget;\r\n  invokeGuardedCallbackAndCatchFirstError(type, listener, undefined, event);\r\n  // 不在事件的回调中时拿不到currentTarget\r\n  event.currentTarget = null;\r\n}\r\n```\r\n### React17 与 React16 事件系统的差别\r\n- 绑定位置，事件委托的节点从 React16 的 document 更改为 React17 的 React 树的根 DOM 容器。\r\n> 如果页面中存在多个 React 应用，由于他们都会在顶层document注册事件处理器，如果你在一个 React 子应用的 React 事件中调用了e.stopPropagation()，无法阻止事件冒泡到外部树，因为真实的事件早已传播到document。而将事件委托在 React 应用的根 DOM 容器则可以避免这样的问题，减少了多个 React 应用并存可能产生的问题，并且事件系统的运行也更贴近现在浏览器的表现。\r\n\r\n- 事件代理阶段\r\n> 在 React16 中，对 document 的事件委托都委托在冒泡阶段，当事件冒泡到 document 之后触发绑定的回调函数，在回调函数中重新模拟一次 捕获-冒泡 的行为，所以 React 事件中的e.stopPropagation()无法阻止原生事件的捕获和冒泡，因为原生事件的捕获和冒泡已经执行完了。在 React17 中，对 React 应用根 DOM 容器的事件委托分别在捕获阶段和冒泡阶段。\r\n\r\n  1. 当根容器接收到捕获事件时，先触发一次 React 事件的捕获阶段，然后再执行原生事件的捕获传播。所以 React 事件的捕获阶段调用e.stopPropagation()能阻止原生事件的传播。\r\n  2. 当根容器接受到冒泡事件时，会触发一次 React 事件的冒泡阶段，此时原生事件的冒泡传播已经传播到根了，所以 React 事件的冒泡阶段调用e.stopPropagation()不能阻止原生事件向根容器的传播，但是能阻止根容器到页面顶层的传播。\r\n- 去除事件池\r\n- scroll 事件不再冒泡\r\n> 在原生 scroll 里，scroll 是不存在冒泡阶段的，但是 React16 中模拟了 scroll 的冒泡阶段，React17 中将此特性去除，避免了当一个嵌套且可滚动的元素在其父元素触发事件时造成混乱。"},function(r,n,e){"use strict";e.r(n),n.default="## react性能优化\r\n### react工作流\r\n- React是声明式UI库，负责将数据转换为页面结构(虚拟DOM结构)后，再转换成真实DOM结构交给浏览器渲染。\r\n- 当数据发生改变时，React会先进行调和(Reconciliation)阶段，调和阶段结束后立刻进入提交(Commit)阶段，提交阶段结束后新数据对应的页面才被展示出来。\r\n#### 调和阶段\r\n1. 计算目标虚拟DOM结构：计算出目标数据对应的虚拟DOM结构(类组件的render方法或函数组件自身)。\r\n2. Diff过程：寻找将当前虚拟DOM结构修改为目标虚拟DOM结构的最优更新方案(Diff算法，会记录虚拟DOM的更新方式如Update、Mount、Unmount，为提交阶段做准备)。\r\n#### 提交阶段\r\n1. 更新真实DOM：将调和阶段记录的更新方式应用到真实DOM中。\r\n2. 调用暴露给开发者的生命周期钩子方法。 \r\n### Render过程\r\n- 调和阶段中计算目标虚拟DOM结构的过程称为Render过程。\r\n- 触发React组件的Render过程的方式\r\n    1. State更新\r\n    2. Props更新\r\n    3. 父组件Render触发子组件Render过程。\r\n    4. 组件依赖的上下文(context)发生变化\r\n    5. forceUpdate强制更新\r\n    6. 组件依赖的自定义hooks发生变化\r\n### react底层优化机制\r\n- 虚拟DOM + Diff算法高效的更新真实DOM。\r\n- 升级fiber架构使得Diff过程可以被中断且恢复，fiber架构把Diff的工作过程时间分片，避免JS脚本执行时间过长导致页面掉帧、页面卡顿。\r\n- 设计任务调度优先级更高效的更新，及时响应用户的操作。\r\n### 优化技巧\r\n- 由于调和阶段的Diff过程和提交阶段的更新真实DOM都属于React的内部实现，开发者能提供的优化能力有限，仅有列表项使用key属性一条优化技巧。\r\n- 实际工程中大部分优化方式都集中在调和阶段计算目标虚拟DOM的过程。\r\n### 跳过不必要的组件更新\r\n#### PureComponent、React.memo\r\n- 当父组件重新渲染时，即使父组件传给子组件的所有Props都没有变化，子组件也会重新渲染。\r\n- PureComponent会对类组件的State和Props进行浅比较，只有当State和Props发生变化时组件才会重新渲染。\r\n- React.memo会对函数组件的Props进行浅比较，只有当Props发生变化时组件才会重新渲染。支持第二个参数传入一个函数，如果组件需要更新就返回false，不需要更新就返回true。和shouldComponentUpdate正好相反。\r\n#### shouldComponentUpdate\r\n- shouldComponentUpdate是class组件主要的优化方式。\r\n- 支持对this.props与nextProps以及this.state与nextState以及this.context和nextContext进行比较，如果组件需要更新就返回true，不需要更新就返回false。\r\n#### useMemo、useCallback生成稳定的Props值\r\n- 如果传给子组件的Props每次都是新的引用(例如传递函数作为子组件Props时，父组件每次重新渲染，作为Props的函数都会生成新的引用)，那么React.memo的优化就会失效。\r\n- 可以借助useMemo或useCallback来生成稳定的Props值，并结合React.memo避免子组件重新渲染。\r\n#### Immutable Data + PureComponent(React.memo)\r\n- 使用Immutable Data凡是有节点被改变，那么它和与它相关的所有上级节点都更新，并且更新后返回了一个全新的引用，即使是浅比对也能感知到数据的改变。\r\n- 使用Immutable Data + PureComponent(React.memo)可以识别出State和Props是否变化(引用类型数据变化也可以识别到)，从而通过PureComponent(React.memo)可以更好的控制组件是否更新。\r\n#### 发布者订阅者跳过中间组件的渲染\r\n- React推荐将公共数据放在所有需要该状态的组件的公共祖先上，但将状态放在公共祖先上后，该状态就需要层层向下传递，直到传递给使用该状态的组件为止。每次状态的更新都会涉及中间组件的渲染，但中间组件并不关心该状态，中间组件只负责将该状态再传给子组件。\r\n- 这种场景下可以将状态用发布者订阅者模式维护，只有关心该状态的组件才去订阅该状态，不再需要中间组件传递该状态。当状态更新时发布者发布数据更新消息，只有订阅者组件才会重新渲染，中间组件不再需要重新渲染。\r\n- 只要是发布者订阅者模式的库，都可以进行该优化。比如redux、React.createContext等。\r\n#### 状态下放，缩小状态影响范围\r\n- 如果一个状态只在某部分子树中使用，那么可以将这部分子树提取为组件，并将该状态移动到该组件内部。\r\n#### useMemo返回稳定的虚拟DOM\r\n- 相较于React.memo需要对组件进行一次包装生成新的组件，useMemo返回稳定的虚拟DOM形式只需在存在性能瓶颈的地方使用，不用修改组件使用更方便。\r\n- useMemo返回稳定的虚拟DOM形式不用判断组件的所有Props，而只需考虑当前场景中用到的值，使用更灵活。\r\n- 父组件\r\n```\r\n// 子组件只关心count数据，当更新name数据的时候，Children子组件不会重新渲染，实现对组件的缓存控制。\r\nimport React, { useState, useMemo } from 'react';\r\nimport Children from './children';\r\n\r\nconst Parent = () => {\r\n  const [count, setCount] = useState(0);\r\n  const [name, setName] = useState(0);\r\n\r\n  const memoChildren = useMemo(() => <Children count = {count} />, [count]);\r\n  return (\r\n    <div>\r\n      <div>count：{count}；name：{name}</div>\r\n      <button onClick={() => setCount(count + 1)}>点击更新count</button>\r\n      <button onClick={() => setName(name + 1)}>点击更新name</button>\r\n      {memoChildren}\r\n    </div>\r\n  )\r\n}\r\n\r\nexport default Parent;\r\n```\r\n- 子组件\r\n```\r\nimport React from 'react';\r\n\r\nconst Children = (props) => {\r\n  console.log('render');\r\n  return (\r\n    <div>\r\n      子组件只关心count数据\r\n      {props.count}\r\n    </div>\r\n  )\r\n}\r\n\r\nexport default Children;\r\n```\r\n### 更快的完成Diff比较\r\n#### 列表项使用稳定唯一的key属性。\r\n### 通用优化\r\n#### 减少波及范围，无关刷新数据不存入State中\r\n- 在class组件可以使用类组件的实例属性存储无关刷新的数据。\r\n- 在函数组件中可以通过useRef来存储无关刷新的数据。\r\n#### 缓存计算结果，减少不必要的计算逻辑\r\n- 使用useMemo缓存上次计算的结果，当useMemo的依赖未发生改变时，就不会触发重新计算。一般用在有非常耗时的计算场景中。\r\n#### 批量更新State，减少setState的重复操作\r\n- 在React18之前的版本中，在生命周期钩子函数和React合成事件中会自动应用批量更新，在异步函数(setTimeout、 Promise的then回调)和原生事件中(addEventListener)不会应用批量更新，可以使用unstable_batchedUpdates方法实现批量更新。\r\n- React18中的任何场景都会自动应用批量更新。\r\n- react合成事件中多次调整state，只会重新渲染一次，批量更新\r\n```\r\nimport React, { Component } from 'react';\r\n\r\nexport default class Home extends Component {\r\n  state = {\r\n    count: 0\r\n  }\r\n\r\n  buttonClick = () => {\r\n    this.setState({\r\n      count: this.state.count + 1\r\n    });\r\n    console.log(this.state.count); // 0\r\n    this.setState({\r\n      count: this.state.count + 1\r\n    });\r\n    console.log(this.state.count); // 0\r\n    this.setState({\r\n      count: this.state.count + 1\r\n    });\r\n    console.log(this.state.count); // 0\r\n  }\r\n\r\n  render() {\r\n    console.log('render', this.state.count); // 1\r\n    return (\r\n      <div>\r\n        <div>{this.state.count}</div>\r\n        <button onClick={this.buttonClick}>click</button>\r\n      </div>\r\n    )\r\n  }\r\n}\r\n```\r\n- 原生事件中多次调整state，会重新渲染多次，react18之前为非批量更新，react18之后为批量更新\r\n```\r\nimport React, { Component } from 'react';\r\n\r\nexport default class Home extends Component {\r\n  state = {\r\n    count: 0\r\n  }\r\n\r\n  componentDidMount() {\r\n    document.getElementById('dyx')?.addEventListener('click', this.buttonClick)\r\n  }\r\n\r\n  componentWillUnMount() {\r\n    document.getElementById('dyx')?.removeEventListener('click', this.buttonClick)\r\n  }\r\n\r\n  buttonClick = () => {\r\n    this.setState({\r\n      count: this.state.count + 1\r\n    });\r\n    console.log(this.state.count); // 1\r\n    this.setState({\r\n      count: this.state.count + 1\r\n    });\r\n    console.log(this.state.count); // 2\r\n    this.setState({\r\n      count: this.state.count + 1\r\n    });\r\n    console.log(this.state.count); // 3\r\n  }\r\n\r\n  render() {\r\n    console.log('render', this.state.count); // 1、2、3\r\n    return (\r\n      <div>\r\n        <div>{this.state.count}</div>\r\n        <button id=\"dyx\">click</button>\r\n      </div>\r\n    )\r\n  }\r\n}\r\n```\r\n- 使用unstable_batchedUpdates将非批量更新的场景调整为批量更新\r\n```\r\nimport React, { Component } from 'react';\r\nimport { unstable_batchedUpdates } from 'react-dom';\r\n\r\nexport default class Home extends Component {\r\n  state = {\r\n    count: 0\r\n  }\r\n\r\n  componentDidMount() {\r\n    document.getElementById('dyx')?.addEventListener('click', this.buttonClick)\r\n  }\r\n\r\n  componentWillUnMount() {\r\n    document.getElementById('dyx')?.removeEventListener('click', this.buttonClick)\r\n  }\r\n\r\n  buttonClick = () => {\r\n    unstable_batchedUpdates(() => {\r\n      this.setState({\r\n        count: this.state.count + 1\r\n      });\r\n      console.log(this.state.count); // 0\r\n      this.setState({\r\n        count: this.state.count + 1\r\n      });\r\n      console.log(this.state.count); // 0\r\n      this.setState({\r\n        count: this.state.count + 1\r\n      });\r\n      console.log(this.state.count); // 0\r\n    })\r\n  }\r\n\r\n  render() {\r\n    console.log('render', this.state.count); // 1\r\n    return (\r\n      <div>\r\n        <div>{this.state.count}</div>\r\n        <button id=\"dyx\">click</button>\r\n      </div>\r\n    )\r\n  }\r\n}\r\n```\r\n#### 按优先级更新，及时响应用户\r\n- 将耗时任务移动到下一个宏任务中执行，优先响应用户行为。\r\n### PureComponent比较逻辑\r\n- PrueComponent继承了Component将shouldComponentUpdate重写成了shallowCompare。\r\n- 在shallowCompare中使用shallowEqual方法对新旧Props和新旧State进行浅比较。\r\n```\r\nexport defualut function PureComponent(props, context) {\r\n  Component.call(this, props, context);\r\n}\r\nPureComponent.prototype = Object.create(Component.prototye);\r\nPureComponent.prototype.contructor = PureComponent;\r\nPureComponent.prototype.shouldComponentUpdate = shallowCompare;\r\n \r\nfunction shallowCompare(nextProps, nextState) {\r\n  return !shallowEqual(this.props, nextProps) || !shallowEqual(this.state, nextState);\r\n}\r\n```\r\n#### shallowEqual的比较步骤\r\n1. 首先会直接比较新老Props和新老State两个对象的地址是否相同，如果地址相同，就直接返回true，如果地址不相同就继续判断。\r\n2. 判断新老Props和新老State，有不是对象或者为null的，返回false。\r\n3. 判断新老Props和新老State的属性个数(Object.keys)是否相同，如果不同证明有属性增加或者减少，返回false。\r\n4. 遍历老Props和老State的每一项，如果对应的新Props或新State中有没有与之对应的属性或对应的属性值不相等(浅比较)，返回false。\r\n```\r\nfunction shallowEqual(objA, objB) {\r\n  if (is(objA, objB)) {\r\n    return true;\r\n  }\r\n \r\n  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {\r\n    return false;\r\n  }\r\n \r\n  const keysA = Object.keys(objA);\r\n  const keysB = Object.keys(objB);\r\n \r\n  if (keysA.length !== keysB.length) {\r\n    return false;\r\n  }\r\n \r\n  // Test for A's keys different from B.\r\n  for (let i = 0; i < keysA.length; i++) {\r\n    if (!hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {\r\n      return false;\r\n    }\r\n  }\r\n \r\n  return true;\r\n}\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## react架构\r\n### react15的架构\r\n#### Reconciler(协调阶段) —— 生成虚拟DOM和找出变化的虚拟DOM\r\n- 调用函数组件、或class组件的render方法，将返回的JSX转化为虚拟DOM\r\n- 将虚拟DOM和上次更新时的虚拟DOM对比\r\n- 通过对比找出本次更新中变化的虚拟DOM\r\n- 通知Renderer将变化的虚拟DOM更新到页面上\r\n#### Renderer(渲染提交阶段) —— 负责将变化的虚拟DOM更新到真实DOM上\r\n### [react15架构的缺点](https://react.iamkasong.com/preparation/oldConstructure.html#react15%E6%9E%B6%E6%9E%84%E7%9A%84%E7%BC%BA%E7%82%B9)\r\n- 在Reconciler中，mount的组件会调用mountComponent，update的组件会调用updateComponent。\r\n- 这两个方法都会递归更新子组件。由于递归执行，所以更新一旦开始，中途就无法中断。当层级很深时，递归更新时间超过了16ms，用户交互就会卡顿。\r\n- react15架构Reconciler和Renderer是交替工作的，当第一个需要更新的dom在页面上已经变化后，第二个需要更新的dom再进入Reconciler。由于整个过程都是同步的，所以在用户看来所有dom是同时更新的。如果中途中断更新会看见更新不完全的dom。\r\n### react16的架构\r\n> 相较于React15，React16中新增了Scheduler(调度器)。\r\n\r\n#### Scheduler(调度阶段) —— 调度任务的优先级，高优任务优先进入Reconciler\r\n- 以浏览器是否有剩余时间作为任务中断的标准，当浏览器有剩余时间时通知我们。其实部分浏览器已经实现了这个API，这就是requestIdleCallback。\r\n- React实现了功能更完备的Scheduler。除了在空闲时触发回调的功能外，Scheduler还提供了多种调度优先级任务的功能。\r\n#### Reconciler(协调阶段) —— 生成虚拟DOM和找出变化的虚拟DOM   Fiber架构\r\n- 在React15中Reconciler是递归处理虚拟DOM的。React16的Reconciler更新工作从递归变成了可以中断的循环过程。每次循环都会调用shouldYield判断当前是否有剩余时间。\r\n- 在React16中Reconciler与Renderer不再是交替工作。当Scheduler将任务交给Reconciler后，Reconciler会为变化的虚拟DOM打上代表增/删/更新的标记。\r\n- 整个Scheduler与Reconciler的工作都在内存中进行(由于在内存中进行，不会更新页面上的DOM，所以即使反复中断，用户也不会看见更新不完全的DOM)。只有当所有组件都完成Reconciler的工作，才会统一交给Renderer。从而解决中断更新时DOM渲染不完全的问题。\r\n#### Renderer(渲染提交阶段) —— 负责将变化的虚拟DOM更新到真实DOM上\r\n- Renderer根据Reconciler为虚拟DOM打的标记，同步执行对应的真实DOM操作。\r\n- 调用暴露给开发者的钩子方法，如componentDidUpdate、useLayoutEffect等。\r\n\r\n\r\n\r\n\r\n\r\n\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## react错误捕获\r\n### 错误捕获的组件(参考官方文档实现)\r\n```\r\nimport React from 'react';\r\n\r\nexport default class ErrorBoundary extends React.Component {\r\n  state = {\r\n    hasError: false,\r\n  }\r\n\r\n  static getDerivedStateFromError() {\r\n    // 更新 state 使下一次渲染能够显示降级后的 UI\r\n    return { hasError: true };\r\n  }\r\n\r\n  componentDidCatch() {\r\n    this.setState({\r\n      hasError: true\r\n    })\r\n  }\r\n\r\n  render() {\r\n    const { tip } = this.props;\r\n    if (this.state.hasError) {\r\n      // 可以自定义降级后的 UI 并渲染\r\n      return <h1>{tip}</h1>;\r\n    }\r\n    return this.props.children; \r\n  }\r\n}\r\n```\r\n### react的ErrorBoundary如果直接包裹在jsx外，jsx中的错误无法捕捉到，只能捕捉到jsx中组件内的错误，正如官方所说的可以捕获发生在其子组件树任何位置的 JavaScript错误，并打印这些错误，同时展示降级UI。\r\n> 如下实例，demoOne中的jsx错误无法被ErrorBoundary捕获到，但是demoTwo中的错误可以被捕获到。\r\n\r\n```\r\n// demoOne\r\nimport React, { Component } from 'react';\r\nimport ErrorBoundary from 'components/errorBoundary';\r\n\r\nexport default class JsxTestOne extends Component {\r\n  render() {\r\n    return (\r\n      <ErrorBoundary tip=\"JsxTestOne 组件的ErrorBoundary\">\r\n        <div>ErrorBoundary直接包裹jsx无法捕捉错误</div>\r\n        <div>{user.name}</div>\r\n      </ErrorBoundary>\r\n    )\r\n  }\r\n}\r\n\r\n// demoTwo\r\nimport React, { Component } from 'react';\r\nimport ErrorBoundary from 'components/errorBoundary';\r\n\r\nclass Demo extends Component {\r\n  render() {\r\n    return (\r\n      <div>\r\n        <div>ErrorBoundary包裹组件可以捕捉错误</div>\r\n        <div>{user.name}</div>\r\n      </div>\r\n    )\r\n  }\r\n}\r\n\r\nexport default class JsxTestTwo extends Component {\r\n  render() {\r\n    return (\r\n      <ErrorBoundary tip=\"JsxTestTwo 组件的ErrorBoundary\">\r\n        <Demo />\r\n      </ErrorBoundary>\r\n    )\r\n  }\r\n}\r\n```\r\n### 一个后代组件抛错，可以被包裹其的祖先组件的ErrorBoundary组件catch到错误，但是会优先被最近包裹其的祖先组件的ErrorBoundary组件catch到错误\r\n> 如下的实例DemoThree抛错，会优先被包裹DemoThree的ErrorBoundary(tip=\"最外层子组件组件的ErrorBoundary组件\")组件catch到错误。如果DemoThree外不包裹ErrorBoundary，将会被包裹DemoTwo的ErrorBoundary(tip=\"最外层组件的ErrorBoundary组件\")组件catch到错误。\r\n\r\n```\r\n// demoOne\r\nimport React, { Component } from 'react';\r\nimport ErrorBoundary from 'components/errorBoundary';\r\nimport DemoTwo from './demoTwo';\r\n\r\nexport default class DemoOne extends Component {\r\n  render() {\r\n    return (\r\n      <div style={{ border: '1px solid green', margin: '20px 0'}}>\r\n        <div>最外层的组件</div>\r\n        <ErrorBoundary tip=\"最外层组件的ErrorBoundary组件\">\r\n          <DemoTwo />\r\n        </ErrorBoundary>\r\n      </div>\r\n    )\r\n  }\r\n}\r\n\r\n// demoTwo\r\nimport React, { Component } from 'react';\r\nimport ErrorBoundary from 'components/errorBoundary';\r\nimport DemoThree from './demoThree';\r\n\r\nexport default class DemoTwo extends Component {\r\n  state={\r\n    user: null\r\n  }\r\n  render() {\r\n    return (\r\n      <div style={{ border: '1px solid red', margin: '20px'}}>\r\n        <div>最外层的子组件</div>\r\n        <div onClick={() => this.setState({ user: { name: 'dyx' }})}>设置user</div>\r\n        <ErrorBoundary tip=\"最外层子组件组件的ErrorBoundary组件\">\r\n          <DemoThree user={this.state.user} />\r\n        </ErrorBoundary>\r\n      </div>\r\n    )\r\n  }\r\n}\r\n\r\n// demoThree\r\nimport React, { Component } from 'react';\r\n\r\nexport default class DemoThree extends Component {\r\n  render() {\r\n    const { user } = this.props;\r\n    return (\r\n      <div style={{ border: '1px solid blue', margin: '20px'}}>\r\n        最外层的孙组件\r\n        {user.name}\r\n      </div>\r\n    )\r\n  }\r\n}\r\n```\r\n### 生命周期函数的错误可以被ErrorBoundary组件catch到\r\n> 如下实例，生命周期的方法中错误会显示回退的UI。\r\n\r\n```\r\nimport React, { Component } from 'react';\r\nimport ErrorBoundary from 'components/errorBoundary';\r\n\r\nclass Demo extends Component {\r\n  componentDidMount() {\r\n    console.log(a)\r\n  }\r\n  render() {\r\n    return (\r\n      <div>\r\n        生命周期的错误\r\n      </div>\r\n    )\r\n  }\r\n}\r\n\r\nexport default class CyclifeTest extends Component {\r\n  render() {\r\n    return (\r\n      <ErrorBoundary tip=\"生命周期的错误捕捉的ErrorBoundary\">\r\n        <Demo />\r\n      </ErrorBoundary>\r\n    )\r\n  }\r\n}\r\n```\r\n### 事件处理的错误不会被ErrorBoundary组件catch到\r\n> 如下实例demoOne中func中的错误并不会被catch到，正如官方文档所说React不需要错误边界来捕获事件处理器中的错误。与render方法和生命周期方法不同，事件处理器不会在渲染期间触发。因此如果它们抛出异常React仍然能够知道需要在屏幕上显示什么。但是demTwo中如果func中的处理导致render函数或者生命周期逻辑抛错则是可以被catch到的。\r\n\r\n- 事件处理的错误不影响render函数和生命周期的正常逻辑，不会被ErrorBoundary组件catch。\r\n```\r\n// demoOne\r\nimport React, { Component } from 'react';\r\nimport ErrorBoundary from 'components/errorBoundary';\r\n\r\nclass DemoOne extends Component {\r\n  state = {\r\n    user: { name: 'dyx' },\r\n  }\r\n\r\n  func = () => {\r\n    console.log(a)\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <div onClick={this.func}>\r\n        事件处理的错误\r\n        <div>{this.state.user.name}</div>\r\n      </div>\r\n    )\r\n  }\r\n}\r\n\r\nexport default class FuncTest extends Component {\r\n  render() {\r\n    return (\r\n      <ErrorBoundary tip=\"事件处理的错误捕捉的ErrorBoundary\">\r\n        <DemoOne />\r\n      </ErrorBoundary>\r\n    )\r\n  }\r\n}\r\n```\r\n- 事件处理的错误影响render函数和生命周期的正常逻辑，会被ErrorBoundary组件catch。\r\n```\r\n// demoTwo\r\nimport React, { Component } from 'react';\r\nimport ErrorBoundary from 'components/errorBoundary';\r\n\r\nclass DemoTwo extends Component {\r\n  state = {\r\n    user: { name: 'dyx' },\r\n  }\r\n\r\n  func = () => {\r\n    this.setState({\r\n      user: null\r\n    })\r\n    console.log(a)\r\n  }\r\n\r\n  componentDidUpdate() {\r\n    console.log(this.state.user.name)\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <div onClick={this.func}>\r\n        事件处理的错误\r\n        <div>{this.state.user.name}</div> \r\n      </div>\r\n    )\r\n  }\r\n}\r\n\r\nexport default class FuncTest extends Component {\r\n  render() {\r\n    return (\r\n      <ErrorBoundary tip=\"事件处理的错误捕捉的ErrorBoundary\">\r\n        <Demo />\r\n      </ErrorBoundary>\r\n    )\r\n  }\r\n}\r\n```\r\n### 如果一个组件抛错，显示了回退的UI，此时我们在其父组件中修改此错误还是会显示回退的UI，不会正常渲染组件，所以如果错误是因为接口数据错误导致的，此时重新获取接口数据，并不会使错误的组件正常渲染，reload才会有效。\r\n> 如下实例中子组件渲染出错，此时在父组件中修改传给子组件的属性，即使此时子组件中的逻辑正确，依然不能正常渲染，因为此时ErrorBoundary中的hasError状态已经是true，所以只会显示回退的UI。\r\n\r\n```\r\n// 父组件\r\nimport React, { Component } from 'react';\r\nimport ErrorBoundary from 'components/errorBoundary';\r\nimport DemoThree from './demoThree';\r\n\r\nexport default class Demo extends Component {\r\n  state={\r\n    user: null\r\n  }\r\n  render() {\r\n    return (\r\n      <div style={{ border: '1px solid red', margin: '20px'}}>\r\n        <div onClick={() => this.setState({ user: { name: 'dyx' } })}>设置user</div>\r\n        <ErrorBoundary tip=\"最外层组件的ErrorBoundary组件\">\r\n          <DemoOne user={this.state.user} />\r\n        </ErrorBoundary>\r\n      </div>\r\n    )\r\n  }\r\n}\r\n\r\n// 子组件\r\nimport React, { Component } from 'react';\r\n\r\nexport default class DemoOne extends Component {\r\n  render() {\r\n    const { user } = this.props;\r\n    return (\r\n      <div style={{ border: '1px solid blue', margin: '20px'}}>\r\n        {user.name}\r\n      </div>\r\n    )\r\n  }\r\n}\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## [redux](https://juejin.cn/post/6844904036013965325)\r\n- Redux遵循“单向数据流”和“不可变状态模型”的设计思想。\r\n- 这使得Redux的状态变化是可预测、可调试的。\r\n### 异步状态更新\r\n- redux执行action是同步的，但是reducer中将新状态返回更新store数据仓库的过程是异步的。\r\n- 组件通过react-redux封装后相当于包了一层高阶组件。而这一个高阶组件在redux里的state更新时会调用setState，所以redux的store的数据仓库更新才会有异步更新的现象。\r\n### 工作流程\r\n- 用户在view层触发某个事件，通过dispatch发送了action和payload。\r\n- action和payload被传入reducer函数，返回一个新的state。\r\n- store拿到reducer返回的state并做更新，同时通知view层进行re-render。\r\n### 三大要素\r\n- 单一数据源，state存储在唯一的store中。\r\n- state是只读的，唯一改变state的方法是dispatch action，action是一个用于描述已发生事件的普通对象。\r\n- 纯函数修改，通过reducer纯函数修改状态，它接收之前的state和action，并返回新的state。一定要返回一个新的对象，而不是修改之前的state。\r\n### reducer为什么要返回一个新的对象\r\n- redux源码中会比较传入的state和reducer修改之后的state，如果相同则返回旧的对象，如果不同则返回新的对象。\r\n- 比较两个javascript对象中所有的属性是否完全相同，唯一的办法就是深比较，深比较在真实的应用中代码是非常大的，非常耗性能的，需要比较的次数特别多，所以一个有效的解决方案就是做一个规定，当无论发生任何变化时开发者都要返回一个新的对象，没有变化时开发者返回旧的对象，这样直接比较对象的存储地址即可以。\r\n```\r\nfor (let i = 0; i < finalReducerKeys.length; i++) {\r\n  const key = finalReducerKeys[i]\r\n  const reducer = finalReducers[key]\r\n  const previousStateForKey = state[key]\r\n  const nextStateForKey = reducer(previousStateForKey, action)\r\n  if (typeof nextStateForKey === 'undefined') {\r\n    const errorMessage = getUndefinedStateErrorMessage(key, action)\r\n    throw new Error(errorMessage)\r\n  }\r\n  nextState[key] = nextStateForKey\r\n  hasChanged = hasChanged || nextStateForKey !== previousStateForKey\r\n}\r\nreturn hasChanged ? nextState : state\r\n```\r\n### redux\r\n#### getState的实现\r\n```\r\nexport const createStore = () => {    \r\n  let currentState = {}       // 公共状态    \r\n  function getState() {       // getter        \r\n    return currentState    \r\n  }    \r\n  function dispatch() {}      // setter    \r\n  function subscribe() {}     // 发布订阅    \r\n  return { getState, dispatch, subscribe }\r\n}\r\n```\r\n#### dispatch实现\r\n```\r\nexport const createStore = () => {    \r\n  let currentState = {}    \r\n  function getState() {        \r\n    return currentState    \r\n  }    \r\n  function dispatch(action) {        \r\n    switch (action.type) {            \r\n      case 'plus':            \r\n      currentState = {                 \r\n        ...state,                 \r\n        count: currentState.count + 1            \r\n      }        \r\n    }    \r\n  }    \r\n  function subscribe() {}    \r\n  return { getState, subscribe, dispatch }\r\n}\r\n\r\n// reducer抽离\r\n// reducer.js\r\nconst initialState = {    \r\n  count: 0\r\n}\r\nexport function reducer(state = initialState, action) {    \r\n  switch(action.type) {      \r\n    case 'plus':        \r\n    return {            \r\n      ...state,                    \r\n      count: state.count + 1        \r\n    }      \r\n    case 'subtract':        \r\n    return {            \r\n      ...state,            \r\n      count: state.count - 1        \r\n    }      \r\n    default:        \r\n    return initialState    \r\n  }\r\n}\r\n\r\nimport { reducer } from './reducer'\r\nexport const createStore = (reducer) => {    \r\n  let currentState = {}     \r\n  function getState() {        \r\n    return currentState    \r\n  }    \r\n  function dispatch(action) {         \r\n    currentState = reducer(currentState, action)  \r\n  }    \r\n  function subscribe() {}    \r\n  dispatch({ type: '@@REDUX_INIT' })  // 初始化store数据  \r\n  return { getState, dispatch, subscribe }\r\n}\r\n```\r\n#### subscribe实现\r\n```\r\nimport { reducer } from './reducer'\r\nexport const createStore = (reducer) => {        \r\n  let currentState = {}        \r\n  let observers = []             // 观察者队列        \r\n  function getState() {                \r\n    return currentState        \r\n  }        \r\n  function dispatch(action) {                \r\n    currentState = reducer(currentState, action)                \r\n    observers.forEach(fn => fn())        \r\n  }        \r\n  function subscribe(fn) {                \r\n    observers.push(fn)        \r\n  }        \r\n  dispatch({ type: '@@REDUX_INIT' })  // 初始化store数据        \r\n  return { getState, subscribe, dispatch }\r\n}\r\n```\r\n### react-redux\r\n####  Provider实现\r\n> Provider将store放进this.context里，就能在组件中通过this.context.store这样的形式取到store，不需要再单独import store。同时也用于connect方法中更好的直接使用store。\r\n\r\n```\r\nimport React from 'react'\r\nimport PropTypes from 'prop-types'\r\n\r\nexport class Provider extends React.Component {  \r\n  // 需要声明静态属性childContextTypes来指定context对象的属性,是context的固定写法  \r\n  static childContextTypes = {    \r\n    store: PropTypes.object  \r\n  } \r\n\r\n  // 实现getChildContext方法,返回context对象,也是固定写法  \r\n  getChildContext() {    \r\n    return { store: this.store }  \r\n  }  \r\n\r\n  constructor(props, context) {    \r\n    super(props, context)    \r\n    this.store = props.store  \r\n  }  \r\n\r\n  // 渲染被Provider包裹的组件  \r\n  render() {    \r\n    return this.props.children  \r\n  }\r\n}\r\n```\r\n#### Connect实现\r\n> connect接收mapStateToProps、mapDispatchToProps两个方法，然后返回一个高阶函数，这个高阶函数接收一个组件，返回一个高阶组件(其实就是给传入的组件增加一些属性和功能)，connect根据传入的map，将state和dispatch(action)挂载子组件的props上。其实context不过是给connect提供了获取store的途径，我们在connect中直接import store完全可以取代context。那么Provider存在的意义是什么，上面这个connect是自己写的，可以直接import store，但react-redux的connect是封装的，对外只提供api，所以需要让Provider传入store。\r\n\r\n```\r\nexport function connect(mapStateToProps, mapDispatchToProps) {    \r\n  return function(Component) {      \r\n    class Connect extends React.Component {        \r\n      componentDidMount() {          \r\n        // 从context获取store并订阅更新          \r\n        this.context.store.subscribe(this.handleStoreChange.bind(this));        \r\n      }       \r\n      handleStoreChange() {          \r\n        // 触发更新          \r\n        // 触发的方法有多种,这里为了简洁起见,直接forceUpdate强制更新,读者也可以通过setState来触发子组件更新          \r\n        this.forceUpdate()        \r\n      }        \r\n      render() {          \r\n        return (            \r\n          <Component              \r\n            // 传入该组件的props,需要由connect这个高阶组件原样传回原组件              \r\n            { ...this.props }              \r\n            // 根据mapStateToProps把state挂到this.props上              \r\n            { ...mapStateToProps(this.context.store.getState()) }               \r\n            // 根据mapDispatchToProps把dispatch(action)挂到this.props上              \r\n            { ...mapDispatchToProps(this.context.store.dispatch) }                 \r\n          />              \r\n        )        \r\n      }      \r\n    }      \r\n    //接收context的固定写法      \r\n    Connect.contextTypes = {        \r\n      store: PropTypes.object      \r\n    }      \r\n    return Connect    \r\n  }\r\n}\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## ref\r\n### string ref\r\n> 这种方式已经被React官方废弃。\r\n\r\n### callback ref\r\n> ref属性传递函数时，会在commit阶段创建真实DOM时执行ref指定的函数，并将元素作为第一个参数传入，此时我们就可以利用它进行赋值以获取DOM元素或组件实例。\r\n\r\n### object ref\r\n> 常用的方式，使用createRef或者useRef创建Ref对象，并将其传给标签的ref属性即可，这种方式获取到的ref需要先调用current属性才能获取到对应的DOM元素或组件实例。\r\n\r\n- createRef\r\n> 不能在函数组件中使用createRef，因为每次函数组件渲染都是一次新的函数执行，每次执行createRef得到的都是一个新的对象，无法保留其原来的引用。\r\n\r\n```\r\nexport function createRef(): RefObject {\r\n  const refObject = {\r\n    current: null,\r\n  }\r\n  return refObject;\r\n}\r\n```\r\n- useRef\r\n> 函数组件中使用useRef创建Ref对象，React会将useRef和函数组件对应的fiber对象关联，将useRef创建的ref对象挂载到对应的fiber对象上，每次函数组件执行，只要函数组件不被销毁，那么对应的fiber对象实例也会一直存在，所以ref也能够被保留下来。"},function(r,n,e){"use strict";e.r(n),n.default="## renderProps\r\n- 组件Props的key为render，值为一个函数。\r\n- renderProps是组件用来确定渲染什么内容的Props，renderProps的函数会返回渲染的结果，从而使得该组件的内容得到动态渲染。\r\n```\r\n// 定义renderProps，作用是为了更好地复用Mouse组件\r\n<Mouse render={mouse => <Cat mouse={mouse} />} />\r\n\r\n// 在Mouse组件中传入一个值，会根据传入的值动态渲染renderProps的内容\r\n{this.props.render(this.state)}\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## react-router\r\n### router中路由切换window的滚动条位置会被记录\r\n### 路由组件渲染使用render和children的差异\r\n- 使用children无论是否匹配都会渲染，使用render只有匹配上才会渲染。\r\n### react路由跳转携带参数\r\n- 使用params，会体现在url上，刷新数据不会丢失\r\n```\r\n{ path: '/detail/:id/:name', component: Detail },\r\n\r\n// 取值\r\nthis.props.match.params.id\r\n```\r\n- 使用query，不会体现在url上，刷新数据会丢失\r\n```\r\nhistory.push({ pathname: '', query: { flag: true } })\r\n\r\n// 取值\r\nthis.props.location.query.flag\r\n```\r\n- 使用state，不会体现在url上，刷新数据会丢失\r\n```\r\nhistory.push({ pathname: '', state: { flag: true} })\r\n\r\n// 取值\r\nthis.props.location.state.flag\r\n```\r\n- search传参，直接在pathname上拼接search，会体现在url上，刷新数据不会丢失\r\n```\r\nhistory.push({ pathname:'/settings/userinfos/mobile', search: '?from=user' })\r\nhistory.push(\"/settings/userinfos/mobile?from=user\")\r\n\r\n// 取值\r\nthis.props.location.search\r\n```\r\n### react-router-dom的抛错\r\n- Invalid prop `component` of type `object` supplied to `Route`, expected `function`\r\n```\r\n// 使用这样会报错\r\n<Route exact path=\"/upload\" component={UploadFile} />\r\n\r\n// 修改如下不会报错\r\n<Route exact path=\"/upload\" render={(props) => <UploadFile {...props} />} />\r\n```\r\n- Switch直接写元素会有warning提示\r\n### react路由切换动画\r\n- react-router-transition\r\n- 当使用类似整体路由模块的时候切换匹配到模块中的某一个时没有动画，因为匹配到的整体路由组件一直在挂载中，所以切换路由，没有办法捕获到组件切换的时机所以没有动画。\r\n```\r\nimport { AnimatedSwitch } from 'react-router-transition';\r\n\r\n<Router>\r\n  <AnimatedSwitch\r\n    atEnter={{ opacity: 0 }}\r\n    atLeave={{ opacity: 0 }}\r\n    atActive={{ opacity: 1 }}\r\n    className=\"switch-wrapper\"\r\n  >\r\n    <Route exact path=\"/\" component={Home} />\r\n    <Route path=\"/about/\" component={About} />\r\n    <Route path=\"/etc/\" component={Etc} />\r\n  </AnimatedSwitch>\r\n</Router>\r\n```\r\n### react异步加载路由上线后报loading chunk fail的解决\r\n```\r\ncomponentDidCatch(error, info) {\r\n  if (String(error).includes('Loading chunk')) {\r\n    window.location.reload();\r\n  }\r\n}\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## setState(同步)\r\n- setState本身并不是异步的，而是如果在调用setState时，如果react正处于更新过程，当前更新会被暂存，等上一次更新执行完成后再执行，这个过程给人一种异步的假象。\r\n- 在react的生命周期和合成事件中，react仍然处于他的更新机制中，这时isBatchingUpdates为true。这时无论调用多少次setState，都不会立即执行更新，而是将要更新的state存入_pendingStateQueue，将要更新的组件存入dirtyComponent。当上一次更新机制执行完毕后会将isBatchingUpdates设置为false。这时将执行之前累积的setState。\r\n### 同步异步场景(setState、useState表现相同)\r\n- 钩子函数和React合成事件中的setState不是立即执行的。\r\n- 异步函数(setTimeout、 Promise的then回调)和原生事件中(addEventListener)的setstate是立即执行的。\r\n### setState异步假象\r\n1. 开始运行\r\n2. 结束运行\r\n3. 新增粉丝数\r\n```\r\nhandleClick = () => {\r\n  const fans = Math.floor(Math.random() * 10)\r\n  console.log('开始运行')\r\n  this.setState({\r\n    count: this.state.count + fans\r\n  }, () => {\r\n    console.log('新增粉丝数:', fans)\r\n  })\r\n  console.log('结束运行')\r\n}\r\n```\r\n### setState执行早于宏任务和微任务\r\n1. 新增粉丝数\r\n2. 微任务触发\r\n3. 宏任务触发\r\n```\r\nhandleClick = () => {\r\n  const fans = Math.floor(Math.random() * 10)\r\n  setTimeout(() => {\r\n    console.log('宏任务触发')\r\n  })\r\n  Promise.resolve().then(() => {\r\n    console.log('微任务触发')\r\n  })\r\n  this.setState({\r\n    count: this.state.count + fans\r\n  }, () => {\r\n    console.log('新增粉丝数:', fans)\r\n  })\r\n}\r\n```\r\n### setState同步现象\r\n> 在React的生命周期钩子函数以及合成事件中，所有的setState操作会先缓存到一个队列中，在整个事件结束后或者mount流程结束后，才会取出之前缓存的setState队列进行一次计算，触发state更新。只要我们跳出React的事件流或者生命周期，就能打破React对setState的掌控。最简单的方法就是把setState放到setTimeout的匿名函数中。\r\n\r\n1. 开始运行\r\n2. 新增粉丝数\r\n3. 结束运行\r\n```\r\nhandleClick = () => {\r\n  setTimeout(() => {\r\n    const fans = Math.floor(Math.random() * 10)\r\n    console.log('开始运行')\r\n    this.setState({\r\n      count: this.state.count + fans\r\n    }, () => {\r\n      console.log('新增粉丝数:', fans)\r\n    })\r\n    console.log('结束运行')\r\n  })\r\n}\r\n```\r\n### 造成state更新延迟的原因\r\n- setState方法最终会调用enqueueSetState方法，而enqueueSetState方法内部会调用scheduleUpdateOnFiber方法。\r\n- 正常调用的时候，scheduleUpdateOnFiber方法内只会调用ensureRootIsScheduled，在事件方法结束后才会调用flushSyncCallbackQueue方法​。\r\n- 脱离React事件流的时候，scheduleUpdateOnFiber在ensureRootIsScheduled调用结束后，会直接调用flushSyncCallbackQueue方法。\r\n- flushSyncCallbackQueue方法就是用来更新state并重新进行render。\r\n```\r\nfunction scheduleUpdateOnFiber(fiber, lane, eventTime) {\r\n  if (lane === SyncLane) {\r\n    // 同步操作\r\n    ensureRootIsScheduled(root, eventTime);\r\n    // 判断当前是否还在 React 事件流中\r\n    // 如果不在，直接调用 flushSyncCallbackQueue 更新\r\n    if (executionContext === NoContext) {\r\n      flushSyncCallbackQueue();\r\n    }\r\n  } else {\r\n    // 异步操作\r\n  }\r\n}\r\n```\r\n### 调用setState就会重新渲染\r\n> setState调用就会引起就会组件重新渲染，即使这个状态没有参与页面渲染，所以不要把非渲染属性放state里面，即使放在了state也不要通过setState去修改这个状态，直接调用this.state.xxx = xxx，或者这种不参与渲染的属性直接挂在this上。\r\n\r\n- 直接调用setState，无参数也会重新渲染。\r\n- 新state和老state完全一致也会重新渲染(useState更新相同的状态不会重新渲染)。"},function(r,n,e){"use strict";e.r(n),n.default="## state和props\r\n> state和props的改变都会导致组件重新render。\r\n\r\n- state用于组件内部数据传递，state数据可以通过this.setState或者useState进行修改。\r\n- props用于组件之间的通信，props不能直接修改。"},function(r,n,e){"use strict";e.r(n),n.default="## useEffect和useLayoutEffect\r\n### useEffect\r\n- useEffect用来取代componentDidMount和componentDidUpdate。\r\n- 主要用于浏览器绘制之后进行一些副作用操作(比如访问DOM，请求数据)。\r\n### useLayoutEffect\r\n- useLayoutEffect中的代码以及其中任何计划的状态更新都会在浏览器重新绘制之前得到处理。\r\n- useLayoutEffect可能会影响性能，尽可能使用useEffect。\r\n### 区别\r\n- useEffect在浏览器重新绘制之后触发，useLayoutEffect在浏览器重新绘制之前触发。\r\n- useEffect异步执行不会阻塞浏览器绘制，useLayoutEffect同步执行会阻塞浏览器绘制。\r\n### 示例\r\n- 为了使效果更明显在渲染期间人为地添加了延迟。\r\n- 使用useEffect时会在浏览器绘制之后再处理useEffect内部的状态更新，点击数字之后会先显示0再显示随机数，页面会有抖动效果。\r\n- 使用useLayoutEffect时会在浏览器绘制之前就处理useLayoutEffect内部的状态更新(所以useLayoutEffect会阻塞浏览器绘制)，点击数字之后会直接显示最后的随机数，页面没有抖动效果。\r\n```\r\nimport React, { useLayoutEffect, useEffect, useState } from 'react';\r\n\r\nconst App = () => {\r\n  const [count, setCount] = useState(0);\r\n  \r\n  // 人为地减慢了渲染\r\n  const now = performance.now();\r\n  while (performance.now() - now < 100) {\r\n    // 不做任何事情...\r\n  }\r\n\r\n  useEffect(() => {\r\n    if (count === 0) {\r\n      setCount(10 + Math.random() * 200);\r\n    }\r\n  }, [count]);\r\n\r\n  return (\r\n    <div onClick={() => setCount(0)}>{count}</div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## useMemo和useCallback\r\n- 缓存内容不同。useMemo是对计算结果的缓存，useCallback是对函数的缓存。\r\n- 优化方向不同。useMemo优化方向是减少重复计算，如果需要经常使用某个计算量很大的函数，可以使用useMemo进行函数计算值的缓存。useCallback优化方向是函数的缓存从而减少重复渲染，如果需要将该函数作为props传递给子组件，那么可以使用useCallback对函数进行缓存。\r\n\r\n### useMemo\r\n> 只有依赖项改变才会调用某一个方法时可以使用useMemo，避免在每次渲染时都进行高开销的计算。返回的是函数运行的结果。\r\n\r\n- 父组件\r\n```\r\nimport React, { useState } from 'react';\r\nimport DemoOne from './demoOne';\r\n\r\nconst UseMemoDemo = () => {\r\n  const [count, setCount] = useState(0);\r\n  const [count1, setCount1] = useState(1);\r\n  return (\r\n    <div>\r\n      <button onClick={() => setCount(count + 1)}>count</button>\r\n      <button onClick={() => setCount1(count1 + 1)}>count1</button>\r\n      <DemoOne count={count} count1={count1} />\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default UseMemoDemo;\r\n```\r\n- 子组件\r\n```\r\nimport React, { useState, useMemo } from 'react';\r\n\r\nconst DemoOne = (props) => {\r\n  const [num, setNum] = useState(100);\r\n  const { count, count1 } = props;\r\n\r\n  const operationProps = (data) => {\r\n    console.log('propsChange');\r\n    return {\r\n      newCount: data.count + 10,\r\n      newCount1: data.count1 + 10,\r\n    }\r\n  }\r\n\r\n  // 如果不使用useMemo在组件内部状态改变时也会重新调用operationProps方法，使用之后只有在props改变时才会重新调用operationProps方法\r\n  const { newCount, newCount1 } = useMemo(() => operationProps(props), [props]);\r\n\r\n  return (\r\n    <div>\r\n      <div>\r\n        props count: {count}  count1: {count1}\r\n      </div>\r\n      <div>\r\n        new count: {newCount}  count1: {newCount1}\r\n      </div>\r\n      <div>\r\n        num {num}\r\n        <button onClick={() => setNum(num + 1)}>changeNum</button>\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default DemoOne;\r\n```\r\n### useCallback\r\n> 父组件重新渲染时声明的函数也会重新定义，如果此函数作为props传递给子组件，那么子组件会重新render。使用useCallback对函数进行缓存，子组件使用React.memo包裹，可以避免子组件不必要的重新渲染。\r\n\r\n- 父组件\r\n```\r\nimport React, { useState, useCallback } from 'react';\r\nimport DemoOne from './demoOne';\r\n\r\nconst UseCallbackDemo = () => {\r\n  const [count, setCount] = useState(0);\r\n  const [count1, setCount1] = useState(1);\r\n\r\n  const reset = () => {\r\n    setCount(0);\r\n    setCount1(0);\r\n  }\r\n\r\n  const useCallbackReset = useCallback(reset, []);\r\n\r\n  return (\r\n    <div>\r\n      <div>\r\n        count: {count}  count1: {count1}\r\n      </div>\r\n      <button onClick={() => setCount(count + 1)}>count</button>\r\n      <button onClick={() => setCount1(count1 + 1)}>count1</button>\r\n      {/* 如果传递reset函数，每一次点击按钮DemoOne都会重新渲染，传递使用useCallback缓存的useCallbackReset函数，点击按钮DemoOne不会重新渲染 */}\r\n      <DemoOne reset={useCallbackReset} />\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default UseCallbackDemo;\r\n```\r\n- 子组件\r\n```\r\nimport React from 'react';\r\n\r\nconst DemoOne = (props) => {\r\n  console.log('render');\r\n\r\n  return (\r\n    <div>\r\n      <button onClick={() => props.reset()}>reset</button>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default React.memo(DemoOne);\r\n```\r\n\r\n\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## 不依赖客户端时间的倒计时\r\n### 依赖客户端时间的问题\r\n> 客户的本地时间会影响这个倒计时的准确性，甚至可以直接通过修改本地时间来绕过倒计时。\r\n\r\n### 实现倒计时的方案\r\n- setTimeout\r\n- setInterval\r\n- requestAnimationFrame (存在兼容性问题)\r\n- Web Worker (存在兼容性问题)\r\n### setInterval VS setTimeout\r\n- setInterval实现倒计时是比较方便的，但是setInterval有两个缺点\r\n  1. 使用setInterval时，某些间隔会被跳过；\r\n  2. 可能多个定时器会连续执行；\r\n- 每个setTimeout产生的任务会直接push到任务队列中；而setInterval在每次把任务push到任务队列前，都要进行一下判断(看上次的任务是否仍在队列中)。\r\n- 主线程的渲染都会对setTimeout和setInterval的执行时间产生影响，但是setTimeout的影响小一点。\r\n### 使用setTimeout实现倒计时\r\n```\r\nconst INTERVAL = 1000;\r\n\r\ninterface CountDownProps {\r\n  restTime: number;\r\n  format?: string;\r\n  onFinish: () => void;\r\n  key: number;\r\n}\r\nexport const CountDown = ({ restTime, format = 'mm:ss', onFinish }: CountDownProps) => {\r\n  const timer = useRef<NodeJS.Timer | null>(null);\r\n  const [remainingTime, setRemainingTime] = useState(restTime);\r\n\r\n  useEffect(() => {\r\n    if (remainingTime < 0 && timer.current) {\r\n      onFinish?.();\r\n      clearTimeout(timer.current);\r\n      timer.current = null;\r\n      return;\r\n    }\r\n    timer.current = setTimeout(() => {\r\n      setRemainingTime((time) => time - INTERVAL);\r\n    }, INTERVAL);\r\n    return () => {\r\n      if (timer.current) {\r\n        clearTimeout(timer.current);\r\n        timer.current = null;\r\n      }\r\n    };\r\n  }, [remainingTime]);\r\n\r\n  return <span>{dayjs(remainingTime > 0 ? remainingTime : 0).format(format)}</span>;\r\n};\r\n```\r\n- 为了修正setTimeout的时间误差，我们需要在聚焦页面的时候以及定时一分钟请求一次服务器时间来修正误差。\r\n```\r\nconst REFRESH_INTERVAL = 60 * 1000;\r\n\r\nexport function useServerTime() {\r\n  const { data } = useSWR('/api/getCurrentTime', swrFetcher, {\r\n    refreshInterval: REFRESH_INTERVAL,\r\n  });\r\n  return { currentTime: data?.currentTime };\r\n}\r\n```\r\n- CountDown组件和useServerTime结合使用\r\n```\r\n// deadline和currentTime都是从服务器请求回来的服务器时间。\r\nfunction TitleAndCountDown() {\r\n  const { currentTime } = useServerTime();\r\n\r\n  return (\r\n    <Countdown\r\n      restTime={deadline - currentTime}\r\n      onFinish={onFinish}\r\n      key={deadline - currentTime}\r\n    />\r\n  );\r\n}\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## 状态管理\r\n### 状态\r\n- 状态是表示组件当前状况的JS对象。在React中可以使用useState或者this.state维护组件内部状态，通过Props传递给子组件使用。\r\n- 为了避免状态传递过程中出现混乱，React引入了“单向数据流”的理念。主要思想是组件不会改变接收的数据，只会监听数据的变化，当数据发生变化时组件会使用接收到的新值而不是修改已有的值。当组件的更新机制触发后，组件使用新的值进行重新渲染。\r\n- 父子组件通信可以直接使用Props进行通信，深层次、兄弟组件通信需要通过Props层层传递或“状态提升”进行通信。\r\n### 状态管理常见模式\r\n- 状态提升：兄弟组件间是没法直接共享状态的，可以通过将状态提升到最近的祖先组件中，兄弟组件就可以通过Props传递获取状态。\r\n- 属性下钻：将父组件的状态以属性的形式一级级传递给深层次子组件。\r\n- Context：使用Context对于深层次子组件可以通过Context直接获取状态，不再需要通过属性下钻获取状态。\r\n- 状态组合：某些状态可能只在应用程序的特定子树中需要。最好将状态存储在尽可能接近实际需要的位置，这有助于优化渲染行为。\r\n### 状态管理库要解决的问题\r\n1. 从组件树的任何地方读取存储的状态。\r\n2. 写入存储状态的能力。\r\n3. 提供优化渲染的机制。\r\n4. 提供优化内存使用的机制。\r\n5. 与并发模式的兼容性。\r\n6. 数据的持久化。\r\n7. 上下文丢失问题。\r\n8. props失效问题。\r\n9. 孤儿问题。\r\n### React Context\r\n- 在多层级嵌套组件的场景下，使用“属性下钻”方式进行组件通信是一件成本极高的事情，React官方提供Context用于避免一级级属性传递。\r\n- Context设计目的是为了共享那些对于一个组件树而言是“全局”的数据，例如当前认证的用户、主题或首选语言。在系统中跟业务相关、会频繁变动的数据在共享时，应谨慎使用Context。\r\n- 在React里Context是个反模式的东西，不同于redux等的细粒度响应式更新，Context的值一旦变化，所有依赖该Context的组件全部都会forceUpdate，因为 Context API并不能细粒度地分析某个组件依赖了Context里的哪个属性。\r\n- 优点\r\n  1. 作为React内置的hook，不需要引入第三方库；\r\n  2. API操作还算方便。\r\n- 缺点\r\n  1. Context只能存储单一值，当数据量大起来时，需要使用createContext创建大量context；\r\n  2. 直接使用的话，会有一定的性能问题：每一次对state的某个值变更，都会导致其他使用该state的组件re-render，即使没有使用该值。可以通过useMemo来解决这个问题，但是就需要一定的成本来定制一个通用的解决方案；\r\n  3. 无法处理异步请求。对于异步的逻辑，Context API并没有提供任何API，需要自己做封装；\r\n  4. 无法处理数据间的联动。Context API并没有提供API来生成派生状态，同样也需要自行去封装一些方法来实现。\r\n### Redux\r\n> Redux 遵循“单向数据流”和“不可变状态模型”的设计思想。这使得Redux的状态变化是可预测、可调试的。\r\n\r\n- 优点\r\n  1. 繁荣的社区，像不支持异步这种问题是有成熟的中间件可以解决的。\r\n  2. 可扩展性高，中间件模式可以随心所欲的武装dispatch。\r\n  3. 单一数据源且是树形结构，这让redux支持回溯，在调试上也更方便。\r\n  4. 有成熟的开发调试工具 redux devtools。\r\n- 缺点\r\n  1. 陡峭的学习曲线。将副作用扔给中间件来处理，导致社区一堆中间件，学习成本陡然增加。\r\n  2. 大量的模版代码。使用redux开发者要编写大量和业务逻辑无关的模板代码，这给开发和后期维护都带来了额外的成本。\r\n  3. 大状态量情况下，性能较差。state更新会影响所有组件。每个action都会调用所有reducer。\r\n  4. reducer要返回新的对象，如果更新的值层级较深，更新成本也很高。\r\n  5. 更多的内存占用，由于采用单一数据源，所有状态存储在一个state中，当某些状态不再需要使用时，也不会被垃圾回收释放内存。\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## 生命周期\r\n### 被废弃的生命周期\r\n> React的更新流程分为：render阶段和commit阶段。componentWillMount、componentWillReceiveProps、componentWillUpdate这三个生命周期钩子都是在render阶段执行的。在应用fiber架构之后，低优先级任务的render阶段可以被高优先级任务打断，这导致的问题就是在render阶段执行的生命周期函数可能被执行多次。\r\n\r\n1. componentWillMount\r\n2. componentWillReceiveProps\r\n3. componentWillUpdate\r\n### 新的生命周期\r\n- 挂载\r\n  1. constructor(构造函数只会执行一次)\r\n  2. static getDerivedStateFromProps(nextProps, prevState)\r\n  3. render\r\n  4. componentDidMount\r\n- 更新(re-render)\r\n  1. static getDerivedStateFromProps(nextProps, prevState)\r\n  2. shouldComponentUpdate(nextProps, nextState)\r\n  3. render\r\n  4. getSnapshotBeforeUpdate(prevProps, prevState)\r\n  5. componentDidUpdate(prevProps, prevState)\r\n- 销毁\r\n  1. componentWillUnmount\r\n### 错误捕获\r\n  1. static getDerivedStateFromError(在errorBoundary中使用)\r\n  2. componentDidCatch\r\n### getDerivedStateFromProps\r\n> 这个生命周期函数是为了替代componentWillReceiveProps，该函数会在组件实例化以及接收新props后调用(state变化也会调用，re-render都会调用)。它可以返回一个对象来更新state，或者返回null来表示新的props不需要任何state更新。函数会在每一次re-render之前调用，即使props没有改变，setState导致state改变，该函数依然会被调用，getDerivedStateFromProps是一个静态函数，也就是这个函数不能通过this访问到class的属性，不推荐直接访问属性。而是应该通过参数提供的nextProps以及prevState来进行判断，根据新传入的props来映射到state。如果props传入的内容不需要影响到你的state，那么就需要返回一个null，这个返回值是必须的。\r\n\r\n```\r\nstatic getDerivedStateFromProps(nextProps, prevState) {\r\n  const { type } = nextProps;\r\n  // 当传入的type发生变化的时候，更新state\r\n  if (type !== prevState.type) {\r\n    return {\r\n      type,\r\n    };\r\n  }\r\n  // 否则，对于state不进行任何操作\r\n  return null;\r\n}\r\n```\r\n### getSnapshotBeforeUpdate\r\n> 此生命周期的返回值将作为第三个参数传递给componentDidUpdate生命周期。\r\n\r\n```\r\nclass ScrollingList extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.listRef = React.createRef();\r\n  }\r\n\r\n  getSnapshotBeforeUpdate(prevProps, prevState) {\r\n    if (prevProps.list.length < this.props.list.length) {\r\n      const list = this.listRef.current;\r\n      return list.scrollHeight - list.scrollTop;\r\n    }\r\n    return null;\r\n  }\r\n\r\n  componentDidUpdate(prevProps, prevState, snapshot) {\r\n    if (snapshot !== null) {\r\n      const list = this.listRef.current;\r\n      list.scrollTop = list.scrollHeight - snapshot;\r\n    }\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <div ref={this.listRef}>\r\n        {/* ...contents... */}\r\n      </div>\r\n    );\r\n  }\r\n}\r\n```\r\n### 父子组件生命周期执行顺序\r\n#### 父子组件初始化\r\n- 父组件 constructor\r\n- 父组件 getDerivedStateFromProps\r\n- 父组件 render\r\n- 子组件 constructor\r\n- 子组件 getDerivedStateFromProps\r\n- 子组件 render\r\n- 子组件 componentDidMount\r\n- 父组件 componentDidMount\r\n#### 父组件修改props\r\n- 父组件 getDerivedStateFromProps\r\n- 父组件 shouldComponentUpdate\r\n- 父组件 render\r\n- 子组件 getDerivedStateFromProps\r\n- 子组件 shouldComponentUpdate\r\n- 子组件 render\r\n- 子组件 getSnapShotBeforeUpdate\r\n- 父组件 getSnapShotBeforeUpdate\r\n- 子组件 componentDidUpdate\r\n- 父组件 componentDidUpdate\r\n#### 卸载子组件\r\n- 父组件 getDerivedStateFromProps\r\n- 父组件 shouldComponentUpdate\r\n- 父组件 render\r\n- 父组件 getSnapShotBeforeUpdate\r\n- 子组件 componentWillUnmount\r\n- 父组件 componentDidUpdate\r\n#### 卸载父组件\r\n- 父组件 componentWillUnmount\r\n- 子组件 componentWillUnmount\r\n"},function(r,n,e){"use strict";e.r(n),n.default='## [简单react (Fiber + Diff + Render)](https://mp.weixin.qq.com/s?__biz=MzIxMzExMjYwOQ==&mid=2651896816&idx=1&sn=cd685d3f4ab5b4b9375552f9980ef3ff&scene=21#wechat_redirect)\r\n### Fiber 渲染过程\r\n> 每个 fiber节点 都有一个链接指向它的第一个子节点、下一个兄弟节点和它的父节点。这种数据结构可以让我们更方便的查找下一个工作单元。\r\n\r\n```\r\n<div>\r\n  <h1>\r\n    <p />\r\n    <a />\r\n  </h1>\r\n  <h2 />\r\n</div>\r\n```\r\n1. 从 root 开始，找到第一个子节点 div。\r\n2. 找到 div 的第一个子节点 h1。\r\n3. 找到 h1 的第一个子节点 p。\r\n4. 找 p 的第一个子节点，如无子节点，则找下一个兄弟节点，找到 p 的兄弟节点 a。\r\n5. 找 a 的第一个子节点，如无子节点，也无兄弟节点，则找它的父节点的下一个兄弟节点，找到 a 的 父节点的兄弟节点 h2。\r\n6. 找 h2 的第一个子节点，找不到，找兄弟节点，找不到，找父节点 div 的兄弟节点，也找不到，继续找 div 的父节点的兄弟节点，找到 root。\r\n7. 第 6 步已经找到了 root 节点，渲染已全部完成。\r\n### 渲染提交阶段\r\n> 由于渲染过程被我们做了可中断的，那么中断的时候，不希望浏览器给用户展示的是渲染了一半的 UI，所以需要等整个渲染过程结束才插入元素。\r\n\r\n1. 去除performUnitOfWork的appendChild的逻辑，待全部渲染结束才append。\r\n2. 新增根节点变量，存储Fiber根节点。\r\n3. 当所有Fiber工作完成时，nextUnitOfWork 为 undefined，这时再渲染真实 DOM。\r\n4. 新增渲染真实DOM的逻辑，递归将 fiber tree 渲染为真实 DOM。\r\n### code\r\n```\r\n<div id=\'container\'></div>\r\n\r\n// 创建html元素\r\nfunction createElement (type, props, ...children) {\r\n  return {\r\n    type,\r\n    props: {\r\n      ...props,\r\n      children: children.map(child => \r\n        typeof child === \'object\'\r\n        ? child \r\n        : createTextElement(child)\r\n      )\r\n    }\r\n  }\r\n}\r\n\r\n// 创建text元素\r\nfunction createTextElement (text) {\r\n  return {\r\n    type: "TEXT_ELEMENT",\r\n    props: {\r\n      nodeValue: text,\r\n      children: []\r\n    }\r\n  }\r\n}\r\n\r\nconst isEvent = key => key.startsWith("on")\r\nconst isProperty = key => key !== "children" && !isEvent(key)\r\nconst isNew = (prev, next) => key => prev[key] !== next[key]\r\nconst isGone = (prev, next) => key => !(key in next)\r\n\r\nlet nextUnitOfWork = null // 下一个Fiber节点\r\nlet wipRoot = null // 根节点\r\nlet currentRoot = null // 更新前的节点数据\r\nlet deletions = null  // 删除的元素\r\n\r\n// 创建dom\r\nfunction createDom (fiber) {\r\n  const dom = fiber.type === \'TEXT_ELEMENT\'\r\n    ? document.createTextNode("")\r\n    : document.createElement(fiber.type)\r\n  // 修改dom的属性\r\n  updateDom(dom, {}, fiber.props)\r\n  return dom\r\n}\r\n\r\n// 更新的dom属性修改\r\nfunction updateDom(dom, prevProps, nextProps) {\r\n  // 删除旧的或者有变化的事件(新的dom中不存在的事件或者新的dom事件绑定值修改的事件删除)\r\n  // 事件绑定值修改的删除是因为下方绑定新的事件后，原来的事件还会继续监听，和普通属性的直接覆盖不同\r\n  Object.keys(prevProps).filter(isEvent).filter(key =>\r\n    !(key in nextProps) ||\r\n    isNew(prevProps, nextProps)(key)\r\n  ).forEach(name => {\r\n    const eventType = name.toLowerCase().substring(2)\r\n    dom.removeEventListener(eventType, prevProps[name])\r\n  })\r\n\r\n  // 添加新的事件监听(新的dom事件绑定值修改的和新的dom新添的事件绑定)\r\n  Object.keys(nextProps).filter(isEvent).filter(isNew(prevProps, nextProps)).forEach(name => {\r\n    const eventType = name.toLowerCase().substring(2)\r\n    dom.addEventListener(eventType, nextProps[name])\r\n  })\r\n\r\n  // 删除旧的属性(新的dom中不存在的属性删除掉)\r\n  Object.keys(prevProps).filter(isProperty).filter(isGone(prevProps, nextProps)).forEach(name => {\r\n    dom[name] = ""\r\n  })\r\n\r\n  // 添加新的属性(新的dom属性值修改的和新的dom新添的属性)\r\n  Object.keys(nextProps).filter(isProperty).filter(isNew(prevProps, nextProps)).forEach(name => {\r\n    dom[name] = nextProps[name]\r\n  })\r\n}\r\n\r\n// 递归生成真实DOM\r\nfunction commitWork (fiber) {\r\n  if (!fiber) return\r\n  const domParent = fiber.parent.dom\r\n  if (\r\n    fiber.effectTag === "PLACEMENT" &&\r\n    fiber.dom != null\r\n  ) {\r\n    // 新的元素\r\n    domParent.appendChild(fiber.dom)\r\n  } else if (fiber.effectTag === "DELETION") {\r\n    // 删除的元素\r\n    domParent.removeChild(fiber.dom)\r\n  } else if (fiber.effectTag === \'UPDATE\' && fiber.dom !== null) {\r\n    // 有更新的元素\r\n    updateDom(fiber.dom, fiber.alternate.props, fiber.props)\r\n  }  \r\n  commitWork(fiber.child)\r\n  commitWork(fiber.sibling)\r\n}\r\n\r\n// 渲染真实DOM\r\nfunction commitRoot () {\r\n  deletions.forEach(commitWork)\r\n  commitWork(wipRoot.child)\r\n  // 正在应用的节点修改，下次再渲染时进行比较\r\n  currentRoot = wipRoot\r\n  wipRoot = null\r\n}\r\n\r\n// 处理当前Fiber节点，并返回下一个要处理的Fiber节点\r\nfunction performUnitOfWork(fiber) {\r\n  if (!fiber.dom) {\r\n    fiber.dom = createDom(fiber)\r\n  }\r\n\r\n  const elements = fiber.props.children\r\n  reconcileChildren(fiber, elements)\r\n\r\n  if (fiber.child) {\r\n    return fiber.child\r\n  }\r\n  let nextFiber = fiber\r\n  while (nextFiber) {\r\n    if (nextFiber.sibling) {\r\n      return nextFiber.sibling\r\n    }\r\n    nextFiber = nextFiber.parent\r\n  }\r\n}\r\n\r\n// Fiber节点的diff \r\nfunction reconcileChildren (wipFiber, elements) {\r\n  let index = 0\r\n  let oldFiber = wipFiber.alternate && wipFiber.alternate.child\r\n  let prevSibling = null\r\n\r\n  while (index < elements.length || oldFiber != null) {\r\n    const element = elements[index]\r\n    let newFiber = null\r\n\r\n    const sameType = oldFiber && element && element.type == oldFiber.type\r\n      \r\n    if (sameType) {\r\n      // 存在oldFiber的同节点类型 (更新)\r\n      newFiber = {\r\n        type: oldFiber.type,\r\n        props: element.props,\r\n        dom: oldFiber.dom,\r\n        parent: wipFiber,\r\n        alternate: oldFiber,\r\n        effectTag: "UPDATE",\r\n      }\r\n    }\r\n\r\n    // 没有oldFiber或者新旧节点的类型不同 (新建)\r\n    if (element && !sameType) {\r\n      newFiber = {\r\n        type: element.type,\r\n        props: element.props,\r\n        dom: null,\r\n        parent: wipFiber,\r\n        alternate: null,\r\n        effectTag: "PLACEMENT",\r\n      }\r\n    }\r\n\r\n    // 有oldFiber但是类型不同 (删除)\r\n    if (oldFiber && !sameType) {\r\n      oldFiber.effectTag = "DELETION"\r\n      deletions.push(oldFiber)\r\n    }    \r\n\r\n    if (oldFiber) {\r\n      // 新节点循环比较的下一个节点是旧节点的兄弟节点\r\n      oldFiber = oldFiber.sibling\r\n    }\r\n\r\n    if (index === 0) {\r\n      wipFiber.child = newFiber\r\n    } else if (element) {\r\n      prevSibling.sibling = newFiber\r\n    }\r\n\r\n    prevSibling = newFiber\r\n    index++\r\n  }\r\n}\r\n\r\n// Fiber 渲染机制\r\nfunction workLoop (deadline) {\r\n  let shouldYield = false\r\n  while (nextUnitOfWork && !shouldYield) {\r\n    nextUnitOfWork = performUnitOfWork(nextUnitOfWork)\r\n    shouldYield = deadline.timeRemaining() < 1\r\n  }\r\n  if (!nextUnitOfWork && wipRoot) {\r\n    commitRoot()\r\n  }\r\n  requestIdleCallback(workLoop)\r\n}\r\nrequestIdleCallback(workLoop)\r\n\r\n// render函数\r\nfunction render (element, container) {\r\n  wipRoot = {\r\n    dom: container,\r\n    props: {\r\n      children: [element]\r\n    },\r\n    alternate: currentRoot // 存储更新前dom结构\r\n  }\r\n  deletions = [] // 存储删除的dom\r\n  nextUnitOfWork = wipRoot\r\n}\r\n\r\nconst container = document.getElementById("container")\r\n// 更新之后改变虚拟 DOM 结构\r\nconst updateValue = e => {\r\n  const newData = Array.from(e.target.value || []).map(item => ({\r\n    "type": "div",\r\n    "props": {\r\n      "children": [\r\n        {\r\n          "type": "TEXT_ELEMENT",\r\n          "props": {\r\n            "nodeValue": item,\r\n            "children": []\r\n          }\r\n        },\r\n      ]\r\n    }\r\n  }))\r\n  element.props.children = [\r\n    {\r\n      "type": "input",\r\n      "props": {\r\n        "value": e.target.value,\r\n        "children": [],\r\n        "onInput": updateValue,\r\n      }\r\n    },\r\n    {\r\n      "type": "h2",\r\n      "props": {\r\n        "children": [\r\n          {\r\n            "type": "TEXT_ELEMENT",\r\n            "props": {\r\n              "nodeValue": `Hello ${e.target.value}`,\r\n              "children": []\r\n            }\r\n          },\r\n        ]\r\n      }\r\n    },\r\n    ...newData,\r\n  ]\r\n  render(element, container)\r\n}\r\n\r\n// 模拟 jsx 的虚拟 DOM 结构\r\nconst element = {\r\n  "type": "div",\r\n  "props": {\r\n    "children": [\r\n      {\r\n        "type": "input",\r\n        "props": {\r\n          "value": "",\r\n          "children": [],\r\n          "onInput": updateValue,\r\n        }\r\n      },\r\n      {\r\n        "type": "h2",\r\n        "props": {\r\n          "children": [\r\n            {\r\n              "type": "TEXT_ELEMENT",\r\n              "props": {\r\n                "nodeValue": "Hello",\r\n                "children": []\r\n              }\r\n            },\r\n          ]\r\n        }\r\n      }\r\n    ]\r\n  }\r\n}\r\nrender(element, container)\r\n```\r\n\r\n'},function(r,n,e){"use strict";e.r(n),n.default="## React类组件中方法绑定到类实例\r\n> 在JS中this会根据当前执行上下文变化，在React类组件方法中希望this引用的是当前的实例，因此有必要将这些方法绑定到当前实例。\r\n\r\n- constructor构造函数中绑定this。\r\n```\r\nexport default class Home extends React.Component {\r\n  constructor() {\r\n    super();\r\n    this.handleClick = this.handleClick.bind(this);\r\n  }\r\n\r\n  handleClick() {\r\n    // ...\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <button onClick={this.handleClick}>123</button>\r\n    )\r\n  }\r\n}\r\n```\r\n- 定义函数时使用箭头函数。\r\n```\r\nexport default class Home extends React.Component {\r\n  handleClick = () => {\r\n    // ...\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <button onClick={this.handleClick}>123</button>\r\n    )\r\n  }\r\n}\r\n```\r\n- 调用函数时绑定this。\r\n```\r\nexport default class Home extends React.Component {\r\n  handleClick() {\r\n    // ...\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <button onClick={this.handleClick.bind(this)}>123</button>\r\n    )\r\n  }\r\n}\r\n```\r\n- 调用函数时使用箭头函数。\r\n```\r\nexport default class Home extends React.Component {\r\n  handleClick() {\r\n    // ...\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <button onClick={() => this.handleClick()}>123</button>\r\n    )\r\n  }\r\n}\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## 组件封装\r\n### 支持传入className、style或者任何html标签的props\r\n- 透传props到组件内的容器标签，用起来体验和原生标签很类似。\r\n### 暴露组件内部的方法\r\n- 使用useImperativeHandle配合forwardRef自定义暴露给外部使用组件的方法。\r\n### 使用useMemo和useCallback来进行渲染性能优化\r\n### 使用Context来跨组件传递值\r\n- 使用Context来传递config、theme、size等全局配置信息。\r\n### React.Children + React.cloneElement对props.children做一些修改\r\n- 对props.children进行处理比如包一层组件、添加ref等参数、添加一些children等。"},function(r,n,e){"use strict";e.r(n),n.default="## 组件通信\r\n### 父组件向子组件通信\r\n- Props传递，利用React单向数据流的思想，通过Props传递。\r\n### 子组件向父组件通信\r\n- 父组件向子组件传递一个函数，通过函数回调，拿到子组件传过来的值。\r\n### 兄弟组件通信\r\n- 通过父组件中转数据，子组件a传递给父组件，父组件再传递给子组件b。\r\n### 父组件向后代组件通信\r\n- Context\r\n### 无关组件通信\r\n- redux"},function(r,n,e){"use strict";e.r(n),n.default="## 自定义hooks\r\n- 自定义hooks可以使用官方提供的hooks和其他自定义hooks，拥有自己的状态，封装通用的逻辑。一个自定义hooks就像一个不用返回jsx的函数组件。\r\n- 自定义hooks的使用尽可能不要做无关的渲染，需要减少性能开销，一个好用的自定义hooks需要配合useMemo、useCallback等进行优化。\r\n### 获取浏览器的高度和宽度\r\n```\r\n// 获取浏览器的高度和宽度\r\nexport const useWinSize = () => {\r\n  const [windowSize, setWindowSize] = useState({\r\n    winHeight: document.documentElement.clientHeight,\r\n    winWidth: document.documentElement.clientWidth\r\n  });\r\n\r\n  const handleResize = () => {\r\n    setWindowSize({\r\n      winHeight: document.documentElement.clientHeight,\r\n      winWidth: document.documentElement.clientWidth\r\n    });\r\n  };\r\n\r\n  useEffect(() => {\r\n    window.addEventListener('resize', handleResize);\r\n    return () => window.removeEventListener('resize', handleResize);\r\n  }, []);\r\n\r\n  return windowSize;\r\n};\r\n```\r\n### 仅在组件重新渲染时调用的useEffect\r\n```\r\n// 仅在组件重新渲染时调用(第一次render不调用)\r\nexport const useNotFirstRenderEffect = (func: () => void, deps: any) => {\r\n  const hasFirstRender = useRef(false); // 是否已经完成第一次render\r\n  useEffect(() => {\r\n    if (hasFirstRender.current) {\r\n      func();\r\n    } else {\r\n      hasFirstRender.current = true;\r\n    }\r\n  }, deps);\r\n}\r\n```\r\n### 支持回调的useState\r\n```\r\n// useState改变状态后支持回调\r\nexport const useCallbackState = (initData: any) => {\r\n  const cbRef: any = useRef(); // 存储回调函数\r\n  const [data, setData] = useState(initData);\r\n\r\n  useEffect(() => {\r\n    cbRef.current && cbRef.current(data);\r\n  }, [data]);\r\n\r\n  return [\r\n    data,\r\n    function (newData: any, callback: any) {\r\n      cbRef.current = callback;\r\n      setData(newData);\r\n    }\r\n  ];\r\n}\r\n```"},function(r,n,e){"use strict";e.r(n),n.default='## 虚拟DOM\r\n- 原生的JavaScript我们直接对DOM进行创建和更改，而React会先将JSX代码转换成一个JavaScript对象，然后再将这个JavaScript对象转换成真实DOM。这个JavaScript对象就是所谓的虚拟DOM。\r\n- 当需要创建或更新元素时，React会先对虚拟DOM对象进行创建或更改，然后再将虚拟DOM对象渲染成真实DOM。\r\n### 虚拟DOM优点\r\n#### 提高开发效率，代码逻辑更易维护\r\n- 使用JavaScript，我们很大的关注点在于如何更新DOM。使用React不必自己去完成属性操作、事件处理、DOM更新，React会替我们完成这一切。\r\n- 我们可以更关注我们的业务逻辑而非DOM操作，可大大提升我们的开发效率。\r\n#### 性能提升 **浏览器在处理DOM的时候会很慢，处理JavaScript会很快**\r\n- 直接操作DOM是非常耗费性能的，React使用虚拟DOM也是无法避免操作DOM的。如果是首次渲染，虚拟DOM并不具有优势，甚至要进行更多的计算，消耗更多的内存。\r\n- 虚拟DOM的优势在于React的Diff算法和批处理策略，React在更新真实DOM之前，提前计算好了如何进行更新和渲染DOM。实际上这个计算过程我们在直接操作DOM时，也是可以自己判断和实现的，但是一定会耗费非常多的精力和时间，而且往往我们自己做的是不如React好，React帮助我们计算如何更高效的更新，而不是它比DOM操作更快，在这个过程中React帮助我们提升了性能。\r\n- 只有虚拟DOM并不能提升性能，虚拟DOM + Diff算法才能真正的提高性能。\r\n#### 事件机制跨浏览器兼容\r\n- React基于虚拟DOM自己实现了一套事件机制，自己模拟了事件冒泡和捕获的过程，采用事件代理，批量更新等方法，抹平了各个浏览器的事件兼容性问题。\r\n#### 跨平台兼容\r\n- 以React Native为例子，根据虚拟DOM绘制出对应平台的ui层。\r\n### 虚拟DOM缺点\r\n- ⾸次渲染⼤量DOM时，由于多了⼀层虚拟DOM的计算，会⽐直接操作真实DOM慢。\r\n- ⽆法进⾏极致优化，虽然虚拟DOM + 合理的优化，⾜以应对绝⼤部分应⽤的性能需求，但在⼀些性能要求极⾼的应⽤中虚拟DOM⽆法进⾏针对性的极致优化。\r\n### 使用了虚拟DOM不一定会比直接渲染真实DOM快\r\n- React框架给的保证是在不需要手动优化的情况下，可以提供过得去的性能。\r\n- 浏览器在处理DOM的时候会很慢，处理JavaScript会很快，Diff过程是JS层面的操作，用途就是减少后续的真实DOM操作。\r\n### 虚拟DOM的结构\r\n```\r\n{\r\n  "type": "div", \r\n  "props": {\r\n    "id": "foo", \r\n    "children": [\r\n      {\r\n        "type": "a", \r\n        "props": {\r\n          "children": [\r\n            {\r\n              "type": "TEXT_ELEMENT", \r\n              "props": {\r\n                "nodeValue": "bar", \r\n                "children": []\r\n              }\r\n            }\r\n          ]\r\n        }\r\n      }, \r\n      {\r\n        "type": "b", \r\n        "props": {\r\n          "children": []\r\n        }\r\n      }\r\n    ]\r\n  }\r\n}\r\n```\r\n\r\n'},function(r,n,e){"use strict";e.r(n),n.default="## Component\r\n### React.Component源码\r\n```\r\nfunction Component(props, context, updater) {\r\n  // 接收 props，context，updater 进行初始化，挂载到 this 上\r\n  this.props = props;\r\n  this.context = context;\r\n  this.refs = emptyObject;\r\n  // updater 上挂载了 isMounted、enqueueForceUpdate、enqueueSetState 等触发器方法\r\n  this.updater = updater || ReactNoopUpdateQueue;\r\n}\r\n\r\n// 原型链上挂载 isReactComponent，在 ReactDOM.render 时用于和函数组件做区分\r\nComponent.prototype.isReactComponent = {};\r\n\r\n// 给类组件添加 `this.setState` 方法\r\nComponent.prototype.setState = function(partialState, callback) {\r\n  // 验证参数是否合法\r\n  invariant(\r\n    typeof partialState === 'object' ||\r\n      typeof partialState === 'function' ||\r\n      partialState == null\r\n  );\r\n  // 添加至 enqueueSetState 队列\r\n  this.updater.enqueueSetState(this, partialState, callback, 'setState');\r\n};\r\n\r\n// 给类组件添加 `this.forceUpdate` 方法\r\nComponent.prototype.forceUpdate = function(callback) {\r\n  // 添加至 enqueueForceUpdate 队列\r\n  this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');\r\n};\r\n```\r\n### React.Component流程\r\n1. 将props、context、updater挂载到this上。\r\n2. 在Component原型链上添加isReactComponent对象，用于标记类组件。\r\n3. 在Component原型链上添加setState方法。\r\n4. 在Component原型链上添加forceUpdate方法。\r\n5. 理解react类组件super()的作用，以及this.setState和this.forceUpdate的由来。\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## createElement\r\n### React.createElement接收三个或以上参数\r\n1. type：要创建的React元素类型，可以是标签名称字符串如'div'或者'span'等。也可以是React组件类型(class组件或者函数组件)。或者是React Fragment类型。\r\n2. config：写在标签上的属性的集合，js对象格式，若标签上未添加任何属性则为null。\r\n3. children：从第三个参数开始后的参数为当前创建的React元素的子节点，每个参数的类型若是当前元素节点的textContent则为字符串类型，否则为新的React.createElement创建的元素。\r\n### React.createElement源码\r\n```\r\nexport function createElement(type, config, children) {\r\n  let propName;\r\n\r\n  // 记录标签上的属性集合\r\n  const props = {};\r\n\r\n  let key = null;\r\n  let ref = null;\r\n  let self = null;\r\n  let source = null;\r\n\r\n  // config 不为 null 时，说明标签上有属性，将属性添加到 props 中\r\n  // 其中，key 和 ref 为 react 提供的特殊属性，不加入到 props 中，而是用 key 和 ref 单独记录\r\n  if (config != null) {\r\n    if (hasValidRef(config)) {\r\n      // 有合法的 ref 时，则给 ref 赋值\r\n      ref = config.ref;\r\n      \r\n      if (__DEV__) {\r\n        warnIfStringRefCannotBeAutoConverted(config);\r\n      }\r\n    }\r\n    if (hasValidKey(config)) {\r\n      // 有合法的 key 时，则给 key 赋值\r\n      key = '' + config.key;\r\n    }\r\n\r\n    // self 和 source 是开发环境下对代码在编译器中位置等信息进行记录，用于开发环境下调试\r\n    self = config.__self === undefined ? null : config.__self;\r\n    source = config.__source === undefined ? null : config.__source;\r\n    // 将 config 中除 key、ref、__self、__source 之外的属性添加到 props 中\r\n    for (propName in config) {\r\n      if (\r\n        hasOwnProperty.call(config, propName) &&\r\n        !RESERVED_PROPS.hasOwnProperty(propName)\r\n      ) {\r\n        props[propName] = config[propName];\r\n      }\r\n    }\r\n  }\r\n\r\n  // 将子节点添加到 props 的 children 属性上\r\n  const childrenLength = arguments.length - 2;\r\n  if (childrenLength === 1) {\r\n    // 共 3 个参数时表示只有一个子节点，直接将子节点赋值给 props 的 children 属性\r\n    props.children = children;\r\n  } else if (childrenLength > 1) {\r\n    // 3 个以上参数时表示有多个子节点，将子节点 push 到一个数组中然后将数组赋值给 props 的 children\r\n    const childArray = Array(childrenLength);\r\n    for (let i = 0; i < childrenLength; i++) {\r\n      childArray[i] = arguments[i + 2];\r\n    }\r\n    // 开发环境下冻结 childArray，防止被随意修改\r\n    if (__DEV__) {\r\n      if (Object.freeze) {\r\n        Object.freeze(childArray);\r\n      }\r\n    }\r\n    props.children = childArray;\r\n  }\r\n\r\n  // 如果有 defaultProps，对其遍历并且将用户在标签上未对其手动设置属性添加进 props 中\r\n  // 此处针对 class 组件类型\r\n  if (type && type.defaultProps) {\r\n    const defaultProps = type.defaultProps;\r\n    for (propName in defaultProps) {\r\n      if (props[propName] === undefined) {\r\n        props[propName] = defaultProps[propName];\r\n      }\r\n    }\r\n  }\r\n  \r\n  // key 和 ref 不挂载到 props 上\r\n  // 开发环境下若想通过 props.key 或者 props.ref 获取则 warning\r\n  if (__DEV__) {\r\n    if (key || ref) {\r\n      const displayName =\r\n        typeof type === 'function'\r\n          ? type.displayName || type.name || 'Unknown'\r\n          : type;\r\n      if (key) {\r\n        defineKeyPropWarningGetter(props, displayName);\r\n      }\r\n      if (ref) {\r\n        defineRefPropWarningGetter(props, displayName);\r\n      }\r\n    }\r\n  }\r\n  \r\n  // 调用 ReactElement 并返回\r\n  return ReactElement(\r\n    type,\r\n    key,\r\n    ref,\r\n    self,\r\n    source,\r\n    ReactCurrentOwner.current,\r\n    props,\r\n  );\r\n}\r\n```\r\n### React.createElement流程\r\n1. 解析config参数中是否有合法的key、ref、__source和__self 属性，若存在分别赋值给key、ref、source和self，将剩余的属性解析挂载到props上。\r\n2. 除type和config外后面的参数，挂载到props.children上。\r\n3. 针对类组件，如果type.defaultProps存在，遍历type.defaultProps的属性，如果props不存在该属性，则添加到props上。\r\n4. 将type、key、ref、self、source、props等信息，调用ReactElement函数创建虚拟dom，ReactElement主要是在开发环境下通过Object.defineProperty将 _store、_self、_source设置为不可枚举，提高element比较时的性能。\r\n### ReactElement源码\r\n```\r\nconst ReactElement = function(type, key, ref, self, source, owner, props) {\r\n  const element = {\r\n    // 用于表示是否为 ReactElement\r\n    $$typeof: REACT_ELEMENT_TYPE,\r\n\r\n    // 用于创建真实 dom 的相关信息\r\n    type: type,\r\n    key: key,\r\n    ref: ref,\r\n    props: props,\r\n\r\n    _owner: owner,\r\n  };\r\n\r\n  if (__DEV__) {\r\n    element._store = {};\r\n\r\n    // 开发环境下将 _store、_self、_source 设置为不可枚举，提高 element 的比较性能\r\n    Object.defineProperty(element._store, 'validated', {\r\n      configurable: false,\r\n      enumerable: false,\r\n      writable: true,\r\n      value: false,\r\n    });\r\n\r\n    Object.defineProperty(element, '_self', {\r\n      configurable: false,\r\n      enumerable: false,\r\n      writable: false,\r\n      value: self,\r\n    });\r\n\r\n    Object.defineProperty(element, '_source', {\r\n      configurable: false,\r\n      enumerable: false,\r\n      writable: false,\r\n      value: source,\r\n    });\r\n    // 冻结 element 和 props，防止被手动修改\r\n    if (Object.freeze) {\r\n      Object.freeze(element.props);\r\n      Object.freeze(element);\r\n    }\r\n  }\r\n\r\n  return element;\r\n};\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## [react服务端渲染](https://juejin.cn/post/6844903881390964744)\r\n### node 不支持import 语法，不能直接使用jsx 需要babel支持，添加babel配置以及使用 babel-node server/index.js  启动node服务。\r\n### 同构\r\n> 使用 react-dom/server 下的 renderToString 方法生成react组件的html字符串。但renderToString并没有做事件相关的处理，因此返回给浏览器的内容不会有事件绑定。\r\n\r\n- 同构就是一套React代码在服务器上运行一遍，到达浏览器又运行一遍。服务端渲染完成页面结构，浏览器端渲染完成事件绑定。\r\n- 浏览器端的事件绑定的方式就是让浏览器去拉取JS文件执行，让JS代码来控制事件的绑定。初始的页面html结构由服务端生成并返回，后续的事件操作交互等交给常规打包完成的js实现。\r\n- 服务端返回的html字符串时将打包的js文件引入，诸如图像、CSS 文件和 JavaScript 文件之类的静态文件，可使用 Express 中的 express.static 内置中间件函数。就可以将 public 目录下的图片、CSS 文件、JavaScript 文件对外开放访问了。\r\n### 加入路由\r\n- 加上路由之后，服务端渲染无法正确匹配路由，服务端响应的路径改为 * 匹配所有路径，使用 StaticRouter 将路由逻辑在服务端执行一遍。\r\n### redux\r\n- redux也需要服务端和客户端分别执行一次，分别使用provider包裹，需要注意store的使用，在服务端单例的使用可能导致多个用户使用一个store，需要每一次引用store时分别创建store。\r\n- 客户端和服务端的store会存在不同步的情况，服务端返回html字符串时在window上挂载服务端的store中的state值，客户端的store中的state值默认使用服务端挂载的值。\r\n### css\r\n- 使用isomorphic-style-loader包获取css。"},function(r,n,e){"use strict";e.r(n),n.default="## SSR 服务端渲染\r\n> CSR(客户端渲染)和SSR(服务端渲染)最大的区别在于前者的页面渲染是JS负责进行的，而后者是服务器端直接返回HTML让浏览器直接渲染。\r\n\r\n### CSR(客户端渲染)的弊端\r\n1. 由于页面显示过程要进行JS文件拉取和通过JS向html中填充DOM，首屏加载时间会比较慢。\r\n2. 对于SEO(Search Engine Optimazition即搜索引擎优化)完全无能为力，因为搜索引擎爬虫只认识html结构的内容，而不能识别JS代码内容。"},function(r,n,e){"use strict";e.r(n),n.default="## interface和type的异同\r\n> 能用interface实现就用interface，如果不能就用type。\r\n\r\n### 相同点\r\n#### 都可以描述一个对象和函数。\r\n```\r\ninterface User {\r\n  name: string\r\n  age: number\r\n}\r\n\r\ninterface SetUser {\r\n  (name: string, age: number): void;\r\n}\r\n\r\ntype User = {\r\n  name: string\r\n  age: number\r\n};\r\n\r\ntype SetUser = (name: string, age: number) => void;\r\n```\r\n#### interface 和 type 都可以继承。可以相互集成\r\n- interface 继承 interface\r\n```\r\ninterface Person {\r\n  name:string\r\n}\r\ninterface Student extends Person { stuNo: number }\r\n```\r\n- interface 继承 type\r\n```\r\ntype Person {\r\n  name:string\r\n}\r\ninterface Student extends Person { stuNo: number }\r\n```\r\n- type 继承 type\r\n```\r\ntype Person {\r\n  name:string\r\n}\r\ntype Student = Person & { stuNo: number }\r\n```\r\n- type 继承 interface\r\n```\r\ninterface Person{\r\n  name:string\r\n}\r\ntype Student = Person & { stuNo: number }\r\n```\r\n### 不同点\r\n#### type 可以声明基本类型别名，联合类型，元组等类型，interface不可以。\r\n```\r\n// 声明基本类型\r\ntype userName = string;\r\ntype stuNo = number;\r\n\r\n// 声明联合类型(表示取值可以为多种类型中的一种)\r\ntype Student = { stuNo: number } | { classId: number }\r\n\r\n// 声明元组\r\ntype Data = [number, string];\r\n```\r\n#### interface 能够重复声明并且会进行合并，但是type不可以。type重复声明会报错。\r\n```\r\ninterface User {\r\n  name: string\r\n  age: number\r\n}\r\n\r\ninterface User {\r\n  sex: string\r\n}\r\n\r\n/*\r\nUser 接口为 {\r\n  name: string\r\n  age: number\r\n  sex: string \r\n}\r\n*/\r\n```\r\n"},function(r,n,e){"use strict";e.r(n),n.default='## tsconfig.json文件\r\n> tsconfig.json文件是用于描述将TypeScript转为JavaScript代码的配置文件。\r\n\r\n- IDE（代码编辑器）将会根据tsconfig.json文件来对当前项目中支持不同程度的类型约束。\r\n- 对TSC编译TypeScript代码过程做一些预定义、约束入口和编译输出目录等配置。\r\n### tsconfig.json配置详解\r\n- files\r\n> 用于指明需要tsc编译的一个或多个ts文件。\r\n\r\n```\r\n{\r\n  "files": [\r\n    "index.ts",\r\n    "global.d.ts"\r\n  ],\r\n}\r\n```\r\n- include\r\n> 用于指明需要被tsc编译的文件或文件夹列表。\r\n\r\n```\r\n{\r\n  "include": [\r\n    "src",\r\n    "global.d.ts"\r\n  ],\r\n}\r\n```\r\n- exclude\r\n> 用于排除不需要tsc编译的文件或文件夹列表。exclude字段中的声明只对include字段有排除效果，对files字段无影响，即与include字段中的值互斥。如果tsconfig.json文件中files和include字段都不存在，则默认包含tsconfig.json文件所在目录及子目录的所有文件，且排除在exclude字段中声明的文件或文件夹。\r\n\r\n```\r\n{\r\n  "exclude": [\r\n    "test.ts",\r\n    "src/test.ts"\r\n  ],\r\n}\r\n```\r\n- compileOnSave\r\n> 声明是否需要在保存时候自动触发tsc编译的字段，一般我们的代码编译过程会通过Rollup、Webpack等打包构建工具，并且使用热更新，因此无需配置该项。\r\n\r\n```\r\n{\r\n  "compileOnSave": false,\r\n}\r\n```\r\n- extends\r\n> 用于指明继承已有的tsconfig配置规则文件。可以结合自己团队的情况，抽离一个基础且公共的tsconfig配置并将其发包，然后作为extends字段的值来继承配置。\r\n\r\n```\r\n// 继承一个发包后的tsconfig基础配置，并通过显示声明编译的目标代码版本为ES2016来覆盖覆盖@tsconfig/recommended中对应配置项。\r\n{\r\n  "extends": "@tsconfig/recommended/tsconfig.json",\r\n  "compilerOptions": {\r\n    "target": "ES2016"\r\n  }\r\n}\r\n```\r\n### compilerOptions\r\n> compilerOptions是一个描述TypeScript编译器功能的大字段，其值类型是对象，包含了很多用于描述编译器功能的子字段。\r\n\r\n- target\r\n> 指明经过TSC编译后的ECMAScript代码语法版本，根据ECMAScript语法标准，默认值为ES3。TypeScript是JavaScript的超集，是对JavaScript语法和类型上的扩展，因此我们可以使用ES5、ES6甚至是最新的ESNext语法来编写TS。target的值有es3、es5、es6(es2015)、es2016一直到es2022、然后还有esnext，esnext指的是当前版本的TS编译器支持的最高版本。\r\n\r\n```\r\n// 把使用了最新ECMAScript语法的TS文件编译为符合ES5语法规范的js文件。\r\n{\r\n  "compilerOptions": {\r\n    "target": "ES5",\r\n  }\r\n}\r\n```\r\n- lib\r\n> 用于为了在我们的代码中显示的指明需要支持的ECMAScript语法或环境对应的类型声明文件。例如我们的代码会使用到浏览器中的一些对象window、document，这些全局对象API对于TypeScript Complier来说是不能识别的。显式引入在DOM即浏览器环境下的一些默认类型定义，即可在代码中使用window、document等浏览器环境中的对象，TS在运行时以及编译时就不会报类型错误。\r\n\r\n```\r\n{\r\n  "compilerOptions": {\r\n    "target": "ES5",\r\n    "lib": ["ES5", "ES6", "DOM"],\r\n  }\r\n}\r\n```\r\n- module\r\n> 指明tsc编译后的代码应该符合何种模块化方案，可以指定的枚举值有：none, commonjs, amd, system, umd, es2015, es2020, ESNext，默认值为 none。可以设置allowSyntheticDefaultImports字段为true，来允许合成默认导入。\r\n\r\n```\r\n{\r\n  "compilerOptions": {\r\n    "allowSyntheticDefaultImports": true,\r\n  }\r\n}\r\n```\r\n- esModuleInterop\r\n> 支持合成默认导入，使用ESM编写代码引入了CJS的模块，由于CJS模块没有默认导出内容，因此需要通过我们的工具去自动化合成CJS的默认导出，以支持在ESM下流畅开发。当esModuleInterop字段设置为true时候，allowSyntheticDefaultImports字段也会自动设置为true。\r\n\r\n```\r\n{\r\n  "compilerOptions": {\r\n    "esModuleInterop": true,\r\n  }\r\n}\r\n```\r\n- moduleResolution\r\n> 声明如何处理模块，值：classic、node，会根据module字段决定默认值。推荐手动设置为node，更符合现在大家的编码认识一些，而且大部分的构建打包工具都是基于Node。\r\n\r\n```\r\n{\r\n  "compilerOptions": {\r\n    "moduleResolution": "node",\r\n  }\r\n}\r\n```\r\n- baseUrl & paths\r\n> baseUrl：设置基本目录以解析非绝对模块名称（定义一个根目录，以此进行绝对文件路径解析）；paths：用于设置模块名或路径映射列表，这样就可以简写项目中自定义模块的文件路径。\r\n\r\n```\r\n{\r\n  "compilerOptions": {\r\n    "baseUrl": ".", \r\n    "paths": {\r\n      "@/*": ["src/*"],\r\n      "moduleA": ["src/libs/moduleA"]\r\n    }\r\n  }\r\n}\r\n\r\n// 代码里这么写\r\nimport Toast from \'@/components/Toast.ts\' // 模块实际位置: src/components/Toast.ts\r\nimport TestModule from \'moduleA/index.js\' // 模块实际位置: src/libs/moduleA/index.js\r\n```\r\n- rootDir\r\n> 指定TypeScript识别读取的根目录。"rootDir": "./src"，则src目录下的TS文件不能引用src目录以外的ts文件，一般我们会设置为./src或 ./（即 tsconfig.json 所在目录）\r\n\r\n```\r\n{\r\n  "compilerOptions": {\r\n    "rootDir": "./src"\r\n  }\r\n}\r\n```\r\n- outDir\r\n> 输出目录即tsc编译后的文件输出的文件夹路径（基于tsconfig.json文件的相对路径）。"outDir": "./dist"，及将TSC编译输出的JS文件，统一输出的./dist目录下。\r\n\r\n```\r\n{\r\n  "compilerOptions": {\r\n    "outDir": "./dist"\r\n  }\r\n}\r\n```\r\n- jsx\r\n> 如果是有jsx语法需要支持的项目，可以设置值preserve、react、react-jsx等。\r\n\r\n```\r\n{\r\n  "compilerOptions": {\r\n    "jsx": "react-jsx",\r\n  },\r\n}\r\n```\r\n- importHelpers\r\n> 决定是否启用从tslib库引入语法降级辅助函数，以避免重复冗余的辅助函数声明。建议设置为true来启用。\r\n\r\n```\r\n{\r\n  "compilerOptions": {\r\n    "importHelpers": true,\r\n  },\r\n}\r\n```\r\n- experimentalDecorators\r\n> 用于声明是否启实验性用装饰器模式。\r\n\r\n```\r\n{\r\n  "compilerOptions": {\r\n    "experimentalDecorators": true,\r\n  },\r\n}\r\n```\r\n- noEmit\r\n> 设置是否输出js文件，一般是设置为false，将打包等工作交给Webpack等工具。\r\n\r\n```\r\n{\r\n  "compilerOptions": {\r\n    "noEmit": false,\r\n  },\r\n}\r\n```\r\n### 建议配置\r\n```\r\n{\r\n  "compilerOptions": {\r\n    "target": "es5",\r\n    "lib": [\r\n      "dom",\r\n      "dom.iterable",\r\n      "esnext"\r\n    ],\r\n    "paths": {\r\n      "@/*": ["src/*"]\r\n    },\r\n    "allowJs": true,\r\n    "skipLibCheck": true,\r\n    "esModuleInterop": true,\r\n    "allowSyntheticDefaultImports": true,\r\n    "strict": true,\r\n    "forceConsistentCasingInFileNames": true,\r\n    "noFallthroughCasesInSwitch": true,\r\n    "module": "esnext",\r\n    "moduleResolution": "node",\r\n    "resolveJsonModule": true,\r\n    "isolatedModules": true,\r\n    "noEmit": true,\r\n    "jsx": "react-jsx"\r\n  },\r\n  "include": [\r\n    "src",\r\n    "global.d.ts"\r\n  ]\r\n}\r\n```\r\n### Webpack + TypeScript\r\n> 需要安装typescript和ts-loader两个模块。Webpack主要是依赖ts-loader实现对TypeScript语法的编译支持。\r\n\r\n```\r\n// webpack配置\r\nconst path = require(\'path\');\r\n\r\nmodule.exports = {\r\n  entry: \'./src/index.ts\',\r\n  module: {\r\n    rules: [\r\n      {\r\n        test: /\\.tsx?$/,\r\n        use: \'ts-loader\',\r\n        exclude: /node_modules/,\r\n      },\r\n    ],\r\n  },\r\n  resolve: {\r\n    extensions: [\'.tsx\', \'.ts\', \'.js\'],\r\n  },\r\n  output: {\r\n    filename: \'bundle.js\',\r\n    path: path.resolve(__dirname, \'dist\'),\r\n  },\r\n};\r\n```\r\n### Babel + TypeScript\r\n> Babel处理TS需要安装@babel/preset-typescript模块，然后在babel项目配置文件中声明。Babel只会对TS代码转为JS代码（通过parseTS文件为AST，并直接移除类型信息，然后打印目标代码），不会去做TS类型检查，所以Babel编译TS文件相较于TSC的速度更快！因为Babel会根据不同的兼容环境，按需引入pollyfill，比TSC直接引入core-js更优雅，因此使用了Babel打包的体积也会更小。\r\n\r\n```\r\n// .babelrc\r\n{\r\n  "presets": ["@babel/preset-typescript"]\r\n}\r\n```\r\n### Rollup + TypeScript\r\n> 添加@rollup/plugin-typescript插件即可，该插件会默认读取项目根目录下的tsconfig.json配置文件。\r\n\r\n```\r\n// rollup.config.js\r\nimport typescript from \'@rollup/plugin-typescript\';\r\n\r\nexport default {\r\n  input: \'src/index.ts\',\r\n  output: {\r\n    dir: \'output\',\r\n    format: \'cjs\'\r\n  },\r\n  plugins: [typescript()]\r\n};\r\n```'},function(r,n,e){"use strict";e.r(n),n.default="## TypeScript\r\n> TypeScript是一种基于JavaScript的强类型编程语言。TypeScript是添加了类型系统的JavaScript。\r\n\r\n### 类型系统\r\n- 动态类型是指在运行时才会进行类型检查，这种语言的类型错误往往会导致运行时错误，JavaScript属于动态类型，它是一门解释型语言，没有编译阶段。\r\n- 静态类型是指编译阶段就能确定每个变量的类型，这种语言的类型错误往往会导致语法错误。由于TypeScript在运行前需要先编译为JavaScript，而在编译阶段就会进行类型检查，所以TypeScript属于静态类型。\r\n### 使用TypeScript的好处\r\n- TypeScript增强了编辑器(IDE)的功能，包括代码补全、接口提示、跳转到定义、代码重构等，这在很大程度上提高了开发效率。\r\n- TypeScript的类型系统可以提升程序的健壮性为大型项目带来更高的可维护性，从开发过程中减少BUG出现的概率。\r\n### tsc\r\n> tsc的全称是TypeScript Compiler，是将TypeScript转码为JavaScript代码的编译器。TSC的编译结果只有部分特性做了pollyfill处理，ES6的一些特性仍然被保留，想要支持完全的降级到ES5还是需要额外引入pollyfill（也就是我们在项目的入口文件处 import 'core-js'），但建议是将target字段值设置为ES6，提升TSC的速度。不应该将TSC作为编译项目的工具，应该将TSC作为类型检查工具，代码编译的工作尽量交给Rollup、Webpack、Babel等打包工具。\r\n\r\n```\r\n// 全局安装\r\nnpm install typescript -g\r\n\r\n// 编译index.ts文件，使用下面的命令可以得到一份编译成为JavaScript代码的./index.js文件\r\ntsc ./index.ts\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## any 和 unknown\r\n### any\r\n> any 可以代表任意类型的值，而且可以绕过 TS 的类型检查。\r\n\r\n```\r\nlet myName: any;\r\nmyName = 1;\r\n\r\n// 错误使用\r\nmyName();\r\n```\r\n### unknown\r\n> unknown 可以代表任意类型的值，但是它不可以绕过 TS 的类型检查。\r\n\r\n```\r\nlet myName: unknown;\r\nmyName = 1;\r\n\r\n// ts error: unknown 无法被调用，这被认为是不安全的\r\nmyName();\r\n\r\n// 使用typeof保护myName类型为function\r\nif (typeof myName === 'function') { \r\n  // 此时校验myName的类型为function，可以正常调用 \r\n  myName();\r\n}\r\n```\r\n### unknown 就代表一些并不会绕过类型检查但又暂时无法确定值的类型\r\n> 在一些无法确定函数参数（返回值）类型中 unknown 使用的场景比较多。\r\n\r\n```\r\n// 在不确定函数参数的类型时\r\nfunction test(val: unknown) {\r\n  if (typeof val === 'string') {  \r\n    // someThing \r\n  } else if (typeof val === 'number') { \r\n    // someThing  \r\n  } \r\n  // ...\r\n}\r\n```\r\n### unknown类型可以接收任意类型的值，但并不支持将unknown赋值给其他类型(可以赋值给any类型)。any类型同样支持接收任意类型的值，同时赋值给其他任意类型(除never类型)。"},function(r,n,e){"use strict";e.r(n),n.default='## 映射类型\r\n### Partial 构造一个类型，其中 Type 的所有属性都设置为可选。\r\n```\r\ninterface User {\r\n  name: string;\r\n  age: number;\r\n  password: string;\r\n}\r\n// {\r\n//   name?: string;\r\n//   age?: number;\r\n//   password?: string;\r\n// }\r\ntype PartialUser = Partial<User>;\r\n```\r\n### Required 构造一个类型，其中 Type 的所有属性都设置为必选。\r\n```\r\ninterface User {\r\n  name?: string;\r\n  age?: number;\r\n  password?: string;\r\n}\r\n// {\r\n//   name: string;\r\n//   age: number;\r\n//   password: string;\r\n// }\r\ntype RequiredUser = Required<User>;\r\n```\r\n### Readonly 构造一个类型，其中 Type 的所有属性都设置为只读。\r\n```\r\ninterface User {\r\n  role: string;\r\n}\r\ntype ReadonlyUser = Readonly<User>;\r\nconst user: ReadonlyUser = { role: "ADMIN" };\r\n\r\n// Error: Cannot assign to \'role\' because it is a read-only property.\r\nuser.role = "USER"; \r\n```\r\n### Pick 主要用于提取某种数据类型的属性\r\n```\r\ninterface User {\r\n  name: string;\r\n  age: number;\r\n  password: string;\r\n}\r\n// {\r\n//   name: string;\r\n//   age: number;\r\n// }\r\ntype UserPick = Pick<User, "name" | "age">;\r\n```\r\n### Omit 主要用于剔除某种数据类型的属性\r\n```\r\ninterface User {\r\n  name: string;\r\n  age: number;\r\n  password: string;\r\n}\r\n// {\r\n//   name: string;\r\n//   age: number;\r\n// }\r\ntype UserOmit = Omit<User, "password">;\r\n```\r\n### Uppercase 构造一个 Type 的所有属性都设置为大写的类型。\r\n```\r\ntype Role = "admin" | "user" | "guest";\r\n// "ADMIN" | "USER" | "GUEST"\r\ntype UppercaseRole = Uppercase<Role>;\r\n```\r\n### Lowercase 构造一个 Type 的所有属性都设置为小写的类型。\r\n```\r\ntype Role = "ADMIN" | "USER" | "GUEST";\r\n// "admin" | "user" | "guest"\r\ntype LowercaseRole = Lowercase<Role>;\r\n```\r\n### Capitalize 构造一个将 Type 的所有属性设置为首字母大写的类型。\r\n```\r\ntype Role = "admin" | "user" | "guest";\r\n// "Admin" | "User" | "Guest"\r\ntype CapitalizeRole = Capitalize<Role>;\r\n```\r\n### Uncapitalize 构造一个将 Type 的所有属性设置为非首字母大写的类型。\r\n```\r\ntype Role = "Admin" | "User" | "Guest";\r\n// "admin" | "user" | "guest"\r\ntype UncapitalizeRole = Uncapitalize<Role>; \r\n```\r\n### Record 构造一个具有一组类型 T 的属性 K 的类型，每个属性 K 都映射到类型 T。\r\n```\r\ninterface Address {\r\n  street: string;\r\n  pin: number;\r\n}\r\ninterface Addresses {\r\n  home: Address;\r\n  office: Address;\r\n}\r\ntype AddressesRecord = Record<"home" | "office", Address>;\r\n```\r\n### Exclude 构造一个具有 Type 的所有属性的类型，除了键在联合类型 Excluded 中的那些。\r\n```\r\ntype Role = "ADMIN" | "USER" | "GUEST";\r\n// "USER" | "GUEST"\r\ntype NonAdmin = Exclude<Role, "ADMIN">;\r\n```\r\n### Extract 构造一个具有 Type 的所有属性的类型，其键在联合类型 Extract 中。\r\n```\r\ntype Role = "ADMIN" | "USER" | "GUEST";\r\n// "ADMIN"\r\ntype Admin = Extract<Role, "ADMIN">;\r\n```\r\n### NonNullable 构造一个类型，其中 Type 的所有属性都设置为不可为空。\r\n```\r\ntype Role = "ADMIN" | "USER" | null;\r\n// "ADMIN" | "USER"\r\ntype NonNullableRole = NonNullable<Role>; // "ADMIN" | "USER"\r\n```'},function(r,n,e){"use strict";e.r(n),n.default="## 泛型\r\n> 泛型的本质是类型参数化，将类型作为参数传递给另一种类型、函数或其他结构。TypeScript中不建议使用any类型，不能保证类型安全。可以使用泛型来创建可重用的组件。这提高了代码灵活性，使组件可重用并消除重复。\r\n\r\n### 方法的参数类型可以传递 \r\n- localStorage获取数据时可以自定义传递获取的数据类型\r\n```\r\npublic static getItem<T>(key: string): T | null {\r\n\r\n}\r\n// 调用时传递类型\r\ngetItem<string>('user')\r\n```\r\n- 通用的接口请求方法定义返回值类型\r\n```\r\nasync function fetchApi<T>(path: string): Promise<T> {\r\n  const response = await fetch(`https://example.com/api${path}`);\r\n  return response.json();\r\n}\r\n// 调用时传递类型\r\nconst data = await fetchApi<Array<{ name: string }>>('/users');\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## defineProperty缺陷\r\n1. 只能劫持对象的属性，因此我们需要对每个对象的每个属性进行遍历监听，如果属性值也是对象那么需要深度遍历。\r\n2. 对象属性的添加和删除无法被Object.defineProperty监听，需要手动添加监听。\r\n```\r\nvar vm = new Vue({\r\n  data: {\r\n    obj: {\r\n      a: 1\r\n    },\r\n  },\r\n  template: '<div>{{ obj.message }}{{ obj.a }}</div>'\r\n});\r\n\r\n// 无法被监听到，可以使用vm.$set(obj, propertyName, newValue)方法实现\r\nvm.obj.message = 'modified';\r\n\r\n// 无法被监听到，可以使用vm.$delete(obj, propertyName)方法实现\r\ndelete vm.obj.a;\r\n```\r\n3. 部分数组的操作无法监听到，Vue虽然针对部分数组的方法进行了包裹促使可以监听到。然而通过push、unshift方法增加的元素，`vm.items[indexOfItem] = newValue`这种是无法检测的\r\n```\r\nconst vm = new Vue({\r\n  data: {\r\n    items: [1, 2, 3, 4, 5],\r\n  },\r\n});\r\n// 对象和数组如果需要监听每个属性和元素，实际上是对每个属性或者元素进行Object.defineProperty劫持，对象是监听key而数组则是以数字下标作为key，数组的数据量可能会很大，因此Vue出于性能考虑，并没有对元素下标进行响应式处理。\r\nvm.items[1] = 8;\r\n// 无法监听到 数组新添加的元素和删除元素无法被Object.defineProperty监听。\r\nvm.items[5] = 6;\r\n// 也是由于Object.defineProperty的限制，数组的长度直接修改也无法被监听。\r\nvm.items.length = 2;\r\n```\r\n### proxy\r\n- proxy代理的是整个对象，而不是对象的某个特定属性，不需要我们通过遍历来逐个进行数据绑定。\r\n- proxy 在遇到一个对象的属性还是一个对象的情况下，不需要递归监听，Object.defineProperty需要递归监听。\r\n- proxy可以直接监听数组的变化。\r\n- proxy提供了更丰富的拦截方式。"},function(r,n,e){"use strict";e.r(n),n.default="## vue的data为什么通过方法返回\r\n> 一个vue组件被创建好之后，就可能被用在各个地方，而组件不管被复用了多少次，组件中的data数据都应该是相互隔离，互不影响的，基于这一理念，组件中的data属性是一个函数，它的每个实例就会有自己的作用域空间，也就是独立的数据，每个实例之间不会相互影响。当某一处复用的地方组件内data数据被改变时，其他复用地方组件的data数据不受影响。"},function(r,n,e){"use strict";e.r(n),n.default="## 生命周期\r\n### 单组件生命周期\r\n1. beforeCreate(创建前) 此时$el、data的值都为undefined，一次挂载只运行一次。\r\n2. created(创建后) 创建之后，此时可以拿到data的值，但是$el依旧为undefined，初始异步请求多在此进行，一次挂载只运行一次。\r\n3. beforeMount(挂载前) $el的值为“虚拟”的元素节点，一次挂载只运行一次。\r\n4. mounted(挂载后) 在触发mounted时，可以获取到$el为真实的dom元素()，一次挂载只运行一次。\r\n5. beforeUpdate(更新前)\r\n6. updated(更新后)\r\n7. beforeDestroy(销毁前)\r\n8. destroyed(销毁后)\r\n### 父子组件生命周期\r\n1. 加载渲染过程：父beforeCreate -> created -> beforeMount -> 子beforeCreate -> 子created -> 子beforeMount -> 子mounted -> 父mounted。\r\n2. 更新过程：父beforeUpdate -> 子beforeUpdate -> 子updated -> 父updated。\r\n3. 销毁过程：父beforeDestroy -> 子beforeDestroy -> 子destroyed -> 父destroyed。\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## 简单vue实现\r\n```\r\nfunction Vue(options = {}) {\r\n\tthis.$options = options;\r\n\tlet data = this._data = this.$options.data;\r\n\t// 数据劫持\r\n\tobserve(data);\r\n\t// this代理，使用this可以直接访问到data\r\n\tfor (let key in data) {\r\n\t\tObject.defineProperty(this, key, {\r\n\t\t\tconfigurable: true,\r\n\t\t\tget() {\r\n\t\t\t\treturn this._data[key];\r\n\t\t\t},\r\n\t\t\tset(newVal) {\r\n\t\t\t\tthis._data[key] = newVal;\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\t// 编译\r\n\tnew Compile(options.el, this);\r\n}\r\n\r\n// 数据劫持的主要逻辑\r\nfunction Observe(data) {\r\n\tlet dep = new Dep();\r\n\t// 把data属性通过defineProperty的方式定义属性\r\n\tfor (let key in data) {\r\n\t\tlet val = data[key];\r\n\t\tobserve(val);   // 实现了深度的数据劫持(属性值也是对象的形式)\r\n\t\tObject.defineProperty(data, key, {\r\n\t\t\tenumerable: true,\r\n\t\t\tget() {\r\n\t\t\t\tDep.target && dep.addSub(Dep.target);\r\n\t\t\t\treturn val;\r\n\t\t\t},\r\n\t\t\tset(newVal) {\r\n\t\t\t\tif (val === newVal) {\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tval = newVal;\r\n\t\t\t\tobserve(newVal);    // 修改的新值也要数据劫持(修改的值为对象的形式)\r\n\t\t\t\tdep.notify();   // 让所有的watcher的update方法执行即可\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n}\r\n\r\n// 数据劫持的方法\r\nfunction observe(data) {\r\n\tif (!data || typeof data !== 'object') {\r\n\t\treturn;\r\n\t}\r\n\treturn new Observe(data);\r\n}\r\n\r\n// 编译\r\nfunction Compile(el, vm) {\r\n\tvm.$el = document.querySelector(el);\r\n\tlet fragment = document.createDocumentFragment();\r\n\r\n\twhile (child = vm.$el.firstChild) {\r\n\t\tfragment.appendChild(child);\r\n\t}\r\n\treplace(fragment);\r\n\r\n\tfunction replace(frag) {\r\n\t\tArray.from(frag.childNodes).forEach(function (node) {\r\n\t\t\tlet txt = node.textContent;\r\n\t\t\tlet reg = /\\{\\{(.*?)\\}\\}/g;\r\n\r\n\t\t\tif (node.nodeType === 3 && reg.test(txt)) { // 即是文本节点又有大括号{}\r\n\t\t\t\t!function replaceTxt() {\r\n\t\t\t\t\tnode.textContent = txt.replace(reg, (matched, placeholder) => {\r\n\t\t\t\t\t\tnew Watcher(vm, placeholder, replaceTxt);  // 监听变化，重新进行匹配替换内容\r\n\t\t\t\t\t\t// 深层次取值的形式\r\n\t\t\t\t\t\treturn placeholder.split('.').reduce((val, key) => {\r\n\t\t\t\t\t\t\treturn val[key];\r\n\t\t\t\t\t\t}, vm);\r\n\t\t\t\t\t});\r\n\t\t\t\t}();\r\n\t\t\t}\r\n\r\n\t\t\tif (node.nodeType === 1) {  // 元素节点 v-model的实现\r\n\t\t\t\tlet nodeAttr = node.attributes;     // 获取dom节点的属性\r\n\t\t\t\tArray.from(nodeAttr).forEach(attr => {\r\n\t\t\t\t\tlet name = attr.name;\r\n\t\t\t\t\tlet exp = attr.value;\r\n\t\t\t\t\tif (name.includes('v-')) {\r\n\t\t\t\t\t\tnode.value = vm[exp];\r\n\t\t\t\t\t}\r\n\t\t\t\t\tnew Watcher(vm, exp, function (newVal) {\r\n\t\t\t\t\t\tnode.value = newVal;    // 当watcher触发时会自动将内容放进输入框中\r\n\t\t\t\t\t});\r\n\t\t\t\t\tnode.addEventListener('input', function (e) {\r\n\t\t\t\t\t\tlet newVal = e.target.value;\r\n\t\t\t\t\t\tvm[exp] = newVal;\r\n\t\t\t\t\t});\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\t// 深层次递归节点\r\n\t\t\tif (node.childNodes && node.childNodes.length) {\r\n\t\t\t\treplace(node);\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\tvm.$el.appendChild(fragment);\r\n}\r\n\r\n// 发布订阅\r\nfunction Dep() {\r\n  this.subs = [];\r\n}\r\n\r\nDep.prototype.addSub = function (sub) {\r\n  this.subs.push(sub);\r\n};\r\nDep.prototype.notify = function () {\r\n  this.subs.forEach(sub => sub.update());\r\n};\r\n\r\n// watcher\r\nfunction Watcher(vm, exp, fn) {\r\n\tthis.fn = fn;\r\n\tthis.vm = vm;\r\n\tthis.exp = exp;\r\n\tDep.target = this;\r\n\tlet val = vm;\r\n\tlet arr = exp.split('.');\r\n\tarr.forEach(key => {\r\n\t\tval = val[key];  // 这里取值的时候Dep.target有值\r\n\t});\r\n\tDep.target = null;\r\n}\r\n\r\nWatcher.prototype.update = function () {\r\n\tlet val = this.vm;\r\n\tlet arr = this.exp.split('.');\r\n\tarr.forEach(key => {\r\n\t\tval = val[key];\r\n\t});\r\n\tthis.fn(val);\r\n};\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## chunk\r\n> webpack实现中，原始的资源模块以Module对象形式存在、流转、解析处理。而Chunk则是输出产物的基本组织单位，在生成阶段webpack按规则将entry及其它Module插入Chunk中，之后再由SplitChunksPlugin插件根据优化规则与ChunkGraph对Chunk做一系列的变化、拆解、合并操作，重新组织成一批性能(可能)更高的Chunks。运行完毕之后webpack继续将chunk一一写入物理文件中完成编译工作。chunk是无法在打包结果中看到的，打包结果中看到的是bundle。\r\n\r\n### chunk的基本分包规则\r\n> 业务模块是指开发者所编写的项目代码；runtime模块是指Webpack分析业务模块后，动态注入的用于支撑各项特性的运行时代码。\r\n\r\n- 每个entry项都会对应生成一个chunk对象，称之为initial chunk。\r\n- 每个异步模块都会对应生成一个chunk对象，称之为async chunk。\r\n- Webpack 5之后，如果entry配置中包含runtime值，则在entry之外再增加一个专门容纳runtime的chunk对象，此时可以称之为runtime chunk。\r\n### bundle vs chunk\r\n> bundle: bundle是webpack打包之后的各个文件，一般就是和chunk是一对一的关系，但有时候也不完全是一对一的关系。bundle就是对chunk进行编译压缩打包等处理之后的产出。chunk是过程中的代码块，bundle是结果的代码块。\r\n\r\n\r\n"},function(r,n,e){"use strict";e.r(n),n.default='## css-loader\r\n- webpack是无法处理css文件的，需要添加对应的css-loader。\r\n- css文件经过css-loader处理之后，将css转化为webpack能够解析的javascript才不会报错。\r\n### css-loader处理\r\n- css-loader会将css处理成字符串。\r\n- css模块经过css-loader处理之后，返回的内容变成了一个js模块。\r\n- 只经过css-loader处理在生产环境是无法正常加载样式的，因为没有用style处理。\r\n```\r\n// css原内容\r\n.wrap {\r\n  color: red;\r\n}\r\n\r\n// css-loader处理后内容\r\n\r\n// Imports\r\nimport ___CSS_LOADER_API_SOURCEMAP_IMPORT___ from "../node_modules/.pnpm/css-loader@6.7.3_webpack@5.79.0/node_modules/css-loader/dist/runtime/sourceMaps.js";\r\nimport ___CSS_LOADER_API_IMPORT___ from "../node_modules/.pnpm/css-loader@6.7.3_webpack@5.79.0/node_modules/css-loader/dist/runtime/api.js";\r\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_SOURCEMAP_IMPORT___);\r\n// Module\r\n___CSS_LOADER_EXPORT___.push([module.id, ".wrap {\\n  color: red;\\n}\\n", "",{"version":3,"sources":["webpack://./src/app.css"],"names":[],"mappings":"AAAA;EACE,UAAU;AACZ","sourcesContent":[".wrap {\\n  color: red;\\n}\\n"],"sourceRoot":""}]);\r\n// Exports\r\nexport default ___CSS_LOADER_EXPORT___;\r\n```\r\n'},function(r,n,e){"use strict";e.r(n),n.default="## css文件提取成单独的文件\r\n### webpack生产环境构建时为什么要将css文件提取成单独的文件\r\n1. 更好的缓存，当CSS和JS分开时浏览器可以缓存CSS文件并重复使用，也不用因为js内容的变化，导致css缓存失效。\r\n2. 更快的渲染速度，浏览器是同时可以并行加载多个静态资源，将css从js中抽离出来后能够加快js的加载与解析速度，最终加快页面的渲染速度。\r\n3. 更好的代码可读性，独立的css文件更方便代码的阅读与调试。\r\n### 使用mini-css-extract-plugin提取css文件\r\n- 安装依赖\r\n```\r\nnpm i mini-css-extract-plugin -D\r\n```\r\n- 修改webpack.common.js，根据环境变量设置开发环境使用style-loader，生产环境使用MiniCssExtractPlugin.loader抽离css。\r\n```\r\nconst MiniCssExtractPlugin = require('mini-css-extract-plugin');\r\nconst isDev = process.env.NODE_ENV === 'development'; // 是否是开发模式\r\n\r\nmodule.exports = {\r\n  // ...\r\n  module: {\r\n    rules: [\r\n      // ...\r\n      {\r\n        test: /\\.css$/,\r\n        use: [\r\n          isDev ? 'style-loader' : MiniCssExtractPlugin.loader,\r\n          'css-loader',\r\n          'postcss-loader'\r\n        ]\r\n      },\r\n      // ...\r\n    ]\r\n  },\r\n  // ...\r\n}\r\n```\r\n- 修改webpack.prod.js, 打包时添加抽离css插件\r\n```\r\nconst { merge } = require('webpack-merge');\r\nconst MiniCssExtractPlugin = require('mini-css-extract-plugin');\r\nconst commonConfig = require('./webpack.common.js');\r\n\r\nmodule.exports = merge(commonConfig, {\r\n  mode: 'production',\r\n  plugins: [\r\n    // 抽离css插件\r\n    new MiniCssExtractPlugin({\r\n      filename: 'static/css/[name].[contenthash:8].css' // 抽离css的输出目录和名称\r\n    }),\r\n  ]\r\n})\r\n```\r\n### mini-css-extract-plugin流程\r\n1. MiniCssExtractPlugin插件会先注册CssModuleFactory与CssDependency。\r\n2. 然后在MiniCssExtractPlugin.loader使用child compiler(webpack5.33.2之后默认使用importModule方法)以css文件为入口进行子编译，子编译流程跑完之后，最终会得到CssDependency。\r\n3. 然后webpack会根据模块是否有dependencies，继续解析子依赖，当碰到CssDenpendcy的时候会先找到CssModuleFactory，然后通过CssModuleFactory.create创建一个css module。\r\n4. 当所有模块都处理完之后，会根据MiniCssExtractPlugin插件内注册的renderManifest hook callback，将当前chunk内所有的css module合并到一起，然后webpack会根据manifest创建assets。\r\n5. 最终webpack会根据assets在生成最终的文件。"},function(r,n,e){"use strict";e.r(n),n.default="## loader\r\n> 利用 Webpack 我们不仅可以打包 JS 文件，还可以打包图片、CSS、字体等其他类型的资源文件。而支持打包非 JS 文件的特性是基于 Loader 机制来实现的。loader的设计要做到每个 Loader 的职责单一。\r\n\r\n### loader的作用\r\n> Loader 本质上是导出函数的 JavaScript 模块。所导出的函数，可用于实现内容转换。\r\n\r\n```\r\n/**\r\n * @param {string|Buffer} content 源文件的内容\r\n * @param {object} [map] 可以被 https://github.com/mozilla/source-map 使用的 SourceMap 数据\r\n * @param {any} [meta] meta 数据，可以是任何内容\r\n */\r\nfunction webpackLoader(content, map, meta) {\r\n  // 你的webpack loader代码\r\n}\r\nmodule.exports = webpackLoader;\r\n```\r\n### 样式相关\r\n- style-loader 将模块导出的内容作为样式并添加到 DOM 中\r\n- css-loader 加载 CSS 文件并解析 import 的 CSS 文件，最终返回 CSS 代码\r\n- less-loader 加载并编译 LESS 文件\r\n- sass-loader 加载并编译 SASS/SCSS 文件\r\n- postcss-loader 使用 PostCSS 加载并转换 CSS/SSS 文件\r\n### 模板相关\r\n- raw-loader\r\n> 此loader可以允许我们以字符串的形式引入文件原始内容，比如markdown文件等。\r\n\r\n```\r\n{\r\n  test: /\\.md$/,\r\n  use: 'raw-loader'\r\n}\r\n```\r\n- markdown-loader\r\n> 使用markdown-loader以及html-loader可以将引入的markdown文件转为html。代码区块有空行会显示错误。\r\n\r\n```\r\n{\r\n  test: /\\.md$/,\r\n  use: ['html-loader', 'markdown-loader'],\r\n},\r\n```\r\n### cache-loader\r\n> 打包时间的大部分都在npm install和各种loader的执行上，可以在loader之前加上cache-loader，这样这个loader执行过一次后的数据会缓存在node_modules/.cache目录下，下次再打包就会利用缓存。只有执行时间很长的loader才适合用缓存，因为读写文件也是有开销的，滥用反而会导致变慢。\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## output\r\n### output.path\r\n> output.path指示静态资源输出的目录，对应一个绝对路径。默认值：process.cwd()。\r\n\r\n```\r\noutput: {\r\n path: path.resolve(__dirname, '../build'),\r\n}\r\n```\r\n### output.publicPath\r\n> output.publicPath为项目中的所有资源指定一个基础路径，它被称为公共路径。这个最终静态资源访问路径在使用html-webpack-plugin打包后得到的html中可以看到。默认值：空字符串。\r\n\r\n- 静态资源最终访问路径 = output.publicPath + 资源loader或插件的配置路径。\r\n- 一般情况下publicPath应该以'/'结尾，而资源loader或插件的配置路径不要以'/'开头。\r\n- 当部署项目访问路径不是根路径或者需要访问cdn资源时会特殊配置output.publicPath。\r\n```\r\noutput: {\r\n  publicPath: '/build/',\r\n  filename: 'static/js/[name].[contenthash:8].js',\r\n},\r\n\r\n// 最终js的访问路径为\r\n/build/static/js/[name].[contenthash:8].js\r\n```\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## output的hash\r\n### hash\r\n> 异步加载打出的每一个包的hash都相同，每次修改任何一个文件，所有文件名的hash值都将改变。所以一旦修改了任何一个文件，整个项目的文件缓存都将失效。\r\n\r\n### chunkhash\r\n> 异步加载打出的每一个包的hash不同，chunkhash根据不同的入口文件(Entry)进行依赖文件解析、构建对应的chunk，生成对应的哈希值。因为打出的css和js文件的hash值相同，只要对应css或js改变，与其关联的文件hash值也会改变，但其内容并没有改变，所以也没有达到缓存意义。\r\n\r\n### contenthash\r\n> 异步加载打出的每一个包的hash不同，针对文件内容级别的，只有自己模块的内容变了，hash值才改变。生产环境建议使用。\r\n\r\n### 占位符的解释\r\n- ext\t文件后缀名\r\n- name\t文件名\r\n- path\t文件相对路径\r\n- folder\t文件所在文件夹\r\n- hash\t每次构建生成的唯一 hash 值\r\n- chunkhash\t根据 chunk 生成 hash 值\r\n- contenthash\t根据文件内容生成hash 值"},function(r,n,e){"use strict";e.r(n),n.default="## plugin\r\n> plugin是一个扩展器，它丰富了webpack本身，针对是loader结束后，webpack打包的整个过程，它并不直接操作文件，而是基于事件机制工作，会监听webpack打包过程中的某些节点，执行广泛的任务。\r\n\r\n### define-plugin\r\n> 定义全局的变量(一般用于区分生产环境和开发环境)。使用时不能通过window.QUERYHOST获取，只能通过QUERYHOST直接使用。\r\n\r\n```\r\nplugins: [\r\n  new webpack.DefinePlugin({\r\n    'QUERYHOST': JSON.stringify('http://localhost:7001/api'),\r\n  })\r\n]\r\n```\r\n### html-webpack-plugin\r\n> 默认添加脚本标签位置是头部而不是主体，由于脚本标记具有defer属性，因此只有在解析了HTML后脚本才会加载，所以不会有任何问题。如果仍然希望将脚本标记添加到正文的末尾，则可以使用inject选项。\r\n\r\n- 自动引入打包后的资源(比如资源名称含hash值的情况)\r\n```\r\nnew HtmlWebpackPlugin({\r\n  filename: 'index.html', // 配置输出文件名和路径\r\n  template: path.join(__dirname, \"../template/index.html\") // 配置文件模板\r\n})\r\n```\r\n- 多入口\r\n```\r\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\r\nmodule.exports = {\r\n  mode:'development', // 开发模式\r\n  entry: {\r\n    main:path.resolve(__dirname,'../src/main.js'),\r\n    header:path.resolve(__dirname,'../src/header.js')\r\n  }, \r\n  output: {\r\n    filename: '[name].[hash:8].js',      // 打包后的文件名称\r\n    path: path.resolve(__dirname,'../dist')  // 打包后的目录\r\n  },\r\n  plugins:[\r\n    new HtmlWebpackPlugin({\r\n      template:path.resolve(__dirname,'../public/index.html'),\r\n      filename:'index.html',\r\n      chunks:['main'] // 与入口文件对应的模块名\r\n    }),\r\n    new HtmlWebpackPlugin({\r\n      template:path.resolve(__dirname,'../public/header.html'),\r\n      filename:'header.html',\r\n      chunks:['header'] // 与入口文件对应的模块名\r\n    }),\r\n  ]\r\n}\r\n```\r\n### clean-webpack-plugin\r\n> 当打包后的文件名字固定时，新的打包文件会自动覆盖上次的，如果文件名使用了hash，则不会自动删除上次打包的文件，使用clean-webpack-plugin可以自动清除上次打包的文件。\r\n\r\n```\r\nconst { CleanWebpackPlugin } = require('clean-webpack-plugin');\r\nplugins: [\r\n  new CleanWebpackPlugin(),\r\n],\r\n```\r\n### hard-source-webpack-plugin\r\n> 可以优化构建速度,第一次构建将花费正常的时间,第二次构建将明显加快（大概提升90%的构建速度。缓存文件默认存在node_module下。webpack5.0会把hard-source-webpack-plugin内置成一个配置。\r\n\r\n```\r\nconst HardSourceWebpackPlugin = require('hard-source-webpack-plugin');\r\nplugins: [\r\n  new HardSourceWebpackPlugin({\r\n    cachePrune: {\r\n      maxAge: 2 * 24 * 60 * 60 * 1000, // 设置缓存文件过期时间为2天\r\n      sizeThreshold: 500 * 1024 * 1024, // 总缓存文件大于500M时才会自动删除过时的缓存文件\r\n    },\r\n  }),\r\n]\r\n```\r\n### extract-text-webpack-plugin\r\n> 将css分开打包\r\n\r\n```\r\nconst ExtractTextPlugin = require('extract-text-webpack-plugin');\r\n{\r\n  test: /.css$/,\r\n  use: ExtractTextPlugin.extract({ // 调用分离插件内的extract方法\r\n    fallback: 'style-loader', // 相当于回滚，经postcss-loader和css-loader处理过的css最终再经过style-loader处理\r\n    use: ['css-loader', 'postcss-loader']\r\n  })\r\n},\r\nplugins: [\r\n  new ExtractTextPlugin('index.css'), // 将css分离到/public文件夹下的css文件夹中的index.css\r\n]\r\n```\r\n### compression-webpack-plugin\r\n> 将文件压缩成gzip的形式\r\n\r\n```\r\nconst CompressionPlugin = require('compression-webpack-plugin');\r\nnew CompressionPlugin({\r\n  filename: '[path].gz[query]',\r\n  algorithm: 'gzip', // 算法\r\n  test: new RegExp(\r\n    '\\\\.(js|css|less|scss)$' // 压缩 js 与 css\r\n  ),\r\n  // threshold: 10240, // 只处理比这个值大的资源。按字节计算\r\n  // minRatio: 0.8 // 只有压缩率比这个值小的资源才会被处理\r\n}),\r\n```\r\n### unused-files-webpack-plugin \r\n> 查找无用文件\r\n\r\n```\r\nconst { UnusedFilesWebpackPlugin } = require(\"unused-files-webpack-plugin\");\r\n \r\n// 会输出无用文件目录\r\nmodule.exports = {\r\n  plugins: [\r\n    new UnusedFilesWebpackPlugin(),\r\n  ],\r\n};\r\n\r\n// cwd  插件检索的目录\r\nglobOptions: { cwd: path.resolve(__dirname, \"../src\") },\r\n\r\n// 找到未使用的文件直接退出命令 默认false\r\nfailOnUnused: true, \r\n```\r\n### webpack-bundle-analyzer\r\n> 运行打包命令，打开的页面会显示各个模块的大小。\r\n\r\n```\r\nconst BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;\r\nplugins: [\r\n  new BundleAnalyzerPlugin({\r\n    analyzerMode: 'server',\r\n    analyzerHost: '127.0.0.1',\r\n    analyzerPort: 8888,\r\n    reportFilename: 'report.html',\r\n    defaultSizes: 'parsed',\r\n    openAnalyzer: true,\r\n    generateStatsFile: false,\r\n    statsFilename: 'stats.json',\r\n    logLevel: 'info'\r\n  })\r\n]\r\n```\r\n### Speed Measure Plugin\r\n> 对打包过程中消耗的时间进行精确的统计，能够测量出在你的构建过程中，每一个 Loader 和 Plugin 的执行时长,在启动本地服务的命令行中显示。smp.wrap包裹所有的webpack的配置module.exports = smp.wrap({})，使用webpack-merge后不用加smp.wrap({}), 引入插件即可。\r\n\r\n```\r\nconst SpeedMeasurePlugin = require(\"speed-measure-webpack-plugin\");\r\nconst smp = new SpeedMeasurePlugin();\r\nconst webpackConfig = smp.wrap({\r\n  plugins: [\r\n    new MyPlugin(),\r\n    new MyOtherPlugin()\r\n  ]\r\n});\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## proxy\r\n> webpack proxy，即webpack提供的代理服务，基本行为就是接收客户端发送的请求后转发给其他服务器，目的是为了便于开发者在开发模式下解决跨域问题，想要实现代理首先需要一个中间服务器，webpack中提供服务器的工具为webpack-dev-server。\r\n\r\n### proxy配置\r\n> 属性的名称是需要被代理的请求路径前缀，一般为了辨别都会设置前缀为/api，值为对应的代理匹配规则，对应如下。\r\n\r\n- target：表示的是代理到的目标地址。\r\n- pathRewrite：默认情况下，我们的 /api-hy 也会被写入到URL中，如果希望删除，可以使用pathRewrite\r\n- secure：默认情况下不接收转发到https的服务器上，如果希望支持，可以设置为false\r\n- changeOrigin：它表示是否更新代理后请求的 headers 中host地址\r\n```\r\n// webpack.config.js\r\nconst path = require('path');\r\n\r\nmodule.exports = {\r\n  // ...\r\n  devServer: {\r\n    port: 8000,\r\n    proxy: {\r\n      '/api': {\r\n        target: 'https://api.com'\r\n      }\r\n    }\r\n    // ...\r\n  }\r\n}\r\n```\r\n### 工作原理\r\n> proxy工作原理实质上是利用 http-proxy-middleware 这个http代理中间件，实现请求转发给其他服务器。在开发阶段，本地地址为http://localhost:3000，该浏览器发送一个前缀带有/api标识的请求到服务端获取数据，但响应这个请求的服务器只是将请求转发到另一台服务器中。\r\n\r\n```\r\nconst express = require('express');\r\nconst proxy = require('http-proxy-middleware');\r\n\r\nconst app = express();\r\n\r\napp.use('/api', proxy({ target: 'http://www.example.org', changeOrigin: true }));\r\napp.listen(3000);\r\n\r\n// http://localhost:3000/api/foo/bar -> http://www.example.org/api/foo/bar\r\n```\r\n### 解决开发时的跨域问题\r\n> 在开发阶段， webpack-dev-server 会启动一个本地开发服务器，所以我们的应用在开发阶段是独立运行在 localhost的一个端口上，而后端服务又是运行在另外一个地址上，所以在开发阶段中，由于浏览器同源策略的原因，当本地访问后端就会出现跨域请求的问题，通过设置webpack proxy实现代理请求后，相当于浏览器与服务端中添加一个代理者，当本地发送请求的时候，代理服务器响应该请求，并将请求转发到目标服务器 (服务器与服务器之间请求数据并不会存在跨域行为，跨域行为是浏览器安全策略限制)，目标服务器响应数据后再将数据返回给代理服务器，最终再由代理服务器将数据响应给本地，在代理服务器传递数据给本地浏览器的过程中，两者同源，并不存在跨域行为，这时候浏览器就能正常接收数据。\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## sourcemap\r\n> sourcemap是从已转换的代码映射到原始代码的文件。包含着源代码与构建产物之间的映射关系，作用是实现运行时代码和开发时代码都能拥有相同准确的信息提示。\r\n\r\n### sourcemap文件不会影响网页性能\r\n> sourcemap只有在打开devtools的情况下才会开始下载，而大部分用户不会去打开这个面板，所以这就不是问题了。浏览器隐藏了sourcemap文件的下载，使用抓包工具可以看到sourcemap文件的下载。\r\n\r\n### 源文件和sourcemap文件关系\r\n> webpack开启了sourcemap功能之后，build后的js文件都会有一个对应的.js.map文件，而在build后的js文件中有一段注释标记了该文件对应的sourcemap文件地址。\r\n\r\n```\r\n// main.d4c530be.js\r\n...\r\n...\r\n...\r\n//# sourceMappingURL=main.d4c530be.js.map\r\n```\r\n### sourcemap选项\r\n> webpack中只要通过设置devtool的选项配置即可，值类型包括以下类型的组合。\r\n\r\n- none（默认值）\r\n  1. 不会生成map文件。\r\n- eval\r\n  1. 会生成被eval函数包裹的模块内容，并在其中通过注释来注明是源文件位置，其中的sourceUrl是用来来指定文件名。\r\n  2. 优点是快因为不用生成.map文件，并且运行时代码映射到开发时代码只需要提供对应的源文件地址。\r\n  3. 缺点就是包含映射信息少，并且eval函数因为安全性问题也是不建议使用的。\r\n![eval](./img/sourcemapEval.jpg)\r\n- source-map\r\n  1. 会生成单独的.map文件包含version、file、sources、sourcesContent、names、mappings、sourceRoot等信息，需要进行mapping和编码工作。\r\n  2. 优点就是拥有单独的.map文件，使得运行时代码体积不会过大，并且能够提供详细的信息，包含文件名、行、列等信息。\r\n  3. 缺点就是慢，因为需要额外生成.map文件，并且随着模块内容的增多整体速度就越慢。\r\n![sourcemap](./img/sourcemap.jpg)\r\n- cheap\r\n  1. 和source-map的方式不同，cheap只会映射到源码的行信息，即它不会生成源码的列信息，也不包含loader的 sourcemap，因此相对来说会比source-map的方式更快。\r\n  2. 优点就是速度更快，只映射到源码的行信息的原因是：通常在进行错误定位时，大多数情况下只需要关注到行就可以知道错误原因，而很少会关注到列，因此列信息其实不是必要性的。\r\n  3. 缺点就是映射信息会不够精确，因为一个文件可能会经过不同loader的处理，而它又不生成loader相关的sourcemap，自然会导致最终产物的信息不够精确。\r\n- module\r\n  1. module的方式生成的sourcemap就会包含和loader相关的sourcemap信息。\r\n  2. 需要loader相关的sourcemap信息的原因在于当一个文件被多个laoder依次进行转换处理后，其内容会发生不同的变化，就会使得我们无法去调试最初始的代码内容。\r\n- inline\r\n  1. 会将原本生成的.map文件的内容作为DataURL（base64 形式）嵌入bundle文件中，不单独生成.map文件。\r\n![sourcemapInline](./img/sourcemapInline.jpg)\r\n- hidden\r\n  1. 会生成单独的.map文件，但是相比于source-map的形式，其会在对应的bundle文件中隐藏sourceMappingURL的路径。\r\n![sourcemapHidden](./img/sourcemapHidden.jpg)\r\n- nosources\r\n  1. 在source-map生成的.map文件中的sourceContent存储的是源码内容，这样的好处是既可以根据文件路径来映射，也可以根据这部分内容来映射，source-map提供了双重保险，但也增加了.map文件体积。\r\n  2. nosources则是在能够保证文件路径可以准确建立映射的情况下，就可以把sourceContent的内容给去除掉，使得.map文件体积能够更小一些。\r\n![sourcemapNosources](./img/sourcemapNosources.jpg)\r\n![sourcemapNosourcesCompare](./img/sourcemapNosourcesCompare.jpg)\r\n### 生产环境建议使用\r\n> 生产环境下为了防止别人获取源代码，通常不会将sourcemap文件上传到静态资源服务器，而是上传到内部服务器上。当用户触发js错误时，通过前端监控系统或者其他手段收集到出错信息，然后根据内部服务器的sourcemap结合出错信息，找到出错的源代码位置。\r\n\r\n- source-map\r\n  1. map文件包含完整的原始代码，但是打包会很慢。打包后的js最后一行是map文件地址的注释。\r\n  2. 生产环境报错会正确提示错误的行数、列数，会显示源代码。source面板会显示源代码目录结构和代码。\r\n- nosources-source-map\r\n  1. 生成的map文件不包含源码。\r\n  2. 生产环境报错会正确提示错误的行数。source面板会显示源代码目录结构和文件名，不会显示代码。\r\n- hidden-source-map\r\n  1. 与source-map相同，也会生成map文件，但是打包后的js最后没有map文件地址的引用。\r\n  2. 生产环境报错不会提示错误的行数、列数，source面板不会显示源代码目录结构和代码。\r\n### 通过sourcemap定位源码信息\r\n- 解析源码使用source-map插件，直接使用error信息的source字段对应的文件可能无法解析到源码(webpack分包情况下)，可以使用error的stack堆栈信息的第一条对应的文件进行解析。\r\n- 使用error-stack-parser插件解析error的stack堆栈信息。\r\n```\r\nconst sourceMap = require(\"source-map\");\r\nconst ErrorStackParser = require('error-stack-parser');\r\nconst fs = require(\"fs\");\r\n\r\n// 解析错误堆栈信息(errorStack为js错误信息的stack字段内容)\r\nconst errorStackData = ErrorStackParser.parse(new Error(errorStack));\r\nconst { fileName, lineNumber, columnNumber } = errorStackData?.[0] || {};\r\nif (fileName.split('/').pop()) {\r\n  // 读取对应的.js.map文件\r\n  const mapObj = fs.readFileSync(`${__dirname}/../public/static/js/${fileName.split('/').pop()}.map`, 'utf-8');\r\n  const consumer = await new sourceMap.SourceMapConsumer(mapObj);\r\n  // 根据报错信息映射出报错的源文件和错误的行数、列数\r\n  const originalInfo = consumer.originalPositionFor({ line: lineNumber, column: columnNumber });\r\n  // 获取报错源文件的代码\r\n  const sourceCode = consumer.sourceContentFor(originalInfo.source);\r\n  // 错误源码信息\r\n  const errorSource = {\r\n    ...originalInfo,\r\n    sourceCode,\r\n  }\r\n}\r\n```\r\n### 浏览器中sourcemap生效\r\n> 浏览器默认会开启sourcemap，如果没有开启可以通过 settings => preferences => enable javascript source map 开启sourcemap。\r\n\r\n### sentry上传sourcemap文件\r\n- [sentry](https://juejin.cn/post/7209648356530962489#heading-10)\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## [SplitChunksPlugin](https://segmentfault.com/a/1190000042093955)\r\n> 默认情况下，Webpack会将所有代码构建成一个单独的包，这在小型项目通常不会有明显的性能问题，但伴随着项目的推进，包体积逐步增长可能会导致应用的响应耗时越来越长。一个多页面应用，所有页面都依赖于相同的基础库，那么这些所有页面对应的entry都会包含有基础库代码，所以需要对产物做适当的分解拆包。\r\n\r\n### 所有资源打包成一个文件方式的弊端\r\n- 资源冗余：客户端必须等待整个应用的代码包都加载完毕才能启动运行，但可能用户当下访问的内容只需要使用其中一部分代码。\r\n- 缓存失效：将所有资源达成一个包后，所有改动——即使只是修改了一个字符，客户端都需要重新下载整个代码包，缓存命中率极低。\r\n\r\n### CommmonsChunkPlugin\r\n> CommmonsChunkPlugin的思路是将满足minChunks所设置的条件的模块移到一个新的chunk文件中去，这个思路是基于父子关系的，也就是这个新产出的new chunk是所有chunk的父亲，在加载孩子chunk的时候，父亲chunk是必须要提前加载的。\r\n\r\n- 同步模块加载\r\n```\r\n// example：\r\nentryA: vue vuex  someComponents \r\nentryB: vue axios someComponents \r\nentryC: vue vuex axios someComponents \r\n\r\nminchunks: 2\r\n\r\n// 产出后的chunk，对entryA和entryB来说，vendor-chunk都包含了多余的module。\r\nvendor-chunk：vue vuex axios \r\nchunkA~chunkC: only the components\r\n```\r\n- 异步的模块\r\n```\r\n// example：\r\nentryA: vue vuex  someComponents \r\nasyncB: vue axios someComponents \r\nentryC: vue vuex axios someComponents \r\n\r\nminchunks: 2\r\n\r\n// 产出后的chunk，如果asyncB在entryA中动态引入，则会引入多余的module。\r\nvendor-chunk：vue vuex  \r\nchunkA: only the components\r\nchunkB: vue axios someComponents \r\nchunkC: axios someComponents\r\n```\r\n#### CommonsChunkPlugin的问题：\r\n- 可能会导致许多不必要的代码代码被加载。\r\n- 会影响异步加载的chunk。\r\n- 高优的chunk产出需要的minchunks配置比较复杂。\r\n### SplitChunksPlugin\r\n> 会使用模块重复计数和模块种类自动识别哪些chunk需要被分离。基于一些启发式的规则将Module编排进不同的Chunk序列，并最终将应用代码分门别类打包出多份产物，从而实现分包功能。\r\n\r\n- 不会下载不必要的模块（只要你强制使用name属性合并chunk）\r\n- 对异步加载的chunk也有效\r\n- 处理从多个vendor chunks分离出来的vendor\r\n- 更容易使用\r\n- 更加自动化\r\n### CommmonsChunkPlugin VS SplitChunksPlugin\r\n> CommonsChunkPlugin就类似于：创建这个chunk并且把所有与minChunks字段匹配的模块移到新的chunk中。而SplitChunksPlugin就类似于：这是启发式的，确保你需要他们。（命令式vs声明式）\r\n\r\n![commmonsChunkPlugin VS SplitChunksPlugin](./img/splitChunksPlugin.png)\r\n\r\n### SplitChunksPlugin使用\r\n- SplitChunksPlugin通过module被引用频率、chunk大小、包请求数三个维度决定是否执行分包操作，这些决策都可以通过 optimization.splitChunks配置项调整定制，基于这些维度我们可以实现：单独打包某些特定路径的内容，例如node_modules打包为 vendors；单独打包使用频率较高的文件。\r\n- SplitChunksPlugin还提供配置组概念optimization.splitChunks.cacheGroup，用于为不同类型的资源设置更有针对性的配置信息。\r\n- SplitChunksPlugin还内置了default与defaultVendors两个配置组，提供一些开箱即用的特性：\r\n  - node_modules资源会命中defaultVendors规则，并被单独打包。\r\n  - 只有包体超过20kb的Chunk才会被单独打包。\r\n  - 加载 Async Chunk 所需请求数不得超过30。\r\n  - 加载 Initial Chunk 所需请求数不得超过30。\r\n#### 分包范围（chunks）\r\n> SplitChunksPlugin默认只对Async Chunk生效，开发者也可以通过optimization.splitChunks.chunks调整作用范围，该配置项支持如下值：\r\n\r\n- 字符串'all' ：对Initial Chunk与Async Chunk都生效，建议优先使用该值。\r\n- 字符串'initial'：只对Initial Chunk生效。\r\n- 字符串'async'：只对Async Chunk生效。\r\n- 函数 (chunk)=>boolean：该函数返回true时生效。\r\n```\r\nmodule.exports = {\r\n  //...\r\n  optimization: {\r\n    splitChunks: {\r\n      chunks: 'all',\r\n    },\r\n  },\r\n}\r\n```\r\n#### 根据Module使用频率分包(minChunks)\r\n> SplitChunksPlugin支持按Module被Chunk引用的次数决定是否进行分包，开发者可通过optimization.splitChunks.minChunks设定最小引用次数。\r\n\r\n```\r\nmodule.exports = {\r\n  //...\r\n  optimization: {\r\n    splitChunks: {\r\n      // 设定引用次数超过 3 的模块才进行分包\r\n      minChunks: 3\r\n    },\r\n  },\r\n}\r\n```\r\n![miniChunk](./img/miniChunk.png)\r\n> entry-a、entry-b分别被视作Initial Chunk处理；async-module被entry-a以异步方式引入，因此被视作Async Chunk处理。那么对于common模块来说，分别被三个不同的Chunk引入，此时引用次数为 3，命中optimization.splitChunks.minChunks=2规则，因此该模块「可能」会被单独分包，最终产物：entry-a.js entry-b.js async-module.js common.js。\r\n\r\n#### 限制分包数量(maxInitialRequest/maxAsyncRequests)\r\n> 在满足minChunks基础上，还可以通过maxInitialRequest/maxAsyncRequests配置项限定分包数量。这里所说的“请求数”，是指加载一个Chunk时所需同步加载的分包数。例如对于一个Chunk A，如果根据分包规则(如模块引用次数、第三方包)分离出了若干子Chunk A¡，那么请求A时，浏览器需要同时请求所有的A¡，此时并行请求数等于¡个分包加A主包，即¡+1。\r\n\r\n- maxInitialRequest：用于设置Initial Chunk最大并行请求数。\r\n- maxAsyncRequests：用于设置 Async Chunk 最大并行请求数。\r\n![maxInitialRequest](./img/maxInitialRequest.png)\r\n> 若minChunks=2，则common-1 、common-2同时命中minChunks规则被分别打包，浏览器请求entry-b时需要同时请求common-1、common-2两个分包，并行数为2+1=3，此时若maxInitialRequest= 2，则分包数超过阈值，SplitChunksPlugin会放弃common-1、common-2中体积较小的分包。maxAsyncRequest逻辑与此类似。\r\n\r\n#### 限制分包体积(minSize、maxSize.........)\r\n- minSize：超过这个尺寸的Chunk才会正式被分包。\r\n- maxSize：超过这个尺寸的Chunk会尝试继续做分包。\r\n- maxAsyncSize：与maxSize功能类似，但只对异步引入的模块生效。 \r\n- maxInitialSize：与maxSize类似，但只对entry配置的入口模块生效。\r\n- enforceSizeThreshold：超过这个尺寸的Chunk会被强制分包，忽略上述其它size限制。\r\n#### SplitChunksPlugin的主体流程\r\n- SplitChunksPlugin尝试将命中minChunks规则的Module统一抽到一个额外的Chunk对象。\r\n- 判断该Chunk是否满足maxInitialRequests阈值，若满足则进行下一步。\r\n- 判断该 Chunk 资源的体积是否大于上述配置项minSize声明的下限阈值。\r\n  - 如果体积「小于」 minSize则取消这次分包，对应的Module依然会被合并入原来的Chunk。\r\n  - 如果Chunk体积「大于」minSize则判断是否超过maxSize、maxAsyncSize、maxInitialSize声明的上限阈值，如果超过则尝试将该Chunk继续分割成更小的部分。\r\n```\r\n这些属性的优先级顺序为：\r\n\r\nmaxInitialRequest/maxAsyncRequests < maxSize < minSize\r\n\r\n而命中 enforceSizeThreshold 阈值的 Chunk 会直接跳过这些属性判断，强制进行分包。\r\n```\r\n#### cacheGroups\r\n> cacheGroups配置项用于为不同文件组设置不同的规则，通过cacheGroups属性设置vendors缓存组，所有命中vendors.test规则的模块都会被视作vendors分组，优先应用该组下的minChunks、minSize等分包配置。缓存组的作用在于能为不同类型的资源设置更具适用性的分包规则，一个典型场景是将所有node_modules下的模块统一打包到vendors产物，从而实现第三方库与业务代码的分离。\r\n\r\n- test：接受正则表达式、函数及字符串，所有符合test判断的Module或Chunk都会被分到该组。\r\n- type：接受正则表达式、函数及字符串，与test类似均用于筛选分组命中的模块，区别是它判断的依据是文件类型而不是文件名，例如type='json'会命中所有JSON文件。\r\n- name：chunk命名。\r\n- priority：数字型，用于设置该分组的优先级，若模块命中多个缓存组，则优先被分到priority更大的组。\r\n**默认分组**\r\n> 这两个配置组可以 将所有node_modules中的资源单独打包到vendors.js命名的产物。对引用次数大于等于2的模块，也就是被多个Chunk引用的模块，单独打包。\r\n\r\n```\r\nmodule.exports = {\r\n  //...\r\n  optimization: {\r\n    splitChunks: {\r\n      chunks: 'async',\r\n      minSize: 30000,\r\n      maxSize: 0,\r\n      minChunks: 1,\r\n      maxAsyncRequests: 5,\r\n      maxInitialRequests: 3,\r\n      automaticNameDelimiter: '~',\r\n      name: true,\r\n      cacheGroups: {\r\n        vendors: {\r\n          test: /[\\\\/]node_modules[\\\\/]/,\r\n          priority: -10\r\n        },\r\n        default: {\r\n          minChunks: 2,\r\n          priority: -20,\r\n          reuseExistingChunk: true\r\n        }\r\n      }\r\n    }\r\n  }\r\n};\r\n```\r\n#### SplitChunksPlugin最佳实战\r\n- 尽量将第三方库拆为独立分包\r\n- 保持按路由分包，减少首屏资源负载\r\n- 尽量保持 chunks='all'\r\n\r\n### 生产环境的output不能使用hash，应该使用contenthash或者chunkhash，开发环境只能使用hash。"},function(r,n,e){"use strict";e.r(n),n.default="## webpack5变化\r\n### 模块联邦\r\n### 更好的hash算法\r\n> webpack4有hash、chunckhash、contenthash三种。在webpack5中，把hash改成了fullhash。webpack4对于添加注释和修改变量是会影响contenthash的计算，如果是webpack5的就不会影响contenthash的计算。\r\n\r\n```\r\n// before\r\nconst num = 1;\r\nconsole.log('这里是输出', num);\r\n\r\n// after\r\nconst str = 1;\r\nconsole.log('这里是输出', str);\r\n```\r\n- hash/fullhash\r\n> hash/fullhash是根据打包中的所有文件计算出来的 hash 值，在一次打包中，所有的资源出口文件的filename获得的 hash 都是一样的。\r\n\r\n- chunckhash\r\n> chunckhash是根据打包过程中当前 chunck 计算出来的 hash 值。\r\n\r\n- contenthash\r\n> contenthash是根据打包时的内容计算出的 hash 值。\r\n\r\n### 持久性缓存来提高构建性能\r\n> 在webpack5之前，webpack是没有提供持久化缓存，需要使用类似cache-loader、模块缓存插件hard-source-webpack-plugin来做缓存方面的处理。在webpack5中加入了持久化缓存，hard-source-webpack-plugin插件内置，缓存webpack生成的模块和chunk来改善构建速度。cache会在开发模式被设置成type: 'memory'，在生产模式中被禁用。\r\n\r\n- cache.type: memory 表示会将打包生成的资源存放于内存中。\r\n- cache.type: filesystem 表示开启了文件系统缓存。\r\n```\r\n// webpack 4\r\nmodule.exports = {\r\n  module: {\r\n    rules: [\r\n      {\r\n        test: /.js$/,\r\n        use: ['cache-loader', ...loaders],\r\n        include: path.resolve('src'),\r\n      },\r\n    ],\r\n  },\r\n};\r\n\r\n// webpack 5\r\nmodule.exports = {\r\n  cache: {\r\n    type: 'filesystem',\r\n  },\r\n};\r\n```\r\n### Tree Shaking的改进\r\n> Tree shaking是一个术语，通常用于移除 JavaScript 上下文中的未引用代码(dead-code)。它依赖于 ES2015 模块语法的静态结构特性，例如 import 和 export。在webpack4中，Tree Shaking对嵌套的导出模块未使用代码无法很好进行Tree Shaking，我们可以借助一些plugin来实现，但是到了webpack5得到了很大的改进。\r\n\r\n```\r\n// a.js\r\nconst name = 'dyxweb';\r\nconst age = 26;\r\nexport { name, age };\r\n\r\n// b.js\r\nimport * as data from './a';\r\nexport { data };\r\n\r\n// index.js\r\nimport * as common from './b';\r\n// 只是使用了 age，而没有使用 name\r\nconsole.log(common.data.age);\r\n\r\n// webpack5打包会移除未使用的变量，但是webpack4没有移除\r\n```\r\n### Asset Modules资源模块\r\n> 指的是图片和字体等这一类型文件模块，它们无须使用额外的预处理器，webpack 通过一些配置就可以完成对它们的解析。在webpack5之前，没有内置资源模块，所以我们通常使用file-loader、url-loader、raw-loader之类的loader去处理。\r\n\r\n- asset/resource 发送一个单独的文件并导出 URL。之前通过使用 file-loader 实现。\r\n- asset/inline 导出一个资源的 data URI。之前通过使用 url-loader 实现。\r\n- asset/source 导出资源的源代码。之前通过使用 raw-loader 实现。\r\n- asset 在导出一个 data URI 和发送一个单独的文件之间自动选择。之前通过使用 url-loader，并且配置资源体积限制实现。\r\n\r\n### 自动清除上次打包内容\r\n> webpack5配置output.clean: true可以自动清除上次打包内容。webpack4需要使用clean-webpack-plugin清除上次打包内容。\r\n\r\n### 热更新\r\n> webpack5设置devServer.hot为true即可实现热更新。webpack4需要使用webpack.HotModuleReplacementPlugin插件实现热更新，webpack5已经内置该插件。\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## webpack5搭建react+ts项目\r\n### 初始化项目基本目录\r\n- 新建项目文件夹typescript-react\r\n- 初始化package.json\r\n```\r\nnpm init -y\r\n```\r\n- 项目文件夹下新增以下目录结构和文件\r\n```\r\n- config\r\n  - webpack.common.js    // 基本配置\r\n  - webpack.dev.js       // 开发环境配置\r\n  - webpack.prod.js      // 打包环境配置\r\n  - webpack.analysis.js  // 打包分析配置\r\n- public\r\n  - index.html  // html模版          \r\n- src\r\n  - app.tsx     // react代码\r\n  - index.tsx   // react应用入口页面\r\n- tsconfig.json // ts配置\r\n- package.json\r\n```\r\n- 安装react依赖\r\n```\r\nnpm i react react-dom -S\r\n```\r\n- 安装react类型依赖\r\n```\r\nnpm i @types/react @types/react-dom -D\r\n```\r\n- 添加public/index.html内容\r\n```\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n  <meta charset=\"UTF-8\">\r\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\r\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n  <title>typescript-react</title>\r\n</head>\r\n<body>\r\n  <noscript>You need to enable JavaScript to run this app.</noscript>\r\n  <div id=\"root\"></div>\r\n</body>\r\n</html>\r\n```\r\n- 添加tsconfig.json内容\r\n```\r\n{\r\n  \"compilerOptions\": {\r\n    \"target\": \"es5\",\r\n    \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"],\r\n    \"allowJs\": true,\r\n    \"skipLibCheck\": true,\r\n    \"esModuleInterop\": true,\r\n    \"allowSyntheticDefaultImports\": true,\r\n    \"strict\": true,\r\n    \"forceConsistentCasingInFileNames\": true,\r\n    \"noFallthroughCasesInSwitch\": true,\r\n    \"module\": \"esnext\",\r\n    \"moduleResolution\": \"node\",\r\n    \"resolveJsonModule\": true,\r\n    \"isolatedModules\": true,\r\n    \"noEmit\": true,\r\n    \"jsx\": \"react-jsx\"\r\n  },\r\n  \"include\": [\"src\"]\r\n}\r\n```\r\n- 添加src/app.tsx内容\r\n```\r\nimport React from 'react';\r\n\r\nconst App = () => <div>app</div>;\r\nexport default App;\r\n```\r\n- 添加src/index.tsx内容\r\n```\r\nimport React from 'react';\r\nimport { createRoot } from 'react-dom/client';\r\nimport App from './app';\r\n\r\nconst root = document.getElementById('root');\r\ncreateRoot(root).render(<App />);\r\n```\r\n### 安装webpack依赖\r\n```\r\nnpm i webpack webpack-cli -D\r\n```\r\n### 配置webpack的entry和output\r\n```\r\n// webpack.common.js\r\nconst path = require('path');\r\n\r\nmodule.exports = {\r\n  // 入口文件\r\n  entry: path.resolve(__dirname, '../src/index.tsx'),\r\n  // 打包文件出口\r\n  output: {\r\n    publicPath: '/', // 打包后文件的公共前缀路径\r\n    path: path.resolve(__dirname, '../build'), // 打包结果输出目录\r\n    filename: 'static/js/[name].[contenthash:8].js', // 打包文件名\r\n    clean: true, // 每一次打包清除上一次打包内容，webpack4需要配置clean-webpack-plugin\r\n  },\r\n}\r\n```\r\n### 设置模块如何被解析 resolve.extensions\r\n> 尝试按顺序解析这些后缀名文件，能够使用户在引入模块时不带文件扩展名。如果有多个文件有相同的名字但后缀名不同，webpack会解析列在数组首位的后缀的文件并跳过其余的后缀。\r\n\r\n```\r\n// webpack.common.js\r\nmodule.exports = {\r\n  // ...\r\n  resolve: {\r\n    // 默认是.js和.json。以下配置解决ts文件无法被引用解析的问题\r\n    extensions: ['.tsx', '.ts', '.jsx', '.js', '.json'],\r\n  },\r\n}\r\n```\r\n### 配置babel-loader(添加babel.config.js文件配置babel相关配置)\r\n#### 解析ts/tsx和js/jsx\r\n> webpack默认只能识别js文件不能识别ts、jsx语法，需要使用@babel/preset-typescript将ts语法转为js语法，再使用@babel/preset-react来转化jsx语法。\r\n\r\n- 安装依赖\r\n```\r\nnpm i babel-loader @babel/core @babel/preset-react @babel/preset-typescript -D\r\n```\r\n- 修改webpack.common.js配置\r\n```\r\nmodule.exports = {\r\n  // ...\r\n  module: {\r\n    rules: [\r\n      {\r\n        test: /\\.(ts|js)x?$/,\r\n        use: 'babel-loader'\r\n      }\r\n    ]\r\n  }\r\n}\r\n```\r\n- 添加babel.config.js文件\r\n```\r\nmodule.exports = {\r\n  // 预设执行顺序由右往左，所以先处理ts再处理jsx\r\n  presets: [\r\n    \"@babel/preset-react\",\r\n    \"@babel/preset-typescript\"\r\n  ]\r\n}\r\n```\r\n#### babel处理js兼容\r\n> js新增很多方便好用的标准语法来方便开发，甚至还有非标准语法比如装饰器。但前者标准语法很多低版本浏览器不支持，后者非标准语法所有的浏览器都不支持。所以需要借助babel把最新的标准语法转换为低版本语法，把非标准语法转换为标准语法才能让浏览器识别解析。\r\n\r\n- 安装依赖\r\n```\r\nnpm i @babel/preset-env @babel/plugin-transform-runtime -D\r\nnpm i core-js @babel/runtime -S\r\n```\r\n- 修改babel.config.js的配置\r\n```\r\n// babel.config.js\r\nmodule.exports = {\r\n  sourceType: \"unambiguous\",\r\n  // 执行顺序由右往左，所以先处理ts再处理jsx，最后再转换为低版本浏览器支持的语法\r\n  presets: [\r\n    [\r\n      \"@babel/preset-env\",\r\n      {\r\n        // 设置兼容目标浏览器版本，这里可以不写，babel-loader会自动寻找配置好的.browserslistrc文件\r\n        // \"targets\": {\r\n        //   > 0.2% in CN\r\n        //   last 10 versions\r\n        // },\r\n        useBuiltIns: \"usage\", // 根据配置的浏览器兼容，以及代码中使用到的api进行引入polyfill按需添加\r\n        corejs: {\r\n          version: 3,\r\n          proposals: true\r\n        } // 配置使用core-js使用的版本\r\n      }\r\n    ],\r\n    \"@babel/preset-react\",\r\n    \"@babel/preset-typescript\"\r\n  ],\r\n  plugins: [\r\n    [\r\n      \"@babel/plugin-transform-runtime\",\r\n    ],\r\n  ]\r\n}\r\n```\r\n- babel-loader添加exclude配置避免报错\r\n```\r\nmodule.exports = {\r\n  // ...\r\n  module: {\r\n    rules: [\r\n      {\r\n        test: /\\.(ts|js)x?$/,\r\n        use: 'babel-loader',\r\n        exclude: [\r\n          /\\bcore-js\\b/,\r\n          /\\bwebpack\\/buildin\\b/\r\n        ],\r\n      },\r\n    ]\r\n  }\r\n}\r\n```\r\n- 添加.browserslistrc文件\r\n```\r\n> 0.2% in CN\r\nlast 10 versions\r\n```\r\n### 使用html-webpack-plugin将webpack最终构建好的静态资源都引入到html文件中\r\n- 安装依赖\r\n```\r\nnpm i html-webpack-plugin -D\r\n```\r\n- 修改webpack.common.js配置\r\n```\r\nconst path = require('path');\r\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\r\n\r\nmodule.exports = {\r\n  // ...\r\n  plugins: [\r\n    new HtmlWebpackPlugin({\r\n      // html模板\r\n      template: path.resolve(__dirname, '../public/index.html'),\r\n    }),\r\n  ]\r\n}\r\n```\r\n### webpack开发环境配置\r\n- 安装依赖\r\n> 使用webpack-dev-server启动本地服务，还需要依赖webpack-merge来合并基本配置。\r\n\r\n```\r\nnpm i webpack-dev-server webpack-merge -D\r\n```\r\n- 修改webpack.dev.js文件配置开发环境\r\n```\r\nconst path = require('path');\r\nconst { merge } = require('webpack-merge');\r\nconst commonConfig = require('./webpack.common.js');\r\n\r\n// 合并基本配置，并添加开发环境配置\r\nmodule.exports = merge(commonConfig, {\r\n  mode: 'development', // 开发模式\r\n  devtool: 'cheap-module-source-map',\r\n  devServer: {\r\n    port: 8000, // 端口号\r\n    compress: false, // gzip压缩开发环境不开启，提升热更新速度\r\n    open: true, // 自动打开浏览器\r\n    hot: true, // 开启热更新\r\n    historyApiFallback: true, // 解决history路由404问题\r\n    static: {\r\n      directory: path.resolve(__dirname, \"../public\"), // 托管静态资源public文件夹\r\n    }\r\n  }\r\n})\r\n```\r\n- package.json添加启动本地服务脚本\r\n```\r\n// package.json\r\n\"scripts\": {\r\n  \"start\": \"webpack-dev-server --config config/webpack.dev.js\"\r\n},\r\n```\r\n### webpack打包环境配置\r\n- 修改webpack.prod.js文件配置打包环境\r\n```\r\nconst { merge } = require('webpack-merge');\r\nconst commonConfig = require('./webpack.common.js');\r\n\r\nmodule.exports = merge(commonConfig, {\r\n  mode: 'production', // 生产模式\r\n})\r\n```\r\n- package.json添加打包脚本\r\n```\r\n\"scripts\": {\r\n  // ...\r\n  \"build\": \"webpack --config config/webpack.prod.js\"\r\n},\r\n```\r\n- 浏览器查看打包结果\r\n> 执行npm run build，最终打包在build文件夹中，在本地借助node服务器serve启动打包后的项目。\r\n\r\n```\r\n// 全局安装serve\r\nnpm i serve -g\r\n\r\n// 启动打包后的项目\r\nserve -s build\r\n```\r\n### 配置环境变量\r\n> 通过环境变量可以区分是开发模式还是打包构建模式，可以使用较为通用process.env.NODE_ENV环境变量进行区分。区分项目业务环境比如开发、测试、预发、正式，可以自定义一个process.env.BASE_ENV环境变量。\r\n\r\n- 安装cross-env\r\n```\r\nnpm i cross-env -D\r\n```\r\n- 修改package.json的scripts脚本字段\r\n```\r\n\"scripts\": {\r\n  \"start\": \"cross-env NODE_ENV=development BASE_ENV=development webpack-dev-server --config config/webpack.dev.js\",\r\n  \"start:test\": \"cross-env NODE_ENV=development BASE_ENV=test webpack-dev-server --config config/webpack.dev.js\",\r\n  \"build\": \"cross-env NODE_ENV=production BASE_ENV=development webpack --config config/webpack.prod.js\",\r\n  \"build:test\": \"cross-env NODE_ENV=production BASE_ENV=test webpack --config config/webpack.prod.js\",\r\n},\r\n```\r\n- process.env.NODE_ENV环境变量webpack会自动根据设置的mode字段来给业务代码注入对应的development和production，在命令中再次设置环境变量NODE_ENV是为了在webpack和babel的配置文件中访问到。\r\n- 测试webpack中可以访问到设置的环境变量，执行npm run start:test\r\n```\r\n// webpack.common.js\r\nconsole.log('NODE_ENV', process.env.NODE_ENV) // NODE_ENV development\r\nconsole.log('BASE_ENV', process.env.BASE_ENV) // BASE_ENV test\r\n```\r\n- 将环境变量注入到业务代码中\r\n```\r\n// webpack.common.js\r\nconst webpack = require('webpack');\r\n\r\nmodule.export = {\r\n  // ...\r\n  plugins: [\r\n    // ...\r\n    new webpack.DefinePlugin({\r\n      // webpack通过命令将自定义的process.env.BASE_ENV环境变量注入到业务代码\r\n      'process.env.BASE_ENV': JSON.stringify(process.env.BASE_ENV)\r\n    })\r\n  ]\r\n```\r\n- 测试业务代码中可以访问到注入的环境变量，执行npm run start:test\r\n```\r\n// src/index.tsx\r\nconsole.log('NODE_ENV', process.env.NODE_ENV) // NODE_ENV development\r\nconsole.log('BASE_ENV', process.env.BASE_ENV) // BASE_ENV test\r\n```\r\n### 支持css使用\r\n- css-loader\r\n> 会分析出各个css文件之间的关系，把各个css文件合并为一大段css，然后将css文件编译为CommonJS模块，并把该模块引入到JS中。\r\n\r\n- style-loader\r\n> 从JS中提取出刚才引入的编译后的css，在页面的header中创建style标签并插入该css。\r\n\r\n- 安装依赖\r\n```\r\nnpm i css-loader style-loader -D\r\n```\r\n- 修改webpack.common.js配置\r\n```\r\n// webpack.common.js\r\nmodule.exports = {\r\n  // ...\r\n  module: {\r\n    rules: [\r\n      // ...\r\n      {\r\n        test: /\\.css$/,\r\n        use: ['style-loader', 'css-loader']\r\n      },\r\n    ]\r\n  }\r\n}\r\n```\r\n- 添加css文件测试\r\n```\r\n// src/app.css\r\n.app {\r\n  color: red;\r\n}\r\n\r\n// src/app.tsx\r\nimport React from 'react';\r\nimport './app.css';\r\n\r\nconst App = () => <div className=\"app\">app</div>;\r\nexport default App;\r\n```\r\n- 新建global.d.ts文件添加css类型声明\r\n```\r\ndeclare module '*.css';\r\n```\r\n- tsconfig.json文件的include属性值添加global.d.ts\r\n```\r\n{\r\n  // ...\r\n  \"include\": [\"src\", \"global.d.ts\"]\r\n}\r\n```\r\n### 支持css预处理器使用(以scss为例)\r\n- 安装依赖\r\n```\r\nnpm i sass sass-loader -D\r\n```\r\n- 修改webpack.common.js配置\r\n```\r\nmodule.exports = {\r\n  // ...\r\n  module: {\r\n    rules: [\r\n      // ...\r\n      {\r\n        test: /\\.css$/,\r\n        use: ['style-loader', 'css-loader']\r\n      },\r\n      {\r\n        test: /.(scss|sass)$/,\r\n        use: [\r\n          'style-loader',\r\n          'css-loader',\r\n          'sass-loader'\r\n        ]\r\n      },\r\n    ]\r\n  }\r\n}\r\n```\r\n- 添加scss文件测试\r\n```\r\n// src/app.scss\r\n.app {\r\n  color: blue;\r\n}\r\n\r\n// src/app.tsx\r\nimport React from 'react';\r\nimport './app.scss';\r\n\r\nconst App = () => <div className=\"app\">app</div>;\r\nexport default App;\r\n```\r\n- global.d.ts文件中添加scss类型声明\r\n```\r\ndeclare module '*.scss';\r\n```\r\n### css兼容性处理\r\n> 由于浏览器兼容性不同，需要进行css兼容性的处理。如果手动编写各种兼容样式工作量较大，可使用postcss-loader来实现css的兼容性。\r\n\r\n- postcss-loader依赖于postcss。postcss有大量的配置我们可以使用它的预设postcss-preset-env，该预设包括了autoprefixer等。\r\n```\r\nnpm i postcss-loader postcss postcss-preset-env -D\r\n```\r\n- 定义通用的postcss-loader配置，根目录新建postcss.config.js，postcss.config.js是postcss-loader的配置文件，postcss-loader会自动读取配置。\r\n```\r\n// postcss.config.js\r\nmodule.exports = {\r\n  plugins: ['postcss-preset-env']\r\n}\r\n```\r\n- postcss-loader会根据.browserslistrc文件判断要加哪些浏览器的前缀\r\n- 在每个css相关的loader配置中添加postcss-loader。postcss-loader需要在css-loader之前执行，在css预处理器的loader之后执行。\r\n```\r\n// webpack.common.js\r\nmodule.exports = {\r\n  // ...\r\n  module: {\r\n    rules: [\r\n      // ...\r\n      {\r\n        test: /\\.css$/,\r\n        use: ['style-loader', 'css-loader', 'postcss-loader']\r\n      },\r\n      {\r\n        test: /.(scss|sass)$/,\r\n        use: [\r\n          'style-loader',\r\n          'css-loader',\r\n          'postcss-loader',\r\n          'sass-loader'\r\n        ]\r\n      },\r\n    ]\r\n  },\r\n}\r\n```\r\n- 添加样式测试，css样式已经加上了浏览器内核前缀。\r\n```\r\n// src/app.scss\r\n.app {\r\n  color: blue;\r\n  transform: translateY(100px);\r\n}\r\n```\r\n### 支持css module形式\r\n- 添加css-loader的options配置\r\n```\r\n// webpack.common.js\r\nmodule.exports = {\r\n  // ...\r\n  module: {\r\n    rules: [\r\n      // ...\r\n      {\r\n        test: /\\.css$/,\r\n        use: [\r\n          'style-loader',\r\n          'css-loader',\r\n          'postcss-loader'\r\n        ]\r\n      },\r\n      {\r\n        test: /.(scss|sass)$/,\r\n        use: [\r\n          'style-loader',\r\n          {\r\n            loader: require.resolve('css-loader'),\r\n            // 开启css module\r\n            options: {\r\n              modules: {\r\n                localIdentName: '[folder]_[local]_[hash:base64:5]',\r\n              },\r\n            },\r\n          },\r\n          'postcss-loader',\r\n          'sass-loader'\r\n        ]\r\n      },\r\n    ]\r\n  },\r\n}\r\n```\r\n- 修改样式使用形式测试效果\r\n```\r\n// src/app.tsx\r\nimport React from 'react';\r\nimport styles from './app.scss';\r\n\r\nconst App = () => <div className={styles.app}>app</div>;\r\nexport default App;\r\n```\r\n### 抽取css样式文件\r\n> 开发环境我们希望css嵌入在style标签里面方便样式热替换但打包时我们希望把css单独抽离出来，方便配置http缓存策略。\r\n\r\n- 安装依赖\r\n```\r\nnpm i mini-css-extract-plugin -D\r\n```\r\n- 修改webpack.common.js，根据环境变量设置开发环境使用style-loader，打包模式抽离css。\r\n```\r\nconst MiniCssExtractPlugin = require('mini-css-extract-plugin');\r\n\r\nconst isDev = process.env.NODE_ENV === 'development'; // 是否是开发模式\r\n\r\nmodule.exports = {\r\n  // ...\r\n  module: {\r\n    rules: [\r\n      // ...\r\n      {\r\n        test: /\\.css$/,\r\n        use: [\r\n          isDev ? 'style-loader' : MiniCssExtractPlugin.loader, // 开发环境使用style-loader，打包模式抽离css\r\n          'css-loader',\r\n          'postcss-loader'\r\n        ]\r\n      },\r\n      {\r\n        test: /.(scss|sass)$/,\r\n        use: [\r\n          isDev ? 'style-loader' : MiniCssExtractPlugin.loader, // 开发环境使用style-loader，打包模式抽离css\r\n          {\r\n            loader: require.resolve('css-loader'),\r\n            // 开启css module\r\n            options: {\r\n              modules: {\r\n                localIdentName: '[folder]_[local]_[hash:base64:5]',\r\n              },\r\n            },\r\n          },\r\n          'postcss-loader',\r\n          'sass-loader'\r\n        ]\r\n      },\r\n    ]\r\n  },\r\n}\r\n```\r\n- 修改webpack.prod.js, 打包时添加抽离css插件\r\n```\r\nconst { merge } = require('webpack-merge');\r\nconst MiniCssExtractPlugin = require('mini-css-extract-plugin');\r\nconst commonConfig = require('./webpack.common.js');\r\n\r\nmodule.exports = merge(commonConfig, {\r\n  mode: 'production', // 生产模式\r\n  plugins: [\r\n    // 抽离css插件\r\n    new MiniCssExtractPlugin({\r\n      filename: 'static/css/[name].[contenthash:8].css' // 抽离css的输出目录和名称\r\n    }),\r\n  ]\r\n})\r\n```\r\n### 压缩css文件\r\n- 安装依赖\r\n```\r\nnpm i css-minimizer-webpack-plugin -D\r\n```\r\n- 修改webpack.prod.js配置\r\n```\r\nconst { merge } = require('webpack-merge');\r\nconst CssMinimizerWebpackPlugin = require('css-minimizer-webpack-plugin');\r\nconst commonConfig = require('./webpack.common.js');\r\n\r\nmodule.exports = merge(commonConfig, {\r\n  mode: 'production', // 生产模式\r\n  // ...\r\n  optimization: {\r\n    minimizer: [\r\n      new CssMinimizerWebpackPlugin(), // 压缩css\r\n    ],\r\n  },\r\n})\r\n```\r\n### 处理图片文件\r\n- webpack4使用file-loader和url-loader来处理图片文件，webpack5使用自带的asset-module来处理。\r\n```\r\n// webpack.common.js\r\nmodule.exports = {\r\n  module: {\r\n    rules: [\r\n      // ...\r\n      {\r\n        test: /.(png|jpg|jpeg|gif|svg)$/, // 匹配图片文件\r\n        type: \"asset\", // type选择asset\r\n        parser: {\r\n          dataUrlCondition: {\r\n            maxSize: 10 * 1024, // 小于10kb转base64位\r\n          }\r\n        },\r\n        generator:{ \r\n          filename: 'static/images/[name].[contenthash:8][ext]', // 文件输出目录和命名\r\n        },\r\n      },\r\n    ]\r\n  }\r\n}\r\n```\r\n- 添加图片引用测试效果\r\n```\r\n// src/app.tsx\r\nimport React from 'react';\r\nimport smallImg from './assets/4kb.png';\r\nimport bigImg from './assets/20kb.png';\r\nimport styles from './app.scss';\r\n\r\nconst App = () => (\r\n  <div className={styles.app}>\r\n    <img src={smallImg} />\r\n    <img src={bigImg} />\r\n    app\r\n  </div>\r\n);\r\nexport default App;\r\n```\r\n- global.d.ts文件中添加图片类型声明\r\n```\r\ndeclare module '*.png';\r\n```\r\n### 处理字体和媒体文件\r\n> 字体文件和媒体文件处理方式和处理图片一样，调整匹配的路径和打包后放置的路径即可。\r\n\r\n```\r\n// webpack.common.js\r\nmodule.exports = {\r\n  module: {\r\n    rules: [\r\n      // ...\r\n      {\r\n        test: /.(woff2?|eot|ttf|otf)$/, // 匹配字体图标文件\r\n        type: \"asset\", // type选择asset\r\n        parser: {\r\n          dataUrlCondition: {\r\n            maxSize: 10 * 1024, // 小于10kb转base64位\r\n          }\r\n        },\r\n        generator: {\r\n          filename: 'static/fonts/[name].[contenthash:8][ext]', // 文件输出目录和命名\r\n        },\r\n      },\r\n      {\r\n        test: /.(mp4|webm|ogg|mp3|wav|flac|aac)$/, // 匹配媒体文件\r\n        type: \"asset\", // type选择asset\r\n        parser: {\r\n          dataUrlCondition: {\r\n            maxSize: 10 * 1024, // 小于10kb转base64位\r\n          }\r\n        },\r\n        generator: {\r\n          filename: 'static/media/[name].[contenthash:8][ext]', // 文件输出目录和命名\r\n        },\r\n      },\r\n    ]\r\n  }\r\n}\r\n```\r\n### react模块热更新\r\n- 模块热更新在webpack5中只要设置devServer.hot为true即可。在webpack4中还需要在插件中添加HotModuleReplacementPlugin，webpack5已经内置该插件。\r\n- 开发模式下修改css和less文件，页面样式可以在不刷新浏览器的情况实时生效，因为此时样式都在style标签里面，style-loader做了替换样式的热更新功能。\r\n- 修改react相关代码，浏览器会自动刷新后再显示修改后的内容，我们期望的是在不需要刷新浏览器的前提下模块热更新，并且能够保留react组件的状态。\r\n- 借助@pmmmwh/react-refresh-webpack-plugin插件来实现，该插件依赖于react-refresh。\r\n- 安装依赖\r\n```\r\nnpm i @pmmmwh/react-refresh-webpack-plugin react-refresh -D\r\n```\r\n- 修改webpack.dev.js配置\r\n```\r\nconst { merge } = require('webpack-merge');\r\nconst ReactRefreshWebpackPlugin = require('@pmmmwh/react-refresh-webpack-plugin');\r\nconst commonConfig = require('./webpack.common.js');\r\n\r\nmodule.exports = merge(commonConfig, {\r\n  // ...\r\n  plugins: [\r\n    new ReactRefreshWebpackPlugin(), // 添加热更新插件\r\n  ]\r\n})\r\n```\r\n- babel-loader配置react-refesh刷新插件，修改babel.config.js文件\r\n```\r\nconst isDEV = process.env.NODE_ENV === 'development'; // 是否是开发模式\r\n\r\nmodule.exports = {\r\n  // ...\r\n  \"plugins\": [\r\n    // ...\r\n    isDEV && require.resolve('react-refresh/babel'), // 如果是开发模式，就启动react热更新插件\r\n  ].filter(Boolean) // 过滤空值\r\n}\r\n```\r\n### 开启持久化存储缓存\r\n- 在webpack5之前做缓存是使用babel-loader缓存js的解析结果，cache-loader缓存css等资源的解析结果，还有模块缓存插件hard-source-webpack-plugin，配置好缓存后第二次打包通过对文件做哈希对比来验证文件前后是否一致，如果一致则采用上一次的缓存，可以极大地节省时间。\r\n- webpack5较于webpack4，新增了持久化缓存、改进缓存算法等。通过配置webpack持久化缓存来缓存生成的webpack模块和chunk，改善下一次打包的构建速度可提速 90%左右，配置也更为简单。\r\n- 修改webpack.common.js配置\r\n```\r\nmodule.exports = {\r\n  // ...\r\n  cache: {\r\n    type: 'filesystem', // 使用文件缓存\r\n  },\r\n}\r\n```\r\n### 配置alias别名\r\n> 设置别名可以让后续引用的地方减少路径的复杂度。如下配置在项目中使用@/xxx.xx就会指向src/xxx.xx，在js/ts和css文件中都可以用。\r\n\r\n- 修改webpack.common.js配置\r\n```\r\nconst path = require('path');\r\n\r\nmodule.export = {\r\n  // ...\r\n   resolve: {\r\n    // ...\r\n    alias: {\r\n      '@': path.resolve(__dirname, '../src')\r\n    }\r\n  }\r\n}\r\n```\r\n- 修改tsconfig.json，添加baseUrl和paths\r\n```\r\n{\r\n  \"compilerOptions\": {\r\n    // ...\r\n    \"baseUrl\": \".\",\r\n    \"paths\": {\r\n      \"@/*\": [\"src/*\"]\r\n    }\r\n  }\r\n}\r\n```\r\n- 修改引用形式测试效果\r\n```\r\n// src/app.tsx\r\nimport React from 'react';\r\nimport smallImg from '@/assets/4kb.png';\r\nimport bigImg from '@/assets/20kb.png';\r\nimport styles from './app.scss';\r\n\r\nconst App = () => (\r\n  <div className={styles.app}>\r\n    <img src={smallImg} />\r\n    <img src={bigImg} />\r\n    app\r\n  </div>\r\n);\r\nexport default App;\r\n```\r\n### 代码分割第三方包和公共模块\r\n- 一般第三方包的代码变化频率比较小，可以单独把node_modules中的代码单独打包，可以有效利用http缓存。\r\n- 公共的模块也可以提取出来，避免重复打包加大代码整体体积。\r\n- 修改webpack.prod.js配置\r\n```\r\nmodule.exports = {\r\n  // ...\r\n  optimization: {\r\n    // ...\r\n    splitChunks: { // 代码分割\r\n      cacheGroups: {\r\n        vendors: { // 提取node_modules代码\r\n          test: /node_modules/, // 只匹配node_modules里面的模块\r\n          name: 'vendors', // 提取文件命名为vendors，js后缀和chunkhash会自动加\r\n          minChunks: 1, // 只要使用一次就提取出来\r\n          chunks: 'initial', // 只提取初始化就能获取到的模块，不管异步的\r\n          minSize: 0, // 提取代码体积大于0就提取出来\r\n          priority: 1, // 提取优先级为1\r\n        },\r\n        commons: { // 提取页面公共代码\r\n          name: 'commons', // 提取文件命名为commons\r\n          minChunks: 2, // 只要使用两次就提取出来\r\n          chunks: 'initial', // 只提取初始化就能获取到的模块，不管异步的\r\n          minSize: 0, // 提取代码体积大于0就提取出来\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n### 压缩js文件\r\n- 设置mode为production后webpack会使用内置插件terser-webpack-plugin压缩js文件，该插件默认支持多线程压缩。\r\n- 但配置optimization.minimizer压缩css后js压缩就失效了，需要手动再添加一下。webpack内部安装了该插件，如果使用的pnpm需要手动再安装一下依赖。\r\n- 压缩css的插件可以设置在plugins中避免js压缩失效的问题。\r\n- 修改webpack.prod.js配置\r\n```\r\nconst { merge } = require('webpack-merge');\r\nconst TerserPlugin = require('terser-webpack-plugin');\r\nconst commonConfig = require('./webpack.common.js');\r\n\r\nmodule.exports = merge(commonConfig, {\r\n  mode: 'production', // 生产模式\r\n  // ...\r\n  optimization: {\r\n    // ...\r\n    minimizer: [\r\n      // ...\r\n      new TerserPlugin({ // 压缩js\r\n        parallel: true, // 开启多线程压缩\r\n        terserOptions: {\r\n          compress: {\r\n            pure_funcs: [\"console.log\"] // 删除console.log\r\n          }\r\n        }\r\n      }),\r\n    ],\r\n  },\r\n})\r\n```\r\n### 开启gzip压缩\r\n- 前端代码在浏览器运行需要从服务器把html、css、js资源下载执行，下载的资源体积越小页面加载速度就会越快。一般会采用gzip压缩，现在大部分浏览器和服务器都支持gzip，可以有效减少静态资源文件大小，压缩率在 70% 左右。\r\n- nginx可以配置gzip: on来开启压缩，但是只在nginx层面开启会在每次请求资源时都对资源进行压缩，压缩文件会需要时间和占用服务器cpu资源，更好的方式是前端在打包的时候直接生成gzip资源，服务器接收到请求直接把对应压缩好的gzip文件返回给浏览器节省时间和cpu。\r\n- 安装依赖\r\n```\r\nnpm i compression-webpack-plugin -D\r\n```\r\n- 修改webpack.prod.js配置\r\n```\r\nconst { merge } = require('webpack-merge');\r\nconst CompressionPlugin  = require('compression-webpack-plugin');\r\nconst commonConfig = require('./webpack.common.js');\r\n\r\nmodule.exports = merge(commonConfig, {\r\n  mode: 'production', // 生产模式\r\n  // ...\r\n  plugins: [\r\n    // ...\r\n    new CompressionPlugin({\r\n      test: /.(js|css)$/, // 只生成css,js压缩文件\r\n      algorithm: 'gzip', // 压缩格式，默认是gzip\r\n      threshold: 10240, // 只有大小大于该值的资源会被处理。默认值是10k\r\n      minRatio: 0.8 // 压缩率，默认值是0.8\r\n    })\r\n  ]\r\n})\r\n```\r\n### 复制public下内容到构建出口文件夹中\r\n- 安装依赖\r\n```\r\nnpm i copy-webpack-plugin -D\r\n```\r\n- 修改webpack.prod.js配置\r\n```\r\nconst path = require('path');\r\nconst { merge } = require('webpack-merge');\r\nconst CopyPlugin = require('copy-webpack-plugin');\r\nconst commonConfig = require('./webpack.common.js');\r\n\r\nmodule.exports = merge(commonConfig, {\r\n  mode: 'production', // 生产模式\r\n  plugins: [\r\n    // 复制文件插件\r\n    new CopyPlugin({\r\n      patterns: [\r\n        {\r\n          from: path.resolve(__dirname, '../public'), // 复制public下文件\r\n          to: path.resolve(__dirname, '../build'), // 复制到build目录中\r\n          filter: source => {\r\n            return !source.includes('index.html') // 忽略index.html，html-webpack-plugin已处理\r\n          }\r\n        },\r\n      ],\r\n    }),\r\n  ]\r\n})\r\n```\r\n### 添加打包分析配置\r\n- 安装依赖\r\n```\r\nnpm i speed-measure-webpack-plugin webpack-bundle-analyzer -D\r\n```\r\n- webpack配置\r\n```\r\n// webpack.analysis.js\r\nconst { merge } = require('webpack-merge');\r\nconst SpeedMeasurePlugin = require('speed-measure-webpack-plugin');\r\nconst { BundleAnalyzerPlugin } = require('webpack-bundle-analyzer');\r\nconst prodConfig = require('./webpack.prod.js');\r\nconst smp = new SpeedMeasurePlugin();\r\n\r\nmodule.exports = smp.wrap(merge(prodConfig, {\r\n  plugins: [\r\n    new BundleAnalyzerPlugin() // 配置分析打包结果插件\r\n  ]\r\n}))\r\n```\r\n- package.json添加scripts脚本\r\n```\r\n\"scripts\": {\r\n  // ...\r\n  \"analysis\": \"cross-env NODE_ENV=production BASE_ENV=development webpack --config config/webpack.analysis.js\",\r\n},\r\n```\r\n### babel处理js非标准语法(以装饰器为例)\r\n- 安装依赖\r\n```\r\nnpm i @babel/plugin-proposal-decorators -D\r\n```\r\n- 开启一下ts装饰器支持，修改tsconfig.json文件\r\n```\r\n{\r\n  \"compilerOptions\": {\r\n    // ...\r\n    // 开启装饰器使用\r\n    \"experimentalDecorators\": true\r\n  }\r\n}\r\n```\r\n- 在babel.config.js中添加插件\r\n```\r\nmodule.exports = { \r\n  // ...\r\n  \"plugins\": [\r\n    // ...\r\n    [\r\n      \"@babel/plugin-proposal-decorators\",\r\n      { \"legacy\": true }\r\n    ]\r\n  ]\r\n}\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## webpack的作用\r\n> webpack是一个用于现代JavaScript应用程序(支持ESM和CommonJS)的静态模块打包工具，可以支持许多不同的静态资源，例如：images, fonts和stylesheets。当 webpack处理应用程序时，它会在内部从一个或多个入口点构建一个依赖图(dependency graph)，然后将你项目中所需的每一个模块组合成一个或多个bundles，它们均为静态资源，用于展示你的内容。\r\n\r\n- Entry：编译入口，webpack编译的起点。\r\n- Compiler：编译管理器，webpack启动后会创建compiler对象，该对象一直存活直到结束退出。\r\n- Compilation：单次编辑过程的管理器，比如watch=true时，运行过程中只有一个compiler但每次文件变更触发重新编译时，都会创建一个新的 compilation对象。\r\n- Dependence：依赖对象，webpack基于该类型记录模块间依赖关系。\r\n- Module：webpack内部所有资源都会以“module”对象形式存在，所有关于资源的操作、转译、合并都是以“module”为基本单位进行的。\r\n- Chunk：编译完成准备输出时，webpack会将module按特定的规则组织成一个一个的chunk，这些chunk某种程度上跟最终输出一一对应。\r\n- Loader：资源内容转换器，其实就是实现从内容A转换B的转换器。\r\n- Plugin：webpack构建过程中，会在特定的时机广播对应的事件，插件监听这些事件，在特定时间点介入编译过程。\r\n### webpack配置大体框架\r\n```\r\nmodule.exports = {\r\n  // 模式\r\n  mode: 'development',\r\n\r\n  // 入口\r\n  entry: {},\r\n\r\n  // 打包输出\r\n  output: {},\r\n\r\n  // 配置模块如何解析\r\n  resolve: {},\r\n\r\n  // 配置各种loader\r\n  module: {},\r\n\r\n  // 配置插件\r\n  plugins: [],\r\n\r\n  // 优化（可以进行代码分割）\r\n  optimization: {},\r\n\r\n  // webpack-dev-server 开发时的配置，一般用于development模式\r\n  devServer: {}\r\n};\r\n```\r\n### mode\r\n> 告知webpack使用相应模式的内置优化。默认值为production。\r\n\r\n- development开发模式，打包更加快速，省了代码优化步骤。\r\n- production生产模式，打包比较慢，会开启tree-shaking和代码压缩。\r\n- none不使用任何默认优化选项。\r\n```\r\nmodule.exports = {\r\n  mode: 'development',\r\n};\r\n\r\n// 打包命令中传递参数\r\nwebpack --mode=development\r\n```\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## 构建体积优化\r\n### webpack包分析工具\r\n> 运行打包命令，打开的页面会显示各个模块资源的大小。\r\n\r\n- 安装依赖\r\n```\r\nnpm install webpack-bundle-analyzer -D\r\n```\r\n- 添加配置\r\n```\r\n// webpack.prod.js\r\nconst { BundleAnalyzerPlugin } = require('webpack-bundle-analyzer');\r\n\r\nplugins: [\r\n  new BundleAnalyzerPlugin({\r\n    analyzerMode: 'server',\r\n    analyzerHost: '127.0.0.1',\r\n    analyzerPort: 8888,\r\n    reportFilename: 'report.html',\r\n    defaultSizes: 'parsed',\r\n    openAnalyzer: true,\r\n    generateStatsFile: false,\r\n    statsFilename: 'stats.json',\r\n    logLevel: 'info'\r\n  })\r\n]\r\n```\r\n### 抽取css样式文件\r\n- 安装依赖\r\n```\r\nnpm install -D mini-css-extract-plugin\r\n```\r\n- 将module.rules中所有 style-loader 替换为该插件提供的loader：MiniCssExtractPlugin.loader。\r\n```\r\n// webpack.common.js\r\nconst MiniCssExtractPlugin = require(\"mini-css-extract-plugin\")\r\n\r\n// 定义通用的 postcss-loader 配置\r\nconst commonPostcssLoader = {\r\n  loader: 'postcss-loader',\r\n  options: {\r\n    postcssOptions: {\r\n      plugins: [\r\n        'postcss-preset-env'\r\n      ]\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = {\r\n  // ...\r\n  module: {\r\n    rules: [\r\n      // ...\r\n      {\r\n        test: /\\.css$/,\r\n        use: [MiniCssExtractPlugin.loader, 'css-loader', commonPostcssLoader]\r\n      },\r\n      {\r\n        test: /.(scss|sass)$/,\r\n        use: [\r\n          MiniCssExtractPlugin.loader,\r\n          'css-loader',\r\n          commonPostcssLoader,\r\n          'sass-loader'\r\n        ]\r\n      },\r\n    ]\r\n  },\r\n}\r\n```\r\n- 在 plugins 中添加该插件。\r\n> 开发环境和生产环境区分独立打包的文件名，防止开发环境修改样式文件热更新失败的问题。\r\n\r\n```\r\n// webpack.prod.js\r\nconst MiniCssExtractPlugin = require(\"mini-css-extract-plugin\")\r\n\r\nmodule.exports = {\r\n  mode: 'production',\r\n  plugins: [\r\n    // 将css独立打包\r\n    new MiniCssExtractPlugin({\r\n      filename: 'static/css/[name].[contenthash:8].css',\r\n    }),\r\n  ]\r\n}\r\n\r\n// webpack.dev.js\r\nconst MiniCssExtractPlugin = require(\"mini-css-extract-plugin\")\r\n\r\nmodule.exports = {\r\n  mode: 'development',\r\n  plugins: [\r\n    // 将css独立打包\r\n    new MiniCssExtractPlugin({\r\n      filename: 'static/css/[name].css',\r\n    }),\r\n  ]\r\n}\r\n```\r\n### 压缩css文件\r\n- 安装依赖\r\n```\r\nnpm install -D css-minimizer-webpack-plugin\r\n```\r\n- 添加配置\r\n```\r\n// webpack.prod.js\r\nconst CssMinimizerWebpackPlugin = require('css-minimizer-webpack-plugin')\r\n\r\n// 直接在plugins中使用插件\r\nmodule.exports = {\r\n  // ...\r\n  plugins: [\r\n    // ...\r\n    new CssMinimizerWebpackPlugin(), // 压缩css\r\n  ]\r\n}\r\n\r\n// 在optimization.minimizer中使用插件\r\nmodule.exports = {\r\n  // ...\r\n  optimization: {\r\n    minimizer: [\r\n      new CssMinimizerWebpackPlugin(), // 压缩css\r\n    ],\r\n  },\r\n}\r\n```\r\n### JS代码压缩\r\n> 设置mode为production时，webpack会使用内置插件terser-webpack-plugin压缩js文件，该插件默认支持多线程压缩，但是在optimization.minimizer中配置压缩css后，js压缩就失效了需要手动再添加一下。\r\n\r\n- 自定义TerserPlugin配置\r\n```\r\n// webpack.prod.js\r\nconst TerserPlugin = require('terser-webpack-plugin');\r\n\r\nmodule.exports = {\r\n  // ...\r\n  optimization: {\r\n    minimizer: [\r\n      new TerserPlugin({ // 压缩js\r\n        parallel: true, // 开启多线程压缩\r\n        terserOptions: {\r\n          compress: {\r\n            pure_funcs: [\"console.log\"] // 删除console.log\r\n          }\r\n        }\r\n      }),\r\n      new CssMinimizerPlugin(),\r\n    ],\r\n  },\r\n}\r\n```\r\n- 在webpack5中可以使用 `...` 语法来扩展现有的minimizer即terser-webpack-plugin。\r\n```\r\n// webpack.prod.js\r\nconst TerserPlugin = require('terser-webpack-plugin');\r\n\r\nmodule.exports = {\r\n  // ...\r\n  optimization: {\r\n    minimizer: [\r\n      `...`,\r\n      new CssMinimizerPlugin(),\r\n    ],\r\n  },\r\n}\r\n```\r\n### gzip压缩\r\n- 安装依赖\r\n```\r\nnpm i compression-webpack-plugin -D\r\n```\r\n- 添加配置\r\n```\r\n// webpack.prod.js\r\nconst CompressionPlugin = require('compression-webpack-plugin');\r\n\r\nnew CompressionPlugin({\r\n  test: new RegExp('\\\\.(js|css)$'),\r\n  algorithm: 'gzip',\r\n  threshold: 10240,\r\n  minRatio: 0.8\r\n}),\r\n```\r\n### 代码分割第三方包和公共模块\r\n> 一般第三方包的代码变化频率比较小，可以单独把node_modules中的代码单独打包，当第三包代码没变化时对应的文件名也不会变化，可以有效利用浏览器缓存，还有公共的模块也可以提取出来，避免重复打包加大代码整体体积。\r\n\r\n```\r\n// webpack.prod.js\r\nmodule.exports = {\r\n  // ...\r\n  optimization: {\r\n    // ...\r\n    splitChunks: { // 分隔代码\r\n      cacheGroups: {\r\n        vendors: { // 提取node_modules代码\r\n          test: /node_modules/, // 只匹配node_modules里面的模块\r\n          name: 'vendors', // 提取文件命名为vendors,js后缀和chunkhash会自动加\r\n          minChunks: 1, // 只要使用一次就提取出来\r\n          chunks: 'initial', // 只提取初始化就能获取到的模块,不管异步的\r\n          minSize: 0, // 提取代码体积大于0就提取出来\r\n          priority: 1, // 提取优先级为1\r\n        },\r\n        commons: { // 提取页面公共代码\r\n          name: 'commons', // 提取文件命名为commons\r\n          minChunks: 2, // 只要使用两次就提取出来\r\n          chunks: 'initial', // 只提取初始化就能获取到的模块,不管异步的\r\n          minSize: 0, // 提取代码体积大于0就提取出来\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n### 资源懒加载\r\n> 单页应用打包默认会打包到一个js文件中，虽然使用代码分割可以把node_modules模块和公共模块分离，但页面初始加载还是会把整个项目的代码下载下来，其实只需要公共资源和当前页面的资源就可以了，其他页面资源可以等使用到的时候再加载，以有效提升首屏加载速度。使用import语法来引入资源，webpack打包的时候就会自动打包为单独的资源文件，等使用到的时候动态加载。\r\n\r\n#### 动态引入模块\r\n- 例如导出excel只会在用户点击导出按钮的时候使用，我们首先在vendor中将其拆出来。\r\n- 使用时将 import 的逻辑由首屏改到运行时异步加载。\r\n```\r\nconst buttonClick = async() => {\r\n  // 使用时异步引入xlsx模块\r\n  const xlsx = await import('xlsx');\r\n  xlsx.writeFile(wb, filename)\r\n}\r\n```\r\n#### 路由懒加载Suspense + React.lazy\r\n```\r\nconst List = React.lazy(() => import('../list'));\r\nconst Operate = React.lazy(() => import('../operate'));\r\n\r\n<Suspense fallback={<div>loading...</div>}>\r\n  <Switch>\r\n    <Route path=\"/list\" component={List}>\r\n    <Route path=\"/operate\" component={Operate}>\r\n  </Switch>\r\n</Suspense>\r\n```\r\n### externals\r\n> 引用一个库但是又不想让webpack打包，可以通过配置Externals。将这些不需要打包的静态资源从构建逻辑中剔除出去，而使用CDN的方式去引用它们。\r\n\r\n#### 在html中配置的CDN引入脚本一定要在body内的最底部\r\n- 如果放在body上面或header内，则加载会阻塞整个页面渲染。\r\n- 如果放在body外，则会在业务代码被加载之后加载，模块中使用了该模块将会报错。\r\n```\r\n// webpack.common.js\r\nmodule.exports = {\r\n  // ...\r\n  externals: {\r\n    react: 'React'\r\n  }\r\n};\r\n\r\n// 使用\r\nimport React from 'react';\r\n```\r\n### tree-shaking清理未引用js\r\n> 模式mode为production时就会默认开启tree-shaking功能以此来标记未引入代码然后移除掉。\r\n\r\n### 合理配置hash\r\n> 改过的文件需要更新hash值，而没改过的文件依然保持原本的hash值，这样浏览器访问没有改变的文件会命中缓存，从而达到性能优化的目的。\r\n\r\n```\r\noutput: {\r\n  publicPath: '/',\r\n  path: path.resolve(__dirname, '../build'),\r\n  filename: 'static/js/[name].[contenthash:8].js',\r\n  // 每一次打包清除上一次打包内容\r\n  clean: true,\r\n},\r\n```\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## 构建时间优化\r\n### Speed Measure Plugin (SMP)\r\n> 对打包过程中消耗的时间进行精确的统计，能够测量出在你的构建过程中，每一个 Loader 和 Plugin 的执行时长，在启动本地服务的命令行中显示。\r\n\r\n```\r\n// 安装\r\nnpm install --save-dev speed-measure-webpack-plugin\r\n\r\n// 使用方式\r\nconst SpeedMeasurePlugin = require(\"speed-measure-webpack-plugin\");\r\nconst smp = new SpeedMeasurePlugin();\r\nconfig.plugins.push(smp());\r\n```\r\n### 构建速度慢的原因\r\n> 构建过程中的大部分时间都消耗在编译JavaScript文件及CSS文件的各类Loader上。Webpack的构建流程主要时间花费在递归遍历各个入口文件，并基于入口文件不断寻找依赖逐个编译再递归处理的过程，每次递归都需要经历 String -> AST -> String 的流程，然后通过不同的loader处理一些字符串或者执行一些JavaScript脚本，由于NodeJS单线程的特性以及语言本身的效率限制，所以webpack的构建会较慢。\r\n\r\n### 构建慢的优化方向\r\n- 缓存\r\n- 多进程\r\n- 寻址优化\r\n- 抽离拆分\r\n- 构建工具替换\r\n### cache-loader (缓存层面优化，缓存资源，提高二次构建的速度)\r\n> 打包时间的大部分都在npm install和各种loader的执行上，可以在loader之前加上cache-loader，这样这个loader执行过一次后的数据会缓存在node_modules/.cache目录下，下次再打包就会利用缓存。在一些性能开销较大的loader之前添加 cache-loader，只有执行时间很长的loader才适合用缓存，因为读写文件也是有开销的，滥用反而会导致变慢。\r\n- webpack4\r\n```\r\n{\r\n  test: /\\.js$/,\r\n  use: [\r\n    'cache-loader',\r\n    'thread-loader',\r\n    'babel-loader'\r\n  ],\r\n}\r\n```\r\n- webpack5\r\n```\r\ncache: {\r\n  type: 'filesystem'\r\n},\r\n```\r\n### hard-source-webpack-plugin (缓存层面优化)\r\n> HardSourceWebpackPlugin 为模块提供中间缓存，缓存默认存放的路径是 node_modules/.cache/hard-source，配置了 HardSourceWebpackPlugin 之后，首次构建时间并没有太大的变化，但是第二次开始，构建时间将会大大的加快。webpack5会把hard-source-webpack-plugin内置成一个配置。\r\n\r\n```\r\nconst HardSourceWebpackPlugin = require('hard-source-webpack-plugin');\r\nplugins: [\r\n  new HardSourceWebpackPlugin({\r\n    cachePrune: {\r\n      maxAge: 2 * 24 * 60 * 60 * 1000, // 设置缓存文件过期时间为2天\r\n      sizeThreshold: 500 * 1024 * 1024, // 总缓存文件大于500M时才会自动删除过时的缓存文件\r\n    },\r\n  }),\r\n]\r\n```\r\n### 设置 babel-loader 的 cacheDirectory 以及 DLL (缓存层面优化)\r\n> 效果不明显。\r\n\r\n### thread-loader (多进程层面优化)\r\n> 把 thread-loader 放置在其它 loader 之前(cache-loader除外)，那么放置在这个 loader 之后的 loader 就会在一个单独的 worker 池中运行。这样做的好处是把原本需要串行执行的任务并行执行。\r\n\r\n```\r\n{\r\n  test: /\\.js$/,\r\n  use: [\r\n    'thread-loader',\r\n    'babel-loader'\r\n  ],\r\n}\r\n```\r\n### 合理设置loader的exclude和include属性 (寻址层面优化)\r\n> 通过配置loader的exclude选项，告诉对应的loader可以忽略某个目录，通过配置loader的include选项，告诉loader只需要处理指定的目录，loader处理的文件越少，执行速度就会更快。\r\n\r\n```\r\n{\r\n  test: /\\.js$/,\r\n  // 使用include来指定编译文件夹\r\n  include: path.resolve(__dirname, '../src'),\r\n  // 使用exclude排除指定文件夹\r\n  exclude: /node_modules/,\r\n  use: [\r\n    'babel-loader'\r\n  ]\r\n},\r\n```\r\n### 开启热更新\r\n> 修改了项目中某一个文件，会导致整个项目刷新，这非常耗时间。如果只刷新修改的这个模块，其他保持原状，将大大提高修改代码的重新构建时间。\r\n\r\n```\r\n// 只用于开发中，所以配置在webpack.dev.js\r\n\r\nconst webpack = require('webpack');\r\nplugins: [\r\n  new webpack.HotModuleReplacementPlugin()\r\n],\r\n\r\n// 最后需要在我们的devserver中配置\r\ndevServer: {\r\n  hot: true\r\n},\r\n```\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## [CSRF](https://juejin.cn/post/6844903689702866952)\r\n- CSRF（Cross-site request forgery）跨站请求伪造，攻击者诱导受害者进入第三方网站，在第三方网站中向被攻击网站发送跨站请求。\r\n- 利用受害者在被攻击网站已经获取的登录凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。\r\n- 请求的哪个网站浏览器就会将需要请求的那个网站对应的Cookie添加到请求头，而不是在哪一个网站下发起的请求就将当前网站对应的Cookie添加到请求头。\r\n### 攻击流程\r\n1. 受害者登录a.com，并保留了登录凭证（Cookie）。\r\n2. 攻击者引诱受害者访问了b.com。\r\n3. b.com向a.com发送了一个请求：a.com/act=xx。浏览器会默认携带a.com的Cookie。\r\n4. a.com接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求。\r\n5. a.com以受害者的名义执行了act=xx。\r\n6. 攻击完成，攻击者在受害者不知情的情况下冒充受害者让a.com执行了自己定义的操作。\r\n### 攻击案例\r\n> 登录银行系统之后点进钓鱼网站，在钓鱼网站中点击按钮请求了银行系统转账的支付接口，因为在钓鱼网站中发起的支付请求携带了银行系统登录后的登录凭证（Cookie），所以能正常调用成功支付接口。\r\n\r\n1. 登录邮件系统后点击邮件中的钓鱼邮件，点击后跳转到一个空白页面。\r\n2. 空白页面中有隐藏逻辑，向邮件系统发送一个请求设置(默认会携带已经登录邮件系统的登录凭证（Cookie）)，将所有的邮件默认转发到攻击者设置的一个邮箱地址。\r\n3. 通过攻击者设置的邮箱地址获取到转发邮件的邮件信息进行信息窃取操作。\r\n### 攻击形式\r\n- GET类型的CSRF：通过img标签向被攻击网站发送包含受害者登录信息的跨域请求。\r\n- POST类型的CSRF：通过自动提交的表单向被攻击网站发送包含受害者登录信息的跨域请求。\r\n- 链接类型的CSRF：通过用户点击链接向被攻击网站发送包含受害者登录信息的跨域请求。\r\n### 攻击特点\r\n1. 攻击一般发起在第三方网站，而不是被攻击的网站。被攻击的网站无法防止攻击发生。\r\n2. 攻击利用受害者在被攻击网站的登录凭证（Cookie），冒充受害者提交操作，而不是直接窃取数据。\r\n3. 整个过程攻击者并不能获取到受害者的登录凭证，仅仅是“冒用”。\r\n4. 跨站请求可以用各种方式：图片URL、超链接、Form提交等等。部分请求方式可以直接嵌入在第三方论坛、文章中，难以进行追踪。\r\n### CSRF预防\r\n> CSRF的两个特点：通常发生在第三方域名，攻击者不能获取到Cookie等信息只是冒用。针对这两个特点制定对应的预防策略。\r\n\r\n- 阻止不明外域的访问\r\n  1. 同源检测\r\n  2. Samesite Cookie\r\n- 提交时要求附加本域才能获取的信息\r\n  1. CSRF Token\r\n  2. 双重Cookie验证\r\n#### 同源检测\r\n- 在HTTP协议中，每一个异步请求都会携带两个Header，用于标记来源域名：Origin Header，Referer Header。这两个Header在浏览器发起请求时大多数情况会自动带上，并且不能由前端自定义内容。服务器可以通过解析这两个Header中的域名，确定请求的来源域。\r\n- 使用Origin Header确定来源域名（不包含path及query），如果Origin存在那么直接使用Origin中的字段确认来源域名是否合法就可以。\r\n  1. IE11不会在跨站CORS请求上添加Origin标头，Referer头将仍然是唯一的标识。\r\n  2. 在302重定向之后Origin不包含在重定向的请求中，因为Origin可能会被认为是其他来源的敏感信息。对于302重定向的情况来说都是定向到新的服务器上的URL，因此浏览器不想将Origin泄漏到新的服务器上。\r\n- 使用Referer Header确定来源域名，如果Referer存在那么直接使用Referer中的字段确认来源域名是否合法就可以。\r\n  1. 在浏览器环境下Referrer是浏览器自己带上的，js无法修改Rerferrer，所以是不能被伪造和篡改。\r\n  2. 通过网关或者抓包可以修改Referrer，这是中间人攻击不属于CSRF攻击范畴，防中间人攻击用HTTPS。\r\n  3. 黑客通过自己后台代理，请求发到黑客自己的后台，黑客后台修改Referrer再转发到攻击网址的后台，这样可以修改Referrer，但请求发送到黑客自己后台不会带上被攻击网站的Cookie，登录态校验不通过，敏感操作做不了。\r\n- 如果Origin和Referer都不存在，建议直接进行阻止。\r\n#### Samesite Cookie\r\n> 设置Cookie是同站Cookie，不能作为第三方Cookie，不随着跨站请求发送，可以很大程度减少CSRF的攻击。\r\n\r\n- Strict：表明这个Cookie在任何情况下都不能作为第三方Cookie，浏览器完全禁止第三方请求携带此Cookie。\r\n```\r\nSet-Cookie: CookieName=CookieValue; SameSite=Strict;\r\n```\r\n- Lax(默认值)：当改变了当前页面或者打开了新页面且同时是个GET请求时，浏览器允许第三方请求携带此Cookie。\r\n```\r\nSet-Cookie: CookieName=CookieValue; SameSite=Lax;\r\n```\r\n- None：请求会自动携带上Cookie。前提是必须同时设置Secure属性（Cookie只能通过HTTPS协议发送），否则无效。\r\n```\r\nSet-Cookie: CookieName=CookieValue; SameSite=None; Secure\r\n```\r\n#### CSRF Token\r\n- 在本站发起的请求中，加一个攻击者无法获取的Token。\r\n- Token和浏览器自动携带的Cookie不一样，是需要前端手动带上的。在服务端收到请求时，如果没有Token，就可以认为是来自恶意网站。\r\n#### 双重Cookie验证\r\n- 在本站发起的请求中，加一个额外的字段其值和Cookie一致。\r\n- 攻击者没有办法获取到Cookie，只是发起请求时会自动携带。在服务端收到请求时，如果没有和Cookie值一样的额外字段，就可以认为是来自恶意网站。\r\n#### 当前用户打开其它网站链接时告知风险，由用户自己决定是否跳转。\r\n### XSS vs CSRF \r\n- XSS与CSRF最大区别在于对Cookie的使用，XSS把受害者的Cookie偷盗过来，而CSRF则是借用了受害者的Cookie。\r\n\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## React防御XSS\r\n- React防御XSS关键在于jsx的处理上。\r\n- React在它的领域范围内已经尽可能地帮我们防住了XSS攻击。\r\n  1. 使用安全的API修改DOM。\r\n  2. 禁止`<script>`执行。\r\n  3. 特殊字符转义。\r\n- React在客户端和服务端对XSS的防御方式不同。\r\n- 使用dangerouslySetInnerHTML和一些可执行代码的地方，需要提高警惕防止XSS攻击。\r\n### React客户端渲染防御XSS\r\n- jsx实际上是React.createElement的语法糖，React使用.textContent安全的API将props.children作为文本插入html，不会有XSS的问题。\r\n```\r\nconst App = () => {\r\n  const [text] = useState('<img src onerror=\"alert(1)\" />');\r\n\r\n  // 不会有XSS问题，img标签以文本形式展示\r\n  return (\r\n    <div>{text}</div>\r\n  );\r\n}\r\n```\r\n- 通过document.getElementById('input').value = xxx或者.setAttribute()安全的API设置元素属性，不会有XSS的问题。\r\n```\r\nconst App = () => {\r\n  const [text] = useState('\"><img src onerror=\"alert(1)\" />');\r\n\r\n  // 不会有XSS问题\r\n  return (\r\n    <input type=\"text\" value={text} />\r\n  );\r\n}\r\n```\r\n- jsx里加入`<script>`既不会执行，也不会显示。\r\n  1. React通过.innerHTML的方式插入`<script>`使得`<script>`不可执行。\r\n  2. 使用dangerouslySetInnerHTML属性插入`<script>`也不会执行，不会显示，因为dangerouslySetInnerHTML底层也是调用.innerHTML。\r\n```\r\nconst App = () => {\r\n  // 不会有XSS问题，也不会显示\r\n  return (\r\n    <div>\r\n      <script>alert(1)<\/script>\r\n    </div>\r\n  );\r\n}\r\n```\r\n### React服务端渲染防御XSS\r\n- 转义特殊字符：React对元素属性和内容中的5种特殊字符进行转义。\r\n### dangerouslySetInnerHTML\r\n- 在一些场景下我们需要直接往页面插入html代码，React提供dangerouslySetInnerHTML属性来实现这个功能，这有可能造成XSS攻击。\r\n```\r\nconst App = () => {\r\n  // 会有XSS问题\r\n  return (\r\n    <div dangerouslySetInnerHTML={{__html: '<img src onerror=\"alert(1)\" />'}} />\r\n  );\r\n}\r\n```\r\n### 字符串可以作为代码运行的地方\r\n- 不安全的字符串作为代码运行时有可能造成XSS攻击。\r\n```\r\nconst App = () => {\r\n  const [href] = useState('javascript:alert(1)');\r\n\r\n  // 会有XSS问题\r\n  return (\r\n    <a href={href}>跳转</a>\r\n  );\r\n}\r\n```\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## SQL注入\r\n- 通过SQL注入可以访问或修改数据库数据，或者利用潜在的数据库漏洞进行攻击。\r\n### SQL注入示例\r\n1. 登录页面服务端的SQL为`SELECT * FROM user WHERE username='${username}' AND password='${password}'`\r\n2. 如果有一个恶意攻击者输入的用户名为`admin' --`，密码随意输入，就可以直接登入系统了。\r\n3. 恶意攻击者用奇怪用户名将服务端的SQL语句变成了`SELECT * FROM user WHERE username='admin' --' AND password='xxxx'`\r\n4. 在SQL中`--`是注释后面的内容的意思，所以查询语句就变成了`SELECT * FROM user WHERE username='admin'`\r\n### SQL注入的必备条件\r\n1. 攻击者可以控制输入的数据。\r\n2. 服务器要执行的SQL语句拼接了攻击者输入的数据。\r\n### SQL注入的危害\r\n1. 获取数据库信息\r\n2. 获取服务器权限\r\n3. 读取服务器敏感文件\r\n### SQL注入的预防\r\n- 使用参数化查询或存储过程，这种方法会将输入值作为参数传递到查询中，而不是直接将其与SQL语句连接起来。这样可以有效地避免SQL注入漏洞。\r\n- 对特殊字符进行转义，在构造SQL语句时，需要确保任何包含特殊字符的输入都被正确转义。常见的特殊字符包括单引号、双引号、分号等。通过使用合适的转义函数或工具可以确保输入值得到正确处理。\r\n- 最小化数据库操作权限，只给予应用程序必要的数据库操作权限，避免使用超级管理员身份登录数据库。这样可以大大减少潜在的攻击面。\r\n"},function(r,n,e){"use strict";e.r(n),n.default='## [XSS](https://juejin.cn/post/6844903685122703367)\r\n- Cross-Site Scripting（跨站脚本攻击）简称XSS，是一种代码注入攻击。\r\n- 攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。利用这些恶意脚本，攻击者可获取用户的敏感信息如Cookie等，进而危害数据安全。\r\n- XSS的本质是恶意代码未经过滤与网站正常的代码混在一起，浏览器无法分辨哪些脚本是可信的，导致恶意脚本被执行。\r\n### XSS的危害\r\n1. 窃取Cookie。\r\n2. 监听用户行为，比如输入账号密码后直接发送到黑客服务器。\r\n3. 修改DOM伪造登录表单。\r\n4. 在页面中生成浮窗广告。\r\n### 注入恶意脚本的方法\r\n- 来自用户的UGC信息\r\n- URL参数\r\n- POST参数\r\n### 存储型XSS\r\n- 常见于带有用户保存数据功能的网站，如论坛发帖、商品评论、用户私信等。\r\n#### 攻击流程\r\n1. 攻击者通过前端页面将恶意代码提交到目标网站的数据库中。\r\n2. 用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在HTML中返回给浏览器。\r\n3. 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。\r\n4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。\r\n### 反射型XSS\r\n- 存储型XSS的恶意代码存在数据库里，反射型XSS的恶意代码存在URL里。\r\n- 反射型XSS漏洞常见于通过URL传递参数的功能，如网站搜索、跳转等。\r\n- 一般是通过给别人发送带有恶意代码参数的URL，当URL地址被打开时，特有的恶意代码参数被解析、执行。\r\n#### 攻击流程\r\n1. 攻击者构造出特殊的URL，其中包含恶意代码。\r\n2. 用户打开带有恶意代码的URL时，网站服务端将恶意代码从URL中取出，拼接在HTML中返回给浏览器。\r\n3. 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。\r\n4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。\r\n### DOM型XSS\r\n- DOM型XSS攻击中取出和执行恶意代码都由浏览器端完成，属于前端自身的安全漏洞，而其它两种XSS都属于服务端的安全漏洞。\r\n#### 攻击流程\r\n1. 攻击者构造出特殊的URL，其中包含恶意代码。\r\n2. 用户打开带有恶意代码的URL。\r\n3. 用户浏览器接收到响应后解析执行，前端JavaScript取出URL中的恶意代码并执行。\r\n4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。\r\n### XSS攻击的两大要素\r\n1. 攻击者提交恶意代码。\r\n2. 浏览器执行恶意代码。\r\n### XSS的预防\r\n#### 输入侧过滤\r\n- 用户提交时由前端过滤输入然后提交到后端的过滤方式是不可行的，攻击者绕过前端过滤直接构造请求，就可以提交恶意代码了。\r\n- 后端在写入数据库前对输入内容进行过滤然后存储，返回给前端的内容是过滤后的内容是不可行的，因为可能会出现特殊符号转义存储之后前端显示乱码的问题。\r\n- 输入侧过滤能够在某些情况下解决特定的XSS问题，但会引入很多不确定性和乱码问题。在防范XSS攻击时应避免此类方法。\r\n#### 防止浏览器执行恶意代码\r\n- 防止HTML中出现注入。\r\n- 防止JavaScript执行恶意代码。\r\n#### 预防存储型和反射型XSS攻击\r\n> 存储型和反射型XSS都是在服务端取出恶意代码后，插入到响应的HTML里的，攻击者编写的恶意代码被内嵌到HTML中，被浏览器所执行。预防这两种漏洞常见做法如下。\r\n\r\n- 改成纯前端渲染（CSR），把代码和数据分隔开。\r\n- 对HTML做充分转义（使用完善的转义库）。\r\n#### 预防DOM型XSS攻击\r\n> DOM型XSS攻击，实际上是网站前端JavaScript代码本身不够严谨，把攻击者注入的恶意代码执行了。\r\n\r\n- 在使用innerHTML、outerHTML、document.write()时要特别小心，不要把不可信的数据作为HTML插到页面上，应使用textContent、.setAttribute()等安全的API修改DOM。\r\n- 如果用Vue/React技术栈，不使用v-html/dangerouslySetInnerHTML功能，在前端render阶段避免innerHTML、outerHTML的XSS隐患。\r\n- DOM中的内联事件监听器，如location、onclick、onerror、onload、onmouseover等，`<a>`标签的href属性，JavaScript的eval()、setTimeout()、setInterval()等都能把字符串作为代码运行。如果不可信的数据拼接到字符串中传递给这些API，很容易产生安全隐患，应避免此类操作。\r\n#### HttpOnly Cookie\r\n- 禁止JavaScript读取某些敏感Cookie，攻击者完成XSS注入后也无法窃取此Cookie。\r\n\r\n```\r\ndocument.cookie = "cookieName=cookieValue; path=/; HttpOnly";\r\n```\r\n#### 输入内容长度控制\r\n- 对于不受信任的输入，都应该限定一个合理的长度。虽然无法完全防止XSS发生，但可以增加XSS攻击的难度。\r\n#### 验证码\r\n- 防止脚本冒充用户提交危险操作。\r\n#### Content Security Policy\r\n> 严格的CSP在XSS的防范中可以起到以下作用。\r\n\r\n- 禁止加载外域代码，防止复杂的攻击逻辑。\r\n- 禁止外域提交，网站被攻击后，用户的数据不会泄露到外域。\r\n- 禁止内联脚本执行。\r\n- 禁止未授权的脚本执行。\r\n- 合理使用上报可以及时发现XSS，利于尽快修复问题。'},function(r,n,e){"use strict";e.r(n),n.default="## 减少if-else的使用\r\n- 短路运算\r\n> 使用或 || 的短路运算代替一些比较简单的 if else。\r\n\r\n```\r\n// 原：\r\nlet c;\r\nif (a) {\r\n  c = a;\r\n} else {\r\n  c = b;\r\n}\r\n\r\n// 后：\r\nlet c = a || b;\r\n```\r\n- 三元运算符\r\n> 使用三元运算符替代 if else。\r\n\r\n```\r\n// 原：\r\nconst fn = (nBoolean) {\r\n  if (nBoolean) {\r\n    return 1;\r\n  } else {\r\n    return 0;\r\n  }\r\n}\r\n\r\n// 后：\r\nconst fn = (nBoolean) {\r\n  return nBoolean ? 1 : 0;\r\n}\r\n```\r\n- switch case\r\n> 对于多重条件判断使用 switch case 的可读性比 if else 更好。\r\n\r\n```\r\n// 原：\r\nlet type = 'A';\r\n\r\nif (type === 'A' || type === 'B') {\r\n  console.log(1);\r\n} else if (type === 'C') {\r\n  console.log(2);\r\n} else if(type === 'D') {\r\n  console.log(3);\r\n} else {\r\n  console.log(0);\r\n}\r\n\r\n// 后：\r\nswitch (type) {\r\n  case 'A':\r\n  case 'B':\r\n    console.log(1);\r\n    break;\r\n  case 'C':\r\n    console.log(2);\r\n    break;\r\n  case 'D':\r\n    console.log(3);\r\n    break;\r\n  default:\r\n    console.log(0);\r\n}\r\n```\r\n- 对象配置/策略模式\r\n> 对象配置看起来跟 策略模式 差不多，都是根据不同得参数使用不同得数据/算法/函数。策略模式就是将一系列算法封装起来，并使它们相互之间可以替换。被封装起来的算法具有独立性，外部不可改变其特性。对象配置不一定非要使用对象去管理我们键值对，还可以使用 Map去管理。\r\n\r\n```\r\n// 原：\r\nconst getDiscount = (userKey) => {\r\n  if (userKey === '普通会员') {\r\n    return 0.9;\r\n  } else if (userKey === '年费会员') {\r\n    return 0.85;\r\n  } else if (userKey === '超级会员') {\r\n    return 0.8;\r\n  } else {\r\n    return 1;\r\n  }\r\n}\r\nconsole.log(getDiscount('普通会员')) // 0.9\r\n\r\n// 后：\r\nconst getDiscount = (userKey) => {\r\n  // 根据用户类型来生成我们的折扣对象\r\n  let discounts = {\r\n    '普通会员': 0.9,\r\n    '年费会员': 0.85,\r\n    '超级会员': 0.8,\r\n    'default': 1,\r\n  }\r\n  return discounts[userKey] || discounts['default'];\r\n}\r\nconsole.log(getDiscount('普通会员')) // 0.9\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## BFF\r\n> Backends For Frontends，服务于前端的后端。BFF就是一层nodejs实现的中间层，能做请求转发、接口聚合、数据转化。\r\n\r\n### BFF的优势\r\n- 服务端对数据展示服务进行解耦，展示服务由独立的BFF端提供，服务端可以聚焦于业务处理。\r\n- 多端展示或者多业务展示时，对于数据获取有更好的灵活性，避免数据冗余造成消耗服务端资源。\r\n- 对于复杂的前端展示，将数据获取和组装的负责逻辑在BFF端执行，降低前端处理的复杂度，提高前端页面响应效率。"},function(r,n,e){"use strict";e.r(n),n.default='## ESlint + Prettier + husky + lint-staged规范前端项目\r\n### ESlint代码检查工具\r\n> JavaScript代码的检查工具，ESlint能够查找并修复JavaScript代码中的问题。\r\n\r\n#### 安装依赖 npm i eslint -D\r\n#### 常用命令\r\n- npx eslint src          检查src目录下的代码问题\r\n- npx eslint src --quiet  只检查src目录下的代码的error问题\r\n- npx eslint --fix src    自动修复src目录下可潜在修复的错误\r\n#### ESlint配置文件\r\n- 执行命令初始化ESlint配置(根据提示进行选择) npm init @eslint/config。\r\n  1. 选择 To check syntax and find problems (检查语法和查找错误)\r\n  2. 选择ES Module的模块规范\r\n  3. 选择react框架\r\n  4. 选择使用TypeScript\r\n  5. 选择browser运行环境\r\n  6. 选择使用js文件作为配置文件\r\n  7. 根据选择安装推荐的相关依赖 eslint-plugin-react、 @typescript-eslint/eslint-plugin、 @typescript-eslint/parser\r\n  8. 生成.eslintrc.js配置文件\r\n- .eslintrc.js配置文件中的extends和rules字段定义了在项目中采用哪些规则。\r\n- .eslintrc.js使用ignorePatterns在一些目录下禁用eslint规则。\r\n```\r\n// ESlint规则禁用config文件夹\r\nignorePatterns: ["config/"]\r\n```\r\n#### 配合编辑器使用ESlint\r\n- 在VSCode中使用ESlint需要安装ESlint插件。启用插件后可以在编辑代码的同时看到哪些代码有问题，及时发现及时修复。\r\n- 启用编辑器的保存自动修复功能，不用执行额外的ESlint命令。\r\n> 左下角管理图标 => 设置 => 文本编辑器 => 在settings.json中编辑。\r\n\r\n```\r\n// VSCode settings.json\r\n{\r\n  // ...\r\n  "editor.codeActionsOnSave": {\r\n    "source.fixAll.eslint": true\r\n  }\r\n}\r\n```\r\n### Prettier代码格式化工具\r\n\r\n#### 安装依赖 npm i prettier eslint-config-prettier eslint-plugin-prettier -D\r\n#### 常用命令\r\n- npx prettier --write src  格式化src目录下的代码文件\r\n#### 解决ESlint和Prettier的冲突。\r\n> 同时使用二者需要关闭ESlint中可能和Prettier冲突的规则。.eslintrc.js文件中的extend中添加"prettier"解决ESlint和Prettier的冲突。\r\n\r\n```\r\n// .eslintrc.js\r\nmodule.exports = {\r\n  // ...\r\n  "extends": [\r\n    // ...\r\n    "prettier"\r\n  ],\r\n}\r\n```\r\n#### 创建.prettierrc文件，并配置自己的规则。\r\n```\r\n{\r\n  "endOfLine": "auto",\r\n  "printWidth": 80, \r\n  "semi": true,\r\n  "trailingComma": "none",\r\n  "singleQuote": true,\r\n  "arrowParens": "avoid"\r\n}\r\n```\r\n### Prettier vs ESLint\r\n> 都会对代码AST（语法树）进行检查，但Prettier只会进行语法分析，只能检查并归正代码的格式问题，而ESLint还会进一步对代码进行语义分析，能发现格式问题和代码模式问题。ESLint只能检查JavaScript代码以及TypeScript、JSX等衍生代码（需配置解析器），无法检查项目中的CSS、HTML等代码。Prettier则天然支持对大多数项目文件的格式化。\r\n\r\n### husky + lint-staged代码提交前检查、格式化代码\r\n#### husky\r\n> 操作git钩子的工具。\r\n\r\n- 安装依赖 npm i husky -D\r\n- 在packgae.json中添加prepare脚本。\r\n> prepare脚本会在npm install之后自动执行。当执行npm install安装完项目依赖后会执行husky install命令，该命令会创建.husky/目录并指定该目录为git hooks所在的目录。\r\n\r\n```\r\n// package.json\r\n{\r\n  // ...\r\n  "scripts": {\r\n    // ...\r\n    "prepare": "husky install"\r\n  }\r\n}\r\n```\r\n- 执行命令npm run prepare\r\n#### lint-staged\r\n> 本地暂存代码检查工具，每一次提交只检查本次提交所修改(指git暂存区里的东西)的内容，而不是每次检查是整个项目的内容。\r\n\r\n- 安装依赖 npm install lint-staged -D\r\n- package.json添加lint-staged的命令\r\n> src/**/*.{js,jsx,ts,tsx} 只对src目录下的js,jsx,ts,tsx文件进行格式化，对应的三条命令会先后分别执行，eslint --fix之后使用Prettier格式化代码，然后git add，最后执行我们的git commit。\r\n\r\n```\r\n"lint-staged": {\r\n  "src/**/*.{js,jsx,ts,tsx}": [\r\n    "eslint --fix",\r\n    "prettier --write",\r\n    "git add"\r\n  ]\r\n},\r\n```\r\n- 设置git的pre-commit钩子执行npx lint-staged命令\r\n```\r\nnpx husky add .husky/pre-commit "npx lint-staged"\r\n```\r\n### 测试commit效果\r\n- 提交时Prettier会格式化代码。\r\n![格式化前](./img/prettierBefore.png)\r\n![格式化后](./img/prettierAfter.png)\r\n- 存在eslint的error信息时commit失败。\r\n> eslint存在error信息时才会阻止提交(warning信息不会阻止提交)，如果阻止了commit提交或者代码格式化后没有任何修改，eslint --fix以及Prettier格式化不会生效。\r\n\r\n![commit失败前](./img/commitBefore.png)\r\n![commit失败结果](./img/commitAfter.png)\r\n\r\n'},function(r,n,e){"use strict";e.r(n),n.default='## [browserslist](https://browsersl.ist/)\r\n> browserslist帮助我们在浏览器兼容性和包大小之间保持适当的平衡。使用browserslist可以做到覆盖更广泛的浏览器同时包的体积也会保持最小化。\r\n\r\n### 配置方式\r\n- 可以在package.json中声明browserslist字段进行配置\r\n```\r\n"browserslist": [\r\n  "> 0.2%",\r\n  "last 10 versions",\r\n]\r\n```\r\n- 通过.browserslistrc文件配置\r\n```\r\n> 0.2%\r\nlast 10 versions\r\n```\r\n### 如何配置\r\n> 可以通过[https://browsersl.ist/](https://browsersl.ist/)网站来查看配置的内容具体支持的浏览器情况。\r\n\r\n- defaults(默认配置)，> 0.5%, last 2 versions, Firefox ESR, not dead。\r\n- 根据全球或某个国家/地区的使用率进行配置\r\n    - `> 0.2%` (全世界使用率大于0.2%)\r\n    - `> 0.2% in CN` (中国使用率大于0.2%)\r\n- 根据最近的浏览器版本进行配置\r\n    - last 10 versions (所有浏览器最新的10个版本)\r\n    - last 10 Chrome versions (Chrome浏览器最新2个版本)\r\n- dead (官方不再支持或24个月没有更新的浏览器)\r\n- 根据特定浏览器版本进行配置\r\n    - iOS 7 (支持iOS版本7的浏览器)\r\n    - Firefox > 20 (支持Firefox版本大于20的浏览器)\r\n    - ie 6-8 (支持ie版本6-8的浏览器)\r\n- 选择支持特定功能的浏览器版本\r\n    - supports es6-module (支持es6-module的浏览器)\r\n    - supports css-grid (支持css-grid的浏览器)\r\n- not (可以给任何配置使用，表示反义)\r\n- 以上条件可以组合\r\n    - `> 0.2%, last 10 versions` (使用率大于0.2%或者所有浏览器最新10个版本，等价于 > 0.2% or last 10 versions)\r\n    - `> 0.2% and last 10 versions` (使用率大于0.2%浏览器且是最新的10个版本)\r\n    - `> 0.2%, last 10 versions, not dead` (使用率大于0.2%或者所有浏览器最新10个版本且没有dead的浏览器)\r\n\r\n### 检查配置是否正确\r\n> 运行`npx browserslist-lint`命令查看配置是否有错误。\r\n\r\n### 查看配置支持的浏览器\r\n> 运行`npx browserslist`命令查看配置支持的浏览器。\r\n'},function(r,n,e){"use strict";e.r(n),n.default='## cdn\r\n- CDN的全称是(Content Delivery Network)，即内容分发网络。\r\n- 其目的是通过在现有的Internet中增加一层新的CACHE(缓存)层，将网站的内容发布到最接近用户的网络"边缘"节点，使用户可以就近取得所需的内容，提高用户访问网站的响应速度。\r\n- CDN的工作原理就是将源站的资源缓存到位于全球各地的CDN节点上，用户请求资源时，就近返回节点上缓存的资源，而不需要每个用户的请求都去源站获取，避免网络拥塞、缓解源站压力，保证用户访问资源的速度和体验。'},function(r,n,e){"use strict";e.r(n),n.default="## dayjs代替moment\r\n### moment\r\n- 可变对象\r\n> moment对象是可变对象（mutable），任何时间上的加减等计算都改变了其本身。这种设计让代码变得十分不可控，而且很容易带来各种隐蔽且难以调试的 bug。以至于我们在每步修改之前，都要先调用.clone克隆一次才能放心操作。\r\n\r\n- 包体积过大\r\n> 因为Momnet.js将全部的功能和所有支持的语言都打到一个包里，包的大小为280.9KB，而且对于Tree shaking无效。如果要使用时区相关的功能，包的大小为467.6 KB。有时可能只需要一个format格式化时间的方法就需要加载数百KB的库，是非常不划算的。\r\n\r\n### dayjs\r\n- 和moment相同的API\r\n> moment.js相同的API、相同的链式操作。\r\n\r\n- 不可变\r\n> 可变性是使用moment时最大的问题之一。在dayjs完全消除了这个问题，它支持不变性。\r\n\r\n- 体积小\r\n> dayjs包的大小只有2KB大小。"},function(r,n,e){"use strict";e.r(n),n.default='## monorepo\r\n### lerna + yarn的workspaces\r\n- lerna初始化\r\n```\r\n// npm install lerna -g\r\nlerna init\r\n\r\nmonorepo\r\n├── packages\r\n├── lerna.json\r\n├── package.json\r\n```\r\n- 修改lerna.json\r\n```\r\n{\r\n  "$schema": "node_modules/lerna/schemas/lerna-schema.json",\r\n  "useWorkspaces": true,\r\n  "npmClient": "yarn",\r\n  "version": "0.0.0"\r\n}\r\n```\r\n- 修改package.json\r\n```\r\n{\r\n  "name": "root",\r\n  "private": true,\r\n  "workspaces": [\r\n    "packages/*"\r\n  ],\r\n  "devDependencies": {\r\n    "lerna": "^6.4.1"\r\n  }\r\n}\r\n```\r\n- packages目录下新建子项目utils、pc\r\n```\r\nmonorepo\r\n├── packages\r\n    ├── pc\r\n    ├── utils\r\n├── lerna.json\r\n├── package.json\r\n```\r\n- pc项目依赖utils项目，在pc项目的package.json的dependencies下手动添加一行依赖。名称和版本来自utils项目的package.json的数据。\r\n```\r\n"utils": "1.0.0"\r\n```\r\n- 使用TypeScript时如果某一个包依赖于另一个包，必须明确让TypeScript知道这种依赖关系。例如pc项目依赖utils项目，需要在pc项目的tsconfig文件中添加references配置。\r\n```\r\n{\r\n  "references": [{ "path": "../utils/tsconfig.json" }],\r\n  "compilerOptions": {\r\n    "target": "es5",\r\n    "lib": [\r\n      "dom",\r\n      "dom.iterable",\r\n      "esnext"\r\n    ],\r\n    "paths": {\r\n      "@/*": ["src/*"],\r\n    },\r\n    "allowJs": true,\r\n    "skipLibCheck": true,\r\n    "esModuleInterop": true,\r\n    "allowSyntheticDefaultImports": true,\r\n    "strict": true,\r\n    "forceConsistentCasingInFileNames": true,\r\n    "noFallthroughCasesInSwitch": true,\r\n    "module": "esnext",\r\n    "moduleResolution": "node",\r\n    "resolveJsonModule": true,\r\n    "isolatedModules": true,\r\n    "noEmit": true,\r\n    "jsx": "react-jsx"\r\n  },\r\n  "include": [\r\n    "src",\r\n    "global.d.ts"\r\n  ]\r\n}\r\n```\r\n- pc项目安装依赖，启动项目。pc项目之所以可以引用utils项目内容依赖于yarn的workspaces功能会自动管理/package.json里workspaces字段指定包下的所有依赖。\r\n```\r\nyarn\r\nyarn start\r\n```\r\n'},function(r,n,e){"use strict";e.r(n),n.default="## 前端主题切换方案\r\n### link标签动态引入\r\n> 提前准备好几套CSS主题样式文件，在需要的时候，创建link标签动态加载到head标签中，或者是动态改变link标签的href属性。\r\n\r\n#### 优点\r\n- 实现了按需加载，提高了首屏加载时的性能。\r\n#### 缺点\r\n- 动态加载样式文件，如果文件过大网络情况不佳的情况下可能会有加载延迟，导致样式切换不流畅。\r\n- 如果主题样式表内定义不当，会有优先级问题。\r\n- 各个主题样式是写死的，后续针对某一主题样式表修改或者新增主题也很麻烦。\r\n### 提前引入所有主题样式，做类名切换\r\n> 这种方案与第一种比较类似，为了解决反复加载样式文件问题提前将样式全部引入，在需要切换主题的时候将指定的根元素类名更换，相当于直接做了样式覆盖，在该类名下的各个样式就统一地更换了。\r\n\r\n```\r\n/* day样式主题 */\r\nbody.day .box {\r\n  color: #f90;\r\n  background: #fff;\r\n}\r\n/* dark样式主题 */\r\nbody.dark .box {\r\n  color: #eee;\r\n  background: #333;\r\n}\r\n\r\n.box {\r\n  width: 100px;\r\n  height: 100px;\r\n  border: 1px solid #000;\r\n}\r\n\r\n<div>\r\n  <div class=\"box\">\r\n    <p>hello</p>\r\n  </div>\r\n  <p>\r\n    <button onclick=\"change('day')\">day</button>\r\n    <button onclick=\"change('dark')\">dark</button>\r\n  </p>\r\n</div>\r\n\r\n// 修改主题\r\nfunction change(theme) {\r\n  document.body.className = theme;\r\n}\r\n```\r\n#### 优点\r\n- 不用重新加载样式文件，在样式切换时不会有卡顿。\r\n#### 缺点\r\n- 首屏加载时会牺牲一些时间加载样式资源。\r\n- 如果主题样式表内定义不当，也会有优先级问题。\r\n- 各个主题样式是写死的，后续针对某一主题样式表修改或者新增主题也很麻烦。\r\n### CSS变量+类名切换\r\n> 跟方案2相似，依然是提前将样式文件载入，切换时将指定的根元素类名更换。不过这里相对灵活的是默认在根作用域下定义好CSS变量，只需要在不同的主题下更改CSS变量对应的取值即可。\r\n\r\n```\r\n/* 定义根作用域下的变量 */\r\n:root {\r\n  --theme-color: #333;\r\n  --theme-background: #eee;\r\n}\r\n/* 更改dark类名下变量的取值 */\r\n.dark{\r\n  --theme-color: #eee;\r\n  --theme-background: #333;\r\n}\r\n/* 更改pink类名下变量的取值 */\r\n.pink{\r\n  --theme-color: #fff;\r\n  --theme-background: pink;\r\n}\r\n\r\n.box {\r\n  transition: all .2s;\r\n  width: 100px;\r\n  height: 100px;\r\n  border: 1px solid #000;\r\n  /* 使用变量 */\r\n  color: var(--theme-color);\r\n  background: var(--theme-background);\r\n}\r\n```\r\n#### 优点\r\n- 不用重新加载样式文件，在样式切换时不会有卡顿。\r\n- 在需要切换主题的地方利用var()绑定变量即可，不存在优先级问题。\r\n- 新增或修改主题方便灵活，仅需新增或修改CSS变量即可，在var()绑定样式变量的地方就会自动更换。\r\n#### 缺点\r\n- IE兼容性（忽略不计）。\r\n- 首屏加载时会牺牲一些时间加载样式资源。\r\n### CSS变量+动态setProperty\r\n> 这个方案适用于由用户根据颜色面板自行设定各种颜色主题，这种是主题颜色不确定的情况，而前几种方案更适用于定义预设的几种主题。\r\n\r\n#### 实现思路\r\n- 只需在全局中设置好预设的全局CSS变量样式，无需单独为每一个主题类名下重新设定CSS变量值，因为主题是由用户动态决定。\r\n```\r\n:root {\r\n  --theme-color: #333;\r\n  --theme-background: #eee;\r\n}\r\n```\r\n- 定义一个工具类方法，用于修改指定的CSS变量值，调用的是CSSStyleDeclaration.setProperty。\r\n```\r\nexport const setCssVar = (prop: string, val: any, dom = document.documentElement) => {\r\n  dom.style.setProperty(prop, val)\r\n}\r\n```\r\n- 在样式发生改变时调用此方法即可。\r\n```\r\nsetCssVar('--theme-color', color)\r\n```\r\n#### 优点\r\n- 不用重新加载样式文件，在样式切换时不会有卡顿。\r\n- 需要切换主题的地方只用在:root上动态更改CSS变量值即可，不存在优先级问题。\r\n- 新增或修改主题方便灵活。\r\n#### 缺点\r\n- IE兼容性（忽略不计）。\r\n- 首屏加载时会牺牲一些时间加载样式资源（相对于前几种预设好的主题，这种方式的样式定义在首屏加载多使用的时间基本可以忽略不计）。"},function(r,n,e){"use strict";e.r(n),n.default="## 前端工程化\r\n> 利用工具链解决前端在开发过程中提升效率和质量的问题。"},function(r,n,e){"use strict";e.r(n),n.default="## 前端规范\r\n### 开发流程规范\r\n- 保障开发质量和开发效率。\r\n- 及时发现问题和规避问题。\r\n### 代码规范\r\n- 代码格式化规范Eslint + Prettier + husky + lint-staged。\r\n- 设置css变量样式文件统一使用css变量，项目样式统一且方便样式整体替换。\r\n- 使用枚举维护localStorage的key，防止多人协作过程中使用重复的key。\r\n- 变量命名语义化。\r\n- 使用错误边界对错误组件进行降级处理。\r\n- 适当添加注释。\r\n### 项目文件结构规范\r\n- 按照团队约定组织项目目录结构，方便其它同事查找对应功能代码。\r\n### UI设计规范\r\n- 选用合适的UI组件库。\r\n- UI色值和边距等内容项目保持统一。\r\n### git commit规范\r\n- 通过git提交信息可以了解到提交的大致内容，可以参考Angular团队的commit规范。\r\n- 一次提交尽可能涉及的改动内容相对独立。"},function(r,n,e){"use strict";e.r(n),n.default="## try-catch\r\n- try-catch中不要写入太多的代码(声明太多的变量)，最好是把要执行的代码放在另一个function中，在try-catch中调用这个function。\r\n- 在代码进入try-catch的时候js引擎会拷贝当前的词法环境，拷贝的其实就是当前scope下的所有的变量，会有较大的性能消耗。\r\n- catch语句不要忽略，避免空的catch块。\r\n- try-catch捕获异常并可以使后续代码正常运行，try代码块的内容在出错之后不会再继续执行，但是不影响try-catch代码块之后的代码执行。\r\n```\r\ntry {\r\n  console.log(1) // 1\r\n  console.log(a)\r\n  console.log(2)\r\n} catch (error) {\r\n  console.log(error) // ReferenceError: a is not defined\r\n}\r\nconsole.log(3) // 3\r\n```\r\n- finally在try-catch语句中是可选的，finally一经使用其代码无论如何都会执行。finally会阻止return语句的终止。\r\n```\r\nconst a = () => {\r\n  try {\r\n    return 'try';\r\n  } catch (e) {\r\n    return 'catch';\r\n  } finally {\r\n    return 'finally';\r\n  }\r\n}\r\nconsole.log(a()) // finally\r\n```\r\n- try-catch嵌套使用，内层try-catch捕获错误之后就不会被外层try-catch捕获错误且不影响外层try代码块的继续执行。\r\n```\r\nconst a = () => {\r\n  try {\r\n    console.log(dyx);\r\n  } catch (error) {\r\n    console.log('inner catch'); // inner catch\r\n  }\r\n}\r\ntry {\r\n  a();\r\n  console.log('outer try');  // outer try\r\n} catch (error) {\r\n  console.log('outer error');\r\n}\r\n```"},function(r,n,e){"use strict";e.r(n),n.default='## 前端异常\r\n### Error对象\r\n- 可以通过构造函数来创建一个新的通用错误\r\n```\r\nconst err = new Error("Error");\r\nconst err = Error("Error");\r\nthrow err; // Uncaught Error: Error\r\n```\r\n- Error对象有三个属性。\r\n  1. message：带有错误消息的字符串。\r\n  2. name: 错误的类型。\r\n  3. stack：函数执行的堆栈跟踪。\r\n- 创建一个TypeError对象，该消息将携带实际的错误字符串，其name将是"TypeError"。\r\n```\r\nconst wrongError = TypeError("Expected number");\r\nconsole.log(wrongError.message); // Expected number\r\nconsole.log(wrongError.name);    // TypeError\r\n```\r\n### 使用instanceof区分异常类型\r\n```\r\ntry {\r\n  // ...\r\n} catch (err) {\r\n  if (err instanceof TypeError) {\r\n    // 处理 TypeError 错误\r\n  } else if (err instanceof RangeError) {\r\n    // 处理 RangeError 错误\r\n  } else {\r\n    // 处理其他类型错误\r\n  }\r\n}\r\n```\r\n### SyntaxError 语法异常\r\n- 在引擎执行代码之前，编译器需要对js进行编译，编译阶段包括：词法分析，语法分析。\r\n- 编译阶段发生的异常都是SyntaxError。\r\n- 绝大部分SyntaxError都可以通过配置编辑器的校验工具在开发阶段避免。\r\n```\r\n// 缺少一个引号  Uncaught SyntaxError: Invalid or unexpected token\r\nconst a = "3;\r\n```\r\n### TypeError 类型异常\r\n- TypeError在对值进行不合理操作时会发生，比如试图对一个非函数类型的值进行函数调用，或者引用null或undefined类型的值中的属性，那么引擎会抛出这种类型的异常。\r\n```\r\n// 变量name不能当作函数调用  Uncaught TypeError: name is not a function\r\nconst name = \'dyx\';\r\nname();\r\n```\r\n### ReferenceError 引用异常\r\n- 当找不到所需的变量时会报ReferenceError引用异常。\r\n```\r\n// a未定义 Uncaught ReferenceError: a is not defined\r\nconsole.log(a);\r\n```\r\n### RangeError 范围错误\r\n- 错误的数组范围。\r\n```\r\n// 错误的数组长度  Uncaught RangeError: Invalid array length\r\nnew Array(-20)\r\n```\r\n- 递归等消耗内存会导致范围错误的异常。Uncaught RangeError: Maximum call stack size exceeded\r\n- 将错误的值传递给数字方法，例如toFixed()等。\r\n```\r\n// Uncaught RangeError: toFixed() digits argument must be between 0 and 100\r\n2.2222.toFixed(111);\r\n```\r\n### URIError\r\n- 使用全局URI处理函数而产生的错误。\r\n- decodeURI, decodeURIComponent, encodeURI, encodeURIComponent这四个方法会产生这种异常。\r\n```\r\n//  Uncaught URIError: URI malformed\r\ndecodeURI(\'%%\')\r\n```\r\n### EvalError\r\n- 在eval()方法执行过程中抛出EvalError异常。\r\n- 根据ECMA2018版以后，此异常不再会被抛出，但是EvalError对象仍然保持兼容性。\r\n### InternalError 内部异常\r\n- 这种异常极为少见，在JS引擎内部发生，示例场景通常为某些成分过大。\r\n```\r\n// 过多 case 子句\r\nUncaught RangeError: too many switch cases\r\n// 正则表达式中括号过多\r\nUncaught RangeError: too many parentheses in regular expression\r\n// 数组初始化器过大 \r\nUncaught RangeError: array initializer too large\r\n```\r\n### Script Error\r\n#### 产生原因\r\n- 跨域资源引用，当a域下页面引用了b域下的js文件，运行b域下的js文件中的方法时报了一个异常，此时前端的错误捕获脚本只能检测到一个script error的异常。\r\n- 这是由于浏览器基于安全考虑故意隐藏了其它域JS文件抛出的具体错误信息。这样可以有效避免敏感信息无意中被第三方(不受控制的)脚本捕获到，因此浏览器只允许同域下的脚本捕获具体的错误信息。\r\n#### 解决办法\r\n1. 给script标签增加crossorigin属性，让浏览器允许页面请求资源。\r\n```\r\n// 以下两种写法均可\r\n<scrpit src="..." crossorigin><\/script>\r\n<scrpit src="..." crossorigin="anonymous"><\/script> \r\n```\r\n2. 给静态资源响应头增加允许跨域标记，让服务器允许资源返回。\r\n    - 服务器的HTTP响应头增加Access-Control-Allow-Origin: * 或者 Access-Control-Allow-Origin: ...\r\n    - 大部分主流CDN默认添加了Access-Control-Allow-Origin属性。\r\n#### 已添加crossorigin依然有script error\r\n- 由于部分浏览器对crossorigin属性不支持，或者无法往HTTP响应头里面添加跨域属性，因此依然可能产生script error。\r\n- 可以通过try catch获取页面报错信息，将JS错误重新抛出或者上报。\r\n```\r\ntry {\r\n  run(); // 调用b域下的js文件中的方法\r\n} catch (e) {\r\n  console.log(e);\r\n  throw e; \r\n}\r\n```\r\n### 创建自定义错误类型\r\n```\r\nclass MyError extends Error {\r\n  constructor(message) {\r\n    super();\r\n    this.name = "MyError";\r\n    this.message = message;     \r\n  }\r\n}\r\n\r\nthrow new MyError("自定义错误"); // Uncaught MyError: 自定义错误\r\n```\r\n### 抛出错误\r\n- 错误和异常不同。Error对象(错误)只有在被抛出时才会成为异常。\r\n- 在JavaScript中抛出异常，可以使用throw来抛出Error对象。\r\n```\r\nthrow TypeError("Expected number"); // Uncaught TypeError: Expected number\r\nthrow new TypeError("Expected number"); // Uncaught TypeError: Expected number\r\n```\r\n- 异常一旦抛出，就会在程序堆栈中冒泡，除非在某个地方被捕获。'},function(r,n,e){"use strict";e.r(n),n.default='## 异常处理\r\n### 同步错误处理\r\n- 常规函数的错误可以使用try-catch捕获。\r\n- 生成器函数的错误可以使用try-catch处理。\r\n### 异步错误处理\r\n#### 定时器的错误处理\r\n- setTimeout外层加try-catch无法捕获错误。\r\n```\r\ntry {\r\n  setTimeout(() => {\r\n    throw Error("error");\r\n  }, 1000);\r\n} catch (error) {\r\n  console.error(error.message);\r\n}\r\n```\r\n- setTimeout回调函数中加try-catch可以捕获错误。\r\n```\r\nsetTimeout(() => {\r\n  try {\r\n    throw Error("error");\r\n  } catch (error) {\r\n    console.error(error.message);\r\n  }\r\n}, 1000);\r\n```\r\n#### 事件的错误处理\r\n- 事件处理外层加try-catch无法捕获错误。\r\n```\r\nconst button = document.querySelector("button");\r\ntry {\r\n  button.addEventListener("click", function() {\r\n    throw Error("error");\r\n  });\r\n} catch (error) {\r\n  console.error(error.message);\r\n}\r\n```\r\n- 事件处理回调函数中加try-catch可以捕获错误。\r\n```\r\nconst button = document.querySelector("button");\r\nbutton.addEventListener("click", function() {\r\n  try {\r\n    throw Error("error");\r\n  } catch (error) {\r\n    console.error(error.message);\r\n  }\r\n});\r\n```\r\n#### onerror\r\n- 当img标签或script等HTML元素命中不存在的资源时，onerror事件处理程序就会触发。\r\n```\r\nconst image = document.querySelector("img");\r\nimage.addEventListener("error", function(event) {\r\n  console.log(event);\r\n});\r\n```\r\n#### Promise的错误处理\r\n- 使用catch方法处理被拒绝的Promise或Promise中的异常。\r\n```\r\nnew Promise((resolve, reject) => {\r\n  return reject(Error("error"));\r\n})\r\n.then(res => console.log(\'res\'))\r\n.catch(error => console.log(\'error\'))  // \'error\'\r\n\r\nnew Promise((resolve, reject) => {\r\n  throw Error("error");\r\n})\r\n.then(res => console.log(\'res\'))\r\n.catch(error => console.log(\'error\')) // \'error\'\r\n```\r\n- 使用catch方法处理Promise.all、Promise.any、Promise.race、Promise.allSettled中的异常。\r\n#### async/await的错误处理\r\n- 使用try-catch处理async/await的错误。\r\n```\r\nconst a = async() => {\r\n  throw Error("error");\r\n  return \'a\';\r\n}\r\n\r\nconst b = async() => {\r\n  try {\r\n    const res = await a();\r\n    console.log(res);\r\n  } catch (error) {\r\n    console.log(\'error\'); // \'error\'\r\n  }\r\n}\r\nb();\r\n```\r\n- 使用Promise.catch处理。\r\n> 使用Promise.catch处理相较于try-catch处理可以继续执行await后续的代码，可以通过判断await执行的返回值判断是否继续执行后续代码。\r\n\r\n```\r\nconst a = async() => {\r\n  throw Error("error");\r\n  return \'a\';\r\n}\r\n\r\nconst b = async() => {\r\n  const res = await a().catch((error) => console.log(\'error\')); // \'error\'\r\n  console.log(res); // undefined\r\n  if (!res) return;\r\n}\r\nb();\r\n```\r\n- 使用await-to-js插件处理。\r\n#### 异步生成器函数的错误可以使用try-catch处理。\r\n'},function(r,n,e){"use strict";e.r(n),n.default="## 异常监控\r\n### 监听资源(js css img...)加载失败错误\r\n```\r\nwindow.addEventListener(\r\n  'error',\r\n  e => {\r\n    // ...\r\n  },\r\n  true\r\n);\r\n```\r\n### 监听js错误\r\n```\r\nwindow.onerror = (msg, url, line, column, error) => {\r\n  // ...\r\n};\r\n```\r\n### 监听promise错误\r\n```\r\nwindow.addEventListener(\r\n  'unhandledrejection',\r\n  e => {\r\n    // ...\r\n  },\r\n  true\r\n});\r\n```\r\n### 重写console.error事件\r\n```\r\nconst oldConsoleError = window.console.error;\r\nwindow.console.error = (...args) => {\r\n  oldConsoleError.apply(this, args);\r\n  // ...\r\n};\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## [ArrayBuffer](https://zhuanlan.zhihu.com/p/568915443)\r\n> ArrayBuffer对象用来表示通用的、固定长度的原始二进制数据缓冲区。ArrayBuffer的内容不能直接操作，只能通过DataView对象或TypedArrray对象来访问。这些对象用于读取和写入缓冲区内容。"},function(r,n,e){"use strict";e.r(n),n.default='## Base64\r\n> Base64是一种基于64个可打印字符来表示二进制数据的表示方法。Base64编码普遍应用于需要通过被设计为处理文本数据的媒介上储存和传输二进制数据而需要编码该二进制数据的场景。这样是为了保证数据的完整并且不用在传输过程中修改这些数据。\r\n\r\n### 编码解码\r\n- atob()：解码，解码一个Base64字符串；\r\n- btoa()：编码，从一个字符串或者二进制数据编码一个Base64字符串。\r\n```\r\nbtoa("JavaScript");       // \'SmF2YVNjcmlwdA==\'\r\natob(\'SmF2YVNjcmlwdA==\'); // \'JavaScript\'\r\n```\r\n### 使用场景\r\n- 使用toDataURL()方法把canvas画布内容生成base64编码格式的图片url进行展示。\r\n```\r\nconst canvas = document.getElementById(\'canvas\'); \r\nconst ctx = canvas.getContext("2d");\r\nconst dataUrl = canvas.toDataURL();\r\n```\r\n- 使用readAsDataURL()方法把上传的文件转为base64格式的图片url进行展示。\r\n```\r\n<input type="file" id="fileInput" />\r\n<img id="preview" />\r\n\r\nconst fileInput = document.getElementById("fileInput");\r\nconst preview = document.getElementById("preview");\r\nconst reader = new FileReader();\r\n\r\nfileInput.onchange = (e) => {\r\n  reader.readAsDataURL(e.target.files[0]);\r\n};\r\n\r\nreader.onload = (e) => {\r\n  preview.src = e.target.result;\r\n};\r\n```'},function(r,n,e){"use strict";e.r(n),n.default='## blob\r\n> blob全称binary large object，即二进制大对象，blob对象表示一个不可变、原始数据的类文件对象，它的数据可以按文本或二进制的格式进行读取，也可以转换成 ReadableStream来用于数据操作。\r\n\r\n### blob创建\r\n> 使用Blob()构造函数创建新的blob对象。\r\n\r\n- array：由ArrayBuffer、ArrayBufferView、Blob、DOMString等对象构成的Array，将会被放进blob。\r\n- options：可指定如下两个属性\r\n  1. type：默认值为""，表示将会被放入到blob中的数组内容的MIME类型。\r\n  2. endings：默认值为"transparent"，用于指定包含行结束符\\n的字符串如何被写入，不常用。\r\n```\r\nconst blob = new Blob(array, options);\r\n\r\nconst blob = new Blob(["Hello World"], { type: "text/plain" });\r\n```\r\n### blob属性\r\n- size属性：blob对象中所包含数据的大小（字节）；\r\n- type属性：字符串，认为该blob对象所包含的MIME类型。如果类型未知，则为空字符串。\r\n```\r\nconst blob = new Blob(["Hello World"], { type: "text/plain" });\r\n\r\nconsole.log(blob.size); // 11\r\nconsole.log(blob.type); // "text/plain"\r\n```\r\n### 将blob转化为URL\r\n> 使用URL.createObjectURL()方法将将blob转化为一个URL进行使用。\r\n\r\n```\r\nconst url = URL.createObjectURL(blob);\r\n```\r\n### blob分片\r\n> 除了使用Blob()构造函数来创建blob对象之外，还可以从blob对象中创建blob，也就是将blob对象切片。blob对象内置了slice()方法用来将blob对象分片。\r\n\r\n- start：设置切片的起点，即切片开始位置。默认值为0，意味着切片应该从第一个字节开始。\r\n- end：设置切片的结束点，会对该位置之前的数据进行切片。默认值为blob.size。\r\n- contentType：设置新blob的MIME类型。如果省略type，则默认为blob的原始值。\r\n```\r\nconst blob = new Blob(["Hello World"], { type: "text/plain" });\r\nconst subBlob = blob.slice(0, 5);\r\n```\r\n'},function(r,n,e){"use strict";e.r(n),n.default='## File\r\n> File 文件接口提供有关文件的信息，并允许网页中的JavaScript访问其内容。实际上File对象是特殊类型的Blob，且可以用在任意的Blob类型的context中。Blob的属性和方法都可以用于File对象。File对象中只存在于浏览器环境中，在Node.js环境中不存在。\r\n\r\n### 获取File对象\r\n- input元素上选择文件后返回的FileList数组，这个数组的每个元素都是一个File对象，一个上传的文件就对应一个File对象。\r\n```\r\n<input type="file" id="fileInput" multiple="multiple">\r\n\r\nconst fileInput = document.getElementById("fileInput");\r\nfileInput.onchange = (e) => {\r\n  console.log(e.target.files); // FileList数组\r\n}\r\n```\r\n- 文件拖放操作生成的DataTransfer对象。当拖放文件到拖放区域时，通过事件参数的dataTransfer属性的files获取到一个FileList数组，该数组的每一个元素都是一个File对象。\r\n```\r\n<div id="drop-zone"></div>\r\n\r\nconst dropZone = document.getElementById("drop-zone");\r\ndropZone.ondragover = (e) => {\r\n  e.preventDefault();\r\n}\r\ndropZone.ondrop = (e) => {\r\n  e.preventDefault();\r\n  const files = e.dataTransfer.files;\r\n  console.log(files); // FileList数组\r\n}\r\n```\r\n### File对象属性\r\n- lastModified：引用文件最后修改日期，为自1970年1月1日0:00以来的毫秒数。\r\n- lastModifiedDate：引用文件的最后修改日期。\r\n- name：引用文件的文件名。\r\n- size：引用文件的文件大小。\r\n- type：文件的媒体类型（MIME）。\r\n- webkitRelativePath：文件的路径或 URL。'},function(r,n,e){"use strict";e.r(n),n.default='## FileReader\r\n> FileReader是一个异步API，用于读取文件并提取其内容以供进一步使用。FileReader可以将Blob读取为不同的格式。\r\nFileReader仅用于以安全的方式从用户（远程）系统读取文件内容，不能用于从文件系统中按路径名简单地读取文件。\r\n\r\n### FileReader创建\r\n> 通过FileReader()构造函数创建FileReader对象。\r\n\r\n```\r\nconst reader = new FileReader();\r\n```\r\n### FileReader属性\r\n- error：表示在读取文件时发生的错误。\r\n- result：文件内容。该属性仅在读取操作完成后才有效，数据的格式取决于使用哪个方法来启动读取操作。\r\n- readyState：表示FileReader状态的数字。取值0：还没有加载任何数据；取值1：数据正在被加载；取值2：已完成全部读取。\r\n### FileReader方法\r\n> 下面这些方法接受一个要读取的blob对象作为参数，读取完之后会将读取的结果放入对象的result属性中。\r\n\r\n- readAsArrayBuffer()：读取指定Blob中的内容，完成之后result属性中保存的将是被读取文件的ArrayBuffer数据对象。\r\n- readAsBinaryString()：读取指定Blob中的内容，完成之后result属性中将包含所读取文件的原始二进制数据。\r\n- readAsDataURL()：读取指定Blob中的内容，完成之后result属性中将包含一个data: URL格式的Base64字符串以表示所读取文件的内容。\r\n- readAsText()：读取指定Blob中的内容，完成之后result属性中将包含一个字符串以表示所读取的文件内容。\r\n### FileReader事件处理\r\n> 这些方法可以加上前置on后在HTML元素上使用，比如onload、onerror、onabort、onprogress。由于FileReader对象继承自EventTarget，因此还可以使用addEventListener()监听上述事件。\r\n\r\n- abort：该事件在读取操作被中断时触发。\r\n- error：该事件在读取操作发生错误时触发。\r\n- load：该事件在读取操作完成时触发。\r\n- progress：该事件在读取Blob时触发。\r\n\r\n```\r\n<input type="file" id="fileInput">\r\n\r\nconst fileInput = document.getElementById("fileInput");\r\nconst reader = new FileReader();\r\nfileInput.onchange = (e) => {\r\n  reader.readAsText(e.target.files[0]);\r\n  // 上传图片文件时可以使用readAsDataURL方法获取base64编码的URL进行预览展示\r\n  reader.readAsDataURL(e.target.files[0]);\r\n}\r\nreader.onload = (e) => {\r\n  console.log(e.target.result);\r\n}\r\n\r\n// 可以通过progress事件来监控文件的读取进度\r\nreader.onprogress = (e) => {\r\n  if (e.loaded && e.total) {\r\n    const percent = (e.loaded / e.total) * 100;\r\n    console.log(`上传进度: ${Math.round(percent)} %`);\r\n  }\r\n});\r\n```\r\n\r\n'},function(r,n,e){"use strict";e.r(n),n.default='## Object URL\r\n> Object URL又称Blob URL，是HTML5中的新标准。它是一个用来表示File Object或Blob Object的URL。\r\n\r\n### createObjectURL\r\n> 可以使用URL构造函数的createObjectURL()方法创建将给出的对象的URL。这个URL对象表示指定的File对象或Blob对象。我们可以在img、script标签中或者a、link标签的href属性中使用这个URL。\r\n\r\n```\r\n<input type="file" id="fileInput" />\r\n<img id="preview" />\r\n\r\nconst fileInput = document.getElementById("fileInput");\r\nconst preview = document.getElementById("preview");\r\nfileInput.onchange = (e) => {\r\n  // 直接预览图片\r\n  preview.src = URL.createObjectURL(e.target.files[0]);\r\n};\r\n```\r\n\r\n### revokeObjectURL\r\n> 当使用createObjectURL()方法创建一个Object URL时，就需要使用revokeObjectURL()方法从内存中清除它来释放内存。虽然浏览器会在文档卸载时自动释放Object URL，但为了提高性能应该使用createObjectURL()来手动释放它。\r\n\r\n```\r\nconst blob = new Blob([\'123\']);\r\nconst url = URL.createObjectURL(blob);\r\nconst link = document.createElement(\'a\');\r\nlink.href = url;\r\nlink.download = \'123.txt\';\r\nlink.click();\r\n// 释放一个之前已经存在的、通过调用URL.createObjectURL()创建的URL对象\r\nURL.revokeObjectURL(url);\r\n```\r\n\r\n'},function(r,n,e){"use strict";e.r(n),n.default="## 前端请求文件数据流\r\n### 前端设置请求的responseType为'blob'\r\n> 指定响应的数据类型为二进制数据流，请求成功会返回文件流内容。\r\n\r\n```\r\naxios.get(url, { responseType: 'blob' })\r\n```\r\n### 转为blob对象\r\n> 使用new Blob()将请求返回的文件流转为blob对象。\r\n\r\n```\r\naxios\r\n  .get(url, { responseType: 'blob' })\r\n  .then(res => {\r\n    const blob = new Blob([res.data]);\r\n  })\r\n```\r\n### 将blob对象转成URL进行显示或下载\r\n> 使用URL.createObjectURL()将blob对象转为URL。\r\n\r\n```\r\naxios\r\n  .get(url, { responseType: 'blob' })\r\n  .then(res => {\r\n    const blob = new Blob([res.data]);\r\n    const url = URL.createObjectURL(blob);\r\n  })\r\n```\r\n### 请求文件流并下载\r\n```\r\n/**\r\n * @param url 接口请求地址\r\n * @param fileName 下载的文件名称\r\n * @returns Promise\r\n */\r\nexport const downloadFile = async(url: string, fileName: string) => {\r\n  return axios\r\n    .get(url, { responseType: 'blob' })\r\n    .then(res => {\r\n      const blob = new Blob([res.data]);\r\n      const url = URL.createObjectURL(blob);\r\n      const link = document.createElement('a');\r\n      link.href = url;\r\n      link.download = fileName;\r\n      link.click();\r\n      // 释放一个之前已经存在的、通过调用URL.createObjectURL()创建的URL对象\r\n      URL.revokeObjectURL(url);\r\n      message.success(\"下载成功\");\r\n      return res;\r\n    })\r\n    .catch((error) => {\r\n      message.error(\"下载失败\");\r\n      return Promise.reject(error);\r\n    })\r\n}\r\n```\r\n### 请求文件流失败时的处理\r\n> 请求的responseType设置为'blob'时，请求成功会返回文件流内容。但是请求失败的时候后端返回的是json，这种情况在我们通常封装的axios中判断后端返回的code值就不适用了，需要进行特殊处理。\r\n\r\n- 将responseType设置为'json'，请求成功之后将json格式转化成blob在进行导出。\r\n- 将responseType设置为'blob'，请求失败之后将blob格式转化成json格式再进行错误提示。(采用的形式)\r\n```\r\n/**\r\n * @param url 接口请求地址\r\n * @param fileName 下载的文件名称\r\n * @returns Promise\r\n */\r\nexport const downloadFile = async(url: string, fileName: string) => {\r\n  return axios\r\n    .get(url, { responseType: 'blob' })\r\n    .then(res => {\r\n      // 请求失败之后的处理 (请求失败时的content-type为application/json)\r\n      if (res.headers['content-type'] === 'application/json') {\r\n        // 将blob转为json进行解析\r\n        const reader = new FileReader();\r\n        reader.readAsText(res.data, 'utf-8');\r\n        reader.onload = function() {\r\n          const parseObj = JSON.parse(reader.result);\r\n          message.error(parseObj.msg || '导出失败');\r\n        }\r\n        return Promise.reject('导出失败');\r\n      }\r\n      const blob = new Blob([res.data]);\r\n      const url = URL.createObjectURL(blob);\r\n      const link = document.createElement('a');\r\n      link.href = url;\r\n      link.download = fileName;\r\n      link.click();\r\n      // 释放一个之前已经存在的、通过调用URL.createObjectURL()创建的URL对象\r\n      URL.revokeObjectURL(url);\r\n      message.success(\"下载成功\");\r\n      return res;\r\n    })\r\n    .catch((error) => {\r\n      message.error(\"下载失败\");\r\n      return Promise.reject(error);\r\n    })\r\n}\r\n```\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## 大文件切片上传\r\n1. 使用Blob.prototype.slice方法将大文件分割成指定大小文件切片。\r\n2. 使用formData并行上传所有文件切片数据（由于并行上传，将文件切片的顺序告诉服务端）。\r\n3. 所有切片全部上传后通知服务端进行文件合并。\r\n4. 服务端使用multiparty处理前端传的formData数据，存储所有文件切片数据。\r\n5. 服务端根据文件切片的顺序使用读写流进行文件合并，合并成功后删除文件切片数据。\r\n### 前端代码\r\n```\r\nimport React, { useState } from 'react';\r\nimport { Button, message } from 'antd';\r\nimport request from '@/utils/request';\r\n\r\nconst SIZE = 10 * 1024 * 1024; // 单个文件切片大小\r\nconst BigFileUpload = () => {\r\n  const [uploadStatus, setUploadStatus] = useState(''); // 上传的状态\r\n  const [selectFile, setSelectFile] = useState<any>(null); // 选择的文件\r\n\r\n  // 选择上传文件时存储文件信息\r\n  const onUploadChange = (e: any) => {\r\n    const [file] = e.target.files;\r\n    if (file) {\r\n      setSelectFile(file);\r\n    }\r\n  };\r\n\r\n  // 生成文件切片\r\n  const createFileChunk = (file: any) => {\r\n    const fileChunkList = [];\r\n    let cur = 0;\r\n    while (cur < file.size) {\r\n      fileChunkList.push({ file: file.slice(cur, cur + SIZE) });\r\n      cur += SIZE;\r\n    }\r\n    return fileChunkList;\r\n  };\r\n\r\n  // 上传文件\r\n  const uploadFile = () => {\r\n    if (selectFile) {\r\n      setUploadStatus('loading');\r\n      const fileChunkList = createFileChunk(selectFile);\r\n      const fileChunkData: any = fileChunkList.map(({ file }, index) => ({\r\n        index,\r\n        chunk: file,\r\n        size: file.size\r\n      }));\r\n      uploadChunks(fileChunkData);\r\n    }\r\n  };\r\n\r\n  // 上传切片\r\n  const uploadChunks = async (fileChunkData: any) => {\r\n    const requestList = fileChunkData\r\n      .map(({ chunk, index }: { chunk: any; index: number }) => {\r\n        const formData = new FormData();\r\n        formData.append('chunk', chunk);\r\n        formData.append('filename', selectFile.name);\r\n        formData.append('index', String(index));\r\n        return { formData, index };\r\n      })\r\n      .map(({ formData }: { formData: any; index: number }) =>\r\n        request({\r\n          url: '/upload',\r\n          method: 'POST',\r\n          data: formData\r\n        })\r\n      );\r\n    await Promise.all(requestList);\r\n    await mergeFile();\r\n  };\r\n\r\n  // 通知服务端合并切片\r\n  const mergeFile = async () => {\r\n    await request({\r\n      url: '/merge',\r\n      method: 'POST',\r\n      data: JSON.stringify({\r\n        size: SIZE,\r\n        filename: selectFile.name\r\n      })\r\n    });\r\n    message.success('上传成功');\r\n    setUploadStatus('');\r\n  };\r\n\r\n  return (\r\n    <div>\r\n      {/* 正在上传中时disabled */}\r\n      <input\r\n        type=\"file\"\r\n        onChange={onUploadChange}\r\n        disabled={uploadStatus === 'loading'}\r\n      />\r\n      {/* 没有选择文件或正在上传中时disabled */}\r\n      <Button\r\n        onClick={uploadFile}\r\n        disabled={!selectFile || uploadStatus === 'loading'}\r\n      >\r\n        上传\r\n      </Button>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default BigFileUpload;\r\n```\r\n### 服务端代码\r\n```\r\nconst multiparty = require(\"multiparty\");\r\nconst fse = require(\"fs-extra\");\r\nconst path = require(\"path\");\r\n\r\n// 大文件存储目录\r\nconst UPLOAD_DIR = path.resolve(__dirname, \"..\", \"files\");\r\n\r\n// 写入文件流\r\nconst pipeStream = (path, writeStream) =>\r\n  new Promise(resolve => {\r\n    const readStream = fse.createReadStream(path);\r\n    readStream.on(\"end\", () => {\r\n      fse.unlinkSync(path);\r\n      resolve();\r\n    });\r\n    readStream.pipe(writeStream);\r\n  });\r\n\r\n// 提取POST请求参数\r\nconst resolvePost = req =>\r\n  new Promise(resolve => {\r\n    let chunk = \"\";\r\n    req.on(\"data\", data => {\r\n      chunk += data;\r\n    });\r\n    req.on(\"end\", () => {\r\n      resolve(JSON.parse(chunk));\r\n    });\r\n  });\r\n\r\n// 创建临时文件夹用于临时存储chunk (添加 chunkDir 前缀与文件名做区分)\r\nconst getChunkDir = fileName => path.resolve(UPLOAD_DIR, `chunkDir_${fileName}`);\r\n\r\n// 合并切片\r\nconst mergeFileChunk = async (filePath, filename, size) => {\r\n  const chunkDir = getChunkDir(filename);\r\n  const chunkPaths = await fse.readdir(chunkDir);\r\n  // 根据切片下标进行排序，否则直接读取目录的获得的顺序会错乱\r\n  chunkPaths.sort((a, b) => a - b);\r\n\r\n  // 并发写入文件\r\n  await Promise.all(\r\n    chunkPaths.map((chunkPath, index) =>\r\n      pipeStream(\r\n        path.resolve(chunkDir, chunkPath),\r\n        // 根据 size 在指定位置创建可写流\r\n        fse.createWriteStream(filePath, {\r\n          start: index * size\r\n        })\r\n      )\r\n    )\r\n  );\r\n  // 合并后删除保存切片的目录\r\n  fse.rmdirSync(chunkDir);\r\n};\r\n\r\nmodule.exports = class {\r\n  // 处理文件切片\r\n  async handleFormData(req, res) {\r\n    const multipart = new multiparty.Form();\r\n    multipart.parse(req, async (err, fields, files) => {\r\n      if (err) {\r\n        console.error(err);\r\n        res.status = 500;\r\n        res.end(\r\n          JSON.stringify({\r\n            code: 100,\r\n            message: \"file error\"\r\n          })\r\n        );\r\n        return;\r\n      }\r\n      const [chunk] = files.chunk;\r\n      const [filename] = fields.filename;\r\n      const [index] = fields.index;\r\n      const filePath = path.resolve(\r\n        UPLOAD_DIR,\r\n        `${filename}`\r\n      ); // 最终合并后的文件路径\r\n      const chunkDir = getChunkDir(filename); // 存放chunk的文件夹路径\r\n      const chunkPath = path.resolve(chunkDir, index); // 存放每个切片文件的路径\r\n\r\n      // 最终合并后的文件已经存在直接返回\r\n      if (fse.existsSync(filePath)) {\r\n        res.end(\r\n          JSON.stringify({\r\n            code: 0,\r\n            message: \"file exist\"\r\n          })\r\n        );\r\n        return;\r\n      }\r\n\r\n      // 切片存在直接返回\r\n      if (fse.existsSync(chunkPath)) {\r\n        res.end(\r\n          JSON.stringify({\r\n            code: 0,\r\n            message: \"chunk exist\"\r\n          })\r\n        );\r\n        return;\r\n      }\r\n\r\n      // 切片目录不存在，创建切片目录\r\n      if (!fse.existsSync(chunkDir)) {\r\n        await fse.mkdirs(chunkDir);\r\n      }\r\n\r\n      await fse.move(chunk.path, chunkPath);\r\n      res.end(\r\n        JSON.stringify({\r\n          code: 0,\r\n          message: \"success\"\r\n        })\r\n      );\r\n    });\r\n  }\r\n\r\n  // 合并切片\r\n  async handleMerge(req, res) {\r\n    const data = await resolvePost(req);\r\n    const { filename, size } = data;\r\n    const filePath = path.resolve(UPLOAD_DIR, `${filename}`);\r\n    await mergeFileChunk(filePath, filename, size);\r\n    res.end(\r\n      JSON.stringify({\r\n        code: 0,\r\n        message: \"success\"\r\n      })\r\n    );\r\n  }\r\n};\r\n```\r\n### 显示上传进度条\r\n- 使用axios的onUploadProgress方法获取到切片上传的进度，可以独立显示每个文件切片的上传进度。\r\n- 根据每个切片的上传进度计算出整个文件的上传进度可以显示整个文件的上传进度。"},function(r,n,e){"use strict";e.r(n),n.default="\r\n## 大文件断点续传\r\n- 记住已上传的切片，下次上传时跳过已上传的文件切片。\r\n  1. 前端使用localStorage存储已上传的切片（切换浏览器后失效）\r\n  2. 服务端存储，前端每次上传前询问服务端已上传的部分（建议使用）。\r\n- 使用spark-md5计算文件hash值作为文件的唯一标识，因为使用文件名作为标识时，文件名一修改就失去效果。计算hash是非常耗费时间，使用web-worker在worker线程计算hash，这样用户仍可以在主界面正常的交互。\r\n- 暂停上传使用axios的CancelToken取消请求。\r\n- 恢复上传时询问服务端已经成功上传的文件切片，重新上传时过滤掉已经上传的文件切片。\r\n### 前端代码\r\n```\r\nimport React, { useEffect, useState, useRef } from 'react';\r\nimport { Button, message, Table, Progress } from 'antd';\r\nimport axios from 'axios';\r\nimport request from '@/utils/request';\r\n\r\nconst { CancelToken } = axios;\r\nconst SIZE = 100 * 1024 * 1024; // 单个文件切片大小\r\nconst BigFileContinueUpload = () => {\r\n  const cancelRequestRef = useRef<any>([]); // 取消请求的存储\r\n  const [uploadStatus, setUploadStatus] = useState(''); // 上传的状态\r\n  const [selectFile, setSelectFile] = useState<any>(null); // 选择的文件\r\n  const [selectFileHash, setSelectFileHash] = useState<any>(null); // 选择的文件hash值\r\n  const [chunkData, setChunkData] = useState<any>([]); // 切片文件数据\r\n  const [totalPercentage, setTotalPercentage] = useState<number>(0); // 上传总进度\r\n\r\n  // 监听文件切片上传进度影响总进度\r\n  useEffect(() => {\r\n    let percentage = 0;\r\n    chunkData.forEach((item: any) => (percentage += item.percentage));\r\n    setTotalPercentage(percentage / 3);\r\n  }, [chunkData]);\r\n\r\n  // 选择上传文件时存储文件信息\r\n  const onUploadChange = (e: any) => {\r\n    const [file] = e.target.files;\r\n    if (file) {\r\n      setSelectFile(file);\r\n    }\r\n  };\r\n\r\n  // 生成文件hash\r\n  const calculateHash = (fileChunkList: any) => {\r\n    return new Promise(resolve => {\r\n      const worker = new Worker('/hash.js');\r\n      worker.postMessage({ fileChunkList });\r\n      worker.onmessage = e => {\r\n        const { hash } = e.data;\r\n        if (hash) {\r\n          resolve(hash);\r\n        }\r\n      };\r\n    });\r\n  };\r\n\r\n  // 生成文件切片\r\n  const createFileChunk = (file: any) => {\r\n    const fileChunkList = [];\r\n    let cur = 0;\r\n    while (cur < file.size) {\r\n      fileChunkList.push({ file: file.slice(cur, cur + SIZE) });\r\n      cur += SIZE;\r\n    }\r\n    return fileChunkList;\r\n  };\r\n\r\n  // 上传文件\r\n  const uploadFile = async () => {\r\n    if (selectFile) {\r\n      setUploadStatus('loading');\r\n      const fileChunkList = createFileChunk(selectFile);\r\n      const fileHash = await calculateHash(fileChunkList);\r\n      setSelectFileHash(fileHash);\r\n      const fileChunkData: any = fileChunkList.map(({ file }, index) => ({\r\n        index,\r\n        chunk: file,\r\n        size: file.size,\r\n        percentage: 0\r\n      }));\r\n      setChunkData(fileChunkData);\r\n      uploadChunks(fileChunkData, fileHash);\r\n    }\r\n  };\r\n\r\n  // 上传切片\r\n  const uploadChunks = async (\r\n    fileChunkData: any,\r\n    fileHash: any,\r\n    hasUploadedChunk: any = []\r\n  ) => {\r\n    const requestList = fileChunkData\r\n      // 断点续传时过滤掉已经上传的文件切片\r\n      .filter(\r\n        ({ index }: { index: number }) =>\r\n          !hasUploadedChunk.includes(String(index))\r\n      )\r\n      .map(({ chunk, index }: { chunk: any; index: number }) => {\r\n        const formData = new FormData();\r\n        formData.append('chunk', chunk);\r\n        formData.append('filename', selectFile.name);\r\n        formData.append('filehash', fileHash);\r\n        formData.append('index', String(index));\r\n        return { formData, index };\r\n      })\r\n      .map(({ formData, index }: { formData: any; index: number }) =>\r\n        request({\r\n          url: '/upload',\r\n          method: 'POST',\r\n          data: formData,\r\n          // 处理上传进度\r\n          onUploadProgress: function (progressEvent: any) {\r\n            const percentCompleted = Math.round(\r\n              (progressEvent.loaded * 100) / progressEvent.total\r\n            );\r\n            setChunkData((prev: any) => {\r\n              const newData = [...prev];\r\n              newData[index].percentage = percentCompleted;\r\n              return newData;\r\n            });\r\n          },\r\n          cancelToken: new CancelToken((cancel: any) => {\r\n            cancelRequestRef.current.push(cancel);\r\n          })\r\n        })\r\n      );\r\n    await Promise.all(requestList);\r\n    await mergeFile(fileHash);\r\n  };\r\n\r\n  // 通知服务端合并切片\r\n  const mergeFile = async (fileHash: any) => {\r\n    await request({\r\n      url: '/merge',\r\n      method: 'POST',\r\n      data: JSON.stringify({\r\n        size: SIZE,\r\n        filename: selectFile.name,\r\n        fileHash: fileHash\r\n      })\r\n    });\r\n    message.success('上传成功');\r\n    setUploadStatus('');\r\n  };\r\n\r\n  // 暂停上传\r\n  const pauseUpload = () => {\r\n    (cancelRequestRef.current || []).forEach((cancel: any) => cancel());\r\n  };\r\n\r\n  // 继续上传\r\n  const resumeUpload = async () => {\r\n    const res = await request({\r\n      url: '/verify',\r\n      method: 'POST',\r\n      data: JSON.stringify({\r\n        fileHash: selectFileHash\r\n      })\r\n    });\r\n    uploadChunks(chunkData, selectFileHash, res.data?.uploadedList || []);\r\n  };\r\n\r\n  const columns = [\r\n    {\r\n      title: '切片',\r\n      dataIndex: 'index',\r\n      render: (value: number) => `${selectFile.name}-${value}`\r\n    },\r\n    {\r\n      title: '切片大小',\r\n      dataIndex: 'size'\r\n    },\r\n    {\r\n      title: '进度',\r\n      dataIndex: 'percentage',\r\n      render: (value: number) => <Progress percent={value} size=\"small\" />\r\n    }\r\n  ];\r\n\r\n  return (\r\n    <div>\r\n      {/* 正在上传中时disabled */}\r\n      <input\r\n        type=\"file\"\r\n        onChange={onUploadChange}\r\n        disabled={uploadStatus === 'loading'}\r\n      />\r\n      {/* 没有选择文件或正在上传中时disabled */}\r\n      <Button\r\n        onClick={uploadFile}\r\n        disabled={!selectFile || uploadStatus === 'loading'}\r\n        type=\"primary\"\r\n      >\r\n        上传\r\n      </Button>\r\n      <Button onClick={pauseUpload}>暂停上传</Button>\r\n      <Button onClick={resumeUpload}>继续上传</Button>\r\n      <h6>总上传进度</h6>\r\n      <Progress percent={totalPercentage} style={{ width: '90%' }} />\r\n      <h6>文件切片上传进度</h6>\r\n      <Table columns={columns} dataSource={chunkData} />\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default BigFileContinueUpload;\r\n```\r\n### 服务端代码\r\n```\r\n/**\r\n * 大文件断点续传\r\n */\r\n/* eslint-disable */\r\nconst multiparty = require(\"multiparty\");\r\nconst fse = require(\"fs-extra\");\r\nconst path = require(\"path\");\r\n\r\n// 大文件存储目录\r\nconst UPLOAD_DIR = path.resolve(__dirname, \"..\", \"files\");\r\n\r\n// 写入文件流\r\nconst pipeStream = (path, writeStream) =>\r\n  new Promise(resolve => {\r\n    const readStream = fse.createReadStream(path);\r\n    readStream.on(\"end\", () => {\r\n      fse.unlinkSync(path);\r\n      resolve();\r\n    });\r\n    readStream.pipe(writeStream);\r\n  });\r\n\r\n// 提取POST请求参数\r\nconst resolvePost = req =>\r\n  new Promise(resolve => {\r\n    let chunk = \"\";\r\n    req.on(\"data\", data => {\r\n      chunk += data;\r\n    });\r\n    req.on(\"end\", () => {\r\n      resolve(JSON.parse(chunk));\r\n    });\r\n  });\r\n\r\n// 创建临时文件夹用于临时存储chunk (添加 chunkDir 前缀与文件hash做区分)\r\nconst getChunkDir = fileHash => path.resolve(UPLOAD_DIR, `chunkDir_${fileHash}`);\r\n\r\n// 返回已上传的所有切片名\r\nconst createUploadedList = async fileHash =>\r\n  fse.existsSync(getChunkDir(fileHash))\r\n    ? await fse.readdir(getChunkDir(fileHash))\r\n    : [];\r\n\r\n// 合并切片\r\nconst mergeFileChunk = async (filePath, size, fileHash) => {\r\n  const chunkDir = getChunkDir(fileHash);\r\n  const chunkPaths = await fse.readdir(chunkDir);\r\n  // 根据切片下标进行排序，否则直接读取目录的获得的顺序会错乱\r\n  chunkPaths.sort((a, b) => a - b);\r\n\r\n  // 并发写入文件\r\n  await Promise.all(\r\n    chunkPaths.map((chunkPath, index) =>\r\n      pipeStream(\r\n        path.resolve(chunkDir, chunkPath),\r\n        // 根据 size 在指定位置创建可写流\r\n        fse.createWriteStream(filePath, {\r\n          start: index * size\r\n        })\r\n      )\r\n    )\r\n  );\r\n  // 合并后删除保存切片的目录\r\n  fse.rmdirSync(chunkDir);\r\n};\r\n\r\nmodule.exports = class {\r\n  // 获取已上传的文件切片\r\n  async handleVerifyUpload(req, res) {\r\n    const data = await resolvePost(req);\r\n    const { fileHash } = data;\r\n    res.end(\r\n      JSON.stringify({\r\n        uploadedList: await createUploadedList(fileHash)\r\n      })\r\n    );\r\n  }\r\n\r\n  // 处理文件切片\r\n  async handleFormData(req, res) {\r\n    const multipart = new multiparty.Form();\r\n    multipart.parse(req, async (err, fields, files) => {\r\n      if (err) {\r\n        console.error(err);\r\n        res.status = 500;\r\n        res.end(\r\n          JSON.stringify({\r\n            code: 100,\r\n            message: \"file error\"\r\n          })\r\n        );\r\n        return;\r\n      }\r\n      const [chunk] = files.chunk;\r\n      const [filename] = fields.filename;\r\n      const [index] = fields.index;\r\n      const [filehash] = fields.filehash;\r\n      const filePath = path.resolve(\r\n        UPLOAD_DIR,\r\n        `${filename}`\r\n      ); // 最终合并后的文件路径\r\n      const chunkDir = getChunkDir(filehash); // 存放chunk的文件夹路径\r\n      const chunkPath = path.resolve(chunkDir, index); // 存放每个切片文件的路径\r\n\r\n      // 最终合并后的文件已经存在直接返回\r\n      if (fse.existsSync(filePath)) {\r\n        res.end(\r\n          JSON.stringify({\r\n            code: 0,\r\n            message: \"file exist\"\r\n          })\r\n        );\r\n        return;\r\n      }\r\n\r\n      // 切片存在直接返回\r\n      if (fse.existsSync(chunkPath)) {\r\n        res.end(\r\n          JSON.stringify({\r\n            code: 0,\r\n            message: \"chunk exist\"\r\n          })\r\n        );\r\n        return;\r\n      }\r\n\r\n      // 切片目录不存在，创建切片目录\r\n      if (!fse.existsSync(chunkDir)) {\r\n        await fse.mkdirs(chunkDir);\r\n      }\r\n\r\n      await fse.move(chunk.path, chunkPath);\r\n      res.end(\r\n        JSON.stringify({\r\n          code: 0,\r\n          message: \"success\"\r\n        })\r\n      );\r\n    });\r\n  }\r\n\r\n  // 合并切片\r\n  async handleMerge(req, res) {\r\n    const data = await resolvePost(req);\r\n    const { filename, size, fileHash } = data;\r\n    const filePath = path.resolve(UPLOAD_DIR, `${filename}`);\r\n    await mergeFileChunk(filePath, size, fileHash);\r\n    res.end(\r\n      JSON.stringify({\r\n        code: 0,\r\n        message: \"success\"\r\n      })\r\n    );\r\n  }\r\n};\r\n```"},function(r,n,e){"use strict";e.r(n),n.default='## 文件上传\r\n### 单文件上传\r\n> accept属性并不能完全限制上传类型，用户可以修改。\r\n\r\n```\r\n<input type="file" id="fileInput">\r\n\r\nconst fileInput = document.getElementById("fileInput");\r\nfileInput.onchange = (e) => {\r\n  console.log(e.target.files); // FileList数组\r\n}\r\n```\r\n### 多文件上传\r\n> 利用input元素的multiple属性。\r\n\r\n```\r\n<input type="file" id="fileInput" multiple>\r\n\r\nconst fileInput = document.getElementById("fileInput");\r\nfileInput.onchange = (e) => {\r\n  console.log(e.target.files); // FileList数组\r\n}\r\n```\r\n### 目录上传\r\n> 利用input元素上的webkitdirectory属性支持目录上传。\r\n\r\n```\r\n<input type="file" id="fileInput" webkitdirectory>\r\n\r\nconst fileInput = document.getElementById("fileInput");\r\nfileInput.onchange = (e) => {\r\n  console.log(e.target.files); // FileList数组\r\n}\r\n```\r\n### 压缩目录上传\r\n> 在目录上传的基础上，利用JSZip实现压缩目录。\r\n\r\n### 拖拽上传\r\n> 文件拖放操作生成的DataTransfer对象。当拖放文件到拖放区域时，通过事件参数的dataTransfer属性的files获取到一个FileList数组，该数组的每一个元素都是一个File对象。\r\n\r\n```\r\n<div id="drop-zone"></div>\r\n\r\nconst dropZone = document.getElementById("drop-zone");\r\ndropZone.ondragover = (e) => {\r\n  e.preventDefault();\r\n}\r\ndropZone.ondrop = (e) => {\r\n  e.preventDefault();\r\n  const files = e.dataTransfer.files;\r\n  console.log(files); // FileList数组\r\n}\r\n```\r\n### 剪贴板上传\r\n> 利用异步Clipboard API监听容器的粘贴事件，读取并解析剪贴板中的内容，动态构建FormData对象并上传。\r\n\r\n```\r\n<div id="upload-area">\r\n   <p>请先复制图片后再执行粘贴操作</p>\r\n</div>\r\n\r\n// 获取文件\r\nconst uploadAreaEle = document.getElementById("upload-area");\r\nuploadAreaEle.addEventListener("paste", async (e) => {\r\n  e.preventDefault();\r\n  const files = [];\r\n  if (navigator.clipboard) {\r\n    let clipboardItems = await navigator.clipboard.read();\r\n    for (const clipboardItem of clipboardItems) {\r\n      for (const type of clipboardItem.types) {\r\n        const blob = await clipboardItem.getType(type);\r\n        files.push(blob);\r\n       }\r\n     }\r\n  } else {\r\n    const items = e.clipboardData.items;\r\n    for (let i = 0; i < items.length; i++) {\r\n      let file = items[i].getAsFile();\r\n      files.push(file);\r\n    }\r\n  }\r\n  console.log(files); // FileList数组\r\n});\r\n```\r\n### 大文件切片上传\r\n> 利用Blob.slice分割文件实现大文件并发上传的功能。\r\n\r\n### 服务端上传\r\n> 服务器上传就是把文件从一台服务器上传到另外一台服务器。利用第三方库form-data实现服务端文件流式上传的功能。'},function(r,n,e){"use strict";e.r(n),n.default="## 文件下载\r\n### a标签\r\n- download属性用来指定下载的文件名，如果不指定那么下载的文件名就会根据响应头中的Content-Disposition来确定，如果响应头没有Content-Disposition会使用请求的URL的最后一部分作为文件名。\r\n- 如果响应头中的Content-Disposition属性指定了一个不同的文件名，那么会优先使用Content-Disposition中指定的文件名，优先级高于download属性指定的文件名。\r\n- a标签添加download属性只适用于下载同源的URL。\r\n    1. 同源URL会进行下载操作\r\n    2. 非同源URL会进行导航预览操作\r\n    3. 非同源的资源仍需要进行下载，可以将其转换为blob: URL和data: URL的形式进行下载。\r\n- 通过a标签实现\r\n```\r\n<a href=\"url\" download=\"filename\">下载</a>\r\n```\r\n- 通过js实现\r\n```\r\nconst a = document.createElement('a');\r\na.href = 'url';\r\na.download = 'filename';\r\na.click();\r\n```\r\n### window.open\r\n- 上面使用a标签的案例也可以通过window.open来实现。\r\n- 对比于a标签window.open这种方式不能下载.html、.htm、.xml、.xhtml等文件，因为这些文件会被当成html文件来处理，所以会直接在页面中打开。\r\n- 只适用于下载同源的URL。\r\n```\r\nwindow.open('url', '_blank', 'download=filename');\r\n```\r\n###  location.href\r\n> 这种方式和window.open(url)效果是一样的。\r\n\r\n```\r\nlocation.href = 'url';\r\n```\r\n### 通过ajax请求文件流下载\r\n> 请求成功后拿到文件数据流，将文件数据流转换成blob对象，通过URL.createObjectURL来创建一个URL，然后通过a标签的download属性来实现文件下载。\r\n\r\n```\r\n/**\r\n * @param url 接口请求地址\r\n * @param fileName 下载的文件名称\r\n * @returns Promise\r\n */\r\nexport const downloadFile = async(url: string, fileName: string) => {\r\n  return axios\r\n    .get(url, { responseType: 'blob' })\r\n    .then(res => {\r\n      const blob = new Blob([res.data]);\r\n      const url = URL.createObjectURL(blob);\r\n      const link = document.createElement('a');\r\n      link.href = url;\r\n      link.download = fileName;\r\n      link.click();\r\n      // 释放一个之前已经存在的、通过调用URL.createObjectURL()创建的URL对象\r\n      URL.revokeObjectURL(url);\r\n      message.success(\"下载成功\");\r\n      return res;\r\n    })\r\n    .catch((error) => {\r\n      message.error(\"下载失败\");\r\n      return Promise.reject(error);\r\n    })\r\n}\r\n```\r\n### 大文件切片下载\r\n- 服务器端将大文件切割成多个切片，并为每个切片生成唯一的标识符。\r\n- 客户端发送请求获取切片列表，同时开始下载第一个切片。\r\n- 客户端在下载过程中，根据切片列表发起并发请求下载其他切片，并逐渐拼接合并下载的数据。\r\n- 当所有切片都下载完成后，客户端将下载的数据合并为完整的文件。\r\n```\r\n/**\r\n * @param url 文件下载请求接口请求地址\r\n * @param chunkUrl 切片下载请求接口请求地址\r\n * @param fileName 下载的文件名称\r\n */\r\nexport const downloadFile = async(url: string, chunkUrl: string, fileName: string) => {\r\n  // 发起文件下载请求\r\n  axios.get(url)\r\n    .then(res => {\r\n      const totalSize = res.data.totalSize;\r\n      const totalChunks = res.data.totalChunks;\r\n      let downloadedChunks = 0;\r\n      let chunks = [];\r\n\r\n      // 下载每个切片\r\n      for (let chunkNumber = 0; chunkNumber < totalChunks; chunkNumber++) {\r\n        axios\r\n          .get(chunkUrl, { responseType: 'blob' })\r\n          .then(res => {\r\n            downloadedChunks++;\r\n            chunks.push(res.data);\r\n\r\n            // 当所有切片都下载完成时\r\n            if (downloadedChunks === totalChunks) {\r\n              // 合并切片\r\n              const mergedBlob = new Blob(chunks);\r\n              const url = URL.createObjectURL(mergedBlob);\r\n              const link = document.createElement('a');\r\n              link.href = url;\r\n              link.download = fileName;\r\n              link.click();\r\n              // 释放一个之前已经存在的、通过调用URL.createObjectURL()创建的URL对象\r\n              URL.revokeObjectURL(url);\r\n              message.success(\"下载成功\");\r\n            }\r\n          })\r\n      }\r\n    })\r\n    .catch(error => {\r\n      message.error(\"下载失败\");\r\n    });\r\n}\r\n```\r\n### 使用浏览器默认下载，类似软件下载网站的形式\r\n- location.href或者window.open可以实现类似效果。\r\n- 可以把token存在cookie中当用户发起请求的时候会默认带上，后端将下载的接口进行扩展支持从cookie中获取token。"},function(r,n,e){"use strict";e.r(n),n.default="## 文件预览\r\n### 图片预览\r\n```\r\n<img src={url} />\r\n```\r\n### word文件预览\r\n- 安装依赖\r\n```\r\nnpm i docx-preview --save\r\n```\r\n- 使用\r\n```\r\nimport React, { useEffect, useRef } from 'react';\r\nimport { renderAsync } from 'docx-preview';\r\n\r\nconst DocxPreviewModal = (props) => {\r\n  const { data } = props; // data的格式是blob文件流\r\n  const docxPreviewRef = useRef(null); // 展示文件的dom\r\n\r\n  // 预览\r\n  useEffect(() => {\r\n    renderAsync(data, docxPreviewRef.current);\r\n  }, []);\r\n\r\n  return (\r\n    <div ref={docxPreviewRef}></div>\r\n  );\r\n};\r\n```\r\n### excel文件预览\r\n- 安装依赖\r\n```\r\nnpm i xlsx docx-preview --save\r\n```\r\n- 使用\r\n```\r\nimport React, { useEffect, useRef } from 'react';\r\nimport { renderAsync } from 'docx-preview';\r\nimport XLSX from 'xlsx';\r\n\r\nconst XlsxPreviewModal = (props) => {\r\n  const { data } = props; // data的格式是blob文件流\r\n  const xlsxPreviewRef = useRef(null); // 展示文件的dom\r\n\r\n  // 预览\r\n  useEffect(() => {\r\n    const reader = new FileReader();\r\n    // 通过readAsArrayBuffer将blob转换为ArrayBuffer\r\n    reader.readAsArrayBuffer(data) // data的格式是blob文件流\r\n    reader.onload = (event) => {\r\n      // 读取ArrayBuffer数据变成Uint8Array\r\n      const transData = new Uint8Array(event.target.result);\r\n      // 这里的transData里面的类型和后面的type类型要对应\r\n      const workbook = XLSX.read(transData, { type: \"array\" });\r\n      const sheetNames = workbook.SheetNames; // 工作表名称\r\n      const worksheet = workbook.Sheets[sheetNames[0]];\r\n      // const excelData = XLSX.utils.sheet_to_json(worksheet); //JSON\r\n      const html = XLSX.utils.sheet_to_html(worksheet);\r\n      xlsxPreviewRef.current.innerHTML = html;\r\n    };\r\n  }, []);\r\n\r\n  return (\r\n    <div ref={xlsxPreviewRef}></div>\r\n  );\r\n};\r\n```\r\n### pdf文件预览\r\n#### pdf.js使用\r\n- 下载[pdf.js资源](http://mozilla.github.io/pdf.js/getting_started/#download)，下载适用旧版本浏览器的资源\r\n- 将资源放在和项目index.html相同的目录下。\r\n- 项目中使用pdf.js实现预览pdf文件。\r\n```\r\n// pdfUrl为需要预览的pdf文件资源路径\r\n<iframe\r\n  src={`/pdfjs/web/viewer.html?file=${encodeURIComponent(pdfUrl)}`}\r\n  width=\"100%\"\r\n  height=\"100%\"\r\n/>\r\n```\r\n#### 预览跨域的PDF资源文件\r\n- 项目的pdf资源跨域时注释viewer.js以下代码。\r\n```\r\nif (fileOrigin !== viewerOrigin) {\r\n  throw new Error(\"file origin does not match viewer's\");\r\n}\r\n```\r\n#### pdf.js屏蔽功能按钮\r\n- viewer.html，将功能按钮直接设置成style='display:none'。\r\n- 通过js修改参数，viewer.html添加代码隐藏对应按钮。body标签添加onload事件，onload=\"onBodyLoad()\"。\r\n```\r\n<script>\r\n  function onBodyLoad() {\r\n    var appConfig = PDFViewerApplication.appConfig;\r\n    appConfig.toolbar.viewBookmark.setAttribute('hidden', 'true');\r\n    appConfig.secondaryToolbar.viewBookmarkButton.setAttribute('hidden', 'true');\r\n    appConfig.toolbar.openFile.setAttribute('hidden', 'true');\r\n    appConfig.secondaryToolbar.openFileButton.setAttribute('hidden', 'true');\r\n    appConfig.toolbar.download.setAttribute('hidden', 'true');\r\n    appConfig.secondaryToolbar.downloadButton.setAttribute('hidden', 'true');\r\n    appConfig.toolbar.print.setAttribute('hidden', 'true');\r\n    appConfig.secondaryToolbar.printButton.setAttribute('hidden', 'true');\r\n  }\r\n<\/script>\r\n```\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## 格式转化\r\n### ArrayBuffer → blob\r\n```\r\nconst blob = new Blob([new Uint8Array(buffer, byteOffset, length)]);\r\n```\r\n### ArrayBuffer → base64\r\n```\r\nconst base64 = btoa(String.fromCharCode.apply(null, new Uint8Array(arrayBuffer)));\r\n```\r\n### base64 → blob\r\n```\r\nconst base64toBlob = (base64Data, contentType, sliceSize) => {\r\n  const byteCharacters = atob(base64Data);\r\n  const byteArrays = [];\r\n\r\n  for (let offset = 0; offset < byteCharacters.length; offset += sliceSize) {\r\n    const slice = byteCharacters.slice(offset, offset + sliceSize);\r\n\r\n    const byteNumbers = new Array(slice.length);\r\n    for (let i = 0; i < slice.length; i++) {\r\n      byteNumbers[i] = slice.charCodeAt(i);\r\n    }\r\n\r\n    const byteArray = new Uint8Array(byteNumbers);\r\n    byteArrays.push(byteArray);\r\n  }\r\n\r\n  const blob = new Blob(byteArrays, { type: contentType });\r\n  return blob;\r\n}\r\n```\r\n### blob → ArrayBuffer\r\n```\r\nfunction blobToArrayBuffer(blob) { \r\n  return new Promise((resolve, reject) => {\r\n    const reader = new FileReader();\r\n    reader.onload = () => resolve(reader.result);\r\n    reader.onerror = () => reject;\r\n    reader.readAsArrayBuffer(blob);\r\n  });\r\n}\r\n```\r\n### blob → base64\r\n```\r\nfunction blobToBase64(blob) {\r\n  return new Promise((resolve) => {\r\n    const reader = new FileReader();\r\n    reader.onload = () => resolve(reader.result);\r\n    reader.onerror = () => reject;\r\n    reader.readAsDataURL(blob);\r\n  });\r\n}\r\n```\r\n### blob → Object URL\r\n```\r\nconst objectUrl = URL.createObjectURL(blob);\r\n```"},function(r,n,e){"use strict";e.r(n),n.default='## sendBeacon\r\n> navigator.sendBeacon()方法可用于通过HTTP POST将少量数据异步传输到Web服务器。\r\n\r\n- url：data将要被发送到的网络地址。\r\n- data：将要发送的ArrayBuffer、ArrayBufferView、Blob、DOMString、FormData或URLSearchParams类型的数据。\r\n- 返回值：当用户代理成功把数据加入传输队列时，sendBeacon()方法将会返回true，否则返回false。\r\n```\r\nnavigator.sendBeacon(url, data);\r\n```\r\n### 文档卸载期间发送数据\r\n> 保证在文档卸载期间发送数据一直是一个困难。因为用户代理通常会忽略在unload事件处理器中产生的异步XMLHttpRequest。下述方法都会迫使用户代理延迟卸载文档，并使得下一个导航出现的更晚。下一个页面对于这种较差的载入表现无能为力。\r\n\r\n- 发起一个同步XMLHttpRequest来发送数据。\r\n- fetch + keepalive。\r\n- 创建一个`<img>`元素并设置src，大部分用户代理会延迟卸载（unload）文档以加载图像。\r\n- 创建一个几秒的 no-op 循环。\r\n### sendBeacon的优势\r\n- 数据发送是可靠的。\r\n- 数据异步传输。\r\n- 不影响下一导航的载入\r\n### 在visibilitychange事件发生时发送数据\r\n- 避免使用unload和beforeunload，在许多情况下（尤其是移动设备）浏览器不会产生unload、beforeunload或pagehide 事件。\r\n- unload事件与现代浏览器实现的往返缓存（bfcache）不兼容。\r\n- 可使用pagehide事件来代替部分浏览器未实现的visibilitychange事件。和beforeunload与unload事件类似，这一事件不会被可靠地触发（特别是在移动设备上），但它与bfcache兼容。\r\n```\r\ndocument.addEventListener("visibilitychange", () => {\r\n  if (document.visibilityState === "hidden") {\r\n    // sendBeacon发送json格式数据\r\n    const blob = new Blob([JSON.stringify(data)], {\r\n      type: \'application/json; charset=UTF-8\'\r\n    });\r\n    window.navigator.sendBeacon(url, blob);\r\n  }\r\n});\r\n```'},function(r,n,e){"use strict";e.r(n),n.default="## 前端监控\r\n1. 数据采集与上报\r\n2. 数据整理和存储\r\n3. 数据展示\r\n4. 监控告警\r\n### 数据采集\r\n1. 错误数据采集\r\n2. 接口请求错误数据采集\r\n3. 行为数据采集\r\n4. 性能数据采集\r\n### 数据上报\r\n#### 上报方法\r\n1. sendBeacon\r\n2. XMLHttpRequest\r\n3. image\r\n#### 上报时机\r\n1. 采用requestIdleCallback/setTimeout延时上报。\r\n2. 在beforeunload回调函数里上报。\r\n3. 缓存上报数据，达到一定数量后再上报。\r\n### 参考文章\r\n- [https://juejin.cn/post/7017974567943536671](https://juejin.cn/post/7017974567943536671)\r\n- [https://juejin.cn/post/6987681953424080926](https://juejin.cn/post/6987681953424080926)\r\n- [https://juejin.cn/post/7172072612430872584](https://juejin.cn/post/7172072612430872584)\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## 性能数据采集\r\n### FP、FCP数据采集\r\n```\r\nconst paintMonitor = () => {\r\n  if (!window.PerformanceObserver) {\r\n    return;\r\n  }\r\n\r\n  const entryHandler = list => {\r\n    for (const entry of list.getEntries()) {\r\n      if (entry.name === 'first-contentful-paint') {\r\n        observer.disconnect();\r\n      }\r\n      const json = entry.toJSON();\r\n      const reportData = {\r\n        type: 'performance',\r\n        subType: entry.name,\r\n        time: dayjs().format('YYYY-MM-DD HH:mm:ss'),\r\n        page: location.href,\r\n        data: JSON.stringify({\r\n          time: json.startTime\r\n        })\r\n      };\r\n      lazyReportCache(reportData);\r\n    }\r\n  };\r\n\r\n  const observer = new PerformanceObserver(entryHandler);\r\n  // buffered属性表示是否观察缓存数据，观察代码添加时机比事情触发时机晚也可以正常使用。\r\n  observer.observe({ type: 'paint', buffered: true });\r\n};\r\n```\r\n### LCP数据采集\r\n```\r\nconst lcpMonitor = () => {\r\n  if (!window.PerformanceObserver) {\r\n    return;\r\n  }\r\n\r\n  const entryHandler = list => {\r\n    for (const entry of list.getEntries()) {\r\n      const json = entry.toJSON();\r\n      const reportData = {\r\n        type: 'performance',\r\n        subType: entry.entryType,\r\n        time: dayjs().format('YYYY-MM-DD HH:mm:ss'),\r\n        page: location.href,\r\n        data: JSON.stringify({\r\n          time: json.startTime\r\n        })\r\n      };\r\n      lazyReportCache(reportData);\r\n    }\r\n    if (observer) {\r\n      observer.disconnect();\r\n    }\r\n  };\r\n\r\n  const observer = new PerformanceObserver(entryHandler);\r\n  // buffered属性表示是否观察缓存数据，观察代码添加时机比事情触发时机晚也可以正常使用。\r\n  observer.observe({ type: 'largest-contentful-paint', buffered: true });\r\n};\r\n```\r\n### DOMContentLoaded、load事件数据采集\r\n```\r\nconst onEvent = type => {\r\n  const callback = () => {\r\n    lazyReportCache({\r\n      type: 'performance',\r\n      subType: type,\r\n      time: dayjs().format('YYYY-MM-DD HH:mm:ss'),\r\n      page: location.href,\r\n      data: JSON.stringify({\r\n        time: performance.now()\r\n      })\r\n    });\r\n    window.removeEventListener(type, callback, true);\r\n  };\r\n  window.addEventListener(type, callback, true);\r\n};\r\n\r\nconst loadMonitor = () => {\r\n  ['load', 'DOMContentLoaded'].forEach(type => onEvent(type));\r\n};\r\n```\r\n### 浏览器往返缓存BFC(back/forward cache)\r\n- bfcache是一种内存缓存，它会将整个页面保存在内存中。当用户返回时可以马上看到整个页面，而不用再次刷新。部分浏览器才支持bfcache。\r\n- bfcache也是有缺点的，当用户返回并从bfcache中恢复页面时，原来页面的代码不会再次执行。为此浏览器提供了一个pageshow事件，可以把需要再次执行的代码放在里面。\r\n```\r\nwindow.addEventListener('pageshow', (event) => {\r\n  // 如果该属性为true，表示是从bfcache中恢复的页面\r\n  if (event.persisted) {\r\n    console.log('bfcache');\r\n  } else {\r\n    console.log('normally');\r\n  }\r\n}, true);\r\n```\r\n- 从bfcache中恢复的页面，收集FP、FCP、LCP各种时间。\r\n  1. 在pageshow事件触发后，用当前时间减去事件触发时间，这个时间差值就是性能指标的绘制时间。\r\n  2. 从bfcache中恢复的页面的这些性能指标值一般都很小，可以给它们加个标识字段bfc: true。\r\n```\r\nconst onBFCacheRestore = (callback) => {\r\n  window.addEventListener('pageshow', (event) => {\r\n    if (event.persisted) {\r\n      callback(event);\r\n    }\r\n  }, true);\r\n}\r\n\r\nonBFCacheRestore(event => {\r\n  requestAnimationFrame(() => {\r\n    ['first-paint', 'first-contentful-paint', 'largest-contentful-paint', 'load', 'DOMContentLoaded'].forEach(type => {\r\n      lazyReportCache({\r\n        type: 'performance',\r\n        subType: type,\r\n        time: dayjs().format('YYYY-MM-DD HH:mm:ss'),\r\n        page: location.href,\r\n        data: JSON.stringify({\r\n          bfc: true,\r\n          time: performance.now() - event.timeStamp,\r\n        })\r\n      });\r\n    })\r\n  })\r\n})\r\n```\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## 接口请求错误数据采集\r\n> 接口请求错误一般可分为两种，一种是http状态码错误类型比如接口请求404，还有一种是业务逻辑错误，http状态码正常，但是根据约定返回的响应数据格式判断为业务逻辑错误。\r\n\r\n### 接口请求的http错误上报\r\n```\r\nexport const httpErrorMonitor = error => {\r\n  const {\r\n    config: { url, method, data, params },\r\n    response: { status },\r\n    message\r\n  } = error;\r\n  lazyReportCache({\r\n    type: 'requestError',\r\n    subType: 'http',\r\n    time: dayjs().format('YYYY-MM-DD HH:mm:ss'),\r\n    page: location.href,\r\n    data: JSON.stringify({\r\n      path: url,\r\n      method,\r\n      status,\r\n      requestData: method === 'get' ? params : (data ? JSON.parse(data) : null),\r\n      message\r\n    })\r\n  });\r\n};\r\n```\r\n### 接口请求的业务错误上报\r\n```\r\nexport const businessErrorMonitor = error => {\r\n  const {\r\n    config: { url, method, data, params },\r\n    status,\r\n    data: { code, msg }\r\n  } = error;\r\n  lazyReportCache({\r\n    type: 'requestError',\r\n    subType: 'business',\r\n    time: dayjs().format('YYYY-MM-DD HH:mm:ss'),\r\n    page: location.href,\r\n    data: JSON.stringify({\r\n      path: url,\r\n      method,\r\n      status,\r\n      requestData: method === 'get' ? params : (data ? JSON.parse(data) : null),\r\n      message: msg,\r\n      businessCode: code,\r\n    })\r\n  });\r\n};\r\n```\r\n### 以axios为例上报请求错误\r\n```\r\nimport axios from 'axios';\r\nimport { message } from 'antd';\r\nimport qs from 'qs';\r\n\r\nconst request = axios.create({\r\n  baseURL: '',\r\n  timeout: 300000,\r\n  paramsSerializer: function (params) {\r\n    return qs.stringify(params, { arrayFormat: 'brackets' });\r\n  }\r\n});\r\n\r\nrequest.interceptors.response.use(\r\n  response => {\r\n    const {\r\n      data: { code, msg }\r\n    } = response;\r\n    if (code && code !== 0) {\r\n      message.warning(msg);\r\n      // code非0表示接口业务逻辑错误\r\n      businessErrorMonitor(response);\r\n    }\r\n    return response;\r\n  },\r\n  error => {\r\n    message.error(error.message || '请求失败，请重试');\r\n    // 接口请求http错误\r\n    httpErrorMonitor(error);\r\n    return Promise.reject(error);\r\n  }\r\n);\r\n\r\nexport default request;\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## 数据上报\r\n### 上报方法\r\n> 使用sendBeacon方法会异步地向服务器发送数据，同时不会延迟页面的卸载或影响下一导航的载入性能。在不支持sendBeacon的浏览器下可以使用XMLHttpRequest来进行上报，在beforeunload用XMLHttpRequest发送30kb的数据(一般待上报数据很少会有这么大)都可以成功发出去。\r\n\r\n1. sendBeacon\r\n2. XMLHttpRequest\r\n3. image\r\n### 上报时机\r\n> 建议将以下方式结合一起上报，先缓存上报数据缓存到一定数量后利用requestIdleCallback/setTimeout延时上报。在页面离开时统一将未上报的数据进行上报。\r\n\r\n1. 采用requestIdleCallback/setTimeout延时上报。\r\n2. 在beforeunload回调函数里上报。\r\n3. 缓存上报数据，达到一定数量后再上报。\r\n### 上报逻辑\r\n- 缓存数据\r\n```\r\nimport { deepCopy } from './utils';\r\n\r\nconst cache = [];\r\n\r\nexport const getCache = () => {\r\n  return deepCopy(cache);\r\n}\r\n\r\nexport const addCache = (data) => {\r\n  cache.push(data);\r\n}\r\n\r\nexport const clearCache = () => {\r\n  cache.length = 0;\r\n}\r\n```\r\n- 上报方法\r\n```\r\n// 上报的配置信息\r\nconst config = {\r\n  // ...\r\n}\r\n\r\n// 使用XMLHttpRequest上报\r\nexport const reportWithXHR = (url, data) => {\r\n  const xhr = new XMLHttpRequest();\r\n  xhr.open('post', url);\r\n  // 设置Content-Type为application/json才能被eggjs的post请求正常解析\r\n  xhr.setRequestHeader('Content-Type', 'application/json');\r\n  xhr.send(JSON.stringify(data));\r\n};\r\n\r\n// 兼容处理上报方法\r\nconst sendBeacon = (url, reportData) => {\r\n  if (window.navigator?.sendBeacon) {\r\n    // sendBeacon发送json格式数据\r\n    const blob = new Blob([JSON.stringify(reportData)], {\r\n      type: 'application/json; charset=UTF-8'\r\n    });\r\n    window.navigator.sendBeacon(url, blob);\r\n  } else {\r\n    reportWithXHR(url, reportData);\r\n  }\r\n};\r\n\r\n// 上报方法\r\nexport const report = (data, isImmediate = false) => {\r\n  const { url, appKey, userId, userPhone } = config;\r\n  // 上报信息\r\n  let reportData = null;\r\n  // 兼容处理直接上报和缓存数据上报(数组格式)两种形式\r\n  if (Array.isArray(data)) {\r\n    reportData = data.map(item => {\r\n      return {\r\n        appKey,\r\n        userId,\r\n        userPhone,\r\n        ...item\r\n      };\r\n    });\r\n  } else {\r\n    reportData = {\r\n      appKey,\r\n      userId,\r\n      userPhone,\r\n      ...data\r\n    };\r\n  }\r\n  // 立即上报\r\n  if (isImmediate) {\r\n    sendBeacon(url, reportData);\r\n    return;\r\n  }\r\n\r\n  // 兼容处理延时上报逻辑\r\n  if (window.requestIdleCallback) {\r\n    window.requestIdleCallback(\r\n      () => {\r\n        sendBeacon(url, reportData);\r\n      },\r\n      { timeout: 3000 }\r\n    );\r\n  } else {\r\n    setTimeout(() => {\r\n      sendBeacon(url, reportData);\r\n    });\r\n  }\r\n};\r\n\r\n// 缓存部分数据后再上报\r\nlet timer = null;\r\nexport const lazyReportCache = (data, timeout = 3000) => {\r\n  addCache(data);\r\n  clearTimeout(timer);\r\n  timer = setTimeout(() => {\r\n    const data = getCache();\r\n    if (data.length) {\r\n      report(data);\r\n      clearCache();\r\n    }\r\n  }, timeout);\r\n};\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## 行为数据采集\r\n### 用户行为信息上报通用方法\r\n```\r\nconst behaviorMonitor = (subType, data) => {\r\n  lazyReportCache({\r\n    type: 'behavior',\r\n    subType,\r\n    time: getTime(),\r\n    page: getPage(),\r\n    data: JSON.stringify(data)\r\n  });\r\n};\r\n```\r\n### PV、UV数据采集\r\n- PV(page view)是页面浏览量，UV(Unique visitor)用户访问量。PV只要访问一次页面就算一次，UV同一天内多次访问只算一次。\r\n- 对于前端来说，只要每次进入页面上报一次PV就行，UV可以根据PV的数据统计出来。\r\n```\r\nbehaviorMonitor('pv', {});\r\n```\r\n### 点击数据采集\r\n```\r\nbehaviorMonitor('click', {});\r\n```\r\n### 页面跳转数据采集(单页应用)\r\n- 利用addEventListener()监听popstate、hashchange页面跳转事件。\r\n- popstate事件只会在浏览器某些行为下触发, 比如点击后退、前进按钮或者调用history.back()、history.forward()、history.go()方法。\r\n- history.pushState()或者history.replaceState()改变路由不会触发popstate事件。通过dispatchEvent改写这两个方法实现对这两个方法的监听。\r\n```\r\nexport const pageChangeMonitor = () => {\r\n  let from = window.location.href;\r\n  // 第一次加载页面上报pv信息\r\n  behaviorMonitor(\r\n    'pv',\r\n    { pageKey: from }\r\n  );\r\n  // 监听popstate事件\r\n  window.addEventListener('popstate', () => {\r\n    const to = window.location.href; // 获取跳转后的页面路径\r\n    // 上报页面跳转信息\r\n    behaviorMonitor(\r\n      'pageChange',\r\n      { fromPageKey: from, toPageKey: to } \r\n    );\r\n    // 上报pv信息\r\n    behaviorMonitor(\r\n      'pv',\r\n      { pageKey: to }\r\n    );\r\n    from = to;\r\n  }, true);\r\n  // 监听hashchange事件\r\n  window.addEventListener('hashchange', event => {\r\n    const { oldURL, newURL}  = event; // 获取跳转后的页面路径\r\n    // 上报页面跳转信息\r\n    behaviorMonitor(\r\n      'pageChange',\r\n      { fromPageKey: oldURL, toPageKey: newURL }\r\n    );\r\n    // 上报pv信息\r\n    behaviorMonitor(\r\n      'pv',\r\n      { pageKey: newURL }\r\n    );\r\n  }, true);\r\n\r\n  const _wr = (type) => {\r\n    const orig = history[type];\r\n    return function () {\r\n      const rv = orig.apply(this, arguments);\r\n      const e = new Event(type);\r\n      e.arguments = arguments;\r\n      window.dispatchEvent(e);\r\n      return rv;\r\n    }\r\n  }\r\n\r\n  // 重写pushState、replaceState事件可以被监听到\r\n  history.pushState = _wr('pushState');\r\n  history.replaceState = _wr('replaceState');\r\n  ['pushState', 'replaceState'].forEach(item => {\r\n    window.addEventListener(item, () => {\r\n      const to = window.location.href; // 获取跳转后的页面路径\r\n      // 上报页面跳转信息\r\n      behaviorMonitor(\r\n        'pageChange',\r\n        { fromPageKey: from, toPageKey: to }\r\n      );\r\n      // 上报pv信息\r\n      behaviorMonitor(\r\n        'pv',\r\n        { pageKey: to }\r\n      );\r\n      from = to;\r\n    });\r\n  })\r\n}\r\n```\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## 解析错误信息源码\r\n- 解析源码使用source-map插件，直接使用error信息的source字段对应的文件可能无法解析到源码(webpack分包情况下)，可以使用error的stack堆栈信息的第一条对应的文件进行解析。\r\n- 使用error-stack-parser插件解析error的stack堆栈信息。\r\n```\r\nconst sourceMap = require(\"source-map\");\r\nconst ErrorStackParser = require('error-stack-parser');\r\nconst fs = require(\"fs\");\r\n\r\n// 解析错误堆栈信息(errorStack为js错误信息的stack字段内容)\r\nconst errorStackData = ErrorStackParser.parse(new Error(errorStack));\r\nconst { fileName, lineNumber, columnNumber } = errorStackData?.[0] || {};\r\nif (fileName.split('/').pop()) {\r\n  // 读取对应的.js.map文件\r\n  const mapObj = fs.readFileSync(`${__dirname}/../public/static/js/${fileName.split('/').pop()}.map`, 'utf-8');\r\n  const consumer = await new sourceMap.SourceMapConsumer(mapObj);\r\n  // 根据报错信息映射出报错的源文件和错误的行数、列数\r\n  const originalInfo = consumer.originalPositionFor({ line: lineNumber, column: columnNumber });\r\n  // 获取报错源文件的代码\r\n  const sourceCode = consumer.sourceContentFor(originalInfo.source);\r\n  // 错误源码信息\r\n  const errorSource = {\r\n    ...originalInfo,\r\n    sourceCode,\r\n  }\r\n}\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## 错误数据采集\r\n### js错误使用window.onerror捕获\r\n- window.onerror可以捕获常规运行时的错误。\r\n- window.onerror可以捕获异步错误(setTimeout)。\r\n- window.onerror无法捕获资源错误和promise的错误。\r\n```\r\nwindow.onerror = (message, source, lineno, colno, error) => {\r\n  // 上报错误\r\n  lazyReportCache({\r\n    type: 'error',\r\n    subType: 'js',\r\n    time: dayjs().format('YYYY-MM-DD HH:mm:ss'),\r\n    page: location.href,\r\n    data: JSON.stringify({\r\n      message,\r\n      source,\r\n      lineno,\r\n      colno,\r\n      // 错误栈\r\n      errorStack: error.stack\r\n    })\r\n  });\r\n}\r\n```\r\n### 资源加载错误使用window.addEventListener('error', () => {})捕获\r\n- js的错误也能被window.addEventListener('error', () => {})捕获到，判断触发错误的事件对象当只有资源加载错误时才处理。\r\n- 当一项资源(图片或脚本)加载失败，加载资源的元素会触发一个Event接口的error事件，error事件不会向上冒泡到window，window.onerror不能捕获到，可以通过window.addEventListener('error', () => {})捕获资源加载错误。\r\n- window.addEventListener('error', () => {})不能捕获new Image的错误，new Image的错误可以单独处理。\r\n- window.addEventListener('error', () => {})不能捕获promise的错误。\r\n```\r\nwindow.addEventListener('error', e => {\r\n  const target = e.target;\r\n  if (!target) return;\r\n  // 判断是否为资源加载错误\r\n  if (target.src || target.href) {\r\n    const url = target.src || target.href;\r\n    lazyReportCache({\r\n      type: 'error',\r\n      subType: 'resource',\r\n      time: dayjs().format('YYYY-MM-DD HH:mm:ss'),\r\n      page: location.href,\r\n      data: JSON.stringify({\r\n        message: `${url} 资源加载失败`,\r\n        url,\r\n        html: target.outerHTML,\r\n        resourceType: target.tagName\r\n      })\r\n    });\r\n  }\r\n}, true);\r\n```\r\n### promise错误使用window.addEventListener('unhandledrejection', () => {})捕获\r\n```\r\nwindow.addEventListener('unhandledrejection', e => {\r\n  lazyReportCache({\r\n    type: 'error',\r\n    subType: 'promise',\r\n    time: dayjs().format('YYYY-MM-DD HH:mm:ss'),\r\n    page: location.href,\r\n    data: JSON.stringify({\r\n      message: e.reason?.message,\r\n      // 错误栈\r\n      errorStack: e.reason?.stack\r\n    })\r\n  });\r\n})\r\n```\r\n### React错误\r\n- react render函数的错误不能被window.onerror捕获到，生命周期函数中的错误可以被window.onerror捕获到，可以通过componentDidCatch声明一个错误边界组件，在错误边界组件中上报错误。\r\n- ErrorBoundary只捕捉发生在React生命周期中的错误，不会捕捉React事件处理、异步代码、ErrorBoundary自己抛出的错误。\r\n- [react的错误开发环境会触发两次，生产环境正常触发一次。](https://github.com/facebook/react/issues/11499)\r\n- [antd的Form的onFinish方法中的错误无法被捕获到](https://github.com/ant-design/ant-design/issues/33876)。\r\n```\r\nclass ErrorBoundary extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = { hasError: false };\r\n  }\r\n\r\n  static getDerivedStateFromError(error) {\r\n    // 更新state使下一次渲染能够显示降级后的UI\r\n    return { hasError: true };\r\n  }\r\n\r\n  componentDidCatch(error) {\r\n    lazyReportCache({\r\n      type: 'error',\r\n      subType: 'react',\r\n      time: dayjs().format('YYYY-MM-DD HH:mm:ss'),\r\n      page: location.href,\r\n      data: JSON.stringify({\r\n        message: error?.message,\r\n        errorStack: error?.stack\r\n      })\r\n    });\r\n  }\r\n\r\n  render() {\r\n    if (this.state.hasError) {\r\n      // 自定义的降级UI\r\n      return <h1>Something went wrong.</h1>;\r\n    }\r\n    return this.props.children; \r\n  }\r\n}\r\n\r\n// 使用ErrorBoundary包裹根组件<App />\r\nconst root = ReactDOM.createRoot(document.getElementById('root') as Element);\r\nroot.render(<ErrorBoundary><App /></ErrorBoundary>);\r\n```\r\n### Vue错误\r\n- 由于Vue会捕获所有Vue单文件组件或者Vue.extend继承的代码，所以在Vue里面出现的错误，并不会直接被window.onerror捕获，而是会抛给Vue.config.errorHandler。\r\n- 可以在Vue.config.errorHandler中将捕获到的错误直接throw给onerror处理。\r\n```\r\nVue.config.errorHandler = (err) => {\r\n  setTimeout(() => {\r\n    throw err\r\n  })\r\n}\r\n```\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## Redux DevTools\r\n> 浏览器安装对应扩展之后，需要在react应用中配置才能正常使用该扩展。\r\n\r\n### 无侵入性的使用\r\n- 不使用redux中间件的简单形式\r\n```\r\nimport { createStore } from 'redux';\r\n\r\nconst store = createStore(\r\n  rootReducers,\r\n  window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__()\r\n);\r\n```\r\n- 使用redux中间件\r\n```\r\nimport { createStore, applyMiddleware, compose } from 'redux';\r\nimport reduxThunk from 'redux-thunk';\r\n\r\nconst composeEnhancers: any = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose;\r\nconst store = createStore(\r\n  rootReducers,\r\n  composeEnhancers(applyMiddleware(reduxThunk))\r\n);\r\n```\r\n- 只在开发环境使用\r\n```\r\nimport { createStore, applyMiddleware, compose } from 'redux';\r\nimport reduxThunk from 'redux-thunk';\r\n\r\nconst composeEnhancers: any = process.env.NODE_ENV === 'development' ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose : compose;\r\nconst store = createStore(\r\n  rootReducers,\r\n  composeEnhancers(applyMiddleware(reduxThunk))\r\n);\r\n```\r\n### 侵入性使用\r\n- 安装@redux-devtools/extension依赖\r\n```\r\nyarn add @redux-devtools/extension\r\n```\r\n- 不使用redux中间件的简单形式\r\n```\r\nimport { createStore } from 'redux';\r\nimport { composeWithDevTools } from '@redux-devtools/extension';\r\n\r\nconst store = createStore(\r\n  rootReducers,\r\n  composeWithDevTools()\r\n);\r\n```\r\n- 使用redux中间件\r\n```\r\nimport { createStore, applyMiddleware } from 'redux';\r\nimport reduxThunk from 'redux-thunk';\r\nimport { composeWithDevTools } from '@redux-devtools/extension';\r\n\r\nconst store = createStore(\r\n  rootReducers,\r\n  composeWithDevTools(applyMiddleware(reduxThunk))\r\n);\r\n```\r\n- 只在开发环境使用\r\n```\r\nimport { createStore, applyMiddleware } from 'redux';\r\nimport reduxThunk from 'redux-thunk';\r\nimport { composeWithDevTools } from '@redux-devtools/extension/src/developmentOnly';\r\n\r\nconst store = createStore(\r\n  rootReducers,\r\n  composeWithDevTools(applyMiddleware(reduxThunk))\r\n);\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## docker部署项目\r\n- 可以备份镜像，实现快速回滚。\r\n### 基本流程\r\n1. 在项目里维护Dockerfile及相关配置文件。\r\n2. 执行docker build构建镜像。\r\n3. push到镜像仓库。\r\n4. 部署的时候pull下来镜像用docker run跑起来。\r\n### 项目根目录添加nginx配置文件\r\n```\r\n// default.conf\r\nserver {\r\n  # 监听端口\r\n  listen       80;\r\n\r\n  # 配置服务ip\r\n  server_name  ip;\r\n\r\n  # nginx默认request header中包含的下划线_的请求头会自动忽略。\r\n  underscores_in_headers on;\r\n\r\n  # 开启gzip压缩功能\r\n  gzip on;\r\n\r\n  # 指定会被压缩的文件类型\r\n  gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/json;\r\n\r\n  # 设置压缩级别，越高资源消耗越大，但压缩效果越好\r\n  gzip_comp_level 5;\r\n\r\n  # 在头部中添加Vary: Accept-Encoding（建议开启）\r\n  gzip_vary on;\r\n  \r\n  # 处理压缩请求的缓冲区数量和大小\r\n  gzip_buffers 16 8k;\r\n\r\n  # 对于不支持压缩功能的客户端请求不开启压缩机制\r\n  gzip_disable \"MSIE [1-6]\\.\"; # 低版本的IE浏览器不支持压缩\r\n\r\n  # 设置压缩响应所支持的HTTP最低版本\r\n  gzip_http_version 1.1;\r\n\r\n  # 设置触发压缩的最小阈值\r\n  gzip_min_length 2k;\r\n\r\n  # 关闭对后端服务器的响应结果进行压缩\r\n  gzip_proxied off;\r\n\r\n  # 配置前端静态资源http缓存\r\n  location / {\r\n    # 指定根目录\r\n    root   /home/admin/build;\r\n    index  index.html index.htm;\r\n    try_files $uri $uri/ /index.html;\r\n\r\n    # index.html使用协商缓存\r\n    add_header Cache-Control 'no-cache';\r\n\r\n    if ($request_uri ~* .*[.](js|css|map|jpg|png|svg|ico)$) {\r\n      # 非html资源强缓存1个月\r\n      add_header Cache-Control \"max-age=2592000\";\r\n    }\r\n\r\n    if ($request_filename ~* ^.*[.](html|htm)$) {\r\n      # html使用协商缓存\r\n      add_header Cache-Control \"no-cache\";\r\n    }\r\n  }\r\n\r\n  # 接口请求代理\r\n  location /api {\r\n    proxy_pass http://ip;\r\n  }\r\n}\r\n```\r\n### 项目根目录添加docker配置文件\r\n> 定义构建镜像的时候基于 Dockerfile 来构建\r\n\r\n```\r\n// Dockerfile\r\n# 该镜像是基于 nginx:latest 镜像而构建的\r\nFROM nginx:latest\r\n\r\n# 将项目根目录下build文件夹下的所有文件复制到镜像中 /home/admin/build/ 目录下\r\nCOPY build/ /home/admin/build/\r\n\r\n# 将项目根目录下default.conf复制到镜像中 etc/nginx/conf.d/default.conf，用本地的 default.conf 配置来替换 Nginx 镜像里的默认配置。\r\nCOPY default.conf /etc/nginx/conf.d/default.conf\r\n```\r\n### 上传打包后的前端静态资源以及相关配置文件\r\n> 将打包后的前端静态资源文件夹build、nginx配置文件default.conf、docker配置文件Dockerfile，使用ftp文件传输工具上传到 /home/admin/ 目录下。\r\n\r\n### 构建镜像(添加镜像tag方便回滚)\r\n```\r\n// 镜像名admin，镜像tag 0.0.1\r\ndocker build -t admin:0.0.1 .\r\n```\r\n### 启动容器\r\n- 将宿主的80端口映射到容器的80端口\r\n- --name admin 容器名为admin\r\n- admin:0.0.1 使用镜像名为admin的 0.0.1 tag版本\r\n```\r\ndocker run -dp 80:80 --name admin admin:0.0.1\r\n```\r\n### 使用node脚本发布\r\n- 安装ssh2-sftp-client ssh2依赖\r\n```\r\nnpm install ssh2-sftp-client ssh2 -D\r\n```\r\n- deploy脚本\r\n```\r\n// deploy.js\r\nconst { Client } = require('ssh2');\r\nconst Sftp = require('ssh2-sftp-client');\r\n\r\nconst conn = new Client();\r\nconst sftp = new Sftp();\r\n\r\n// 根据命令获取部署的版本\r\nconst params = process.argv || [];\r\nconst deployVersion = params[2];\r\nconst romotePath = '/home/admin/';\r\nconst config = {\r\n  name: 'admin',\r\n  ssh: {\r\n    host: '服务ip',\r\n    port: 22,\r\n    username: 'root',\r\n    password: 'password',\r\n  },\r\n  romotePath,\r\n  localPath: './build',\r\n};\r\n\r\n// docker部署\r\nfunction dockerDeploy() {\r\n  conn.on('ready', () => {\r\n    console.log('部署准备');\r\n    conn.shell((err, stream) => {\r\n      if (err) {\r\n        console.log('部署失败');\r\n        conn.end();\r\n        console.log('部署连接断开');\r\n      };\r\n      stream.on('close', () => {\r\n        console.log('部署成功');\r\n        conn.end();\r\n        console.log('部署连接断开');\r\n      }).on('data', (data) => {\r\n        console.log('OUTPUT: ' + data);\r\n      });\r\n      stream.end(`cd /home/admin/\r\n        docker build -t admin:${deployVersion} .\r\n        docker rm -f admin\r\n        docker run -dp 80:80 --name admin admin:${deployVersion}\r\n        exit\r\n      `);\r\n    });\r\n  }).connect(config.ssh);\r\n}\r\n\r\nfunction deploy() {\r\n  console.log(`您选择了上传${config.name}`);\r\n  // 更新前端静态资源以及相关配置文件\r\n  sftp.connect(config.ssh).then(() => {\r\n    console.log('连接成功，上传中..');\r\n    return Promise.all([\r\n      sftp.delete(`${config.romotePath}/default.conf`, true),\r\n      sftp.delete(`${config.romotePath}/Dockerfile`, true),\r\n      sftp.rmdir(`${config.romotePath}/build`, true),\r\n    ]);\r\n  }).then(() => {\r\n    return Promise.all([\r\n      sftp.uploadDir('./build', `${config.romotePath}/build`),\r\n      sftp.fastPut('./default.conf', `${config.romotePath}/default.conf`),\r\n      sftp.fastPut('./Dockerfile', `${config.romotePath}/Dockerfile`),\r\n    ]);\r\n  }).then(() => {\r\n    console.log('上传成功');\r\n    dockerDeploy();\r\n  }).catch(err => {\r\n    console.log(err, '上传失败');\r\n  }).finally(() => {\r\n    sftp.end(); // 断开连接\r\n    console.log('上传连接断开');\r\n  })\r\n}\r\n\r\ndeploy();\r\n```\r\n- 添加npm脚本\r\n```\r\n// package.json\r\n\"scripts\": {\r\n  \"deploy\": \"npm run build && node deploy.js\"\r\n}\r\n```\r\n- 使用部署脚本(添加版本参数)\r\n```\r\nnpm run deploy 0.0.1\r\n```"},function(r,n,e){"use strict";e.r(n),n.default='## gitlab runner部署项目\r\n### 安装gitlab runner\r\n- [windows下载](https://docs.gitlab.com/runner/install/windows.html)\r\n- 下载完成之后，使用管理员运行cmd命令行，然后到刚刚下载的位置中，使用install进行安装，然后start启动。\r\n```\r\ngitlab-runner-windows-amd64.exe install\r\ngitlab-runner-windows-amd64.exe start\r\n```\r\n- 注册gitlab runner\r\n> 服务器上运行gitlab-runner后，runner会轮询的发送带token的http请求给gitlab，如果gitlab有任务了(一般是git push)，那么会把任务信息返回给runner，然后runner就开始调用注册时选的Executor来执行项目根目录下的配置文件.gitlab-ci.yml，执行后把结果反馈给gitlab。\r\n\r\n  1. 在gitlab的项目中打开Settings => CI/CD  => Runners中找到注册的url以及token。\r\n  2. 执行命令register填写上面中对应的url跟token。tags的值很重要要认真填写，executor执行者选择shell。\r\n  3. 注册成功之后可以在Settings => CI/CD  => Runners中看到刚注册的Runner。\r\n```\r\ngitlab-runner-windows-amd64.exe register\r\n```\r\n### gitlab-ci.yml\r\n- 必须指定tags\r\n- cache的设置保证下一阶段任务可以正常使用\r\n```\r\n# 构建阶段：build & deploy 两个 job；按照先后顺序执行\r\nstages:\r\n  - install\r\n  - build\r\n  - deploy\r\n  \r\ncache:\r\n  paths:\r\n    - node_modules\r\n    # 这里将这两个文件缓存，为了在第二个job中使用。其实只要缓存第二个也就够了\r\n    - build/\r\n\r\ninstall:\r\n  tags:\r\n    - deploy test\r\n  stage: install\r\n  only: \r\n    # 只在提交到 deploy/test 分支的时候触发\r\n    - deploy/test\r\n  script:\r\n    # 安装依赖\r\n    - npm install\r\n\r\nbuild:\r\n  tags:\r\n    - deploy test\r\n  stage: build\r\n  only: \r\n    # 只在提交到 deploy/test 分支的时候触发\r\n    - deploy/test\r\n  script:\r\n    # 打包\r\n    - npm run build\r\n\r\ndeploy:\r\n  tags:\r\n    - deploy test\r\n  stage: deploy\r\n  only:\r\n    - deploy/test\r\n  script:\r\n    # 打包\r\n    - npm run deploy test\r\n```\r\n### 报错记录\r\n- ERROR: Job failed (system failure): prepare environment: failed to start process: exec: “pwsh”: executable file not found in %PATH%.\r\n>  因为运行脚本的executor不正确，需要指定一下，打开我们安装gitlab runner的文件夹，有一个config.toml的文件，打开之后吧shell的位置修改为powerShell。然后重启gitlab runner。\r\n\r\n- Treating warnings as errors because process.env.CI = true. Most CI servers set it automati\r\n> build之前设置CI=false\r\n\r\n```\r\n"build": "set \\"CI=false\\" && node scripts/build.js",\r\n```'},function(r,n,e){"use strict";e.r(n),n.default="## nginx配置前端项目\r\n### 服务器安装nginx，安装后的默认目录假设如下\r\n```\r\n存放前端项目目录  /usr/share/nginx/html \r\n存放配置文件  /etc/nginx/conf.d/default.conf\r\n```\r\n### 上传打包后的前端静态资源\r\n> 将打包后的前端静态资源文件夹build使用ftp文件传输工具上传到 /home/admin 目录下（admin为项目名称）。\r\n\r\n### 配置nginx文件\r\n> 修改 /etc/nginx/conf.d/default.conf 配置文件。\r\n\r\n```\r\nserver {\r\n  # 监听端口\r\n  listen       80;\r\n\r\n  # 配置服务ip\r\n  server_name  ip;\r\n\r\n  # nginx默认request header中包含的下划线_的请求头会自动忽略。\r\n  underscores_in_headers on;\r\n\r\n  # 开启gzip压缩功能\r\n  gzip on;\r\n\r\n  # 指定会被压缩的文件类型\r\n  gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/json;\r\n\r\n  # 设置压缩级别，越高资源消耗越大，但压缩效果越好\r\n  gzip_comp_level 5;\r\n\r\n  # 在头部中添加Vary: Accept-Encoding（建议开启）\r\n  gzip_vary on;\r\n  \r\n  # 处理压缩请求的缓冲区数量和大小\r\n  gzip_buffers 16 8k;\r\n\r\n  # 对于不支持压缩功能的客户端请求不开启压缩机制\r\n  gzip_disable \"MSIE [1-6]\\.\"; # 低版本的IE浏览器不支持压缩\r\n\r\n  # 设置压缩响应所支持的HTTP最低版本\r\n  gzip_http_version 1.1;\r\n\r\n  # 设置触发压缩的最小阈值\r\n  gzip_min_length 2k;\r\n\r\n  # 关闭对后端服务器的响应结果进行压缩\r\n  gzip_proxied off;\r\n\r\n  # 配置前端静态资源http缓存\r\n  location / {\r\n    # 指定根目录\r\n    root   /home/admin/build;\r\n    index  index.html index.htm;\r\n    try_files $uri $uri/ /index.html;\r\n\r\n    # index.html使用协商缓存\r\n    add_header Cache-Control 'no-cache';\r\n\r\n    if ($request_uri ~* .*[.](js|css|map|jpg|png|svg|ico)$) {\r\n      # 非html资源强缓存1个月\r\n      add_header Cache-Control \"max-age=2592000\";\r\n    }\r\n\r\n    if ($request_filename ~* ^.*[.](html|htm)$) {\r\n      # html使用协商缓存\r\n      add_header Cache-Control \"no-cache\";\r\n    }\r\n  }\r\n\r\n  # 接口请求代理\r\n  location /api {\r\n    proxy_pass http://ip;\r\n  }\r\n}\r\n```\r\n### 启动nginx服务\r\n```\r\nservice nginx start\r\n```\r\n### 使用node脚本将打包后的文件夹build上传到服务器\r\n- 安装ssh2-sftp-client依赖\r\n```\r\nnpm install ssh2-sftp-client -D\r\n```\r\n- deploy脚本\r\n```\r\n// deploy.js\r\nconst Sftp = require('ssh2-sftp-client');\r\n\r\nconst sftp = new Sftp();\r\nconst romotePath = '/home/admin/build/';\r\nconst config = {\r\n  name: 'admin',\r\n  ssh: {\r\n    host: '服务ip',\r\n    port: 22,\r\n    username: 'root',\r\n    password: 'password',\r\n  },\r\n  romotePath,\r\n  localPath: './build',\r\n};\r\n\r\nfunction deploy() {\r\n  console.log(`您选择了上传${config.name}`);\r\n  sftp.connect(config.ssh).then(() => {\r\n    console.log('连接成功，上传中..');\r\n    return sftp.rmdir(config.romotePath, true);\r\n  }).then(() => {\r\n    return sftp.uploadDir(config.localPath, config.romotePath);\r\n  }).then(() => {\r\n    console.log('上传成功');\r\n  }).catch(err => {\r\n    console.log(err, '上传失败');\r\n  }).finally(() => {\r\n    sftp.end(); // 断开连接\r\n    console.log('上传连接断开');\r\n  })\r\n}\r\n\r\ndeploy();\r\n```\r\n- 添加npm脚本\r\n```\r\n// package.json\r\n\"scripts\": {\r\n  \"deploy\": \"npm run build && node deploy.js\"\r\n}\r\n```\r\n- 使用部署脚本\r\n```\r\nnpm run deploy\r\n```\r\n\r\n\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## [react-markdown渲染markdown文件](https://blog.csdn.net/Sakuraaaa_/article/details/128400497)\r\n### 安装依赖\r\n```\r\nyarn add react-markdown\r\n \r\n// 其余样式插件\r\nyarn add remark-gfm   \r\nyarn add rehype-raw   \r\nyarn add react-syntax-highlighter   \r\nyarn add github-markdown-css\r\n```\r\n### 渲染markdown文件\r\n```\r\nimport ReactMarkdown from 'react-markdown';\r\n\r\nconst App = () => {\r\n  return (\r\n    <ReactMarkdown>\r\n      {/* markdown文件文件内容 */}\r\n      {mdContent}\r\n    </ReactMarkdown>\r\n  )\r\n}\r\n```\r\n### 优化样式\r\n```\r\nimport ReactMarkdown from 'react-markdown';\r\nimport remarkGfm from 'remark-gfm'; // 划线、表、任务列表和直接url等的语法扩展\r\nimport rehypeRaw from 'rehype-raw'; // 解析标签，支持html语法\r\nimport { Prism as SyntaxHighlighter } from 'react-syntax-highlighter'; // 代码高亮\r\nimport { vscDarkPlus } from 'react-syntax-highlighter/dist/esm/styles/prism'; // 代码高亮的主题\r\nimport 'github-markdown-css'; // 样式文件\r\n\r\nconst App = () => {\r\n  return (\r\n    <ReactMarkdown\r\n      // 类名必须有才会有样式\r\n      className=\"markdown-body\"\r\n      remarkPlugins={[remarkGfm]}\r\n      rehypePlugins={[rehypeRaw]}\r\n      components={{\r\n        // 渲染代码块\r\n        code(props: any) {\r\n          const { children, ...rest } = props;\r\n          return (\r\n            <SyntaxHighlighter\r\n              {...rest}\r\n              style={vscDarkPlus}\r\n              PreTag=\"div\"\r\n              language=\"javascript\"\r\n            >\r\n              {String(children).replace(/\\n$/, '')}\r\n            </SyntaxHighlighter>\r\n          );\r\n        }\r\n      }}\r\n    >\r\n      \r\n      {mdContent}\r\n    </ReactMarkdown>\r\n  )\r\n}\r\n```\r\n### 生成导航目录\r\n- 如果借用相关插件实现目录对我们markdown的书写格式规范要求较高，可能会出现解析目录失败的问题。\r\n- 手动实现导航目录\r\n  1. 对markdown渲染后的DOM进行遍历，取出所有的h1-h6标签以及标签中的文本进行目录展示，同时给所有的h1-h6标签添加a标签作为锚点，方便点击目录进行定位。\r\n  ```\r\n  // 根据H标签获取目录数据以及为H标签添加锚点\r\n  const getNavs = () => {\r\n    const blogDom = document.getElementsByClassName('markdown-body')[0];\r\n    let eid = 0;\r\n    const titles: any = [];\r\n    for (const item of blogDom.childNodes as any) {\r\n      const { nodeName, innerText } = item;\r\n      if (['H1', 'H2', 'H3', 'H4', 'H5', 'H6'].includes(nodeName)) {\r\n        const a = document.createElement('a');\r\n        a.setAttribute('id', '#' + eid);\r\n        a.innerText = ' ';\r\n        const title = {\r\n          type: nodeName,\r\n          id: eid,\r\n          name: innerText\r\n        };\r\n        titles.push(title);\r\n        item.appendChild(a);\r\n        eid++;\r\n      }\r\n    }\r\n    setNavs(titles);\r\n  };\r\n  ```\r\n  2. 点击生成的目录，跳转到对应的位置\r\n  ```\r\n  // 点击目录移动到对应内容\r\n  const onNavClick = (e: any, id: number) => {\r\n    e.preventDefault();\r\n    if (id) {\r\n      // 找到锚点对应得的节点\r\n      const element = document.getElementById(`#${id}`);\r\n      // 如果对应id的锚点存在，就跳滚动到锚点顶部\r\n      element && element.scrollIntoView({ block: 'start', behavior: 'smooth' });\r\n      onClose();\r\n    }\r\n  };\r\n  ```"},function(r,n,e){"use strict";e.r(n),n.default="## qiankun微应用\r\n### 应用的请求代理proxy配置\r\n> 子应用配置的请求代理，在独立运行是没问题的。但是通过主应用去加载的子应用，子应用发出的请求实际已经被主应用劫持了，不会运行到子应用的请求代理。所以主应用也需要配置子应用需要的请求代理。\r\n\r\n### react子应用使用react-refresh，主应用不响应热更新的问题\r\n> 当React Refresh的多个实例同时运行时，需要使用library属性为React Refresh设置命名空间，类似于webpack中的output.library选项。\r\n\r\n- [react-refresh API](https://github.com/pmmmwh/react-refresh-webpack-plugin/blob/main/docs/API.md)\r\n```\r\n// webpack.dev.js\r\nconst ReactRefreshWebpackPlugin = require('@pmmmwh/react-refresh-webpack-plugin');\r\nconst { name } = require('../package.json');\r\n\r\nmodule.exports = {\r\n  mode: 'development',\r\n  devServer: {\r\n    headers: {\r\n      'Access-Control-Allow-Origin': '*',\r\n    },\r\n    hot: true,\r\n    open: true,\r\n    port: 3000,\r\n  },\r\n  plugins: [\r\n    new ReactRefreshWebpackPlugin({\r\n      library: `${name}-[name]`\r\n    }),\r\n  ]\r\n}\r\n```\r\n### 使用react-refresh，报错出现浮层影响本地开发\r\n> 将overlay属性值设置为false，关闭浮层报错。\r\n\r\n```\r\n// webpack.dev.js\r\nconst ReactRefreshWebpackPlugin = require('@pmmmwh/react-refresh-webpack-plugin');\r\nconst { name } = require('../package.json');\r\n\r\nmodule.exports = {\r\n  mode: 'development',\r\n  devServer: {\r\n    headers: {\r\n      'Access-Control-Allow-Origin': '*',\r\n    },\r\n    hot: true,\r\n    open: true,\r\n    port: 3000,\r\n  },\r\n  plugins: [\r\n    new ReactRefreshWebpackPlugin({\r\n      library: `${name}-[name]`,\r\n      overlay: false,\r\n    }),\r\n  ]\r\n}\r\n```\r\n### 应用样式隔离\r\n> 默认情况下沙箱可以确保单实例场景子应用之间的样式隔离，但是无法确保主应用跟子应用、或者多实例场景的子应用样式隔离。当配置为{ strictStyleIsolation: true }时表示开启严格的样式隔离模式。这种模式下qiankun会为每个微应用的容器包裹上一个shadow dom节点，从而确保微应用的样式不会对全局造成影响。\r\n\r\n- 使用{ strictStyleIsolation: true }有时候导致vue3的组件样式丢失，可以使用{ experimentalStyleIsolation: true }\r\n> 使用{ experimentalStyleIsolation: true }qiankun会改写子应用所添加的样式为所有样式规则增加一个特殊的选择器规则来限定其影响范围。\r\n\r\n```\r\n// 假设应用名是 react16\r\n.app-main {\r\n  font-size: 14px;\r\n}\r\n\r\ndiv[data-qiankun-react16] .app-main {\r\n  font-size: 14px;\r\n}\r\n```\r\n### 子应用之间跳转\r\n- 主应用和微应用都是hash模式，主应用根据hash来判断微应用，则不用考虑这个问题。\r\n- 主应用根据path来判断微应用，history模式的微应用之间的跳转，或者微应用跳主应用页面，直接使用微应用的路由实例是不行的，原因是微应用的路由实例跳转都基于路由的base。有两种办法可以跳转：\r\n  1. history.pushState()。\r\n  2. 将主应用的路由实例通过props传给微应用，微应用这个路由实例跳转。"},function(r,n,e){"use strict";e.r(n),n.default="#### qiankun微前端各应用分别部署\r\n> 主应用和微应用分别部署（不同ip或不同端口）。\r\n\r\n```\r\n1. 主应用访问路径 http://ip\r\n2. react子应用访问路径 http://ip:8001\r\n3. vue子应用访问路径 http://ip:8002\r\n\r\n/home/micro  // 资源目录\r\n    ├── main\r\n        ├── build  // 主应用静态资源\r\n    ├── microReact     \r\n        ├── build       // react微应用静态资源\r\n    ├── microVue      \r\n        ├── build       // vue微应用静态资源\r\n```\r\n### 子应用配置webpack构建时的publicPath。\r\n```\r\npublicPath: process.env.NODE_ENV === 'development' ? '/' : '/microVue/',\r\n```\r\n### 主应用中注册微应用的entry设置成微应用的部署路径，可以使用相对路径。\r\n> entry路径最后面的 / 不可省略，否则 publicPath 会设置错误。注册微应用的activeRule不能和微应用的部署路径一样，否则在主应用页面刷新会直接变成微应用页面。\r\n\r\n```\r\n// 注册子应用\r\nregisterMicroApps([\r\n  {\r\n    name: 'micro-react',\r\n    entry: process.env.NODE_ENV === 'development' ? '//localhost:8001' : '/microReact/',\r\n    container: '#microContainer',\r\n    activeRule: '/micro-react',\r\n  },\r\n  {\r\n    name: 'micro-vue',\r\n    entry: process.env.NODE_ENV === 'development' ? '//localhost:8002' : '/microVue/',\r\n    container: '#microContainer',\r\n    activeRule: '/micro-vue',\r\n  },\r\n]);\r\n```\r\n### nginx配置\r\n```\r\n# 主应用\r\nserver {\r\n  # 监听端口\r\n  listen       80;\r\n\r\n  # 服务ip\r\n  server_name  ip;\r\n\r\n  # 开启gzip压缩功能\r\n  gzip on;\r\n\r\n  # 指定会被压缩的文件类型\r\n  gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/json;\r\n\r\n  # 设置压缩级别，越高资源消耗越大，但压缩效果越好\r\n  gzip_comp_level 5;\r\n\r\n  # 在头部中添加Vary: Accept-Encoding（建议开启）\r\n  gzip_vary on;\r\n  \r\n  # 处理压缩请求的缓冲区数量和大小\r\n  gzip_buffers 16 8k;\r\n\r\n  # 对于不支持压缩功能的客户端请求不开启压缩机制\r\n  gzip_disable \"MSIE [1-6]\\.\"; # 低版本的IE浏览器不支持压缩\r\n\r\n  # 设置压缩响应所支持的HTTP最低版本\r\n  gzip_http_version 1.1;\r\n\r\n  # 设置触发压缩的最小阈值\r\n  gzip_min_length 2k;\r\n\r\n  # 关闭对后端服务器的响应结果进行压缩\r\n  gzip_proxied off;\r\n\r\n  # 配置前端静态资源\r\n  location / {\r\n    root   /home/micro/main/build;\r\n    index  index.html index.htm;\r\n    try_files $uri $uri/ /index.html;\r\n\r\n    # index.html使用协商缓存\r\n    add_header Cache-Control 'no-cache';\r\n\r\n    if ($request_uri ~* .*[.](js|css|map|jpg|png|svg|ico)$) {\r\n      # 非html资源强缓存1个月\r\n      add_header Cache-Control \"max-age=2592000\";\r\n    }\r\n\r\n    if ($request_filename ~* ^.*[.](html|htm)$) {\r\n      # html使用协商缓存\r\n      add_header Cache-Control \"no-cache\";\r\n    }\r\n  }\r\n\r\n  # react子应用的转发\r\n  location /microReact {\r\n    proxy_pass http://ip:8001/;\r\n    proxy_set_header Host $host:$server_port;\r\n  }\r\n\r\n  # vue子应用的转发\r\n  location /microVue {\r\n    proxy_pass http://ip:8002/;\r\n    proxy_set_header Host $host:$server_port;\r\n  }\r\n}\r\n\r\n# react子应用\r\nserver {\r\n  # 监听端口\r\n  listen       8001;\r\n\r\n  # 服务ip\r\n  server_name  ip;\r\n\r\n  # 开启gzip压缩功能\r\n  gzip on;\r\n\r\n  # 指定会被压缩的文件类型\r\n  gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/json;\r\n\r\n  # 设置压缩级别，越高资源消耗越大，但压缩效果越好\r\n  gzip_comp_level 5;\r\n\r\n  # 在头部中添加Vary: Accept-Encoding（建议开启）\r\n  gzip_vary on;\r\n  \r\n  # 处理压缩请求的缓冲区数量和大小\r\n  gzip_buffers 16 8k;\r\n\r\n  # 对于不支持压缩功能的客户端请求不开启压缩机制\r\n  gzip_disable \"MSIE [1-6]\\.\"; # 低版本的IE浏览器不支持压缩\r\n\r\n  # 设置压缩响应所支持的HTTP最低版本\r\n  gzip_http_version 1.1;\r\n\r\n  # 设置触发压缩的最小阈值\r\n  gzip_min_length 2k;\r\n\r\n  # 关闭对后端服务器的响应结果进行压缩\r\n  gzip_proxied off;\r\n\r\n  # 配置前端静态资源\r\n  location / {\r\n    root   /home/micro/microReact/build;\r\n    index  index.html index.htm;\r\n    try_files $uri $uri/ /index.html;\r\n\r\n    # # index.html使用协商缓存\r\n    add_header Cache-Control 'no-cache';\r\n\r\n    if ($request_uri ~* .*[.](js|css|map|jpg|png|svg|ico)$) {\r\n      # 非html资源强缓存1个月\r\n      add_header Cache-Control \"max-age=2592000\";\r\n    }\r\n\r\n    if ($request_filename ~* ^.*[.](html|htm)$) {\r\n      # html使用协商缓存\r\n      add_header Cache-Control \"no-cache\";\r\n    }\r\n  }\r\n\r\n  # 兼容子应用独立访问\r\n  location /microReact {\r\n    proxy_pass http://ip:8001/;\r\n  }\r\n}\r\n\r\n# vue子应用\r\nserver {\r\n  # 监听端口\r\n  listen       8002;\r\n\r\n  # 服务ip\r\n  server_name  ip;\r\n\r\n  # 开启gzip压缩功能\r\n  gzip on;\r\n\r\n  # 指定会被压缩的文件类型\r\n  gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/json;\r\n\r\n  # 设置压缩级别，越高资源消耗越大，但压缩效果越好\r\n  gzip_comp_level 5;\r\n\r\n  # 在头部中添加Vary: Accept-Encoding（建议开启）\r\n  gzip_vary on;\r\n  \r\n  # 处理压缩请求的缓冲区数量和大小\r\n  gzip_buffers 16 8k;\r\n\r\n  # 对于不支持压缩功能的客户端请求不开启压缩机制\r\n  gzip_disable \"MSIE [1-6]\\.\"; # 低版本的IE浏览器不支持压缩\r\n\r\n  # 设置压缩响应所支持的HTTP最低版本\r\n  gzip_http_version 1.1;\r\n\r\n  # 设置触发压缩的最小阈值\r\n  gzip_min_length 2k;\r\n\r\n  # 关闭对后端服务器的响应结果进行压缩\r\n  gzip_proxied off;\r\n\r\n  # 配置前端静态资源\r\n  location / {\r\n    root   /home/micro/microVue/build;\r\n    index  index.html index.htm;\r\n    try_files $uri $uri/ /index.html;\r\n\r\n    # index.html使用协商缓存\r\n    add_header Cache-Control 'no-cache';\r\n\r\n    if ($request_uri ~* .*[.](js|css|map|jpg|png|svg|ico)$) {\r\n      # 非html资源强缓存1个月\r\n      add_header Cache-Control \"max-age=2592000\";\r\n    }\r\n\r\n    if ($request_filename ~* ^.*[.](html|htm)$) {\r\n      # html使用协商缓存\r\n      add_header Cache-Control \"no-cache\";\r\n    }\r\n  }\r\n\r\n  # 兼容子应用独立访问\r\n  location /microVue {\r\n    proxy_pass http://ip:8002/;\r\n  }\r\n}\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## qiankun微前端部署同级目录\r\n> 主应用和微应用部署到同一个服务器（同一个 IP 和端口）。微应用和主应用放在同一级目录下。\r\n\r\n```\r\n1. 主应用访问路径 http://ip\r\n2. react子应用访问路径 http://ip/microReact\r\n3. vue子应用访问路径 http://ip/microVue\r\n\r\n/home/micro  // 资源目录\r\n    ├── main\r\n        ├── build  // 主应用静态资源\r\n    ├── microReact     \r\n        ├── build       // react微应用静态资源\r\n    ├── microVue      \r\n        ├── build       // vue微应用静态资源\r\n```\r\n### 子应用配置webpack构建时的publicPath。\r\n```\r\npublicPath: process.env.NODE_ENV === 'development' ? '/' : '/microVue/build/',\r\n```\r\n### 子应用设置history路由base，用于微应用独立访问时使用。\r\n> 独立访问时的base设置成/microVue/而不是/microVue/build/，是因为nginx的location配置成/microVue/，具体可见下方nginx配置。同时保证和主应用配置的activeRule不一样\r\n\r\n```\r\nbase: window.__POWERED_BY_QIANKUN__ ? '/micro-vue/' : '/microVue/',\r\n```\r\n### 主应用中注册微应用的entry设置成微应用的部署路径，可以使用相对路径。\r\n> entry路径最后面的 / 不可省略，否则 publicPath 会设置错误。注册微应用的activeRule不能和微应用的部署路径一样，否则在主应用页面刷新会直接变成微应用页面。\r\n\r\n```\r\n// 注册子应用\r\nregisterMicroApps([\r\n  {\r\n    name: 'micro-react',\r\n    entry: process.env.NODE_ENV === 'development' ? '//localhost:8001' : '/microReact/',\r\n    container: '#microContainer',\r\n    activeRule: '/micro-react',\r\n  },\r\n  {\r\n    name: 'micro-vue',\r\n    entry: process.env.NODE_ENV === 'development' ? '//localhost:8002' : '/microVue/',\r\n    container: '#microContainer',\r\n    activeRule: '/micro-vue',\r\n  },\r\n]);\r\n```\r\n### nginx配置\r\n```\r\nserver {\r\n  # 监听端口\r\n  listen       80;\r\n\r\n  # 服务ip\r\n  server_name  ip;\r\n\r\n  # 开启gzip压缩功能\r\n  gzip on;\r\n\r\n  # 指定会被压缩的文件类型\r\n  gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/json;\r\n\r\n  # 设置压缩级别，越高资源消耗越大，但压缩效果越好\r\n  gzip_comp_level 5;\r\n\r\n  # 在头部中添加Vary: Accept-Encoding（建议开启）\r\n  gzip_vary on;\r\n  \r\n  # 处理压缩请求的缓冲区数量和大小\r\n  gzip_buffers 16 8k;\r\n\r\n  # 对于不支持压缩功能的客户端请求不开启压缩机制\r\n  gzip_disable \"MSIE [1-6]\\.\"; # 低版本的IE浏览器不支持压缩\r\n\r\n  # 设置压缩响应所支持的HTTP最低版本\r\n  gzip_http_version 1.1;\r\n\r\n  # 设置触发压缩的最小阈值\r\n  gzip_min_length 2k;\r\n\r\n  # 关闭对后端服务器的响应结果进行压缩\r\n  gzip_proxied off;\r\n\r\n  # 配置前端静态资源\r\n  # 主应用\r\n  location / {\r\n    root   /home/micro/main/build;\r\n    index  index.html index.htm;\r\n    try_files $uri $uri/ /index.html;\r\n\r\n    # index.html使用协商缓存\r\n    add_header Cache-Control 'no-cache';\r\n\r\n    if ($request_uri ~* .*[.](js|css|map|jpg|png|svg|ico)$) {\r\n      # 非html资源强缓存1个月\r\n      add_header Cache-Control \"max-age=2592000\";\r\n    }\r\n\r\n    if ($request_filename ~* ^.*[.](html|htm)$) {\r\n      # html使用协商缓存\r\n      add_header Cache-Control \"no-cache\";\r\n    }\r\n  }\r\n\r\n  # react子应用\r\n  location /microReact {\r\n    root   /home/micro;\r\n    index  build/index.html build/index.htm;\r\n    try_files $uri $uri/ /microReact/build/index.html;\r\n\r\n    # index.html使用协商缓存\r\n    add_header Cache-Control 'no-cache';\r\n\r\n    if ($request_uri ~* .*[.](js|css|map|jpg|png|svg|ico)$) {\r\n      # 非html资源强缓存1个月\r\n      add_header Cache-Control \"max-age=2592000\";\r\n    }\r\n\r\n    if ($request_filename ~* ^.*[.](html|htm)$) {\r\n      # html使用协商缓存\r\n      add_header Cache-Control \"no-cache\";\r\n    }\r\n  }\r\n\r\n  # vue子应用\r\n  location /microVue {\r\n    root   /home/micro;\r\n    index  build/index.html build/index.htm;\r\n    try_files $uri $uri/ /microVue/build/index.html;\r\n\r\n    # index.html使用协商缓存\r\n    add_header Cache-Control 'no-cache';\r\n\r\n    if ($request_uri ~* .*[.](js|css|map|jpg|png|svg|ico)$) {\r\n      # 非html资源强缓存1个月\r\n      add_header Cache-Control \"max-age=2592000\";\r\n    }\r\n\r\n    if ($request_filename ~* ^.*[.](html|htm)$) {\r\n      # html使用协商缓存\r\n      add_header Cache-Control \"no-cache\";\r\n    }\r\n  }\r\n}\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## qiankun微前端部署非同级目录\r\n> 主应用和微应用部署到同一个服务器（同一个 IP 和端口）。微应用都放在一个特殊名称的文件夹下，下面案例的文件夹名为child。\r\n\r\n```\r\n1. 主应用访问路径 http://ip\r\n2. react子应用访问路径 http://ip/child/micro-react\r\n3. vue子应用访问路径 http://ip/child/micro-vue\r\n\r\n/home/micro  // 资源目录\r\n    ├── main\r\n        ├── build  // 主应用静态资源\r\n    ├── child  // 微应用存放的文件夹\r\n        ├── micro-react      \r\n            ├── build       // react微应用静态资源\r\n        ├── micro-vue      \r\n            ├── build       // vue微应用静态资源\r\n```\r\n### 子应用配置webpack构建时的publicPath。\r\n```\r\npublicPath: process.env.NODE_ENV === 'development' ? '/' : '/child/micro-vue/build/',\r\n```\r\n### 子应用设置history路由base，用于微应用独立访问时使用。\r\n> 独立访问时的base设置成/child/micro-vue/而不是/child/micro-vue/build/，是因为nginx的location配置成/child/micro-vue/，具体可见下方nginx配置。\r\n\r\n```\r\nbase: window.__POWERED_BY_QIANKUN__ ? '/micro-vue/' : '/child/micro-vue/',\r\n```\r\n### 主应用中注册微应用的entry设置成微应用的部署路径，可以使用相对路径。\r\n> entry路径最后面的 / 不可省略，否则 publicPath 会设置错误。注册微应用的activeRule不能和微应用的部署路径一样，否则在主应用页面刷新会直接变成微应用页面。\r\n\r\n```\r\n// 注册子应用\r\nregisterMicroApps([\r\n  {\r\n    name: 'micro-react',\r\n    entry: process.env.NODE_ENV === 'development' ? '//localhost:8001' : '/child/micro-react/',\r\n    container: '#microContainer',\r\n    activeRule: '/micro-react',\r\n  },\r\n  {\r\n    name: 'micro-vue',\r\n    entry: process.env.NODE_ENV === 'development' ? '//localhost:8002' : '/child/micro-vue/',\r\n    container: '#microContainer',\r\n    activeRule: '/micro-vue',\r\n  },\r\n]);\r\n```\r\n### nginx配置\r\n```\r\nserver {\r\n  # 监听端口\r\n  listen       80;\r\n\r\n  # 服务ip\r\n  server_name  ip;\r\n\r\n  # 开启gzip压缩功能\r\n  gzip on;\r\n\r\n  # 指定会被压缩的文件类型\r\n  gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/json;\r\n\r\n  # 设置压缩级别，越高资源消耗越大，但压缩效果越好\r\n  gzip_comp_level 5;\r\n\r\n  # 在头部中添加Vary: Accept-Encoding（建议开启）\r\n  gzip_vary on;\r\n  \r\n  # 处理压缩请求的缓冲区数量和大小\r\n  gzip_buffers 16 8k;\r\n\r\n  # 对于不支持压缩功能的客户端请求不开启压缩机制\r\n  gzip_disable \"MSIE [1-6]\\.\"; # 低版本的IE浏览器不支持压缩\r\n\r\n  # 设置压缩响应所支持的HTTP最低版本\r\n  gzip_http_version 1.1;\r\n\r\n  # 设置触发压缩的最小阈值\r\n  gzip_min_length 2k;\r\n\r\n  # 关闭对后端服务器的响应结果进行压缩\r\n  gzip_proxied off;\r\n\r\n  # 配置前端静态资源\r\n  # 主应用\r\n  location / {\r\n    root   /home/micro/main/build;\r\n    index  index.html index.htm;\r\n    try_files $uri $uri/ /index.html;\r\n\r\n    # index.html使用协商缓存\r\n    add_header Cache-Control 'no-cache';\r\n\r\n    if ($request_uri ~* .*[.](js|css|map|jpg|png|svg|ico)$) {\r\n      # 非html资源强缓存1个月\r\n      add_header Cache-Control \"max-age=2592000\";\r\n    }\r\n\r\n    if ($request_filename ~* ^.*[.](html|htm)$) {\r\n      # html使用协商缓存\r\n      add_header Cache-Control \"no-cache\";\r\n    }\r\n  }\r\n\r\n  # react子应用\r\n  location /child/micro-react {\r\n    root   /home/micro;\r\n    index  build/index.html build/index.htm;\r\n    try_files $uri $uri/ /child/micro-react/build/index.html;\r\n\r\n    # index.html使用协商缓存\r\n    add_header Cache-Control 'no-cache';\r\n\r\n    if ($request_uri ~* .*[.](js|css|map|jpg|png|svg|ico)$) {\r\n      # 非html资源强缓存1个月\r\n      add_header Cache-Control \"max-age=2592000\";\r\n    }\r\n\r\n    if ($request_filename ~* ^.*[.](html|htm)$) {\r\n      # html使用协商缓存\r\n      add_header Cache-Control \"no-cache\";\r\n    }\r\n  }\r\n\r\n  # vue子应用\r\n  location /child/micro-vue {\r\n    root   /home/micro;\r\n    index  build/index.html build/index.htm;\r\n    try_files $uri $uri/ /child/micro-vue/build/index.html;\r\n\r\n    # index.html使用协商缓存\r\n    add_header Cache-Control 'no-cache';\r\n\r\n    if ($request_uri ~* .*[.](js|css|map|jpg|png|svg|ico)$) {\r\n      # 非html资源强缓存1个月\r\n      add_header Cache-Control \"max-age=2592000\";\r\n    }\r\n\r\n    if ($request_filename ~* ^.*[.](html|htm)$) {\r\n      # html使用协商缓存\r\n      add_header Cache-Control \"no-cache\";\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## 微前端\r\n### 使用微前端的场景\r\n- 项目功能逐渐增多，代码规模庞大，导致代码维护和开发效率低下。\r\n- 项目需要集成多个不同技术栈的模块或服务。\r\n- 团队成员分散，各自负责开发不同的模块或服务，需要实现独立开发和部署。\r\n- 项目需要支持独立的生命周期管理和版本控制。\r\n- 需要实现动态加载和卸载子应用等场景。\r\n### iframe\r\n#### iframe优点\r\n- iframe提供了浏览器原生的硬隔离方案，不论是样式隔离、js隔离这类问题统统都能被完美解决。\r\n#### iframe缺点\r\n1. 隔离性和通信复杂性：iframe本身提供了一种隔离的环境，但这也带来了通信和数据交互的复杂性。由于每个子应用都在独立的iframe中运行，它们之间的通信需要通过特定的机制，而这增加了开发和维护的复杂性。\r\n2. 性能和加载时间：每个iframe都需要加载和渲染独立的HTML、CSS和JavaScript。这意味着在加载微前端应用时，需要同时加载多个iframe，导致额外的网络请求和页面资源占用，可能会影响性能和加载时间。\r\n3. 样式和布局限制：iframe的内容在页面中是独立的，它们具有自己的CSS样式和布局上下文。这导致在微前端架构中难以实现全局样式的一致性，以及子应用之间的布局和交互的协调问题。例如带遮罩层的弹框居中显示的问题。\r\n4. url不同步：浏览器刷新iframe的url状态丢失、后退前进按钮无法使用。\r\n5. 浏览器安全性限制：由于安全策略的限制，iframe之间的跨域通信可能受到限制，特别是在涉及跨域资源访问和共享数据时。这可能导致在微前端架构中需要处理复杂的安全性问题。\r\n### 微前端运行原理\r\n#### 监听路由变化\r\n- 监听hash路由：window.onhashchange。\r\n- 监听history路由：window.onpopstate，重写pushState、replaceState通过函数重写的方式进行劫持。\r\n#### 匹配子应用\r\n> 监听路由的变化后拿到当前路由的路径window.location.pathname，然后根据registerMicroApps注册的子应用的activeRule获取匹配的子应用。\r\n\r\n#### 加载子应用\r\n> 找到当前路由匹配的子应用后可以加载这个子应用的html资源。不能给直接通过container.innerHTML = html将文本放到容器内，这样是无法显示的。浏览器处于安全考虑，放到页面上的html如果包含了js脚本，它是不会去执行js的，需要手动处理script脚本。\r\n\r\n- 将获取到的html文本放到template DOM节点中\r\n- 获取所有的script脚本，script脚本分为内联脚本和外链脚本，拿到内联脚本后获取内容可以通过eval直接处理。如果是含有scr的script脚本，还需要拿到src的值，通过fetch去获取脚本。\r\n- 执行所有的script脚本，通过eval执行脚本。\r\n#### 渲染子应用\r\n\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## 图片资源优化\r\n### 图片懒加载\r\n> 当图片出现在可视区域或者即将出现在可视区域时再加载图片，避免一次性加载全部图片。\r\n\r\n### 图片压缩\r\n> 一些图片适当降低图片质量时，通常是看不出来区别的，可以使用image-webpack-loader进行图片压缩。\r\n\r\n### 使用webp图片\r\n> webp的优势体现在它具有更优的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量；同时具备了无损和有损的压缩模式、Alpha透明以及动画的特性，在JPEG和PNG上的转化效果都相当优秀、稳定和统一。\r\n\r\n### 尽量使用CSS代替图片\r\n> 一些简单的图片效果如果可以通过CSS效果实现则进行用CSS来实现，可以减小请求次数或者打包体积大小。"},function(r,n,e){"use strict";e.r(n),n.default="## 客户端优化H5加载速度\r\n### 容器预建\r\n- 与浏览器不同，App打开H5页面的第一步并不是建立页面请求连接，而是初始化Webview。\r\n- 初始化Webview包括创建Webview实例，对于App冷启动后的首次Webview初始化，还需要初始化浏览器内核。\r\n- 对于冷启动或者全新安装的App，首次初始化Webview耗时相对较长，大概在数百ms；而二次打开就较快了，大概在数十ms。\r\n### 资源离线化\r\n- 将H5资源提前下载或内置到App中。这样加载资源时就可以通过App内部的请求拦截机制转发本地资源，避免网络请求。\r\n- 优化后可以显著降低资源加载的耗时，减少白屏时间，一般不超过100ms（仅剩资源解析和本地 I/O 耗时），不再受弱网限制。"},function(r,n,e){"use strict";e.r(n),n.default='## [性能指标](https://juejin.cn/post/6850037270729359367)\r\n### 性能检测网站\r\n- [https://gtmetrix.com/](https://gtmetrix.com/)\r\n- [https://www.debugbear.com/test](https://www.debugbear.com/test)\r\n### First Paint(FP) 首次绘制\r\n> 首次渲染的时间点，可以视为白屏时间，比如完成背景色渲染的时间点。通常作为时间点最早的一个性能指标。\r\n\r\n### First Contentful Paint(FCP) 首次内容绘制\r\n> 首次有内容渲染的时间点，指标测量页面从开始加载到页面内容的任何部分在屏幕上完成渲染的时间。对于该指标，"内容"指的是文本、图像、`<svg>`元素或非白色的`<canvas>`元素。可以作为首屏时间。\r\n\r\n### Largest Contentful Paint (LCP) 最大内容绘制\r\n> 页面的最大内容（通常是比较核心的内容）加载完成的时间，这个最大内容可以是图片/文本块。它是一个 SEO 相关的指标。LCP 其实能比前两个指标更能体现一个页面的性能好坏程度，当页面出现骨架屏或者 Loading 动画时 FCP 其实已经被记录下来了，但是此时用户希望看到的内容其实并未呈现，我们更想知道的是页面主要的内容是何时呈现出来的。\r\n\r\n### Time to Interactive(TTI) 可交互时间\r\n> Long Task：如果浏览器主线程执行的一个 task 耗时大于 50ms，那么这个 task 称为 long task。用户的交互操作也是在主线程执行的，所以当发生 Long Task 时，用户的交互操作很可能无法及时执行，这时用户就会体验到卡顿（当页面响应时间超过 100ms 时，用户可以体验到卡顿），进而影响用户体验。从页面加载开始到页面处于完全可交互状态所花费的时间。通常是发生在页面依赖的资源已经加载完成，此时浏览器可以快速响应用户交互的时间。\r\n\r\n**满足条件**\r\n- 从 FCP 指标后开始计算\r\n- 持续 5 秒内无长任务（执行时间超过 50 ms）且无两个以上正在进行中的 GET 请求\r\n- 往前回溯至 5 秒前的最后一个长任务结束的时间\r\n\r\n### First Input Delay(FID) 首次输入延迟\r\n> 记录在 FCP 和 TTI 之间用户首次与页面交互时响应的延迟。这个指标的触发是在用户第一次与页面交互的的时候，记录的是是用户第一次与页面交互到浏览器真正能够开始处理事件处理程序以响应该交互的时间，即交互延迟时间。比如发生在用户第一次在页面进行 click， keydown 等交互。发生输入延迟是因为浏览器的主线程正忙着执行其他工作（比如解析和执行大型 JS 文件），还不能响应用户。\r\n\r\n### Cumulative Layout Shift(CLS) 累积布局偏移\r\n> 在一个页面的生命周期中，会不断的发生布局变化（layout shift），对每一次布局变化做一个累积的记分，其中得分最大布局变化即为 CLS。是衡量页面稳定性的重要指标（visual stability）。\r\n\r\n### Total Blocking Time(TBT) 阻塞总时间\r\n> 记录在 FCP 到 TTI 之间所有长任务的阻塞时间总和。\r\n\r\n### First Meaningful Paint(FMP) 首次有效绘制\r\n> 首次绘制有意义内容的时间。业界比较认可的方式是在加载和渲染过程中最大布局变动之后的那个绘制时间即为当前页面的 FMP。因为它计算相对复杂，且存在准确性等问题，Lighthouse 6.0 中被废弃。更多的使用LCP指标。\r\n\r\n### Core Web Vitals\r\n> Google 提出的衡量网站用户体验的核心数据指标，涵盖了页面的加载速度、可交互性和稳定性。是近期生效的会影响 SEO 的重要指标，包含一下三项：LCP、FID、CLS。\r\n\r\n### DOMContentLoaded(DCL)\r\n> DOM 加载完成即触发，不用等页面资源加载。\r\n\r\n### Load(L)\r\n> 页面及其依赖的资源全部加载完成的时间，包括所有的资源文件，如样式表和图片等。\r\n\r\n### FP vs FCP\r\n> 可以把这两个指标认为是和白屏时间相关的指标。\r\n\r\n- FP：从开始加载到第一次渲染，FCP：从开始加载到第一次内容渲染。\r\n- FCP 是 FP 的增强版，对用户来说更关键。因为 FCP 带着图像和文字这些内容信息，是用户更关心的。\r\n- FP时间小于等于FCP。\r\n\r\n### LCP vs FCP\r\n- FCP：页面加载过程中，比较早期的一个指标，如果一个页面有 loading 态，这个指标表现可能很好，但是实际内容什么时候呈现给用户，这个指标没办法衡量。\r\n- LCP：关注页面核心内容呈现时间，这个内容是用户更感兴趣的，更加用户相关。'},function(r,n,e){"use strict";e.r(n),n.default='## 网络层面优化\r\n### http2\r\n- 解析速度快。\r\n- 多路复用，多个请求可以共用一个TCP连接。\r\n- 头部压缩，更小的负载体积。\r\n### 静态资源上传到CDN(内容分发网络)\r\n> 将静态资源上传到CDN，用户请求资源时返回就近节点上缓存的资源，不需要每个用户的请求都回源站获取，避免网络拥塞、缓解源站压力，保证用户访问资源的速度和体验。\r\n\r\n### 充分利用http缓存\r\n> HTML：使用协商缓存。CSS&JS&图片：使用强缓存，将打包的文件名加上contenthash。\r\n\r\n### DNS优化\r\n#### 减少DNS请求次数\r\n#### 缩短DNS解析时间dns-prefetch（DNS预解析）\r\n> 提前解析之后可能会用到的域名，使解析结果缓存到系统缓存中，缩短DNS解析时间，进而提高网站的访问速度。适用于网页引用了大量其他域名的资源。dns-prefetch需慎用，多页面应用重复DNS预解析会增加重复DNS查询次数导致过量的DNS解析，对网络是一种负担。\r\n\r\n```\r\n// 用meta标签来告知浏览器当前页面要做DNS预解析。\r\n<meta http-equiv="x-dns-prefetch-control" content="on" />\r\n\r\n// 用link标签对指定域名做DNS预解析。\r\n<link rel="dns-prefetch" href="https://www.baidu.com/" />\r\n```\r\n#### dns-prefetch原理\r\n> 当浏览器访问一个域名的时候，需要解析一次DNS获得对应域名的ip地址。解析过程按照如下顺序逐步读取缓存直到拿到IP地址。dns-prefetch就是在将解析后的IP缓存在系统中。因为dns-prefetch在本地操作系统做了DNS缓存，使得DNS在解析的过程中，提前在系统缓存中找到了对应IP，后续的解析步骤就不用执行了，有效地缩短了DNS解析时间。\r\n\r\n- 浏览器缓存\r\n- 系统缓存\r\n- 路由器缓存\r\n- ISP(运营商)DNS缓存\r\n- 根域名服务器\r\n- 顶级域名服务器\r\n- 主域名服务器\r\n#### DNS解析耗时\r\n> dns-prefetch可以给DNS解析过程带来15-300ms的提升，尤其是一些大量引用很多其他域名资源的网站，提升效果就更加明显了。\r\n\r\n- 假如浏览器首次将一个域名解析为IP地址，并缓存至操作系统，那么下一次DNS解析时间可以低至0-1ms。\r\n- 假如解析结果不缓存在系统，那么就需要读取路由器的缓存，进而后续的解析时间最小也要约15ms。\r\n- 如果路由器缓存也不存在，则需要读取ISP(运营商)DNS缓存，一般像taobao.com、baidu.com这些常见的域名，读取ISP(运营商)DNS缓存需要的时间在80-120ms，如果是不常见的域名，平均需要200-300ms。大部分的网站到运营商这块都能找到IP。\r\n#### 浏览器DNS缓存\r\n- 现代浏览器为了优化DNS解析，也设有了浏览器DNS缓存。\r\n- 每当在首次DNS解析后会对其IP进行缓存。缓存时长每种浏览器都不一样，比如Chrome的过期时间是1分钟，在这个期限内不会重新请求DNS。\r\n- 每当Chrome浏览器启动的时候，就会自动的快速解析浏览器最近一次启动时记录的前10个域名。所以经常访问的网址就不存在DNS解析的延迟，进而打开速度更快。\r\n- 而dns-prefetch相当于在浏览器缓存之后，在本地操作系统中做了DNS缓存，为的是给浏览器缓存做保障，尽量让DNS解析存储在本地，以此做了又一层的DNS解析优化。\r\n- DNS在系统的缓存时间是大于浏览器的。\r\n#### 浏览器与系统DNS缓存时间\r\n> TTL(Time-To-Live)就是一条域名解析记录在DNS服务器中的存留时间，国内和国际上很多平台的TTL值都是以秒为单位的，很多的默认值都是3600，也就是默认缓存1小时。\r\n\r\n- 浏览器DNS缓存的时间跟DNS服务器返回的TTL值无关, 它的缓存时间取决于浏览器自身设置。\r\n- 系统缓存会参考DNS服务器响应的TTL值，但是不完全等于TTL值。\r\n#### dns-prefetch最佳实践\r\n- dns-prefetch仅对跨域域上的DNS查找有效，因此请避免使用它来指向相同域。这是因为到浏览器看到提示时站点域背后的IP已经被解析。\r\n- 考虑将dns-prefetch与preconnect(预连接)搭配使用。\r\n    - 由于dns-prefetch仅执行DNS查找，不像preconnect会建立与服务器的连接。如果站点是通过HTTPS服务的，两者的组合会涵盖DNS解析，建立TCP连接以及执行TLS握手。将两者结合起来可提供进一步减少跨域请求的感知延迟的机会。\r\n    - 如果页面需要建立与许多第三方域的连接，则将它们预先连接会适得其反。preconnect提示最好仅用于最关键的连接，对于其它的连接使用dns-prefetch节省第一步的DNS查找时间即可。\r\n```\r\n<link rel="preconnect" href="https://www.baidu.com/" crossorigin>\r\n<link rel="dns-prefetch" href="https://www.baidu.com/" />\r\n```\r\n### 自托管第三方资源\r\n> 第三方资源官方的cdn比较慢的情况下可以考虑自托管三方资源，根据项目实际情况进行使用。'},function(r,n,e){"use strict";e.r(n),n.default="## 资源体积优化\r\n### 单独打包css及压缩css代码\r\n  - webpack默认将js代码和css代码打包到一个文件，可使用mini-css-extract-plugin单独打包css会减少整包的体积。\r\n  - 使用css-minimizer-webpack-plugin压缩css代码。\r\n### 压缩代码\r\n> 如果使用的是webpack v5或更高版本是自带的功能，如果是v5以下或者希望自定义配置，可使用terser-webpack-plugin实现压缩。\r\n\r\n### 开启gzip压缩\r\n### 路由懒加载Suspense + React.lazy\r\n### 代码分割optimization.splitChunks\r\n- webpack默认会将所有模块代码打包在一起，这种规则的优点是能减少页面的HTTP请求数，缺点是页面初始代码包过大影响首屏渲染性能。\r\n- 无法有效使用http缓存，分包可避免代码修改整个bundle缓存失效。\r\n### 三方依赖单独使用cdn引入，使用externals属性单独配置。\r\n### 三方依赖的按需引入\r\n> 如果直接引入整个依赖，会导致项目的体积过大，可以只引入需要使用的内容，以达到减小项目体积的目的。\r\n\r\n```\r\nimport lodash -> import lodash/get\r\n```\r\n### 使用支持Tree Shaking的三方依赖\r\n```\r\nimport lodash -> import lodash-es\r\n```\r\n### 替换使用更小的库\r\n- 使用dayjs替换moment。\r\n### 语言包按需加载\r\n- 使用moment只保留en-gb、zh-cn两个语言包时gzip体积小53kb\r\n```\r\n// 只引入中文和英文两个语言包\r\nnew webpack.ContextReplacementPlugin(/moment[/\\\\]locale$/, /en-gb|zh-cn/)\r\n```\r\n### 减少不必要的三方依赖的使用\r\n> yarn why查看依赖被引用的情况。可根据项目实际情况减少三方依赖的使用。\r\n\r\n### polyfill按需加载\r\n> polyfill是为了浏览器兼容性而生，是否需要polyfill应该由客户端的浏览器自己决定，而不是开发者决定，可以通过设置应用要运行的目标浏览器环境实现polyfill的按需加载。\r\n\r\n### 使用时动态导入模块，不在首页就加载(组件懒加载)\r\n- xlsx下载文件，在使用的时候再加载xlsx依赖。使用动态import引入的依赖可以单独打包出来。\r\n\r\n```\r\nconst buttonClick = async() => {\r\n  // 使用时异步引入xlsx模块\r\n  const xlsx = await import('xlsx');\r\n  xlsx.writeFile(wb, filename)\r\n}\r\n```\r\n```\r\nconst srcSuccess = []\r\n\r\nfunction stdOnEnd(script, cb) {\r\n  script.onload = function () {\r\n    this.onerror = this.onload = null\r\n    cb(null, script)\r\n  }\r\n  script.onerror = function () {\r\n    // this.onload = null here is necessary\r\n    // because even IE9 works not like others\r\n    this.onerror = this.onload = null\r\n    cb(new Error('Failed to load ' + this.src), script)\r\n  }\r\n}\r\n\r\nfunction ieOnEnd(script, cb) {\r\n  script.onreadystatechange = function () {\r\n    if (this.readyState !== 'complete' && this.readyState !== 'loaded') return\r\n    this.onreadystatechange = null\r\n    cb(null, script) // there is no way to catch loading errors in IE8\r\n  }\r\n}\r\n\r\nfunction load(src, opts, cb) {\r\n  var head = document.head || document.getElementsByTagName('head')[0]\r\n  var script = document.createElement('script')\r\n\r\n  if (typeof opts === 'function') {\r\n    cb = opts\r\n    opts = {}\r\n  }\r\n\r\n  opts = opts || {}\r\n  cb = cb || function () {}\r\n\r\n  script.type = opts.type || 'text/javascript'\r\n  script.charset = opts.charset || 'utf8'\r\n  script.async = 'async' in opts ? !!opts.async : true\r\n  script.src = src\r\n\r\n  if (opts.attrs) {\r\n    for (var attr in opts.attrs) {\r\n      script.setAttribute(attr, opts.attrs[attr])\r\n    }\r\n  }\r\n\r\n  if (opts.text) {\r\n    script.text = '' + opts.text\r\n  }\r\n\r\n  const callback = (error, script) => {\r\n    cb(error, script)\r\n    error && head.removeChild(script)\r\n  }\r\n\r\n  var onend = 'onload' in script ? stdOnEnd : ieOnEnd\r\n  onend(script, callback)\r\n\r\n  // some good legacy browsers (firefox) fail the 'in' detection above\r\n  // so as a fallback we always set onload\r\n  // old IE will ignore this and new IE will set onload\r\n  if (!script.onload) {\r\n    stdOnEnd(script, callback)\r\n  }\r\n\r\n  head.appendChild(script)\r\n}\r\n\r\n\r\nconst importScript = (src, opts) => {\r\n  if (srcSuccess.indexOf(src) !== -1) {\r\n    return Promise.resolve()\r\n  }\r\n  return new Promise((resolve, reject) => {\r\n    load(src, opts, (error, script) => {\r\n      if (error) {\r\n        reject(error)\r\n      } else {\r\n        srcSuccess.push(src)\r\n        resolve()\r\n      }\r\n    })\r\n  })\r\n}\r\n\r\nexport default importScript\r\n\r\n// 使用\r\nconst onExport = async () => {\r\n  const isSuccess = await importScript(\"https://cdn.bootcdn.net/ajax/libs/xlsx/0.18.5/xlsx.full.min.js\", { async: false });\r\n  if (isSuccess) {\r\n    // 下载逻辑\r\n    ...\r\n  } else {\r\n    message.error('资源加载失败');\r\n  }\r\n}\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## 项目细节优化\r\n### 长时间任务优化\r\n> 浏览器单线程的运行方式决定了JavaScript长时间运行的任务会阻塞UI渲染和用户交互，从而影响性能。\r\n\r\n- 使用Web Worker执行长时间任务避免阻塞UI。\r\n- 对于长时间任务可以将其分解为一系列较小的任务并在空闲时执行，使用时间切片的策略。\r\n```\r\nfunction chunk(taskList, iteration, context) {\r\n  requestIdleCallback((deadline) => {\r\n    while (deadline.timeRemaining() > 0 && taskList.length > 0) {\r\n      iteration.call(context, taskList.shift());\r\n    }\r\n\r\n    if (taskList.length > 0) {\r\n      chunk(taskList, iteration, context);\r\n    }\r\n  });\r\n}\r\n\r\nchunk(longTasks, (task) => {\r\n  task.execute();\r\n}, this);\r\n```\r\n### 交互形式优化\r\n- 合理使用防抖和节流\r\n- 骨架屏优化白屏时长\r\n- 长列表\r\n    - 滚动加载更多\r\n    - 分页实现\r\n    - 虚拟列表\r\n### 动画优化\r\n- 使用CSS3动画替代JavaScript动画\r\n- 使用requestAnimationFrame进行动画处理\r\n### 布局优化\r\n- 避免回流和重绘\r\n> 回流和重绘是浏览器渲染过程中的两个步骤，它们对性能影响很大。优化的关键在于尽可能减少触发回流和重绘的操作，例如一次性修改样式避免布局抖动等。\r\n\r\n- 将CSS放在html头部，JavaScript文件放在html底部\r\n> css文件链接尽量放在html头部，css加载不会阻塞DOM Tree解析，但是会阻塞DOM Tree渲染，也会阻塞后面js执行。也就是说DOM Tree在渲染前就要解析好CSS，从而减少浏览器重排文档的次数。而且css放在页面底部会导致页面白屏时间变长。js文件一般放在页面底部，这是防止js的加载和解析阻塞页面元素的正常渲染。\r\n\r\n- 避免使用同步布局\r\n> 同步布局(或强制布局)是指浏览器强制在DOM修改和计算样式之后，立即进行布局。这会中断浏览器的优化过程导致性能下降。一般出现在连续的样式修改和读取操作之间。\r\n\r\n```\r\nlet div = document.querySelector('div');\r\n\r\n// 写样式\r\ndiv.style.width = '100px';\r\n// 读样式，导致同步布局\r\nlet width = div.offsetWidth;\r\n// 再写样式\r\ndiv.style.height = width + 'px';  // 强制布局\r\n\r\n\r\n// 为避免这个问题，可以将读操作移到所有写操作之后：\r\nlet div = document.querySelector('div');\r\n\r\n// 写样式\r\ndiv.style.width = '100px';\r\n// 写样式\r\ndiv.style.height = '100px';\r\n// 读样式\r\nlet width = div.offsetWidth;\r\n```\r\n### 字体图标优化\r\n> 使用字体图标代替图片图标，字体图标使用方便灵活、矢量方式设计不会失真、资源体积小。\r\n\r\n### 代码编写优化\r\n- 减少DOM的操作，尽可能的合并DOM操作\r\n- 使用事件委托减少事件处理器的数量\r\n- 优化循环\r\n```\r\n// 不好的写法\r\nfor (let i = 0; i < arr.length; i++) {\r\n  console.log(arr[i]);\r\n}\r\n\r\n// 好的写法\r\nlet length = arr.length;\r\nfor (let i = 0; i < length; i++) {\r\n  console.log(arr[i]);\r\n}\r\n\r\n// 更好的写法\r\narr.forEach((item) => {\r\n  console.log(item);\r\n});\r\n```\r\n- 避免过度使用全局变量，全局变量会占用更多的内存，从而降低程序的运行效率。\r\n- 避免不必要的闭包\r\n- 利用浏览器缓存，将一些经常用到的、变化不大的数据存储在本地，以减少对服务器的请求。可以使用localStorage或sessionStorage来存储这些数据。\r\n- 减少cookie大小，消除不必要的cookie。cookie传输会造成带宽浪费，影响响应时间。\r\n- 在for-in循环中使用hasOwnProperty方法会查询对象的整个原型链，这可能会影响性能。在for-in循环中应该直接访问对象的属性。\r\n- 使用位操作进行整数运算，比传统的算术运算符更快。\r\n- 使用WeakMap和WeakSet进行高效的内存管理。\r\n- 通过Intersection Observer API可以知道一个元素何时进入或离开视口，实现图片或者其他资源的懒加载时可以使用。\r\n- 使用Web Socket进行数据通信，当需要频繁地与服务器进行数据交换可以使用Web Socket，比HTTP有更低的开销。\r\n- 避免使用with语句，with语句会改变代码的作用域，这可能会导致性能问题。\r\n- 使用双缓冲技术进行绘图\r\n> 当需要进行频繁的绘图操作时，可以使用双缓冲技术，即先在离屏画布上进行绘图，然后一次性将离屏画布的内容复制到屏幕上，这样可以避免屏幕闪烁，并且提升绘图性能。\r\n\r\n```\r\nvar offscreenCanvas = document.createElement('canvas');\r\nvar offscreenContext = offscreenCanvas.getContext('2d');\r\n\r\n// 在离屏画布上进行绘图...\r\noffscreenContext.fillRect(0, 0, 100, 100);\r\n\r\n// 将离屏画布的内容复制到屏幕上\r\ncontext.drawImage(offscreenCanvas, 0, 0);\r\n```\r\n### 使用新技术优化\r\n- 通过服务器端渲染(SSR)改善首次页面加载性能\r\n> 服务器端渲染意味着在服务器上生成HTML，然后将其发送到客户端。这可以加快首次页面加载速度，因为用户可以直接看到渲染好的页面，而不必等待JavaScript下载并执行。这对于性能要求很高的应用来说，是一种有效的优化手段。\r\n\r\n- 使用IndexedDB存储大量数据\r\n> 如果需要在客户端存储大量数据，可以使用IndexedDB。与localStorage相比IndexedDB可以存储更大量的数据，并且支持事务和索引。\r\n\r\n- 使用WebRTC进行实时通信\r\n> WebRTC是一种提供实时通信能力的技术，允许数据直接在浏览器之间传输，对于需要实时交互的应用，如视频聊天、实时游戏等可以使用WebRTC来提高性能。\r\n\r\n- 使用WebGL进行3D渲染\r\n> WebGL是一种用于进行3D渲染的Web标准，它提供了底层的图形API，并且能够利用GPU进行加速，非常适合于进行复杂的3D渲染。\r\n\r\n- 使用Service Worker进行资源缓存\r\n> Service Workers可以让你控制网页的缓存策略，进一步减少HTTP请求，提升网页的加载速度，可以将一些不常变化的资源文件预先缓存起来。\r\n\r\n- 使用Progressive Web Apps(PWA)技术\r\n> PWA可以让网站在离线时仍然可用，并且可以被添加到用户的主屏幕，提供类似于原生应用的体验。PWA需要使用Service Workers和Manifest等技术。\r\n\r\n- 使用WebAssembly进行性能关键部分的开发\r\n> WebAssembly是一种新的编程语言，它的代码运行速度接近原生代码，非常适合进行性能关键部分的开发。例如可以用WebAssembly来开发图形渲染、物理模拟等复杂任务。"},function(r,n,e){"use strict";e.r(n),n.default="## 手写ES6数组方法\r\n### forEach\r\n```\r\nArray.prototype.myForEach = function(callback, thisArg) {\r\n  if (!((typeof callback === 'Function' || typeof callback === 'function') && this)) {\r\n    throw new TypeError();\r\n  }\r\n  const arr = Object(this);  // this 就是调用当前方法的数组\r\n  const len = arr.length >>> 0;  // 转换为正整数\r\n  let i = 0;\r\n  while (i < len) {\r\n    if (i in arr) {\r\n      callback.call(thisArg, arr[i], i, arr);\r\n    }\r\n    i++;\r\n  }\r\n}\r\n\r\n// 使用\r\nconst arr = new Array(1, 2, 3)\r\narr.myForEach((item, index, arr) => {\r\n  console.log(item, index, arr)\r\n})\r\nconsole.log(arr)\r\n```\r\n### map\r\n```\r\nArray.prototype.myMap = function(callback, thisArg) {\r\n  if (!((typeof callback === 'Function' || typeof callback === 'function') && this)) {\r\n    throw new TypeError();\r\n  }\r\n  const arr = Object(this)  // this 就是调用当前方法的数组\r\n  const len = arr.length >>> 0  // 转换为正整数\r\n  let i = 0\r\n  let res = []\r\n  while (i < len) {\r\n    if (i in arr) {\r\n      res[i] = callback.call(thisArg, arr[i], i, arr);\r\n    }\r\n    i++;\r\n  }\r\n  return res\r\n}\r\n\r\nconst arr = new Array(1, 2, 3)\r\nconst arr1 = arr.myMap((item, index, arr) => item + 1)\r\nconsole.log(arr)\r\nconsole.log(arr1)\r\n```\r\n### filter\r\n```\r\nArray.prototype.myFilter = function(callback, thisArg) {\r\n  if (!((typeof callback === 'Function' || typeof callback === 'function') && this)) {\r\n    throw new TypeError();\r\n  }\r\n  const arr = Object(this)  // this 就是调用当前方法的数组\r\n  const len = arr.length >>> 0  // 转换为正整数\r\n  let i = 0\r\n  let res = [] // 返回值\r\n  while (i < len) {\r\n    if (i in arr) {\r\n      if (callback.call(thisArg, arr[i], i, arr)) {\r\n        res.push(arr[i])\r\n      }\r\n    }\r\n    i++;\r\n  }\r\n  return res\r\n}\r\n\r\nconst arr = new Array(1, 2, 3)\r\nconst arr1 = arr.myFilter((item, index, arr) => item > 1)\r\nconsole.log(arr)\r\nconsole.log(arr1)\r\n```\r\n### some\r\n```\r\nArray.prototype.mySome = function(callback, thisArg) {\r\n  if (!((typeof callback === 'Function' || typeof callback === 'function') && this)) {\r\n    throw new TypeError();\r\n  }\r\n  const arr = Object(this)  // this 就是调用当前方法的数组\r\n  const len = arr.length >>> 0  // 转换为正整数\r\n  let i = 0\r\n  while (i < len) {\r\n    if (i in arr) {\r\n      if (callback.call(thisArg, arr[i], i, arr)) {\r\n        return true\r\n      }\r\n    }\r\n    i++;\r\n  }\r\n  return false\r\n}\r\n\r\n// 使用\r\nconst arr = new Array(1, 2, 3)\r\nconst res = arr.mySome((item, index, arr) => item > 1)\r\nconst res1 = [].mySome((item, index, arr) => item > 1)\r\nconsole.log(arr)\r\nconsole.log(res)\r\nconsole.log(res1) // 空数组使用返回 false\r\n```\r\n### every\r\n```\r\nArray.prototype.myEvery = function(callback, thisArg) {\r\n  if (!((typeof callback === 'Function' || typeof callback === 'function') && this)) {\r\n    throw new TypeError();\r\n  }\r\n  const arr = Object(this)  // this 就是调用当前方法的数组\r\n  const len = arr.length >>> 0  // 转换为正整数\r\n  let i = 0\r\n  while (i < len) {\r\n    if (i in arr) {\r\n      if (!callback.call(thisArg, arr[i], i, arr)) {\r\n        return false\r\n      }\r\n    }\r\n    i++;\r\n  }\r\n  return true\r\n}\r\n\r\n// 使用\r\nconst arr = new Array(1, 2, 3)\r\nconst res = arr.myEvery((item, index, arr) => item > 1)\r\nconst res1 = [].myEvery((item, index, arr) => item > 1)\r\nconsole.log(arr)\r\nconsole.log(res)\r\nconsole.log(res1) // 空数组使用返回 true\r\n```\r\n### reduce\r\n```\r\nArray.prototype.myReduce = function(callback, initialValue) {\r\n  if (!((typeof callback === 'Function' || typeof callback === 'function') && this)) {\r\n    throw new TypeError();\r\n  }\r\n  const arr = Object(this)  // this 就是调用当前方法的数组\r\n  const len = arr.length >>> 0  // 转换为正整数\r\n  let i = 0, res\r\n  \r\n  if (arguments.length > 1) {\r\n    res = initialValue\r\n  } else {\r\n    // 没传入初始值的时候，取数组中第一个非 empty 的值为初始值\r\n    while (i < len && !(i in arr)) {\r\n      i++\r\n    }\r\n    // 空数组必须有初始值否则抛错\r\n    if (i >= len) {\r\n      throw new TypeError( 'Reduce of empty array with no initial value' );\r\n    }\r\n    res = arr[i++]\r\n  }\r\n  while (i < len) {\r\n    if (i in arr) {\r\n      res = callback(res, arr[i], i, arr)\r\n    }\r\n    i++\r\n  }\r\n  return res\r\n}\r\n\r\n// 使用\r\nconst arr = new Array(1, 2, 3)\r\nconst emptyArr = new Array()\r\nconst res = arr.myReduce((prev, curr) => console.log(prev, curr))\r\nconst res1 = emptyArr.myReduce((prev, curr) => console.log(prev, curr))\r\nconsole.log(arr)\r\nconsole.log(res)\r\nconsole.log(res1)\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## 手写bind、call、apply\r\n### bind\r\n- 形式一\r\n```\r\nFunction.prototype.myBind = function(context) {\r\n  var self = this;\r\n  var args = Array.prototype.slice.call(arguments, 1);\r\n  var fNOP = function () {};\r\n  var fBound = function () {\r\n    var bindArgs = Array.prototype.slice.call(arguments);\r\n    var finalArgs = args.concat(bindArgs);\r\n    return self.apply(this instanceof fNOP ? this : context, finalArgs);\r\n  }\r\n\r\n  fNOP.prototype = this.prototype;\r\n  fBound.prototype = new fNOP();\r\n  return fBound;\r\n}\r\n```\r\n- 使用\r\n```\r\nconst obj = { name: 'douyaxing' };\r\nvar name = 'dyx';\r\nfunction exer(age, sex) {\r\n  console.log(this.name, age, sex);\r\n}\r\nexer(18, 'man');\r\nconst newExer = exer.myBind(obj, 23);\r\nnewExer('man');\r\n```\r\n### call\r\n- 形式一\r\n```\r\nFunction.prototype.myCall = function(context) {\r\n  var context = context || window;\r\n  context.fn = this;\r\n  var args = [];\r\n\r\n  for(var i = 1, len = arguments.length; i < len; i++) {\r\n    args.push('arguments[' + i + ']');\r\n  }\r\n  var result = eval('context.fn(' + args +')');\r\n\r\n  delete context.fn;\r\n  return result;\r\n}\r\n```\r\n- 形式二\r\n```\r\nFunction.prototype.myCall = function(context, ...args) {\r\n  context = context || window;\r\n  context.fn = this;\r\n  let result = context.fn(...args);\r\n  delete context.fn;\r\n  return result;\r\n}\r\n```\r\n- 使用\r\n```\r\nconst obj = { name: 'douyaxing' };\r\nconst obj1 = { name: 'douyaxing23' };\r\nvar name = 'dyx';\r\nfunction exer(age, sex) {\r\n  console.log(this.name, age, sex);\r\n}\r\nexer(18, 'man');\r\nexer.myCall(obj, '23', 'women');\r\nexer.myCall(obj1, '2', 'women');\r\n```\r\n### apply\r\n- 形式1\r\n```\r\nFunction.prototype.myApply = function(context, arr) {\r\n  var context = context || window;\r\n  context.fn = this;\r\n\r\n  var result;\r\n  if (!arr) {\r\n    result = context.fn();\r\n  } else {\r\n    var args = [];\r\n    for (var i = 0, len = arr.length; i < len; i++) {\r\n      args.push('arr[' + i + ']');\r\n    }\r\n    result = eval('context.fn(' + args + ')');\r\n  }\r\n  delete context.fn;\r\n  return result;\r\n}\r\n```\r\n- 形式2\r\n```\r\nFunction.prototype.myApply = function(context) {\r\n  context = context || window;\r\n  context.fn = this;\r\n  let result;\r\n  if (arguments[1]) {\r\n    result = context.fn(...arguments[1]);\r\n  } else {\r\n    result = context.fn();\r\n  }\r\n  delete context.fn;\r\n  return result;\r\n}\r\n```\r\n- 使用\r\n```\r\nconst obj = { name: 'douyaxing' };\r\nconst obj1 = { name: 'douyaxing23' };\r\nvar name = 'dyx';\r\nfunction exer(age, sex) {\r\n  console.log(this.name, age, sex);\r\n}\r\nexer(18, 'man');\r\nexer.myApply(obj, ['23', 'women']);\r\nexer.myApply(obj1, ['2', 'women']);\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## 手写instanceof\r\n> 递归获取实例的原型，判断其是否和构造函数的原型对象相等。\r\n\r\n```\r\nconst myInstanceof = (left, right) => {\r\n  // 边界判断\r\n  if (typeof left !== 'object' && typeof left !== 'function' || left === null) return false;\r\n  let proto = Object.getPrototypeOf(left);   // 获取左侧对象实例的原型\r\n  while (proto !== right.prototype) {  // 找到了就终止循环\r\n    if (proto === null) return false;    // 找不到返回 false\r\n    proto = Object.getPrototypeOf(proto);   // 沿着原型链继续获取原型\r\n  }\r\n  return true;\r\n}\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## [手写Promise](https://juejin.cn/post/6945319439772434469)\r\n### 基本功能\r\n1. Promise 是一个类，在执行这个类的时候会传入一个执行器，这个执行器会立即执行,执行器会传入内部的resolve和reject方法供调用的时候使用\r\n```\r\nclass MyPromise {\r\n  constructor(executor){\r\n    // 立即执行并传入resolve和reject方法\r\n    executor(this.resolve, this.reject) \r\n  }\r\n\r\n  // 用箭头函数就可以让this指向当前实例对象\r\n  // 更改成功后的状态\r\n  resolve = () => {}\r\n\r\n  // 更改失败后的状态\r\n  reject = () => {}\r\n}\r\n```\r\n2. Promise 会有三种状态Pending 等待, Fulfilled 完成, Rejected 失败,状态只能由 Pending --\x3e Fulfilled 或者 Pending --\x3e Rejected，且一但发生改变便不可二次修改\r\n3. Promise 中使用 resolve 和 reject 两个函数来更改状态；\r\n```\r\n// 先定义三个常量表示状态\r\nconst PENDING = 'pending';\r\nconst FULFILLED = 'fulfilled';\r\nconst REJECTED = 'rejected';\r\n\r\nclass MyPromise {\r\n  constructor(executor){\r\n    // 立即执行并传入resolve和reject方法\r\n    executor(this.resolve, this.reject)\r\n  }\r\n\r\n  // 储存状态的变量，初始值是 pending\r\n  status = PENDING;\r\n\r\n  // 成功之后的值\r\n  value = null;\r\n\r\n  // 失败之后的原因\r\n  reason = null;\r\n\r\n  // 用箭头函数就可以让this指向当前实例对象\r\n  // 更改成功后的状态\r\n  resolve = (value) => {\r\n    // 只有状态是等待，才执行状态修改\r\n    if (this.status === PENDING) {\r\n      // 状态修改为成功\r\n      this.status = FULFILLED;\r\n      // 保存成功之后的值\r\n      this.value = value;\r\n    }\r\n  }\r\n\r\n  // 更改失败后的状态\r\n  reject = (reason) => {\r\n    // 只有状态是等待，才执行状态修改\r\n    if (this.status === PENDING) {\r\n      // 状态成功为失败\r\n      this.status = REJECTED;\r\n      // 保存失败后的原因\r\n      this.reason = reason;\r\n    }\r\n  }\r\n}\r\n```\r\n4. then 方法内部做的事情就是状态判断,如果状态是成功，调用成功回调函数, 如果状态是失败，调用失败回调函数\r\n```\r\nthen(onFulfilled, onRejected) {\r\n  // 判断状态\r\n  if (this.status === FULFILLED) {\r\n    // 调用成功回调，并且把值返回\r\n    onFulfilled(this.value);\r\n  } else if (this.status === REJECTED) {\r\n    // 调用失败回调，并且把原因返回\r\n    onRejected(this.reason);\r\n  }\r\n}\r\n```\r\n\r\n### Promise处理异步，保证.then的执行等待异步执行完\r\n> then方法中判断当前的状态，如果是Pending 则缓存成功和失败的回调函数，待状态改变之后在对应的reject或resolve方法中调用对应的回调函数。\r\n\r\n```\r\n// 存储成功回调函数\r\nonFulfilledCallback = null;\r\n\r\n// 存储失败回调函数\r\nonRejectedCallback = null;\r\n\r\nthen(onFulfilled, onRejected) {\r\n  // 判断状态\r\n  if (this.status === FULFILLED) {\r\n    // 调用成功回调，并且把值返回\r\n    onFulfilled(this.value);\r\n  } else if (this.status === REJECTED) {\r\n    // 调用失败回调，并且把原因返回\r\n    onRejected(this.reason);\r\n  } else if (this.status === PENDING) {\r\n    // 将成功回调和失败回调存储起来，等到执行成功失败函数的时候再传递\r\n    this.onFulfilledCallback = onFulfilled;\r\n    this.onRejectedCallback = onRejected;\r\n  }\r\n}\r\n\r\n// 用箭头函数就可以让this指向当前实例对象\r\n// 更改成功后的状态\r\nresolve = (value) => {\r\n  // 只有状态是等待，才执行状态修改\r\n  if (this.status === PENDING) {\r\n    // 状态修改为成功\r\n    this.status = FULFILLED;\r\n    // 保存成功之后的值\r\n    this.value = value;\r\n    // 判断成功回调是否存在，如果存在就调用\r\n    this.onFulfilledCallback && this.onFulfilledCallback(value);\r\n  }\r\n}\r\n\r\n// 更改失败后的状态\r\nreject = (reason) => {\r\n  // 只有状态是等待，才执行状态修改\r\n  if (this.status === PENDING) {\r\n    // 状态成功为失败\r\n    this.status = REJECTED;\r\n    // 保存失败后的原因\r\n    this.reason = reason;\r\n    // 判断失败回调是否存在，如果存在就调用\r\n    this.onRejectedCallback && this.onRejectedCallback(reason)\r\n  }\r\n}\r\n```\r\n### then方法的多次调用实现\r\n> 由于then方法可以多次调用，所以缓存时应该缓存所有的回调函数(数组存储)，状态改变之后调用的时候循环调用存储的回调函数。\r\n\r\n```\r\n// 存储成功回调函数\r\nonFulfilledCallbacks = [];\r\n\r\n// 存储失败回调函数\r\nonRejectedCallbacks = [];\r\n\r\nthen(onFulfilled, onRejected) {\r\n  // 判断状态\r\n  if (this.status === FULFILLED) {\r\n    // 调用成功回调，并且把值返回\r\n    onFulfilled(this.value);\r\n  } else if (this.status === REJECTED) {\r\n    // 调用失败回调，并且把原因返回\r\n    onRejected(this.reason);\r\n  } else if (this.status === PENDING) {\r\n    // 将成功回调和失败回调存储起来，等到执行成功失败函数的时候再传递\r\n    this.onFulfilledCallbacks.push(onFulfilled);\r\n    this.onRejectedCallbacks.push(onRejected);\r\n  }\r\n}\r\n\r\n// 更改成功后的状态\r\nresolve = (value) => {\r\n  // 只有状态是等待，才执行状态修改\r\n  if (this.status === PENDING) {\r\n    // 状态修改为成功\r\n    this.status = FULFILLED;\r\n    // 保存成功之后的值\r\n    this.value = value;\r\n    // resolve里面将所有成功的回调拿出来执行\r\n    while (this.onFulfilledCallbacks.length) {\r\n      // Array.shift() 取出数组第一个元素，然后（）调用，shift不是纯函数，取出后，数组将失去该元素，直到数组为空\r\n      this.onFulfilledCallbacks.shift()(value)\r\n    }\r\n  }\r\n}\r\n\r\n// 更改失败后的状态\r\nreject = (reason) => {\r\n  // 只有状态是等待，才执行状态修改\r\n  if (this.status === PENDING) {\r\n    // 状态成功为失败\r\n    this.status = REJECTED;\r\n    // 保存失败后的原因\r\n    this.reason = reason;\r\n    // reject里面将所有失败的回调拿出来执行\r\n    while (this.onRejectedCallbacks.length) {\r\n      this.onRejectedCallbacks.shift()(reason)\r\n    }\r\n  }\r\n}\r\n```\r\n### then方法的链式调用\r\n> then 方法要链式调用就需要返回一个 Promise 对象。then 方法里面 return 一个返回值作为下一个 then 方法的参数，如果是 return 一个 Promise 对象，那么就需要判断它的状态。\r\n\r\n```\r\nclass MyPromise {\r\n  // ......\r\n  then(onFulfilled, onRejected) {\r\n    // 为了链式调用这里直接创建一个 MyPromise，并在后面 return 出去\r\n    const promise2 = new MyPromise((resolve, reject) => {\r\n      // 这里的内容在执行器中，会立即执行\r\n      if (this.status === FULFILLED) {\r\n        // 获取成功回调函数的执行结果\r\n        const x = onFulfilled(this.value);\r\n        // 传入 resolvePromise 集中处理\r\n        resolvePromise(x, resolve, reject);\r\n      } else if (this.status === REJECTED) {\r\n        onRejected(this.reason);\r\n      } else if (this.status === PENDING) {\r\n        this.onFulfilledCallbacks.push(onFulfilled);\r\n        this.onRejectedCallbacks.push(onRejected);\r\n      }\r\n    }) \r\n    return promise2;\r\n  }\r\n}\r\n\r\nfunction resolvePromise(x, resolve, reject) {\r\n  // 判断x是不是 MyPromise 实例对象\r\n  if(x instanceof MyPromise) {\r\n    // 执行 x，调用 then 方法，目的是将其状态变为 fulfilled 或者 rejected\r\n    // x.then(value => resolve(value), reason => reject(reason))\r\n    // 简化之后\r\n    x.then(resolve, reject)\r\n  } else {\r\n    // 普通值\r\n    resolve(x)\r\n  }\r\n}\r\n```\r\n### then方法判断是否返回自己\r\n> 如果 then 方法返回的是自己的 Promise 对象，则会发生循环调用，这个时候程序会报错\r\n\r\n1. 判断返回的Promise是否等于自己，如果等于自己抛错\r\n2. 判断的过程在Promise的运行过程中，此时无法获取到返回的Promise，所以判断的过程需要创建微任务queueMicrotask(可以使用setTimeout来代替)来处理，保证可以获取到返回的Promise\r\n```\r\nclass MyPromise {\r\n  // ......\r\n  then(onFulfilled, onRejected) {\r\n    const promise2 = new MyPromise((resolve, reject) => {\r\n      if (this.status === FULFILLED) {\r\n        // 创建一个微任务等待 promise2 完成初始化\r\n        queueMicrotask(() => {\r\n          // 获取成功回调函数的执行结果\r\n          const x = onFulfilled(this.value);\r\n          // 传入 resolvePromise 集中处理\r\n          resolvePromise(promise2, x, resolve, reject);\r\n        })  \r\n      } else if (this.status === REJECTED) {\r\n        onRejected(this.reason);\r\n      } else if (this.status === PENDING) {\r\n        this.onFulfilledCallbacks.push(onFulfilled);\r\n        this.onRejectedCallbacks.push(onRejected);\r\n      }\r\n    }) \r\n    \r\n    return promise2;\r\n  }\r\n}\r\n\r\nfunction resolvePromise(promise2, x, resolve, reject) {\r\n  // 如果相等了，说明return的是自己，抛出类型错误并返回\r\n  if (promise2 === x) {\r\n    return reject(new TypeError('Chaining cycle detected for promise #<Promise>'))\r\n  }\r\n  if (x instanceof MyPromise) {\r\n    x.then(resolve, reject)\r\n  } else {\r\n    resolve(x)\r\n  }\r\n}\r\n```\r\n### 参考 fulfilled 状态下的处理方式，对 rejected 和 pending 状态进行改造\r\n```\r\nthen(onFulfilled, onRejected) {\r\n  // 为了链式调用这里直接创建一个 MyPromise，并在后面 return 出去\r\n  const promise2 = new MyPromise((resolve, reject) => {\r\n    // 判断状态\r\n    if (this.status === FULFILLED) {\r\n      // 创建一个微任务等待 promise2 完成初始化\r\n      queueMicrotask(() => {\r\n        try {\r\n          // 获取成功回调函数的执行结果\r\n          const x = onFulfilled(this.value);\r\n          // 传入 resolvePromise 集中处理\r\n          resolvePromise(promise2, x, resolve, reject);\r\n        } catch (error) {\r\n          reject(error)\r\n        } \r\n      })  \r\n    } else if (this.status === REJECTED) { \r\n      // 创建一个微任务等待 promise2 完成初始化\r\n      queueMicrotask(() => {\r\n        try {\r\n          // 调用失败回调，并且把原因返回\r\n          const x = onRejected(this.reason);\r\n          // 传入 resolvePromise 集中处理\r\n          resolvePromise(promise2, x, resolve, reject);\r\n        } catch (error) {\r\n          reject(error)\r\n        } \r\n      }) \r\n    } else if (this.status === PENDING) {\r\n      // 将成功回调和失败回调存储起来，等到执行成功失败函数的时候再传递\r\n      this.onFulfilledCallbacks.push(() => {\r\n        queueMicrotask(() => {\r\n          try {\r\n            // 获取成功回调函数的执行结果\r\n            const x = onFulfilled(this.value);\r\n            // 传入 resolvePromise 集中处理\r\n            resolvePromise(promise2, x, resolve, reject);\r\n          } catch (error) {\r\n            reject(error)\r\n          } \r\n        }) \r\n      });\r\n      this.onRejectedCallbacks.push(() => {\r\n        queueMicrotask(() => {\r\n          try {\r\n            // 调用失败回调，并且把原因返回\r\n            const x = onRejected(this.reason);\r\n            // 传入 resolvePromise 集中处理\r\n            resolvePromise(promise2, x, resolve, reject);\r\n          } catch (error) {\r\n            reject(error)\r\n          } \r\n        }) \r\n      });\r\n    }\r\n  }) \r\n  \r\n  return promise2;\r\n}\r\n```\r\n### then方法的参数可选\r\n> then方法的参数可以不传或者单传都不影响执行，then方法的参数进行判断，没有传入参数时执行默认的方法\r\n\r\n```\r\nthen(onFulfilled, onRejected) {\r\n  // 如果不传，就使用默认函数\r\n  onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value => value;\r\n  onRejected = typeof onRejected === 'function' ? onRejected : reason => { throw reason };\r\n\r\n  // ......\r\n}\r\n```\r\n### 捕获错误\r\n1. 捕获执行器中的代码，如果执行器中有代码错误(外部调用的语法)，那么 Promise 的状态要变为失败\r\n2. then方法执行时捕获错误\r\n```\r\n// 执行器捕获错误\r\nconstructor(executor) {\r\n  // 立即执行并传入resolve和reject方法\r\n  try {\r\n    executor(this.resolve, this.reject)\r\n  } catch (error) {\r\n    // 如果有错误，就直接执行 reject\r\n    this.reject(error)\r\n  }\r\n}\r\n\r\n// then方法执行捕获错误\r\nthen(onFulfilled, onRejected) {\r\n  // 为了链式调用这里直接创建一个 MyPromise，并在后面 return 出去\r\n  const promise2 = new MyPromise((resolve, reject) => {\r\n    // 判断状态\r\n    if (this.status === FULFILLED) {\r\n      // 创建一个微任务等待 promise2 完成初始化\r\n      queueMicrotask(() => {\r\n        try {\r\n          // 获取成功回调函数的执行结果\r\n          const x = onFulfilled(this.value);\r\n          // 传入 resolvePromise 集中处理\r\n          resolvePromise(promise2, x, resolve, reject);\r\n        } catch (error) {\r\n          reject(error)\r\n        }  \r\n      })  \r\n    } else if (this.status === REJECTED) {\r\n      // 调用失败回调，并且把原因返回\r\n      onRejected(this.reason);\r\n    } else if (this.status === PENDING) {\r\n      // 将成功回调和失败回调存储起来，等到执行成功失败函数的时候再传递\r\n      this.onFulfilledCallbacks.push(onFulfilled);\r\n      this.onRejectedCallbacks.push(onRejected);\r\n    }\r\n  }) \r\n  return promise2;\r\n}\r\n```\r\n### resolve和reject的静态调用\r\n> 在Promise类中使用static关键字实现resolve和reject方法，方法的内部就是调用new Promise((resolve, reject) => {})\r\n\r\n```\r\n// resolve 静态方法\r\nstatic resolve (parameter) {\r\n  // 如果传入 MyPromise 就直接返回\r\n  if (parameter instanceof MyPromise) {\r\n    return parameter;\r\n  }\r\n\r\n  // 转成常规方式\r\n  return new MyPromise(resolve =>  {\r\n    resolve(parameter);\r\n  });\r\n}\r\n\r\n// reject 静态方法\r\nstatic reject (reason) {\r\n  return new MyPromise((resolve, reject) => {\r\n    reject(reason);\r\n  });\r\n}\r\n```\r\n### 全量实现\r\n```\r\n// 先定义三个常量表示状态\r\nconst PENDING = 'pending';\r\nconst FULFILLED = 'fulfilled';\r\nconst REJECTED = 'rejected';\r\n\r\n// 新建 MyPromise 类\r\nclass MyPromise {\r\n  constructor(executor) {\r\n    // 会立即执行并传入resolve和reject方法\r\n    try {\r\n      executor(this.resolve, this.reject)\r\n    } catch (error) {\r\n      this.reject(error)\r\n    }\r\n  }\r\n\r\n  // 储存状态的变量，初始值是 pending\r\n  status = PENDING;\r\n  // 成功之后的值\r\n  value = null;\r\n  // 失败之后的原因\r\n  reason = null;\r\n\r\n  // 存储成功回调函数\r\n  onFulfilledCallbacks = [];\r\n  // 存储失败回调函数\r\n  onRejectedCallbacks = [];\r\n\r\n  // 更改成功后的状态\r\n  resolve = (value) => {\r\n    // 只有状态是等待，才执行状态修改\r\n    if (this.status === PENDING) {\r\n      // 状态修改为成功\r\n      this.status = FULFILLED;\r\n      // 保存成功之后的值\r\n      this.value = value;\r\n      // resolve里面将所有成功的回调拿出来执行\r\n      while (this.onFulfilledCallbacks.length) {\r\n        // Array.shift() 取出数组第一个元素，然后（）调用，shift不是纯函数，取出后，数组将失去该元素，直到数组为空\r\n        this.onFulfilledCallbacks.shift()(value)\r\n      }\r\n    }\r\n  }\r\n\r\n  // 更改失败后的状态\r\n  reject = (reason) => {\r\n    // 只有状态是等待，才执行状态修改\r\n    if (this.status === PENDING) {\r\n      // 状态成功为失败\r\n      this.status = REJECTED;\r\n      // 保存失败后的原因\r\n      this.reason = reason;\r\n      // resolve里面将所有失败的回调拿出来执行\r\n      while (this.onRejectedCallbacks.length) {\r\n        this.onRejectedCallbacks.shift()(reason)\r\n      }\r\n    }\r\n  }\r\n\r\n  then(onFulfilled, onRejected) {\r\n    const realOnFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value => value;\r\n    const realOnRejected = typeof onRejected === 'function' ? onRejected : reason => { throw reason };\r\n\r\n    // 为了链式调用这里直接创建一个 MyPromise，并在后面 return 出去\r\n    const promise2 = new MyPromise((resolve, reject) => {\r\n      const fulfilledMicrotask = () =>  {\r\n        // 创建一个微任务等待 promise2 完成初始化\r\n        queueMicrotask(() => {\r\n          try {\r\n            // 获取成功回调函数的执行结果\r\n            const x = realOnFulfilled(this.value);\r\n            // 传入 resolvePromise 集中处理\r\n            resolvePromise(promise2, x, resolve, reject);\r\n          } catch (error) {\r\n            reject(error)\r\n          } \r\n        })  \r\n      }\r\n\r\n      const rejectedMicrotask = () => { \r\n        // 创建一个微任务等待 promise2 完成初始化\r\n        queueMicrotask(() => {\r\n          try {\r\n            // 调用失败回调，并且把原因返回\r\n            const x = realOnRejected(this.reason);\r\n            // 传入 resolvePromise 集中处理\r\n            resolvePromise(promise2, x, resolve, reject);\r\n          } catch (error) {\r\n            reject(error)\r\n          } \r\n        }) \r\n      }\r\n\r\n      // 判断状态\r\n      if (this.status === FULFILLED) {\r\n        fulfilledMicrotask() \r\n        // 可以使用setTimeout实现\r\n        setTimeout(() => {\r\n          try {\r\n            let x = realOnFulfilled(this.value);\r\n            x instanceof MyPromise ? x.then(resolve, reject) : resolve(x)\r\n          } catch (err) {\r\n            reject(err)\r\n          }\r\n        })\r\n      } else if (this.status === REJECTED) { \r\n        rejectedMicrotask()\r\n      } else if (this.status === PENDING) {\r\n        // 将成功回调和失败回调存储起来，等到执行成功失败函数的时候再传递\r\n        this.onFulfilledCallbacks.push(fulfilledMicrotask);\r\n        this.onRejectedCallbacks.push(rejectedMicrotask);\r\n      }\r\n    }) \r\n    \r\n    return promise2;\r\n  }\r\n\r\n  // resolve 静态方法\r\n  static resolve(parameter) {\r\n    // 如果传入 MyPromise 就直接返回\r\n    if (parameter instanceof MyPromise) {\r\n      return parameter;\r\n    }\r\n\r\n    // 转成常规方式\r\n    return new MyPromise(resolve =>  {\r\n      resolve(parameter);\r\n    });\r\n  }\r\n\r\n  // reject 静态方法\r\n  static reject(reason) {\r\n    return new MyPromise((resolve, reject) => {\r\n      reject(reason);\r\n    });\r\n  }\r\n}\r\n\r\nfunction resolvePromise (promise2, x, resolve, reject) {\r\n  // 如果相等了，说明return的是自己，抛出类型错误并返回\r\n  if (promise2 === x) {\r\n    return reject(new TypeError('Chaining cycle detected for promise #<Promise>'))\r\n  }\r\n  // 判断x是不是 MyPromise 实例对象\r\n  if(x instanceof MyPromise) {\r\n    // 执行 x，调用 then 方法，目的是将其状态变为 fulfilled 或者 rejected\r\n    // x.then(value => resolve(value), reason => reject(reason))\r\n    // 简化之后\r\n    x.then(resolve, reject)\r\n  } else{\r\n    // 普通值\r\n    resolve(x)\r\n  }\r\n}\r\n\r\nmodule.exports = MyPromise;\r\n```\r\n### Promise.resolve\r\n- Promise.resolve最终结果还是一个Promise，并且与Promise.resolve(该值)传入的值息息相关\r\n- 传入的参数可以是一个Promise实例，那么该函数执行的结果是直接将实例返回\r\n- 如果这个值是thenable（即带有\"then\" 方法），返回的promise会“跟随”这个thenable的对象，采用它的最终状态；否则返回的promise将以此值完成。\r\n```\r\nPromise.resolve = function(value) {\r\n  // 如果是 Promsie，则直接返回\r\n  if (value && typeof value === 'object' && value instanceof Promise) {\r\n    return value;\r\n  }\r\n  return new Promise(resolve => resolve(value))\r\n}\r\n```\r\n### Promise.reject\r\n> Promise.reject() 方法返回一个带有拒绝原因的Promise对象。\r\n\r\n```\r\nPromise.reject = function(reason) {\r\n  return new Promise((resolve, reject) => reject(reason))\r\n}\r\n```\r\n### Promise.all\r\n```\r\nPromise.all = function(promiseArr) {\r\n  let count = 0, result = [];\r\n  const len = promiseArr.length;\r\n  return new Promise((resolve, reject) => {\r\n    if (len === 0) {\r\n      return resolve([]);\r\n    }\r\n    promiseArr.forEach((p, i) => {\r\n      Promise.resolve(p).then(val => {\r\n        count++\r\n        result[i] = val\r\n        // 全部resolve之后才返回最终的值\r\n        if (count === promiseArr.length) {\r\n          resolve(result)\r\n        }\r\n      }, err => {\r\n        reject(err)\r\n      })\r\n    })\r\n  })\r\n}\r\n```\r\n### Promise.allSettled\r\n```\r\nPromise.allSettled = (promiseArr) => {\r\n  let count = 0, result = [];\r\n  const len = promiseArr.length\r\n  return new Promise((resolve, reject) => {\r\n    // 数组是空的话，直接返回空数据\r\n    if (len === 0) {\r\n      return resolve([]);\r\n    }\r\n    promiseArr.forEach((p, i) => {\r\n      Promise.resolve(p).then((res) => {\r\n        count += 1\r\n        // 成功属性设置 \r\n        result[ i ] = {\r\n          status: 'fulfilled',\r\n          value: res\r\n        }\r\n        \r\n        if (count === len) {\r\n          rs(result)\r\n        }\r\n      }).catch((err) => {\r\n        count += 1\r\n        // 失败属性设置 \r\n        result[i] = { \r\n          status: 'rejected', \r\n          reason: err \r\n        }\r\n        if (count === len) {\r\n          rs(result)\r\n        }\r\n      })\r\n    })\r\n  })\r\n}\r\n```\r\n### Promise.race\r\n```\r\nPromise.race = function(promiseArr) {\r\n  return new Promise((resolve, reject) => {\r\n    promiseArr.forEach(p => {\r\n      Promise.resolve(p).then(val => {\r\n        // 有一个resolve之后就返回最终的值\r\n        resolve(val)\r\n      }, err => {\r\n        reject(err)\r\n      })\r\n    })\r\n  })\r\n}\r\n```\r\n### Promise 并行限制\r\n```\r\nclass Scheduler {\r\n  constructor() {\r\n    this.queue = [];\r\n    this.maxCount = 2;\r\n    this.runCounts = 0;\r\n  }\r\n  add(promiseCreator) {\r\n    this.queue.push(promiseCreator);\r\n  }\r\n  taskStart() {\r\n    for (let i = 0; i < this.maxCount; i++) {\r\n      this.request();\r\n    }\r\n  }\r\n  request() {\r\n    if (!this.queue || !this.queue.length || this.runCounts >= this.maxCount) {\r\n      return;\r\n    }\r\n    this.runCounts++;\r\n\r\n    this.queue.shift()().then(() => {\r\n      this.runCounts--;\r\n      this.request();\r\n    });\r\n  }\r\n}\r\n   \r\nconst timeout = time => new Promise(resolve => {\r\n  setTimeout(resolve, time);\r\n})\r\n  \r\nconst scheduler = new Scheduler();\r\n  \r\nconst addTask = (time,order) => {\r\n  scheduler.add(() => timeout(time).then(()=>console.log(order)))\r\n}\r\n  \r\n  \r\naddTask(1000, '1');\r\naddTask(500, '2');\r\naddTask(300, '3');\r\naddTask(400, '4');\r\nscheduler.taskStart()\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## 字典\r\n> 一个存储唯一值的结构，以键值对的形式存储，js中有字典数据结构 就是 Map 类型。"},function(r,n,e){"use strict";e.r(n),n.default="## 栈\r\n> 栈是一种特殊的线性表。特点是只能在表的一端操作。可以操作的端称为栈顶，不可以操作的另一端称为栈底。栈的特性是先进后出。比如蒸馒头的笼屉、羽毛球筒。js中没有栈的数据类型。\r\n\r\n### js 实现\r\n```\r\nclass Stack {\r\n\tconstructor() {\r\n\t\t// 存储数据\r\n\t\tthis.items = [];\r\n\t}\r\n\r\n\tpush(item) {\r\n\t\t// 入栈\r\n\t\tthis.items.push(item);\r\n\t}\r\n\r\n\tpop() {\r\n\t\t// 出栈\r\n\t\treturn this.items.pop();\r\n\t}\r\n\r\n\ttop() {\r\n\t\t// 获取栈顶元素\r\n\t\treturn this.items[this.items.length - 1];\r\n\t}\r\n\r\n\tclear() {\r\n\t\t// 清空栈\r\n\t\tthis.items = [];\r\n\t}\r\n\r\n\tsize() {\r\n\t\t// 获取栈的大小\r\n\t\treturn this.items.length;\r\n\t}\r\n\r\n\tisEmpty() {\r\n\t\t// 判断栈是否为空\r\n\t\treturn this.items.length === 0;\r\n\t}\r\n}\r\n```\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## 树\r\n> 树是一种数据结构，它是由 n(n>=1)个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。\r\n\r\n- 无序树：树中任意节点的子结点之间没有顺序关系，这种树称为无序树,也称为自由树。\r\n- 有序树：树中任意节点的子结点之间有顺序关系，这种树称为有序树。\r\n- 二叉树：每个节点最多含有两个子树的树称为二叉树。\r\n- 满二叉树：叶节点除外的所有节点均含有两个子树的树被称为满二叉树。\r\n- 完全二叉树：除最后一层外，所有层都是满节点，且最后一层缺右边连续节点的二叉树称为完全二叉树（堆就是一个完全二叉树）。\r\n- 哈夫曼树（最优二叉树）：带权路径最短的二叉树称为哈夫曼树或最优二叉树。\r\n### 二叉树\r\n![二叉树](./img/二叉树.png)\r\n\r\n```\r\nfunction Node(data) {\r\n  this.data = data;\r\n  this.left = null;\r\n  this.right = null;\r\n}\r\n\r\nconst nodeA = new Node('A');\r\nconst nodeB = new Node('B');\r\nconst nodeC = new Node('C');\r\nconst nodeD = new Node('D');\r\nconst nodeE = new Node('E');\r\nconst nodeF = new Node('F');\r\nconst nodeG = new Node('G');\r\n\r\nnodeA.left = nodeB;\r\nnodeA.right = nodeC;\r\nnodeB.left = nodeD;\r\nnodeB.right = nodeE;\r\nnodeC.left = nodeF;\r\nnodeC.right = nodeG;\r\n```\r\n### 深度优先遍历\r\n> 尽可能深的搜索树的分支,就比如遇到一个节点就会直接去遍历他的子节点，不会立刻去遍历他的兄弟节点。\r\n\r\n- 访问根节点\r\n- 对根节点的 children 挨个进行深度优先遍历\r\n```\r\nconst dfs = (tree) => {\r\n  tree.children.forEach(dfs)\r\n};\r\n```\r\n### 广度优先遍历\r\n> 先访问离根节点最近的节点, 如果有兄弟节点就会先遍历兄弟节点，再去遍历自己的子节点。\r\n\r\n- 新建一个队列 并把根节点入队\r\n- 把队头出队并访问\r\n- 把队头的children挨个入队\r\n- 重复第二 、三步 直到队列为空\r\n```\r\nconst bfs = (tree) => {\r\n  const q = [tree];\r\n  while (q.length > 0) {\r\n    const n = q.shift()\r\n    console.log(n.val);\r\n    n.children.forEach(c => q.push(c))\r\n  }\r\n};\r\n```\r\n#### 二叉树层序遍历\r\n![二叉树层序遍历](./img/二叉树层序遍历.png)\r\n```\r\n// 需要返回 [[1], [2,3], [4,5]]\r\n\r\n\r\n// 时间复杂度 O(n) n为树的节点数\r\n// 空间复杂度 O(n) \r\nvar levelOrder = function (root) {\r\n  if (!root) return []\r\n   \r\n  // 广度优先遍历\r\n  const q = [root];\r\n  const res = [];\r\n  while (q.length) {\r\n    let len = q.length\r\n    res.push([])\r\n    // 循环每层的节点数量次\r\n    while (len--) {\r\n      const n = q.shift();\r\n      res[res.length - 1].push(n.val)\r\n      if (n.left) q.push(n.left);\r\n      if (n.right) q.push(n.right);\r\n    }\r\n  }\r\n  return res\r\n};\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## 链表\r\n> 由若干个结点链结成一个链表，称之为链式存储结构。通过 next 指针来链接, 最底层为 null。\r\n\r\n```\r\nconst Node = function (data) {\r\n  this.data = data;\r\n  this.next = null;\r\n}\r\n\r\nconst node1 = new Node(1);\r\nconst node2 = new Node(2);\r\nconst node3 = new Node(3);\r\n\r\nnode1.next = node2;\r\nnode2.next = node3;\r\n```\r\n### 链表和数组的区别\r\n> 链表和数组都可以存储多个数据。数组需要一块连续的内存空间来存储数据，对内存的要求比较高。而链表却相反，它并不需要一块连续的内存空间。链表是通过指针将一组零散的内存块串联在一起。相比数组，链表是一种稍微复杂一点的数据结构。两者没有好坏之分，各有各的优缺点。由于内存存储特性，数组可以实现快速的查找元素，但是在插入和删除时就需要移动大量的元素。原因就在于相邻元素在内存中的位置也是紧挨着的，中间没有空隙，因此就无法快速添加元素。而当删除后，内存空间中就会留出空隙，自然需要弥补。\r\n\r\n- 单向链表\r\n![单向链表](./img/单向.png)\r\n- 双向链表\r\n![双向链表](./img/双向.png)\r\n- 单向循环链表\r\n![单向循环链表](./img/单向循环.png)\r\n- 双向循环链表\r\n![双向循环链表](./img/双向循环.png)\r\n- 环形链表\r\n![环形链表](./img/环形.png)\r\n- 相交链表\r\n![环形链表](./img/相交.png)\r\n- 回文链表\r\n![回文链表](./img/回文.png)\r\n\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## 队列\r\n> 队列也是一种特殊的线性表，可以进行删除操作的端称为队首，而可以进行插入操作的端称为队尾。删除一个元素称为出队，插入一个元素称为入队。和栈一样，队列也是一种操作受限制的线性表。队列的特性是先进先出。比如排队。 js中没有队列的数据类型。\r\n\r\n```\r\nclass Queue {\r\n  constructor() {\r\n    // 存储数据\r\n    this.items = [];\r\n  }\r\n\r\n  enqueue(item) {\r\n    // 入队\r\n    this.items.push(item);\r\n  }\r\n\r\n  dequeue() {\r\n    // 出队\r\n    return this.items.shift();\r\n  }\r\n\r\n  head() {\r\n    // 获取队首的元素\r\n    return this.items[0];\r\n  }\r\n\r\n  tail() {\r\n    // 获取队尾的元素\r\n    return this.items[this.items.length - 1];\r\n  }\r\n\r\n  clear() {\r\n    // 清空队列\r\n    this.items = [];\r\n  }\r\n\r\n  size() {\r\n    // 获取队列的长度\r\n    return this.items.length;\r\n  }\r\n\r\n  isEmpty() {\r\n    // 判断队列是否为空\r\n    return this.items.length === 0;\r\n  }\r\n}\r\n```\r\n\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## 集合\r\n> 一种无序且唯一的数据结构，ES6中有集合 Set 类型。"},function(r,n,e){"use strict";e.r(n),n.default="## refreshToken\r\n> 用户携带的accessToken过期时，用户需要重新获取新的accessToken，而refreshToken就用来重新获取新的accessToken的凭证。\r\n\r\n### 使用refreshToken可以提高安全性\r\n> 有了refreshToken可以降低accessToken被盗的风险。\r\n\r\n- 用户在访问网站时，accessToken被盗取了，此时攻击者就可以拿这个accessToke访问权限以内的功能了。如果accessToken设置一个短暂的有效期2小时，攻击者能使用被盗取的accessToken的时间最多也就2个小时，除非再通过refreshToken刷新accessToken才能正常访问。\r\n- 设置accessToken有效期是永久的，用户在更改密码之后，之前的accessToken也是有效的。\r\n\r\n### 请求前判断token是否过期\r\n> 在请求前利用最初请求返回的字段expires_in字段来判断access_token是否已经过期，若已过期则将请求挂起，先刷新access_token后再继续请求。\r\n\r\n- 优点\r\n  1. 能节省http请求。\r\n- 缺点\r\n  1. 因为使用了本地时间判断，若本地时间被篡改，有校验失败的风险。\r\n### 响应拦截器里判断是否过期\r\n> 响应拦截器里拦截返回后的数据。先发起请求，如果接口返回access_token过期，刷新access_token再进行一次重试。\r\n\r\n- 优点\r\n  1. 无需判断时间。\r\n- 缺点\r\n  1. 会消耗多一次http请求。\r\n### 响应拦截器里判断是否过期代码实现\r\n1. 创建isRefreshing = false变量存储否正在刷新token，创建requests = []变量存储待重发请求。\r\n2. 当请求返回401(约定好为token过期)且不是请求刷新token的接口时特殊处理。\r\n3. 如果正在刷新token(isRefreshing为true)\r\n  - 返回未执行resolve的Promise。\r\n  - requests变量存储当前的请求(用函数形式将resolve存入，等待token刷新后再执行)。\r\n4. 如果没有正在刷新token(isRefreshing为false)，请求刷新token的接口(开始请求时isRefreshing改为true，请求结束之后isRefreshing改为false)\r\n  - 请求成功时\r\n    1. 存储新的token。\r\n    2. 使用新的token将requests数组中的请求重新执行并清空requests变量。\r\n    3. 并重新发起原来的请求。\r\n  - 请求失败时\r\n    1. 需跳转到登录页重新登录。\r\n```\r\n/**\r\n * axios 请求方法\r\n */\r\nimport axios, { AxiosRequestConfig } from 'axios';\r\nimport { message } from 'antd';\r\nimport qs from 'qs';\r\nimport history from './history';\r\n\r\n// 刷新access_token的接口\r\nconst refreshToken = () => {\r\n  return request.post('/auth/refresh', { refresh_token: 'refresh_token' });\r\n}\r\n\r\nconst request = axios.create({\r\n  baseURL: '',\r\n  timeout: 300000,\r\n  paramsSerializer: function (params) {\r\n    return qs.stringify(params, { arrayFormat: 'brackets' })\r\n  }\r\n});\r\n\r\n// 请求头添加access_token\r\nrequest.interceptors.request.use((config: AxiosRequestConfig) => {\r\n  const accessToken = localStorage.getItem('access_token');\r\n  if (accessToken && config.headers) {\r\n    config.headers.access_token = accessToken;\r\n  }\r\n  return config;\r\n})\r\n\r\nlet isRefreshing: boolean = false;// 标记是否正在刷新token\r\nlet requests: any = []; // 存储待重发请求的数组\r\n\r\nrequest.interceptors.response.use(response => {\r\n  const { data: { code, msg } } = response;\r\n  // code非0的请求进行特殊提示\r\n  if (code && code !== 0) {\r\n    message.warning(msg);\r\n  }\r\n  return response;\r\n}, error => {\r\n  // 请求失败时的提示\r\n  if (!error.response) {\r\n    message.error('请求失败，请重试');\r\n    return Promise.reject(error);\r\n  }\r\n  // 请求返回401且不是请求刷新token的接口\r\n  if (error.response?.status === 401 && error.config.url !== '/auth/refresh') {\r\n    const { config } = error;\r\n    if (isRefreshing) {\r\n      // 返回未执行resolve的Promise\r\n      return new Promise(resolve => {\r\n        // 用函数形式将resolve存入，等待刷新后再执行\r\n        requests.push((token: string) => {\r\n          resolve(request(config))\r\n        });\r\n      })\r\n    } else {\r\n      isRefreshing = true;\r\n      return refreshToken().then(res => {\r\n        const { access_token } = res.data;\r\n        // 存储新的token\r\n        localStorage.setItem('access_token', access_token);\r\n        // token刷新后将数组中的请求重新执行\r\n        requests.forEach((cb: any) => cb(access_token));\r\n        requests = []; // 重新请求完清空\r\n        return request(config);\r\n      }).catch(err => {\r\n        // 刷新token的接口请求失败时需重新登录\r\n        message.error('抱歉，您的登录状态已失效，请重新登录');\r\n        history.push('/login');\r\n        return Promise.reject(err);\r\n      }).finally(() => {\r\n        isRefreshing = false;\r\n      })\r\n    }\r\n  }\r\n  message.error(error.message || '请求失败，请重试');\r\n  return Promise.reject(error);\r\n})\r\n\r\nexport default request;\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## sendBeacon\r\n> navigator.sendBeacon是一个用于发送少量数据到服务器的浏览器API。\r\n\r\n### 优点\r\n- 异步和非阻塞：navigator.sendBeacon是异步的，它不会阻塞浏览器的其他操作，不会影响到页面的性能。\r\n- 在页面卸载时仍然可以发送数据：当用户离开页面(例如关闭页面或者导航到其他页面)时，navigator.sendBeacon仍然可以发送数据。\r\n- 低优先级：navigator.sendBeacon发送的请求是低优先级的，它不会影响到页面的其他网络请求。\r\n- 简单易用：navigator.sendBeacon的API非常简单，只需要提供上报的URL和数据，就可以发送请求。\r\n### 缺点\r\n- 只能发送POST请求，不能发送GET请求。\r\n- 发送的请求没有返回值，不能接收服务器的响应。\r\n- 一些旧的浏览器可能不支持navigator.sendBeacon。在使用navigator.sendBeacon时需要根据实际情况进行兼容性处理。\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## 数据请求\r\n### ajax\r\n> 一种异步通信的方法，通过直接由 js 脚本向服务器发起 http 通信，然后根据服务器返回的数据，更新网页的相应部分，而不用刷新整个页面的一种方法。\r\n\r\n```\r\n// 1：创建Ajax对象\r\nvar xhr = window.XMLHttpRequest ? new XMLHttpRequest(): new ActiveXObject('Microsoft.XMLHTTP'); // 兼容IE6及以下版本\r\n\r\n// 2：配置 Ajax请求地址\r\nxhr.open('get', 'index.xml', true);\r\n\r\n// 3：发送请求\r\nxhr.send(null); // 严谨写法\r\n\r\n// 4:监听请求，接受响应\r\nxhr.onreadysatechange = function(){\r\n  if (xhr.readySate == 4 && xhr.status == 200 || xhr.status == 304) {\r\n    console.log(xhr.responsetXML)\r\n  }\r\n}\r\n```\r\n### fetch\r\n### axios\r\n### 终止请求\r\n> AbortController允许根据需要中止一个或多个Web请求。\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## 轮询\r\n> 适用需要多次调用接口的情景\r\n\r\n### 短轮询\r\n> 浏览器定时向服务器发送请求，获取最新数据，由于定时发送请求，两次请求之间的数据更新并不能及时响应，可能会有实时数据更新不及时的情况。\r\n\r\n```\r\n// 请求数据方法\r\nconst request = () => {}\r\n// 每隔5秒发送一次请求\r\nsetInterval(request(), 5000)\r\n```\r\n### 长轮询\r\n> 页面发送请求，保持连接，当数据有更新时，服务端返回新的数据，随机又发起下一次的数据请求，要注意请求的超时设置问题。\r\n\r\n```\r\n// 请求数据方法\r\nconst request = () => {}\r\n// 当数据请求返回结果后发起下一次请求\r\nrequest().then(res => {\r\n  request();\r\n})\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## 冒泡排序\r\n- 比较所有相邻元素，如果第一个比第二个大就交换它们。\r\n- 执行一次后可以保证当前循环的最后一个数字是最大的。\r\n- 重复执行 n-1 次，就可以完成排序。\r\n```\r\n// 时间复杂度 O(n ^ 2) n为数组长度\r\n// 空间复杂度 O(1)\r\n\r\nconst bubbleSort = (arr) => {\r\n  for (i = 0; i < arr.length - 1; i++) {\r\n    for (let j = 0; j < arr.length - 1 - i; j++) {\r\n      if (arr[j] > arr[j + 1]) {\r\n        // 交换数据\r\n        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];\r\n      }\r\n    }\r\n  }\r\n  return arr;\r\n}\r\n```\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## 归并排序\r\n- 分： 把数组劈成两半 在递归的对子数组进行分操作，直到分成一个个单独的数\r\n- 合： 把两个数合并为有序数组，再对有序数组进行合并，直到全部子数组合并为一个完整的数组\r\n```\r\n// 时间复杂度 O(nlogn) 分需要劈开数组，所以是logn，合则是n\r\n// 空间复杂度 O(n)\r\n\r\nconst mergeSort = (originArr) => {\r\n  const rec = (arr) => {\r\n    // 递归终点\r\n    if (arr.length === 1) return arr;\r\n    // 获取中间索引\r\n    const mid = arr.length >> 1;\r\n    // 通过中间下标,进行分割数组\r\n    const left = arr.slice(0, mid);\r\n    const right = arr.slice(mid);\r\n    // 左边和右边的数组进行递归，会得到有序的左数组,和有序的右数组\r\n    const orderLeft = rec(left);\r\n    const orderRight = rec(right);\r\n    // 存放结果的数组\r\n    const res = [];\r\n    // 对两个有序数组进行顺序合并\r\n    while (orderLeft.length || orderRight.length) {\r\n      // 如左边和右边数组都有值\r\n      if (orderLeft.length && orderRight.length) {\r\n        // 左边队头的值小于右边队头的值 就左边队头出队,否则就是右边队头出队\r\n        res.push(orderLeft[0] < orderRight[0] ? orderLeft.shift() : orderRight.shift())\r\n      } else if (orderLeft.length) {\r\n        // 把左边的队头放入数组\r\n        res.push(orderLeft.shift())\r\n      } else if (orderRight.length) {\r\n        // 把右边的队头放入数组\r\n        res.push(orderRight.shift())\r\n      }\r\n    }\r\n    return res;\r\n  }\r\n  const res = rec(originArr);\r\n  return res;\r\n}\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## 快速排序\r\n- 分区：从数组中任意选择一个基准，所有比基准小的元素放在基准前面，比基准大的元素放在基准后面。\r\n- 递归：递归的对基准前后的子数组进行分区。\r\n```\r\n// 时间复杂度 O(nlogN)\r\n// 空间复杂度 O(1)\r\n\r\nconst quickSort = (originArr) => {\r\n  const rec = (arr) => {\r\n    // 如果数组长度小于等于1 就不用排序了\r\n    if (arr.length <= 1) {\r\n      return arr;\r\n    }\r\n    // 存放基准前后的数组\r\n    const left = [];\r\n    const right = [];\r\n    // 取基准\r\n    const mid = arr[0];\r\n    for (let i = 1; i < arr.length; i++) {\r\n      // 如果当前值小于基准就放到基准前数组里面\r\n      if (arr[i] < mid) {\r\n        left.push(arr[i]);\r\n      } else {\r\n        // 否则就放到基准后数组里面\r\n        right.push(arr[i]);\r\n      }\r\n    }\r\n    // 递归调用两边的子数组\r\n    return [...rec(left), mid, ...rec(right)];\r\n  };\r\n\r\n  const res = rec(originArr);\r\n  return res;\r\n}\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## 插入排序\r\n- 从第二个数，开始往前比较。\r\n- 如它大就往后排。\r\n- 以此类推进行到最后一个数。\r\n```\r\n// 时间复杂度 O(n ^ 2)\r\n\r\nconst insertionSort = (arr) => {\r\n  // 遍历数组 从第二个开始\r\n  for (let i = 1; i < arr.length; i++) {\r\n    // 获取第二个元素\r\n    const temp = arr[i];\r\n    let j = i;\r\n    while (j > 0) {\r\n      // 如果当前元素小于前一个元素，当前元素的值修改为前一个元素的值\r\n      if (arr[j - 1] > temp) {\r\n        arr[j] = arr[j - 1];\r\n      } else {\r\n        // 否则就跳出循环\r\n        break;\r\n      }\r\n      // 递减\r\n      j--;\r\n    }\r\n    // 前一位置赋值为当前元素\r\n    arr[j] = temp;\r\n  }\r\n  return arr;\r\n}\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## 选择排序\r\n- 找到数组中最小的值，选中它并放到第一位。\r\n- 接着找到数组中第二小的值，选中它并放到第二位。\r\n- 重复上述步骤执行 n-1 次。\r\n```\r\n// 时间复杂度：O(n ^ 2) n为数组长度\r\n// 空间复杂度：O(1)\r\n\r\nconst selectionSort = (arr) => {\r\n  for (let i = 0; i < arr.length - 1; i++) {\r\n    let indexMin = i;\r\n    for (let j = i; j < arr.length; j++) {\r\n      // 如果当前这个元素 小于最小值的下标 就更新最小值的下标\r\n      if (arr[j] < arr[indexMin]) {\r\n        indexMin = j;\r\n      }\r\n    }\r\n    // 避免自己和自己进行交换\r\n    if (indexMin !== i) {\r\n      // 进行交换数据\r\n      [arr[i], arr[indexMin]] = [arr[indexMin], arr[i]];\r\n    }\r\n  }\r\n  return arr;\r\n}\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## vite VS webpack\r\n### vite启动快\r\n- 底层语言不同\r\n> vite是基于esbuild预构建依赖。esbuild是采用go语言编写，因为go语言的操作是纳秒级别，而js是以毫秒计数，所以vite比用js编写的打包器快10-100倍。\r\n\r\n- 启动方式不同\r\n> vite在启动的时候不需要打包，所以不用分析模块与模块之间的依赖关系，不用进行编译。当浏览器请求某个模块时，再根据需要对模块内容进行编译。按需动态编译可以缩减编译时间，当项目越复杂，模块越多的情况下，vite明显优于webpack。\r\n\r\n  1. webpack: 分析依赖 => 编译打包 => 交给本地服务器进行渲染。首先分析各个模块之间的依赖，然后进行打包，在启动 webpack-dev-server，请求服务器时，直接显示打包结果。webpack打包之后存在的问题：随着模块的增多，会造成打出的 bundle 体积过大，进而会造成热更新速度明显拖慢。\r\n  2. vite: 启动服务器 => 请求模块时按需动态编译显示。是先启动开发服务器，请求某个模块时再对该模块进行实时编译，因为现代游览器本身支持ES-Module，所以会自动向依赖的Module发出请求。所以vite就将开发环境下的模块文件作为浏览器的执行文件，而不是像webpack进行打包后交给本地服务器。\r\n  3. 热更新方面，效率更高。当改动了某个模块的时候，也只用让浏览器重新请求该模块，不需要像webpack那样将模块以及模块依赖的模块全部编译一次。"},function(r,n,e){"use strict";e.r(n),n.default="## [React、Vue3、Vue2 列表的 Diff 算法对比](https://juejin.cn/post/6919376064833667080)\r\n### React\r\n> React的思路是递增法。通过对比新的列表中的节点，在原本的列表中的位置是否是递增，来判断当前节点是否需要移动。\r\n\r\n- nextList为新的列表，prevList为旧列表。遍历nextList，找到每一个节点在prevList中的位置。找到位置后与上一个节点的位置进行对比，如果当前的位置大于上一个位置，说明当前节点不需要移动。因此我们要定义一个lastIndex来记录上一个节点的位置。\r\n- 找到位置后与上一个节点的位置进行对比，如果当前的位置小于上一个位置，需要将DOM节点移动到前一个vnode节点之后。\r\n- 如果新列表中有全新的节点，在旧列表中找不到。我们需要根据新的VNode节点生成DOM节点，并插入DOM树中。如果新的节点位于新列表的第一个，这时候我们需要找到旧列表第一个节点，将新节点插入到原来第一个节点之前。\r\n- 当旧的节点不在新列表中时，将其对应的DOM节点移除。\r\n```\r\nfunction reactDiff(prevChildren, nextChildren, parent) {\r\n  let lastIndex = 0;\r\n  for (let i = 0; i < nextChildren.length; i++) {\r\n    let nextChild = nextChildren[i];\r\n    let find = false;\r\n    for (let j = 0; j < prevChildren.length; j++) {\r\n      let prevChild = prevChildren[j];\r\n      if (nextChild.key === prevChild.key) {\r\n        find = true;\r\n        patch(prevChild, nextChild, parent);\r\n        if (j < lastIndex) {\r\n          // 移动到前一个节点的后面\r\n          let refNode = nextChildren[i - 1].el.nextSibling;\r\n          parent.insertBefore(nextChild.el, refNode);\r\n        } else {\r\n          // 不需要移动节点，记录当前位置，与之后的节点进行对比\r\n          lastIndex = j;\r\n        }\r\n        break;\r\n      }\r\n    }\r\n    if (!find) {\r\n      // 插入新节点\r\n      let refNode = i <= 0 ? prevChildren[0].el : nextChildren[i - 1].el.nextSibling;\r\n      mount(nextChild, parent, refNode);\r\n    }\r\n  }\r\n\r\n  // 当旧的节点不在新列表中时，将其对应的DOM节点移除。\r\n  for (let i = 0; i < prevChildren.length; i++) {\r\n    const prevChild = prevChildren[i];\r\n    const key = prevChild.key;\r\n    const has = nextChildren.find(item => item.key === key);\r\n    if (!has) parent.removeChild(prevChild.el);\r\n  }\r\n}\r\n``` \r\n### Vue2\r\n> 新列表和旧列表两个列表的头与尾互相对比，在对比的过程中指针会逐渐向内靠拢，当其中一个列表的节点全部遍历完成时循环结束。\r\n\r\n- 新列表和旧列表两个列表的头与尾互相对比，寻找key相同的可复用的节点，当在某一步中找到了则停止后面的寻找。\r\n  1. 使用旧列表的头一个节点oldStartNode与新列表的头一个节点newStartNode对比\r\n  2. 使用旧列表的最后一个节点oldEndNode与新列表的最后一个节点newEndNode对比\r\n  3. 使用旧列表的头一个节点oldStartNode与新列表的最后一个节点newEndNode对比\r\n  4. 使用旧列表的最后一个节点oldEndNode与新列表的头一个节点newStartNode对比\r\n- 新列表和旧列表两个列表的头与尾互相对比，如果找到了可复用的节点，移动指针。\r\n  1. 当旧列表的头一个节点oldStartNode与新列表的头一个节点newStartNode对比时key相同。那么旧列表的头指针oldStartIndex与新列表的头指针newStartIndex同时向后移动一位。\r\n  2. 当旧列表的最后一个节点oldEndNode与新列表的最后一个节点newEndNode对比时key相同。那么旧列表的尾指针oldEndIndex与新列表的尾指针newEndIndex同时向前移动一位。\r\n  3. 当旧列表的头一个节点oldStartNode与新列表的最后一个节点newEndNode对比时key相同。那么旧列表的头指针oldStartIndex向后移动一位；新列表的尾指针newEndIndex向前移动一位。\r\n  4. 当旧列表的最后一个节点oldEndNode与新列表的头一个节点newStartNode对比时key相同。那么旧列表的尾指针oldEndIndex向前移动一位；新列表的头指针newStartIndex向后移动一位。\r\n- 旧列表的尾节点oldEndNode与新列表的头节点newStartNode的key相同，是可复用的DOM节点。只需要把当前的节点移动到原本旧列表中的第一个节点之前，让它成为第一个节点即可。\r\n- 旧列表的头节点oldStartNode和新列表的尾节点newEndNode为复用节点。只要在旧列表中把当前的节点移动到原本尾节点的后面，就可以了。\r\n- 当头和尾对比没有找到可以复用的节点时，拿新列表的第一个节点去旧列表中找与其key相同的节点。\r\n  1. 如果在旧列表中找到对应的节点，我们只需要将找到的节点的DOM元素，移动到开头就可以了。DOM移动后，由我们将旧列表中的节点改为undefined，因为我们已经做了节点的移动了所以我们不需要进行再次的对比了。最后我们将头指针newStartIndex向后移一位。\r\n  2. 如果在旧列表中没有找到复用节点，直接创建一个新的节点放到最前面就可以了，然后后移头指针newStartIndex。\r\n- 如果老数组的游标先相交了，则判断新数组中是否还有剩下的节点，没有进行比对的，创建它们。\r\n- 如果新数组的游标先相交了，则判断老数组中是否还有剩下的节点，没有进行比对的，把它们都删除掉。\r\n```\r\nfunction vue2diff(prevChildren, nextChildren, parent) {\r\n  let oldStartIndex = 0;\r\n  let newStartIndex = 0;\r\n  let oldStartIndex = prevChildren.length - 1;\r\n  let newStartIndex = nextChildren.length - 1;\r\n  let oldStartNode = prevChildren[oldStartIndex];\r\n  let oldEndNode = prevChildren[oldStartIndex];\r\n  let newStartNode = nextChildren[newStartIndex];\r\n  let newEndNode = nextChildren[newStartIndex];\r\n\r\n  当新旧列表的起始指针小于终止指针时才继续循环\r\n  while (oldStartIndex <= oldStartIndex && newStartIndex <= newStartIndex) {\r\n    if (oldStartNode === undefined) {\r\n      oldStartNode = prevChildren[++oldStartIndex];\r\n    } else if (oldEndNode === undefined) {\r\n      oldEndNode = prevChildren[--oldStartIndex];\r\n    } else if (oldStartNode.key === newStartNode.key) {\r\n      patch(oldStartNode, newStartNode, parent);\r\n\r\n      oldStartIndex++;\r\n      newStartIndex++;\r\n      oldStartNode = prevChildren[oldStartIndex];\r\n      newStartNode = nextChildren[newStartIndex];\r\n    } else if (oldEndNode.key === newEndNode.key) {\r\n      patch(oldEndNode, newEndNode, parent);\r\n\r\n      oldStartIndex--;\r\n      newStartIndex--;\r\n      oldEndNode = prevChildren[oldStartIndex];\r\n      newEndNode = nextChildren[newStartIndex];\r\n    } else if (oldStartNode.key === newEndNode.key) {\r\n      patch(oldStartNode, newEndNode, parent);\r\n      parent.insertBefore(oldStartNode.el, oldEndNode.el.nextSibling);\r\n      oldStartIndex++;\r\n      newStartIndex--;\r\n      oldStartNode = prevChildren[oldStartIndex];\r\n      newEndNode = nextChildren[newStartIndex];\r\n    } else if (oldEndNode.key === newStartNode.key) {\r\n      patch(oldEndNode, newStartNode, parent);\r\n      parent.insertBefore(oldEndNode.el, oldStartNode.el);\r\n      oldStartIndex--;\r\n      newStartIndex++;\r\n      oldEndNode = prevChildren[oldStartIndex];\r\n      newStartNode = nextChildren[newStartIndex];\r\n    } else {\r\n      let newKey = newStartNode.key;\r\n      let oldIndex = prevChildren.findIndex(child => child && (child.key === newKey));\r\n      if (oldIndex === -1) {\r\n        mount(newStartNode, parent, oldStartNode.el);\r\n      } else {\r\n        let prevNode = prevChildren[oldIndex];\r\n        patch(prevNode, newStartNode, parent);\r\n        parent.insertBefore(prevNode.el, oldStartNode.el);\r\n        prevChildren[oldIndex] = undefined;\r\n      }\r\n      newStartIndex++;\r\n      newStartNode = nextChildren[newStartIndex];\r\n    }\r\n  }\r\n\r\n  if (newStartIndex > newStartIndex) {\r\n    while (oldStartIndex <= oldStartIndex) {\r\n      if (!prevChildren[oldStartIndex]) {\r\n        oldStartIndex++;\r\n        continue;\r\n      }\r\n      parent.removeChild(prevChildren[oldStartIndex++].el);\r\n    }\r\n  } else if (oldStartIndex > oldStartIndex) {\r\n    while (newStartIndex <= newStartIndex) {\r\n      mount(nextChildren[newStartIndex++], parent, oldStartNode.el);\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## react和vue的异同\r\n### 相同点\r\n- 都提倡组件化。\r\n- 都使用虚拟DOM高效的更新视图。\r\n- 都实现了数据驱动视图。\r\n- 都使用diff算法，也都对diff算法进行了优化。\r\n- 都有router库实现url到组件的映射。\r\n- 都有状态管理。\r\n### 组件化\r\n- 组件是独立和可复用的代码组织单元，它使开发者使用小型、独立和通常可复用的组件构建大型应用。\r\n- 能大幅提高应用开发效率、测试性、复用性、维护性，降低整个系统的耦合度。\r\n- 调试方便，根据报错的组件快速定位问题，之所以能够快速定位，是因为每个组件之间低耦合，职责单一，所以逻辑会比分析整个系统要简单。\r\n- 提高可维护性，由于每个组件的职责单一，并且组件在系统中是被复用的，所以对代码进行优化可获得系统的整体升级。\r\n### 组件化相同点\r\n- react和vue都推崇组件化，通过将页面拆分成一个一个小的可复用单元来提高代码的复用率和开发效率。\r\n- 在开发时react和vue有相同的套路，比如都有父子组件传参，都有数据状态管理，都有前端路由等。\r\n### 组件化差异\r\n- React推荐的做法是JSX + inline style, 也就是把 HTML 和 CSS 全都写进 JavaScript 中，即 all in js。\r\n- Vue 推荐的做法是 template 的单文件组件格式,即 html,css,JS 写在同一个文件(vue也支持JSX写法)。\r\n### 虚拟DOM\r\n- 虚拟dom是一个js对象，存储在内存之中。\r\n- 虚拟dom能够描述真实dom（存在一个对应关系）。\r\n- 当数据变化的时候，生成新的DOM，对比新旧虚拟DOM的差异，将差异更新到真实DOM上。\r\n### 虚拟DOM相同点\r\n- Vue与React都使用了虚拟DOM + Diff算法，不管是Vue的Template模板 + options api写法， 还是React的Class或者Function写法，最后都是生成render函数，而render函数执行返回VNode(虚拟DOM的数据结构，本质上是棵树)。\r\n- 当每一次UI更新时，总会根据render重新生成最新的VNode，然后跟以前缓存起来老的VNode进行比对，再使用Diff算法（框架核心）去真正更新真实DOM（虚拟DOM是JS对象结构，同样在JS引擎中，而真实DOM在浏览器渲染引擎中，所以操作虚拟DOM比操作真实DOM开销要小的多）。\r\n![虚拟DOM](./img/%E8%99%9A%E6%8B%9FDOM.jpg)\r\n### 虚拟DOM差异\r\n- react会自顶向下全diff。vue会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。\r\n- 在react中当状态发生改变时，组件树就会自顶向下的全diff，重新render页面，重新生成新的虚拟dom tree, 新旧dom tree进行比较，进行patch打补丁方式，局部更新dom。所以react为了避免父组件更新而引起不必要的子组件更新，可以在shouldComponentUpdate做逻辑判断，减少没必要的render，以及重新生成虚拟dom做差量对比的过程。\r\n- 在vue中通过Object.defineProperty把data属性全部转为getter/setter。同时watcher实例对象会在组件渲染时，将属性记录为dep, 当dep项中的setter被调用时，通知watch重新计算，使得关联组件更新。\r\n### Diff算法\r\n- 在处理老节点部分，都需要把节点处理 key - value 的 Map 数据结构，方便在往后的比对中可以快速通过节点的 key 取到对应的节点。\r\n- 同样在比对两个新老节点是否相同时，key 是否相同也是非常重要的判断标准。所以不同是 React, 还是 Vue，在写动态列表的时候，都需要设置一个唯一值 key，这样在 diff 算法处理的时候性能才最大化。\r\n### Diff算法的相同点\r\n- tag不同认为是不同节点。\r\n- 只比较同一层级，不跨级比较。\r\n- 同一层级的节点用key唯一标识，tag和key都相同则认为是同一节点。\r\n- Diff算法借助元素的 Key 判断元素是新增、删除、修改，从而减少不必要的元素重渲染。\r\n### Diff算法的差异\r\n- vue对比节点时当节点元素相同，但是classname不同，认为是不同类型的元素，删除重建，而react认为是同类型节点，只是修改节点属性。\r\n- vue的列表对比，采用的是两端到中间比对的方式，而react采用的是从左到右依次对比的方式。当一个集合只是把最后一个节点移到了第一个，react会把前面的节点依次移动，而vue只会把最后一个节点移到第一个。\r\n### 数据驱动视图\r\n> 数据变化的时候，相应的视图会得到更新。开发者只需要关注数据的变化而不用再去手动的操作DOM。\r\n\r\n### vue中的数据驱动视图\r\n> Vuejs的数据驱动是通过MVVM这种框架来实现的。MVVM框架主要包含3个部分:model、view和 viewModel。Model:指的是数据部分，对应到前端就是javascript对象；View:指的是视图部分，对应前端就是dom；ViewModel:就是连接视图与数据的中间件。\r\n\r\n- ViewModel是实现数据驱动视图的核心，当数据变化的时候，ViewModel能够监听到这种变化，并及时的通知view做出修改。同样的，当页面有事件触发时，ViewModel也能够监听到事件，并通知model进行响应。ViewModel就相当于一个观察者，监控着双方的动作，并及时通知对方进行相应的操作。\r\n- vuejs在实例化的过程中，会对遍历传给实例化对象选项中的data 选项，遍历其所有属性并使用 Object.defineProperty 把这些属性全部转为 getter/setter。\r\n同时每一个实例对象都有一个watcher实例对象，他会在模板编译的过程中，用getter去访问data的属性，watcher此时就会把用到的data属性记为依赖，这样就建立了视图与数据之间的联系。\r\n- 当之后我们渲染视图的数据依赖发生改变（即数据的setter被调用）的时候，watcher会对比前后两个的数值是否发生变化，然后确定是否通知视图进行重新渲染。这样就实现了所谓的数据对于视图的驱动。\r\n### react的数据驱动视图\r\n> React通过setState实现数据驱动视图，通过setState来引发一次组件的更新过程从而实现页面的重新渲染(除非shouldComponentUpdate返回false)。pending：当前所有等待更新的state队列；isBatchingUpdates：React中用于标识当前是否处理批量更新状态，默认false；dirtyComponent：当前所有待更新state的组件队列。\r\n\r\n- setState()首先将接收的第一个参数state存储在pending队列中。（state）\r\n- 判断当前React是否处于批量更新状态，是的话就将需要更新state的组件添加到dirtyComponents中。（组件）\r\n- 不是的话，它会遍历dirtyComponents的所有组件，调用updateComponent方法更新每个dirty组件。（开启批量更新事务）\r\n### 响应式原理的差异\r\n> react和vue都是通过修改数据来改变dom的显示，react需要调用setState方法，而vue直接修改变量就行，看似是api不同其实是响应式的原理不同。\r\n\r\n- 在react中，组件的状态是不能被修改的，setState没有修改原来那块内存中的变量，而是去新开辟一块内存；而vue则是直接修改保存状态的那块原始内存。\r\n- react中，调用setState方法后，会自顶向下重新渲染组件，自顶向下的含义是，该组件以及它的子组件全部需要渲染；而vue使用Object.defineProperty（vue@3迁移到了Proxy）对数据的设置（setter）和获取（getter）做了劫持，也就是说，vue能准确知道视图模版中哪一块用到了这个数据，并且在这个数据修改时，告诉这个视图，你需要重新渲染了。所以当一个数据改变，react的组件渲染是很消耗性能的——父组件的状态更新了，所有的子组件得跟着一起渲染，它不能像vue一样，精确到使用当前修改数据的组件粒度。\r\n"},function(r,n,e){"use strict";e.r(n),n.default='## Cookie\r\n- Cookie最开始被设计出来其实并不是来做本地存储的，而是为了弥补HTTP在状态管理上的不足。HTTP协议是一个无状态协议，客户端向服务器发请求，服务端无法识别客户端身份。利用Cookie向同一个域名下发送请求，都会携带相同的 Cookie，服务器拿到Cookie进行解析便能拿到客户端的状态。\r\n- 服务端可以通过响应头中的Set-Cookie字段来对客户端写入Cookie。\r\n- Cookie都是name=value的结构在浏览器中存储，name和value都为字符串。\r\n### 服务端设置Cookie，后续请求携带Cookie的流程\r\n1. 在首次访问网站时，浏览器发送请求中并未携带Cookie。\r\n2. 浏览器看到请求中未携带Cookie，在HTTP的响应头中加入Set-Cookie。\r\n3. 浏览器收到Set-Cookie后，会将Cookie保存下来。\r\n4. 之后该网站的请求，HTTP请求头就会携带Cookie。\r\n### Cookie配置属性\r\n- Name：Cookie的名称\r\n- Value：对应名称的值\r\n- Domain：Cookie生效的域名\r\n- Path：Cookie生效的路径\r\n- Expires：过期时间，过了这个时间后Cookie失效\r\n- Max-Age：生效时间，表示Cookie在多长时间后失效，单位为秒\r\n- Size：Cookie的长度，为name和value的长度和\r\n- HttpOnly：禁止通过JavaScript访问Cookie\r\n- Secure：只在HTTPS协议的情况下才会将Cookie传到服务端\r\n- SameSite：是否允许跨站请求时发送Cookie\r\n- Priority：优先级\r\n- Partitioned：第三方Cookie分区\r\n### Cookie生命周期\r\n> 如果没有指定Expires或Max-Age属性，默认值是Session，即它只在本次对话存在，一旦用户关闭浏览器，浏览器就不会再保留这个Cookie。如果同时指定了Expires和Max-Age，那么Max-Age的值将优先生效。\r\n\r\n#### Session\r\n- 这里的Session并不是存储在服务端的Session，而是指浏览器会话。\r\n- 如果Cookie的有效期为Session，一般关闭会话时Cookie便会失效。而一些浏览器重启时也会将会话恢复，此时Cookie并不会失效。\r\n#### Expires\r\n- Expires表示过期时间，是一个确定的日期时间，例如Expires=Wed, 21 Oct 2015 07:28:00 GMT。当浏览器端本地的当前时间超过这个时间时Cookie便会失效。\r\n#### Max-Age\r\n- Max-Age表示Cookie的存活时间，以秒作为单位，例如Max-Age=3000。当获取到该Cookie后开始倒计时，3000秒之后便失效。\r\n### Cookie作用范围\r\n#### Domain\r\n- Domain用来设置Cookie作用的域名，即Cookie在哪个网站生效。\r\n- 默认情况下生效的域名为当前访问的域名。例如我们在dyx.com设置的Cookie，就只能限制在该网站内使用。\r\n#### 多级域名\r\n- 如果访问的网站有多级域名，则Cookie默认仅在访问的多级域名内生效。例如在a.dyx.com下设置的Cookie，就只在这个域名下生效。\r\n- 如果希望在更大范围内生效，可以指定域名。如果在设置Cookie时同时设置了domain=dyx.com，则该Cookie可以在dyx.com下的任何域名内生效。比如：\r\n  - dyx.com\r\n  - a.dyx.com\r\n  - b.dyx.com\r\n  - c.d.dyx.com\r\n#### Path\r\n- 当希望Cookie仅仅在部分路径下生效，就可以使用Path进行限制，默认的Path=/，即在所有路径下生效。 \r\n- 如果设置了path=/abc，则只在/abc路径下生效。比如：\r\n  - dyx.com 不生效\r\n  - dyx.com/abc 生效\r\n  - dyx.com/abc/def 生效\r\n  - dyx.com/qaz 不生效\r\n  - dyx.com/qaz/abc 不生效\r\n### 个数和大小限制\r\n- 不同的浏览器允许的Cookie大小并不相同，通常的个数限制为: 20~50；总大小限制为: 4KB左右。\r\n- 一个Cookie的大小可以在浏览器中查看Size属性得知，这个大小是key和value的和。\r\n### HttpOnly\r\n- 通常的Cookie在客户端是可以通过js脚本代码访问的。\r\n- 如果设置了HttpOnly属性，则该Cookie在浏览器中无法通过js代码读取也无法写入。这样可以防止窃取Cookie信息，一般用来防止XSS攻击。\r\n### Secure\r\n- 只能通过HTTPS传输Cookie。\r\n### Priority优先级\r\n- 当Cookie的数量超过限制时，浏览器会清除一部分Cookie，低优先级的Cookie会优先被清除。\r\n- Priority属性用来定义Cookie的优先级。\r\n  - Low\r\n  - Medium\r\n  - High\r\n### 跨站与SameSite设置\r\n- SameSite是Cookie的跨站属性，也可以看做是“更高级”的作用范围设置。\r\n#### 跨站与跨域\r\n- 一般浏览器限制请求的内容是按照跨域来判断的，比如XHR和fetch。但是SameSite限制的并不是跨域而是跨站。\r\n- 跨站是比跨域更宽松的一种限制。如果跨站那么肯定会跨域，但如果跨域不一定会跨站。\r\n#### 跨站和跨域的主要区别\r\n- 子域名不同时属于跨域不属于跨站。例如a.dyx.com与b.dyx.com。\r\n- 端口不同时属于跨域不属于跨站。例如dyx.com:8000与dyx.com:9000。\r\n- IP不同时（如果直接使用IP访问网站）属于跨域和跨站。\r\n#### 请求分类\r\n- 可能打开新页面或者改变当前页面的请求。例如：window.open()，`<a>`链接，form表单提交等。\r\n- 不改变当前页面的请求。例如：`<script>、<css>、<img>`等标签，fetch，XHR请求等。\r\n- 这两类的主要区别是第一类请求直接把页面替换了或者打开了一个新的页面，即和原有的页面不属于同一个页面。而第二类请求依然在原页面上，仅仅是做一些内容上的更新。\r\n- 请求分类与SameSite配置相关。\r\n#### SameSite设置\r\n- None：关闭SameSite属性，即不对跨站Cookie做限制。关闭的前提是设置了Secure，即Cookie只能在HTTPS下使用，否则关闭是无效的。\r\n- Strict：禁止发送跨站Cookie。即不管是什么请求，如果我们请求的地址与所在的页面地址属于跨站，那么Strict的Cookie将不会被发送。\r\n- Lax(默认值)：请求分类的第一种情况下可以发送跨站Cookie，即可能打开新页面或者改变当前页面的请求而且是个Get请求时可以发送。其它请求不允许发送。\r\n### JavaScript中操作Cookie\r\n- 设置Cookie\r\n> 一次只能设置一个Cookie。但是可以同时对单个Cookie的多个属性进行设置，每个属性使用分隔符;\r\n\r\n```\r\ndocument.cookie = "name=dyx";\r\ndocument.cookie = "name=dyx; doamin=dyx.com";\r\ndocument.cookie = "name=dyx; doamin=dyx.com; path=/abc";\r\n```\r\n- 修改Cookie\r\n> 修改Cookie相当于对其进行重新设置。\r\n\r\n- 读取Cookie\r\n> 读取到的是一个字符串，内容为该页面的所有Cookie，不同的Cookie用分隔符;分隔。只能读到key和value，其余的属性读不到。\r\n\r\n```\r\ndocument.cookie\r\n// 读取到的值\r\n"name=dyx; name1=douyaxing"\r\n```\r\n- 删除Cookie\r\n> js中没有直接删除Cookie的方法。如果需要删除某个Cookie，需要重新设置该Cookie，将它的有效期直接设置为过期即可实现删除功能。\r\n\r\n```\r\ndocument.cookie = "name=dyx; max-age=-1";\r\n```\r\n### 相同域名下的不同端口的Cookie可以共享\r\n### 跨域请求携带Cookie\r\n- 网站a中使用ajax请求跨域访问网站b的接口。\r\n- 网站b的服务端需要设置CORS，这样网站a的跨域请求才能够被正常处理。\r\n- 网站a的请求参数中添加withCredentials=true属性，这样浏览器才会携带Cookie到网站b的服务端。\r\n- ajax跨域请求无法携带SameSite=Lax的Cookie。\r\n### Cookie相较于WebStorage的缺陷\r\n- 容量缺陷：Cookie的体积上限只有4KB，只能用来存储少量的信息。\r\n- 安全缺陷：Cookie在每次请求中都会被发送，如果不使用HTTPS并对其加密，其保存的信息很容易被窃取导致安全风险。\r\n- 操作缺陷：Cookie的操作相较于WebStorage较为繁琐复杂。\r\n### Cookie与Session的区别\r\n- 存储位置不同：Cookie的数据信息存放在客户端浏览器上，Session的数据信息存放在服务器上。\r\n- 存储容量不同：单个Cookie保存的数据<=4KB，一个站点最多保存20个Cookie，而对于Session来说并没有上限，但出于对服务器端的性能考虑，Session内不要存放过多的东西，并且设置Session删除机制。\r\n- 存储方式不同：Cookie中只能保管ASCII字符串，并需要通过编码方式存储为Unicode字符或者二进制数据。Session中能够存储任何类型的数据，包括且不限于string，integer，list，map等。\r\n- 隐私策略不同：Cookie对客户端是可见的，别有用心的人可以分析存放在本地的Cookie并进行Cookie欺骗，所以它是不安全的，而Session存储在服务器上，对客户端是不透明的，不存在敏感信息泄漏的风险。\r\n- 有效期上不同：开发可以通过设置Cookie的属性，达到使Cookie长期有效的效果。Session依赖于名为JSESSIONID的Cookie，而Cookie JSESSIONID的过期时间默认为-1，只需关闭窗口该Session就会失效，因而Session不能达到长期有效的效果。\r\n- 服务器压力不同：Cookie保管在客户端，不占用服务器资源。对于并发用户十分多的网站Cookie是很好的选择。Session是保管在服务器端的，每个用户都会产生一个Session。假如并发访问的用户十分多，会产生十分多的Session，耗费大量的内存。\r\n- 跨域支持上不同：Cookie支持跨域名访问(二级域名是可以共享Cookie的)。Session不支持跨域名访问。'},function(r,n,e){"use strict";e.r(n),n.default='## WebStorage\r\n### localStorage\r\n- 使用Key-Value形式储存，通过setItem和getItem等方法进行操作，使用很方便。\r\n- Key和Value以字符串形式储存。对于一些复杂的数据存储需要使用JSON.stringify()。\r\n- 持久化存储，不手动清除不会消失。\r\n- 存储大小有10MB。\r\n- 只存储在客户端，默认不参与与服务端的通信。这样就很好地避免了Cookie在http传输过程带来的性能问题和安全问题。\r\n#### 应用场景\r\n- 利用localStorage的较大容量和持久特性，可以利用localStorage存储一些内容稳定的资源如token。\r\n### sessionStorage\r\n- sessionStorage和localStorage有一个本质的区别，sessionStorage只是会话级别的存储，localStorage是持久化存储。\r\n- 会话结束也就是页面关闭，sessionStorage就不存在了。\r\n#### 在标签或窗口打开一个新页面时会复制当前会话的上下文作为新会话的上下文。\r\n- 多窗口之间sessionStorage不可以共享状态，但是在某些特定场景下新开的页面会复制之前页面的sessionStorage，复制之后的新窗口的sessionStorage和之前窗口的sessionStorage各自独立互不影响。\r\n- window.open("同源页面")这种方式新开的页面会复制之前的sessionStorage，通过a标签新开的页面同样也会。\r\n- 如果不想要这种复制的效果，可以先新建一个空白页面窗口，再将url设置到窗口中的地址栏中去。\r\n#### 应用场景\r\n- 存储本次浏览记录，关闭之后不再需要这些记录。'},function(r,n,e){"use strict";e.r(n),n.default="## 回流和重绘\r\n> 回流必将引起重绘，重绘不一定会引起回流。回流比重绘的代价要更高。\r\n\r\n### 回流(重排)\r\n> 当RenderTree中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为回流。\r\n\r\n- 页面首次渲染\r\n- 元素尺寸或位置发生改变\r\n- 元素内容变化（文字数量或图片大小等等）\r\n- 元素字体大小变化\r\n- 添加或者删除可见的DOM元素\r\n- 浏览器窗口大小发生改变\r\n- 激活CSS伪类（例如：:hover）\r\n- 查询某些属性或调用某些方法\r\n  - clientWidth、clientHeight、clientTop、clientLeft\r\n  - offsetWidth、offsetHeight、offsetTop、offsetLeft\r\n  - scrollWidth、scrollHeight、scrollTop、scrollLeft\r\n  - scrollIntoView()、scrollIntoViewIfNeeded()\r\n  - getComputedStyle()\r\n  - getBoundingClientRect()\r\n  - scrollTo()\r\n### 重绘\r\n> 当页面中元素样式的改变并不影响它在文档流中的位置时例如：color、background-color、visibility等，浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。\r\n\r\n### 如何避免\r\n- 避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性。\r\n- 避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中。\r\n- 对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## 复合图层\r\n> 浏览器渲染的图层一般包含两大类：普通图层以及复合图层。\r\n\r\n### 多个复合图层互不影响\r\n> 普通文档流内可以理解为一个复合图层（这里称为默认复合层，里面不管添加多少元素，其实都是在同一个复合图层中），absolute布局（fixed也一样）虽然可以脱离普通文档流，但它仍然属于默认复合层。然后可以通过硬件加速的方式，声明一个新的复合图层，它会单独分配资源（当然也会脱离普通文档流，这样一来，不管这个复合图层中怎么变化，也不会影响默认复合层里的回流重绘）。可以理解成GPU中各个复合图层是单独绘制的，所以互不影响。\r\n\r\n### 生成新的复合图层（硬件加速）\r\n- 最常用的方式：translate3d、translateZ\r\n- opacity属性/过渡动画（需要动画执行的过程中才会创建合成层，动画没有开始或结束后元素还会回到之前的状态）\r\n- will-change属性，一般配合opacity与translate使用（除了上述可以引发硬件加速的属性外，其它属性并不会变成复合层）\r\n### absolute和生成新的复合图层（硬件加速）的区别\r\n- absolute虽然可以脱离普通文档流，但是无法脱离默认复合层。所以就算absolute中信息改变时不会改变普通文档流中render树，但是浏览器最终绘制时是整个复合层绘制的，所以absolute中信息的改变，仍然会影响整个复合层的绘制。（浏览器会重绘它，如果复合层中内容多，absolute带来的绘制信息变化过大，资源消耗是非常严重的）\r\n- 生成新的复合图层（硬件加速）直接就是在另一个复合层了，所以它的信息改变不会影响默认复合层。\r\n### 生成新的复合图层作用\r\n> 一般一个元素开启硬件加速后会变成复合图层，可以独立于普通文档流中，改动后可以避免整个页面重绘，提升性能。但是尽量不要大量使用复合图层，否则由于资源消耗过度，页面反而会变的更卡。\r\n\r\n### 生成新的复合图层要使用index\r\n> 使用硬件加速生成新的复合层时，尽可能的使用index，防止浏览器默认给后续的元素创建复合层渲染。如果这个元素添加了硬件加速，并且index层级比较低，那么在这个元素的后面其它元素（层级比这个元素高的，或者相同的，并且releative或absolute属性相同的），会默认变为复合层渲染，如果处理不当会极大的影响性能。如果a是一个复合图层，而且b在a上面，那么b也会被隐式转为一个复合图层，这点需要特别注意。\r\n\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## 浏览器渲染进程\r\n### 进程和线程\r\n- 进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）。\r\n- 线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）。\r\n- 不同进程之间也可以通信，不过代价较大。\r\n- 单线程与多线程，是指在一个进程内的单和多（核心还是得属于一个进程）。\r\n### 浏览器是多进程\r\n> 每打开一个Tab页，就相当于创建了一个独立的浏览器进程（进程内有自己的多线程）。浏览器有时会将多个进程合并（譬如打开多个空白标签页后，会发现多个空白标签页被合并成了一个进程）。\r\n\r\n1. Browser进程：浏览器的主进程（负责协调、主控），只有一个。作用如下\r\n    - 负责浏览器界面显示，与用户交互。如前进，后退等。\r\n    - 负责各个页面的管理，创建和销毁其它进程。\r\n    - 将浏览器渲染进程得到的内存中的Bitmap，绘制到用户界面上。\r\n    - 网络资源的管理，下载等。\r\n2. 第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建。\r\n3. GPU进程：最多一个，用于3D绘制等。\r\n4. 浏览器渲染进程：内部是多线程的，默认每个Tab页面一个进程，互不影响。主要作用为页面渲染，脚本执行，事件处理等。\r\n### Browser进程和浏览器渲染进程的通信过程\r\n1. Browser进程收到用户请求，首先需要获取页面内容（譬如通过网络下载资源），随后将该任务通过RendererHost接口传递给渲染进程。\r\n2. 渲染进程的Renderer接口收到消息，简单解释后，交给GUI渲染线程，然后开始渲染。\r\n    - 渲染线程接收请求，加载网页并渲染网页，这其中可能需要Browser进程获取资源和需要GPU进程来帮助渲染。\r\n    - 当然可能会有JS线程操作DOM（这样可能会造成回流并重绘）。\r\n    - 最后渲染进程将结果传递给Browser进程。\r\n3. Browser进程接收到结果并将结果绘制出来。\r\n### 浏览器多进程的优势\r\n- 避免单个page crash影响整个浏览器。\r\n- 避免第三方插件crash影响整个浏览器。\r\n- 多进程充分利用多核优势。\r\n- 方便使用沙盒模型隔离插件等进程，提高浏览器稳定性。\r\n### 浏览器的渲染进程是多线程的\r\n1. GUI渲染线程\r\n    - 负责渲染浏览器界面，解析HTML，CSS，构建DOM树和CSSOM树和Render树，布局和绘制等。\r\n    - 当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行。\r\n    - **GUI渲染线程与JS引擎线程是互斥的**，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。\r\n2. JS引擎线程\r\n    - 也称为JS内核，负责处理Javascript脚本程序。\r\n    - JS引擎线程负责解析Javascript脚本，运行代码。\r\n    - JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（浏览器渲染进程）中无论什么时候都只有一个JS线程在运行JS程序。\r\n    - **GUI渲染线程与JS引擎线程是互斥的**，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。\r\n3. 事件触发线程\r\n    - 归属于浏览器而不是JS引擎，用来控制事件循环。\r\n    - 当JS引擎执行代码块如setTimeOut时（也可来自浏览器渲染进程的其他线程，如鼠标点击、AJAX异步请求等），会将对应任务添加到事件线程中。\r\n    - 当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理。\r\n    - 由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）。\r\n4. 定时触发器线程\r\n    - 传说中的setInterval与setTimeout所在线程。\r\n    - 浏览器定时计数器并不是由JavaScript引擎计数的,（因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）。\r\n    - 因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）。\r\n    - W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。\r\n5. 异步http请求线程\r\n    - 在XMLHttpRequest在连接后是通过浏览器新开一个线程请求。\r\n    - 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由JavaScript引擎执行。\r\n### GUI渲染线程与JS引擎线程互斥\r\n> 由于JavaScript是可操做DOM的，如果在修改这些元素属性同时渲染界面（即JS线程和UI线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。因此为了防止渲染出现不可预期的结果，浏览器设置GUI渲染线程与JS引擎为互斥的关系，当JS引擎执行时GUI线程会被挂起，GUI更新则会被保存在一个队列中等到JS引擎线程空闲时立即被执行。\r\n\r\n### JS阻塞页面加载\r\n> JS如果执行时间过长就会阻塞页面。假设JS引擎正在进行巨量的计算，此时就算GUI有更新，也会被保存到队列中，等待JS引擎空闲后执行。然后由于巨量计算，所以JS引擎很可能很久很久后才能空闲，自然会感觉到巨卡无比。\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## 跨域\r\n> 浏览器有一个重要的安全策略，称之为同源策略。其中源 = 协议 + 主机 + 端口。两个源相同称之为同源，两个源不同称之为跨源或跨域。\r\n\r\n### 同源策略\r\n> 同源策略是指若页面的源和页面运行过程中加载的源不一致时，出于安全考虑，浏览器会对跨域的资源访问进行一些限制。\r\n\r\n### 非同源的限制\r\n- 不能读取和修改对方的DOM。\r\n- 不读访问对方的Cookie、IndexDB和WebStorage。\r\n- 限制XMLHttpRequest请求。\r\n### 跨域\r\n> 当浏览器向目标地址发起ajax请求时，只要当前URL和目标URL不同源则产生跨域，被称为跨域请求。跨域请求的响应一般会被浏览器所拦截，注意是被浏览器拦截，响应其实是成功到达客户端了。\r\n\r\n### 跨域解决方案\r\n#### 代理\r\n- 前端通过webpack-dev-server的proxy实现代理，前端请求通过中间服务器进行转发。\r\n- nginx代理\r\n> 反向代理拿到客户端的请求，将请求转发给其它的服务器，主要的场景是维持服务器集群的负载均衡，反向代理帮其它的服务器拿到请求，然后选择一个合适的服务器，将请求转交给它。\r\n\r\n```\r\n// nginx相当于起了一个跳板机，这个跳板机的域名也是client.com(客户端的域名client.com)，让客户端首先访问client.com/api时是没有跨域的，然后nginx服务器作为反向代理，将请求转发给server.com，当响应返回时又将响应给到客户端，这就完成整个跨域请求的过程。\r\n\r\nserver {\r\n  listen  80;\r\n  server_name  client.com;\r\n  location /api {\r\n    proxy_pass server.com;\r\n  }\r\n}\r\n```\r\n#### CORS\r\n> CORS是基于http1.1的一种跨域解决方案，它的全称是Cross-Origin Resource Sharing跨域资源共享。如果浏览器要跨域访问服务器的资源，需要获得服务器的允许。\r\n\r\n#### JSONP\r\n> 虽然XMLHttpRequest对象遵循同源政策，但是script标签不一样，它可以通过src填上目标地址从而发出GET请求，实现跨域请求并拿到响应，这也就是JSONP的原理。\r\n\r\n- 优点：和CORS相比JSONP最大的优势在于兼容性好，IE低版本不能使用CORS但可以使用JSONP。\r\n- 缺点：请求方法单一，只支持GET请求。\r\n```\r\nconst jsonp = ({ url, params, callbackName }) => {\r\n  const generateUrl = () => {\r\n    let dataSrc = ''\r\n    for (let key in params) {\r\n      if (params.hasOwnProperty(key)) {\r\n        dataSrc += `${key}=${params[key]}&`\r\n      }\r\n    }\r\n    dataSrc += `callback=${callbackName}`\r\n    return `${url}?${dataSrc}`\r\n  }\r\n  return new Promise((resolve, reject) => {\r\n    const scriptEle = document.createElement('script')\r\n    scriptEle.src = generateUrl()\r\n    document.body.appendChild(scriptEle)\r\n    window[callbackName] = data => {\r\n      resolve(data)\r\n      document.removeChild(scriptEle)\r\n    }\r\n  })\r\n}\r\n\r\n// 使用\r\njsonp({\r\n  url: 'http://localhost:3000',\r\n  params: { \r\n    a: 1,\r\n    b: 2\r\n  }\r\n}).then(data => {\r\n  // 拿到数据进行处理\r\n  console.log(data); // 数据包\r\n})\r\n```\r\n#### chrome设置允许跨域 (只能用于调试阶段)\r\n- windows\r\n> 新建一个chrome快捷方式，右键“属性”。“快捷方式”选项卡里选择“目标”，添加 --args --disable-web-security --user-data-dir\r\n\r\n- mac\r\n> open -n /Applications/Google\\ Chrome.app/ --args --disable-web-security --ignore-certificate-errors --user-data-dir=/Users/${此处完成用户名}/MyChromeDevUserData/\r\n\r\n### CORS请求类型\r\n> 一个请求可以附带很多信息，从而会对服务器造成不同程度的影响，比如有的请求只是获取一些信息，有的请求会改动服务器的数据，针对不同的请求，CORS规定了三种不同的交互模式，分别是：简单请求、需要预检的请求、附带身份凭证的请求。这三种模式依次可以做的事越来越多，要求也越来越严格。\r\n\r\n#### 简单请求(同时满足以下要求)\r\n> 同时满足请求方法为get、post、head。请求头只包括：Accept、Accept-Language、Content-Language、Content-Type(只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain)。\r\n\r\n- 请求头中会自动添加Origin字段\r\n- 服务器响应头中应包含Access-Control-Allow-Origin，当服务器收到请求后，如果允许该请求跨域访问，需要在响应头中添加Access-Control-Allow-Origin字段，该字段的值可以是 * 表示所有地址都可以访问，也可以是具体的地址表示只允许规定的地址访问。\r\n- 当浏览器看到服务器响应头允许浏览器访问时，就把响应信息正常交给js的请求。\r\n#### 需要预检的请求\r\n> 当完成预检请求之后，后续的处理与普通请求相同。\r\n\r\n1. 浏览器发送预检请求，询问服务器是否允许\r\n> 请求方法为OPTIONS；并非我们想要发出的真实请求，请求中不包含我们定义的请求头，也没有请求体；请求头中包含Origin：请求的源；Access-Control-Request-Method：后续的真实请求将使用的请求方法；Access-Control-Request-Headers：后续的真实请求会改动的请求头。\r\n\r\n2. 服务器允许\r\n> 服务器收到预检请求后，可以检查预检请求中包含的信息，如果允许这样的请求，不需要响应任何的消息体，响应头会包含Access-Control-Allow-Origin：表示允许的源；Access-Control-Allow-Methods：表示允许的后续真实的请求方法；Access-Control-Allow-Headers：表示允许改动的请求头；Access-Control-Max-Age：告诉浏览器，多少秒内对于同样的请求源、方法、请求头都不需要再发送预检请求了。\r\n\r\n3. 浏览器发送真实请求\r\n4. 服务器完成真实的响应\r\n#### 附带身份凭证的请求\r\n> 默认情况下，ajax的跨域请求并不会附带Cookie，这样某些需要权限的操作就无法进行。可以通过如下的配置实现跨域请求附带Cookie。\r\n\r\n```\r\n// xhr\r\nvar xhr = new XMLHttpRequest();\r\nxhr.withCredentials = true;\r\n\r\n// fetch api\r\nfetch(url, {\r\n  credentials: 'include',\r\n});\r\n```\r\n- 该跨域的请求就是一个附带身份凭证的请求，当一个请求需要附带Cookie时，无论它是简单请求还是预检请求，都会在请求头中添加Cookie字段。\r\n- 而服务器响应时，需要明确告知客户端服务器允许这样的凭据，需要在响应头中添加：Access-Control-Allow-Credentials: true。对于一个附带身份凭证的请求，若服务器没有明确告知，浏览器仍然视为跨域被拒绝。另外要特别注意的是对于附带身份凭证的请求，服务器不得设置Access-Control-Allow-Origin的值为*。\r\n### 跨域请求时js使用响应头\r\n> 在跨域访问时，JS只能拿到一些最基本的响应头如：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma，如果要访问其它头，则需要服务器设置该响应头。Access-Control-Expose-Headers头让服务器把允许浏览器访问的头放入白名单，这样JS就能够访问指定的响应头了。\r\n\r\n```\r\nAccess-Control-Expose-Headers: authorization, a, b\r\n```\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## 输入URL到页面显示\r\n1. DNS解析(一个网址和IP地址的转换)，会查DNS缓存(浏览器缓存、系统缓存)。\r\n2. 发起TCP连接，建立客户端和服务器之间的连接。\r\n3. 发送HTTP请求(会查询缓存，强缓存或者协商缓存)。\r\n4. 服务器处理请求，浏览器接收HTTP响应。\r\n5. 浏览器解析。\r\n    - 构造文档对象模型(DOM)\r\n    - 构造CSS对象模型(CSSOM)\r\n    - 生成渲染树\r\n    - 布局\r\n    - 绘制"},function(r,n,e){"use strict";e.r(n),n.default='## JSBridge\r\n> Web 端和 Native 端得以实现双向通信。\r\n\r\n### WebView\r\n> WebView 是移动端中的一个控件，它为 JS 运行提供了一个沙箱环境。WebView 能够加载指定的 url，拦截页面发出的各种请求等各种页面控制功能，JSBridge 的实现就依赖于 WebView 暴露的各种接口。\r\n\r\n| 平台和版本 | WebView 内核\t|\r\n| --- | --- |\r\n| iOS 8+ | WKWebView |\r\n| iOS 2-8 |\tUIWebView |\r\n| Android 4.4+ | Chrome |\r\n| Android 4.4- | Webkit |\r\n\r\n### Native 向 Web 发送消息\r\n> Native 向 Web 发送消息基本原理上是在 WebView 容器中动态地执行一段 JS 脚本，通常情况下是调用一个挂载在全局上下文的方法。Native 端可以直接调用挂载在 window 上的全局方法并传入相应的函数执行参数，并且在函数执行结束后 Native 端可以直接拿到执行成功的返回值。\r\n\r\n1. web端提前subscribe订阅事件 (存储事件处理函数)。\r\n2. 原生调用一个挂载在全局上下文的方法，此事件处理中publish发布事件， 执行之前web端subscribe订阅时存储的事件处理函数。\r\n### Web 向 Native 发送消息\r\n> Web 向 Native 发送消息本质上就是某段 JS 代码的执行端上是可感知的。\r\n\r\n### 拦截式\r\n> 和浏览器类似 WebView 中发出的所有请求都是可以被 Native 容器感知到的，因此拦截式具体指的是 Native 拦截 Web 发出的 URL 请求，双方在此之前约定一个 JSB 请求格式，如果该请求是 JSB 则进行相应的处理，若不是则直接转发。\r\n\r\n#### 发送请求的方式\r\n> Web 端发出请求的方式非常多样，例如 a标签 、iframe.src、location.href、ajax 等，但 a标签 需要用户手动触发，location.href 可能会导致页面跳转，安卓端拦截 ajax 的能力有所欠缺，因此绝大多数拦截式实现方案均采用iframe 来发送请求。\r\n\r\n#### 拦截式劣势\r\n> 拦截式在双端都具有非常好的向下兼容性，曾经是最主流的 JSB 实现方案，但目前在高版本的系统中已经逐渐被淘汰。\r\n\r\n- 连续发送时可能会造成消息丢失（可以使用消息队列解决该问题）\r\n- URL 字符串长度有限制\r\n- 性能一般，URL request 创建请求有一定的耗时（Android 端 200-400ms）\r\n\r\n### 注入式\r\n> 这种方式简单而直观，并且不存在参数长度限制和性能瓶颈等问题，目前主流的 JSBridge SDK 都将注入式方案作为优先使用的对象。\r\n\r\n#### 原生应用调用h5方法\r\n> h5端在全局上下文对象(window)中注入方法，原生应用可以通过evaluateJavascript调用h5在window上注入的方法。\r\n\r\n```\r\n// h5端注入h5MinusCount方法\r\nwindow.h5MinusCount = (minusNum: number) => {\r\n  setCount((prev: number) => prev - minusNum);\r\n  return \'h5MinusCountValue\';\r\n};\r\n\r\n// 原生应用调用h5MinusCount方法\r\nh5MinusCountButton.setOnClickListener {\r\n  val minusNum: Number = 3\r\n  // 调用H5的h5MinusCount方法\r\n  myWebView.evaluateJavascript("javascript:h5MinusCount(${minusNum})", ValueCallback<String>() {\r\n    Toast.makeText(this, it, Toast.LENGTH_SHORT).show()\r\n  })\r\n}\r\n```\r\n#### h5端调用原生应用方法\r\n> 原生应用通过addJavascriptInterface可以在h5端的全局上下文对象(window)中注入方法，h5端直接调用原生应用在window上注入的方法。\r\n\r\n```\r\n// 原生应用注入showNativeToast方法\r\nmyWebView.addJavascriptInterface(WebAppInterface(this), "jsbridge")\r\nclass WebAppInterface(private val mContext: Context) {\r\n  @JavascriptInterface\r\n  fun showNativeToast(toast: String): String {\r\n    Toast.makeText(mContext, toast, Toast.LENGTH_SHORT).show()\r\n    return "showNativeToast return value"\r\n  }\r\n}\r\n\r\n// h5端调用showNativeToast方法\r\nwindow.jsbridge?.showNativeToast(\'h5 click showNativeToast\');\r\n```\r\n### 两种方案对比\r\n| 方案 | 兼容性 | 性能 | 参数长度限制 |\r\n| --- | --- | --- | --- |\r\n| 拦截式 | 无兼容性问题\t| 较差，安卓端尤为明显 | 有限制 |\r\n| 注入式 | 安卓4.2+ 和 iOS 7+以上可用 |\t较好 | 无 |'},function(r,n,e){"use strict";e.r(n),n.default="## dsbridge\r\n### 调用原生同步方法\r\n```\r\nimport dsBridge from 'dsbridge';\r\n\r\nconst __function = function (name, defaultValue) {\r\n  return function (args) {\r\n    const returnValue = dsBridge.call(name, args);\r\n    if (returnValue) {\r\n      return JSON.parse(returnValue);\r\n    } else {\r\n      if (!window.isApp) {\r\n        return defaultValue;\r\n      } else {\r\n        throw new Error(`函数 ${name} 没有有效的返回值`);\r\n      }\r\n    }\r\n  };\r\n};\r\n\r\n// 使用\r\nconst getStatusBarHeight = __function(\"getStatusBarHeight\", 45);\r\nconst height = getStatusBarHeight()\r\n```\r\n### 调用原生异步方法\r\n```\r\nimport dsBridge from 'dsbridge';\r\n\r\nconst __functionAsync = function (name, defaultValue) {\r\n  return function (args) {\r\n    return new Promise((resolve, reject) => {\r\n      if (!window.isApp) {\r\n        resolve(defaultValue);\r\n      } else {\r\n        dsBridge.call(name, args, (returnValue) => {\r\n          resolve(JSON.parse(returnValue));\r\n        });\r\n      }\r\n    });\r\n  };\r\n};\r\n\r\n// 使用\r\nconst getSystemPushStatus = __functionAsync('getSystemPushStatus', { systemPushStatus: 0 });\r\nconst getStatus = async() => {\r\n  const res = await getSystemPushStatus();\r\n}\r\n```\r\n### 判断是否有此方法\r\n```\r\nimport dsBridge from 'dsbridge';\r\n\r\n// 判断方法是否存在\r\ndsBridge.hasNativeMethod('')\r\n```\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## [whistle](http://wproxy.org/whistle/)\r\n> 跨平台抓包调试代理工具。\r\n\r\n### 安装启动\r\n1. npm install -g whistle\r\n2. w2 start  启动\r\n3. w2 stop  关闭\r\n\r\n### 移动端配置代理抓包\r\n1. 电脑安装证书，手机也要安装证书。\r\n2. 手机WIFI的代理设置改为手动，设置主机名和端口(whistle的online选项查看即可)。此时就可以正常抓包。\r\n3. 设置域名映射，应用本地代码进行实时调试。\r\n  1. rules中新建类目\r\n  2. 添加对应映射规则， 比如将百度的网址映射为本地，添加 https://baidu.com/  http://localhost:3000/  即可"},function(r,n,e){"use strict";e.r(n),n.default="## 混合开发\r\n> Native 和 H5 都有着各自的优缺点，为了满足业务的需要，公司实际项目的开发过程中往往会融合两者进行 Hybrid 开发。使用JSBridge连接着桥两端的 Native 和 H5，可以方便的在APP内实现Native 调用 JS，JS 调用 Native。\r\n\r\n| name | H5\t| Native |\r\n| --- | --- | --- |\r\n| 稳定性 | 调用系统浏览器内核，稳定性较差 | 使用原生内核，更加稳定 |\r\n| 灵活性 | 版本迭代快，上线灵活 | 迭代慢，需要应用商店审核，上线速度受限制 |\r\n| 受网速 | 影响\t较大 | 较小|\r\n| 流畅度 | 有时加载慢，给用户“卡顿”的感觉 |\t加载速度快，更加流畅 |\r\n| 用户体验 | 功能受浏览器限制，体验有时较差 |\t原生系统 api 丰富，能实现的功能较多，体验较好 |\r\n| 可移植性 | 兼容跨平台跨系统，如 PC 与 移动端，iOS 与 Android | 可移植性较低，对于 iOS 和 Android 需要维护两套代码 |\r\n\r\n### 区分APP页面是H5还是原生页面\r\n- 断开网络\r\n> 显示404或错误页面的说明是一个H5页面，如果还有控件基本上就是原生的。\r\n\r\n- 看页面布局边界（仅针对安卓手机适用）\r\n> 在手机设置-开发者选项中，开启显示布局边界功能，进入应用原生页面则可以看到页面各个控件的布局，而H5页面则显示整个页面的边界。"},function(r,n,e){"use strict";e.r(n),n.default="## 像素\r\n### 屏幕尺寸\r\n- 屏幕尺寸指的是以屏幕对角线的长度来计算的，单位是英寸。\r\n- 电子设备一般都用英寸来描述屏幕的物理大小，1英寸=2.54厘米。\r\n### 像素pixel\r\n- 从计算机技术的角度来解释，像素是硬件和软件所能控制的最小单位。\r\n- 显示屏的画面上表示出来的最小单位，一个像素，就是一个点，或者说是一个很小的正方形。\r\n### 屏幕分辨率\r\n- 屏幕分辨率指一个屏幕具体由多少个像素点组成，单位是px。\r\n### 物理像素(设备像素)\r\n- 在同一个设备上它的物理像素是固定的，也就是厂家在生产显示设备时就决定的实际点的个数，对于不同设备物理像素点的大小是不一样的。\r\n- 常说的1920*1080像素分辨素就是用的物理像素单位。\r\n- 如果都使用物理像素就会带来问题。21英寸显示器的分辨率是1440x1080，5.8英寸的iPhone X的分辨率是2436×1125，用CSS画一条线其长度是20px，如果都以物理像素作为度量单位，那么在显示器上看起来正常，在iPhone X屏幕上就变得非常小。\r\n### 逻辑像素(设备独立像素)\r\n- 高分辨率的设备，多了一个逻辑像素。不同设备的逻辑像素仍然是有差异的，只不过差异没有物理像素那么大。\r\n- 逻辑像素是与设备无关的逻辑像素，可以通过程序控制使用的虚拟像素。\r\n- 普通屏幕下1设备独立像素等于1设备像素。高清屏幕下1设备独立像素等于N设备像素。\r\n### 设备像素比dpr\r\n> 设备像素/设备独立像素，代表设备独立像素到设备像素的转换关系，在JS中可以通过window.devicePixelRatio获取，计算公式为DPR = 物理像素/逻辑像素。\r\n\r\n- 当设备像素比为1:1时，使用1（1×1）个设备像素显示1个CSS像素。\r\n- 当设备像素比为2:1时，使用4（2×2）个设备像素显示1个CSS像素。\r\n- 当设备像素比为3:1时，使用9（3×3）个设备像素显示1个CSS像素。\r\n### CSS像素\r\n- CSS中使用到的单位PX，就是CSS像素。\r\n- 当页面缩放比为1:1时，一个CSS像素等于一个设备独立像素。但CSS像素是很容易被改变的，比如用户对页面进行放大，CSS像素会被放大，此时的CSS像素会跨越更多的设备像素。\r\n- 页面缩放系数 = CSS像素 / 设备独立像素\r\n### 每英寸像素点ppi\r\n- 表示每英寸所包含的像素点数目，数值越高，说明屏幕能以更高密度显示图像。\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## 兼容问题\r\n### ios日期解析问题\r\n> 在某些情况下苹果系统上解析YYYY-MM-DD HH:mm:ss格式的日期会报错Invalid Date，而安卓系统则没有这个问题。解决这个问题的一种方法是将日期字符串中的 - 替换为 /。\r\n\r\n```\r\n// 将日期字符串的格式符号替换成'/'\r\n\"2023-07-16 00:00:00\".replace(/-/g, '/')\r\n```\r\n### iOS上拉边界下拉出现空白\r\n- 手指按住屏幕下拉屏幕顶部会多出一块白色区域。手指按住屏幕上拉底部多出一块白色区域。\r\n- 在iOS中手指按住屏幕上下拖动，会触发touchmove事件。这个事件触发的对象是整个webview容器，容器自然会被拖动，剩下的部分会成空白。\r\n```\r\ndocument.body.addEventListener(\r\n  'touchmove',\r\n  function(e) {\r\n    if (e._isScroller) {\r\n      return;\r\n    }\r\n    // 阻止默认事件\r\n    e.preventDefault()\r\n  },\r\n  {\r\n    passive: false\r\n  }\r\n)\r\n```\r\n### ios下点击input页面会放大\r\n- html添加禁止缩放的meta\r\n- 添加样式\r\n```\r\ninput {\r\n  font-size: 16px;\r\n}\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## 微信h5调试\r\n### Android\r\n> x5内核 + dhrome://inspect\r\n\r\n1. 手机微信进入http://debugmm.qq.com/?forcex5=true\r\n2. 手机微信进入http://debugx5.qq.com选择打开，打开TBS内核Inspector调试功能\r\n3. USB连接手机、电脑，打开开发者模式以及打开USB调试\r\n4. Chrome中进入chrome://inspect/#devices页面，Devices页面下有对应的Devices Tab，选择对应的网址点击inspect即可\r\n> 提示HTTP/1.1 404 Not Found需要使用代理软件。\r\n\r\n5. 想要应用本地的代码，直接在inspect中的location.href指向本地IP的地址即可。"},function(r,n,e){"use strict";e.r(n),n.default="## 移动端点击事件\r\n> 由于移动端的双击会缩放导致click判断延迟，移动端浏览器在派发点击事件的时候，通常会出现300ms左右的延迟.\r\n\r\n### fastclick\r\n> 在检测到touchend事件的时候，会通过DOM自定义事件立即触发模拟一个click事件，并把浏览器在300ms之后真正的click事件阻止掉.\r\n\r\n```\r\n// 安装\r\nnpm install fastclick -S\r\n\r\n// 引入\r\nimport FastClick from 'fastclick'\r\n\r\n// 使用\r\nFastClick.attach(document.body);\r\n```"},function(r,n,e){"use strict";e.r(n),n.default='## [移动端适配](https://mp.weixin.qq.com/s/ruvX0hLzExQgCVVApJyDSA)\r\n### 媒体查询@media\r\n> 使用CSS3中的媒体查询属性@media分别为不同屏幕尺寸的移动设备编写属于当前移动设备的css属性。\r\n\r\n```\r\n/* <375px */\r\n@media screen and (max-width:375px) { \r\n  .box {\r\n    width: 100%;\r\n  }\r\n}\r\n\r\n/* >=375px and <450px */\r\n@media screen and (min-width:375px) and (max-width:450px) {\r\n  .box {\r\n    width: 90%;\r\n  }\r\n}\r\n\r\n/* >=450px */\r\n@media screen and (min-width:450px) {\r\n  .box {\r\n    width: 80%;\r\n  }\r\n}\r\n```\r\n#### 媒体查询缺点\r\n- 页面上所有的元素都得在不同的@media中定义一遍不同的尺寸，代码冗余多。\r\n- 如果再多一种屏幕尺寸，就得多写一个@media查询块。\r\n- 媒体查询块的书写顺序也有要求，后面的会覆盖前面的，很容易出错。\r\n### rem适配方案\r\n- rem是一个相对于页面根元素html的font-size的一个单位。\r\n- 假如设置了根元素html的font-size为18px，那么1rem等于18px。\r\n- rem的大小会随着根元素html的font-size的改变而改变。rem方案就是利用了这一点，根据不同的屏幕尺寸，来设置根元素html的font-size的大小，以此来达到适配不同屏幕尺寸的目的。\r\n- 封装一个根据屏幕尺寸自动改变html的font-size大小的函数。\r\n```\r\nconst initFontSize = () => {\r\n  const clientWidth = document.documentElement.clientWidth || document.body.clientWidth;\r\n  // 设计图尺寸是750px，这样 * 10之后1rem就等于10px。\r\n  const fontSize = (clientWidth / 750 * 10);\r\n  document.documentElement.style.fontSize = fontSize + "px";\r\n};\r\ninitFontSize();\r\n\r\nwindow.addEventListener("resize", initFontSize);\r\nexport default initFontSize;\r\n```\r\n#### flexible + postcss-pxtorem方案\r\n- index.html添加viewport元数据标签，使页面宽度和设备宽度一致\r\n```\r\n<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">\r\n```\r\n- 安装插件\r\n```\r\nnpm install amfe-flexible --save\r\nnpm install postcss-pxtorem --save-dev\r\n```\r\n- 在main.js中引入amfe-flexible\r\n```\r\nimport \'amfe-flexible\';\r\n```\r\n- 在postcss.config.js文件中配置postcss-pxtorem\r\n```\r\nmodule.exports = {\r\n  "plugins": {\r\n    "postcss-pxtorem": {\r\n      rootValue: 75,  // 根据设计图尺寸写，设计图是750，就写75\r\n      propList: [\'*\'] // 需要被转换的属性\r\n    }\r\n  }\r\n}\r\n```\r\n### viewport适配方案\r\n- viewport方案即是使用vw、vh作为样式单位。\r\n- vw、vh将viewport分成了一百等份，1vw等于视口1%的宽度，1vh等于视口1%的高度。当我们的设计稿是750px时，1vw就等于7.5px。\r\n#### viewport + postcss-px-to-viewport方案\r\n- index.html添加viewport元数据标签，使页面宽度和设备宽度一致\r\n```\r\n<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">\r\n```\r\n- 安装插件\r\n```\r\nnpm install postcss-px-to-viewport --save-dev\r\n```\r\n- 在postcss.config.js文件中配置postcss-px-to-viewport\r\n```\r\nmodule.exports = {\r\n  "plugins": {\r\n    "postcss-px-to-viewport": {\r\n      viewportWidth: 750,    // 设计稿的宽度\r\n      unitPrecision: 5,      // 转换后的位数，即小数点位数\r\n      viewportUnit: \'vw\',    // 转换成的视窗单位\r\n      propList: [\'*\'],       // 要进行转换的属性，如果某个属性不进行转换，只需在其前加个“!”即可\r\n      selectorBlackList: [], // 不进行转换的选择器\r\n      minPixelValue: 1,      // 小于或等于1px则不进行转换\r\n      mediaQuery: true,      // 是否在媒体查询的css代码中也进行转换，默认false\r\n    },\r\n  },\r\n};\r\n```\r\n- 标注不需要转换的属性\r\n  1. px-to-viewport-ignore-next 下一行不进行转换。\r\n  2. px-to-viewport-ignore 当前行不进行转换\r\n```\r\n/* 转化前 */\r\n.box {\r\n  /* px-to-viewport-ignore-next */\r\n  width: 100px;\r\n  padding: 20px;\r\n  height: 100px; /* px-to-viewport-ignore */\r\n}\r\n\r\n/* 转化后 */\r\n.box {\r\n  width: 100px; \r\n  padding: 2.6667vw;\r\n  height: 100px;\r\n}\r\n```\r\n### viewport适配方案相较于rem适配方案的优势\r\n1. 不需要去计算html的font-size。\r\n2. 不需要给html设置font-size，不会因为设置html的font-size大小而必须给body再设置一个font-size，防止继承。\r\n3. 因为不依赖font-size的尺寸，所以不用担心某些原因html的font-size尺寸被纂改导致页面尺寸混乱。\r\n4. vw相对于rem更加语义化，1vw刚好是1/100的viewport的大小。'},function(r,n,e){"use strict";e.r(n),n.default='## 视口viewport\r\n- 视口是浏览器或app中webview显示页面的区域。\r\n- 通常情况下PC端的视口指的是浏览器窗口区域。\r\n- 移动端有些复杂，有三个视口：\r\n  1. layout viewport：布局视口\r\n  2. visual viewport：视觉视口\r\n  3. ideal viewport：理想视口\r\n### 布局视口\r\n- 由浏览器提出的一种虚拟的布局视口，用来解决页面在手机上显示的问题。\r\n- 这种视口可以通过`<meta>`标签设置viewport来改变。移动设备上的浏览器都会把自己默认的viewport设为980px或1024px(也可能是其它值，这个是由设备自己决定的)，但带来的后果就是浏览器会出现横向滚动条，因为浏览器可视区域的宽度是比这个默认的viewport的宽度要小的。\r\n- 可以通过document.documentElement.clientWidth来获取布局视口大小。\r\n### 视觉视口\r\n- 指的是浏览器的可视区域，也就是我们在移动端设备上能够看到的区域。\r\n- 默认与当前浏览器窗口大小相等，当用户对浏览器进行缩放时，不会改变布局视口的大小，但会改变视觉窗口的大小。\r\n- 可以通过window.innerWidth来获取视觉视口大小。\r\n### 理想视口\r\n- 目的是解决在布局视口下页面元素过小的问题，显示在理想视口中的页面具有最理想的宽度，用户无需进行缩放。\r\n- 理想视口即页面绘制区域可以完美适配设备宽度的视口大小，不需要出现滚动条即可正常查看网站的所有内容，且文字图片清晰。\r\n- 当页面缩放比例为100%时，理想视口 = 视觉视口。\r\n- 可以通过screen.width来获取理想视口大小。\r\n### meta viewport\r\n> 对于移动端页面，可以采用`<meta>`标签来配置视口大小和缩放等。viewport只对移动端浏览器有效，对PC端浏览器是无效的。\r\n\r\n```\r\n<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />\r\n```\r\n- width\r\n  1. 该属性被用来控制视窗的宽度，可以将width设置为320这样确切的像素数，也可以设为device-width这样的关键字，表示设备的实际宽度。\r\n  2. 通常情况下为了自适应布局，普遍的做法是将width设置为device-width。\r\n- height\r\n  1. 该属性被用来控制视窗的高度，可以将height设置为640这样确切的像素数，也可以设为device-height这样的关键字，表示设备的实际高度。\r\n  2. 通常情况下不会设置视窗的高度，这样内容超出的话采用滚动方式浏览。\r\n- initial-scale\r\n  1. 该属性用于指定页面的初始缩放比例，可以配置0.0～10的数字。\r\n  2. initial-scale=1表示不进行缩放，视窗刚好等于理想视窗，当大于1时表示将视窗进行放大，小于1时表示缩小。\r\n  3. 这里只表示初始视窗缩放值，用户也可以自己进行缩放，例如双指拖动手势缩放或者双击手势放大。\r\n  4. 安卓设备上的initial-scale无默认值，一定要设置，这个属性才会起作用。\r\n  5. 在iphone和ipad上，无论你给viewport设的宽的是多少，如果没有指定默认的缩放值，则iphone和ipad会自动计算这个缩放值，以达到当前页面不会出现横向滚动条(或者说viewport的宽度就是屏幕的宽度)的目的。\r\n- maximum-scale\r\n  1. 该属性表示用户能够手动放大的最大比例，可以配置0.0～10的数字。\r\n- minimum-scale\r\n  1. 该属性表示用户能够手动缩小的最小比例。\r\n  2. 通常情况下不会定义该属性的值，页面太小将难以浏览。\r\n- user-scalable\r\n  1. 该属性表示是否允许用户手动进行缩放，可配置no或者yes。\r\n  2. 当配置成no时，用户将不能通过手势操作的方式对页面进行缩放。\r\n### 适配与缩放\r\n- 为了让移动端页面获得更好的显示效果，我们必须让布局视口、视觉视口都尽可能等于理想视口。\r\n- 所以通常情况下会设置width=device-width，相当于让布局视口等于理想视口。\r\n- 设置initial-scale=1.0，相当于让视觉视口等于理想视口。\r\n- width可以决定布局视口的宽度，但它并不是布局视口的唯一决定性因素，设置initial-scale也有可能影响到布局视口，因为布局视口宽度取的是width和视觉视口宽度的最大值。\r\n  1. 若手机的理想视口宽度为400px，设置width=device-width，initial-scale=2，此时视觉视口宽度 = 理想视口宽度 / initial-scale即200px，布局视口取两者最大值即device-width 400px。\r\n  2. 若设置width=device-width，initial-scale=0.5，此时视觉视口宽度 = 理想视口宽度 / initial-scale即800px，布局视口取两者最大值即800px。\r\n'},function(r,n,e){"use strict";e.r(n),n.default="## [软键盘弹起](https://setcina.github.io/2020/01/20/WebView%E4%B8%8A%E8%BD%AF%E9%94%AE%E7%9B%98%E7%9A%84%E5%85%BC%E5%AE%B9%E6%96%B9%E6%A1%88/)\r\n### ios软键盘弹起表现\r\n> 在ios上，输入框获取焦点键盘弹起，页面(webview)并没有被压缩，或者说高度(height)没有改变，只是页面(webview)整体往上滚了，且最大滚动高度(scrollTop)为软键盘高度。\r\n\r\n### Android软键盘弹起表现\r\n> 在Android上，输入框获取焦点键盘弹起，页面(webview)高度会发生改变，一般来说高度为可视区高度(原高度减去软键盘高度)，除了因为页面内容被撑开可以产生滚动，webview本身不能滚动。\r\n\r\n### ios软键盘收起表现\r\n> 触发软键盘上的“收起”按钮键盘或者输入框以外的页面区域时，输入框失去焦点，软键盘收起。\r\n\r\n### Android软键盘收起表现\r\n> 触发输入框以外的区域时，输入框失去焦点，软键盘收起。触发键盘上的收起按钮键盘时，输入框不会失去焦点，软键盘会收起。\r\n\r\n### 监听软键盘弹起和收起\r\n- 在ios上，监听输入框的focus事件来获知软键盘弹起，监听输入框的blur事件获知软键盘收起。\r\n- 在Android上，监听webview高度变化，高度变小获知软键盘弹起，否则软键盘收起。\r\n```\r\n// 判断设备类型\r\nvar judgeDeviceType = function () {\r\n  var ua = window.navigator.userAgent.toLocaleLowerCase();\r\n  var isIOS = /iphone|ipad|ipod/.test(ua);\r\n  var isAndroid = /android/.test(ua);\r\n\r\n  return {\r\n    isIOS: isIOS,\r\n    isAndroid: isAndroid\r\n  }\r\n}()\r\n\r\n// 监听输入框的软键盘弹起和收起事件\r\nfunction listenKeybord($input) {\r\n  if (judgeDeviceType.isIOS) {\r\n    // IOS 键盘弹起：IOS 和 Android 输入框获取焦点键盘弹起\r\n    $input.addEventListener('focus', function () {\r\n      console.log('IOS 键盘弹起啦！');\r\n      // IOS 键盘弹起后操作\r\n    }, false)\r\n\r\n    // IOS 键盘收起：IOS 点击输入框以外区域或点击收起按钮，输入框都会失去焦点，键盘会收起，\r\n    $input.addEventListener('blur', () => {\r\n      console.log('IOS 键盘收起啦！');\r\n      // IOS 键盘收起后操作\r\n    })\r\n  }\r\n\r\n  // Andriod 键盘收起：Andriod 键盘弹起或收起页面高度会发生变化，以此为依据获知键盘收起\r\n  if (judgeDeviceType.isAndroid) {\r\n    var originHeight = document.documentElement.clientHeight || document.body.clientHeight;\r\n\r\n    window.addEventListener('resize', function () {\r\n      var resizeHeight = document.documentElement.clientHeight || document.body.clientHeight;\r\n      if (originHeight < resizeHeight) {\r\n        console.log('Android 键盘收起啦！');\r\n        // Android 键盘收起后操作\r\n      } else {\r\n        console.log('Android 键盘弹起啦！');\r\n        // Android 键盘弹起后操作\r\n      }\r\n\r\n      originHeight = resizeHeight;\r\n    }, false)\r\n  }\r\n}\r\n\r\nvar $inputs = document.querySelectorAll('.input');\r\n\r\nfor (var i = 0; i < $inputs.length; i++) {\r\n  listenKeybord($inputs[i]);\r\n}\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## LRU\r\n> LRU（Least recently used，最近最少使用），如果数据最近被访问过，那么将来被访问的几率也更高。所以，越常被使用的数据权重越高。当需要清理数据时，总是清理最不常使用的数据。\r\n\r\n### 实践\r\n- 浏览器的访问历史\r\n- tab形式页面的切换\r\n\r\n### 实现\r\n> 主要是使用什么数据结构来存储数据，因为 map 的存取非常快，所以采用了它，当然数组、链表其实也可以实现的。\r\n\r\n- set 方法：往 map 里面添加新数据，如果添加的数据存在了，则先删除该条数据，然后再添加。如果添加数据后超长了，则需要删除最久远的一条数据。data.keys().next().value 便是获取第一个键（最先存入map集合的键）。\r\n- get 方法：首先从 map 对象中拿出该条数据，然后删除该条数据，最后再重新插入该条数据，确保将该条数据移动到最前面。\r\n```\r\nclass LRUCache {\r\n  constructor(lenght) {\r\n    this.length = lenght; // 存储长度\r\n    this.data = new Map(); // 存储数据\r\n  }\r\n\r\n  // 存储数据，通过键值对的方式\r\n  set(key, value) {\r\n    const data = this.data;\r\n    if (data.has(key)) {\r\n      data.delete(key)\r\n    }\r\n    data.set(key, value);\r\n\r\n    // 如果超出了容量，则需要删除最久的数据\r\n    if (data.size > this.length) {\r\n      const delKey = data.keys().next().value;\r\n      data.delete(delKey);\r\n    }\r\n  }\r\n\r\n  // 获取数据\r\n  get(key) {\r\n    const data = this.data;\r\n    // 未找到\r\n    if (!data.has(key)) {\r\n      return null;\r\n    }\r\n    const value = data.get(key); // 获取元素\r\n    data.delete(key); // 删除元素\r\n    data.set(key, value); // 重新插入元素\r\n  }\r\n}\r\nconst lruCache = new LRUCache(5);\r\n```\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## conclude\r\n### 链表\r\n- 判断回文链表\r\n- 翻转链表\r\n- 判断是否是环形链表\r\n- 返回链表的相交节点\r\n- 删除链表的指定节点\r\n- 删除链表的指定节点\r\n- 手写instanceOf\r\n### 二叉树\r\n- 寻找两个节点最近的公共祖先\r\n- 二叉搜索树\r\n- 二叉树的最小深度\r\n- 二叉树的最大深度\r\n- 比较是否是相同的树\r\n### 栈\r\n- 判断单组括号是否匹配\r\n- 判断多组括号是否匹配\r\n- 十进制转二进制\r\n- 判断html标签是否匹配\r\n### 队列\r\n- 约瑟夫环问题\r\n- 斐波那契数列\r\n### 双指针\r\n- 盛水最多的容器\r\n- 判断字符串是否为某一个字符串的子序列，顺序一致即可，不一定要是连续的\r\n- 删除有序数组中的重复项\r\n- 删除数组的重复项,返回数组的长度。不要使用额外的数组空间，必须在原地修改数组\r\n- 是否为回文字符串\r\n- 数组中字符串翻转\r\n- 给定一个数组将所有0移动到数组的末尾，同时保持非零元素的相对顺序。\r\n### 哈希表\r\n- 给定一个整数数组，判断是否存在重复元素\r\n- 返回字符串中第一个唯一字符的索引\r\n- 判断是否为有效的字母异位词\r\n- 给定一个大长度n的数组，找到在数组中出现次数大于n/2的元素\r\n- 两数之和(给定一个整数数组nums和一个整数目标值target，在该数组中找出和为目标值target的那 两个整数，并返回它们的数组下标)\r\n- 两个数组的交集，返回所有交集的数字\r\n### 数组\r\n- 找出数组中最长的连续递增序列，并返回长度\r\n- 最大子数组和\r\n- 版本号比较\r\n### 字符串\r\n- 查找字符串数组中的最长公共前缀\r\n### 找规律题\r\n- 买卖股票最佳时期\r\n- 罗马数字转整数\r\n- 杨辉三角\r\n### 集合\r\n- 数组去重\r\n- 两个数组交集\r\n### 字典\r\n- 两数之和\r\n- 两个数组的交集\r\n- 最小覆盖字串\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## 分而治之\r\n> 算法设计中的一种思想，将一个问题分成多个子问题，递归解决子问题，然后将子问题的解合并成最终的解。\r\n\r\n### 归并排序 (详见数组排序文档)\r\n- 分：把数组从中间一分为二\r\n- 解：递归地对两个子数组进行归并排序\r\n- 合：合并有序子数组\r\n\r\n### 快速排序 (详见数组排序文档)\r\n- 分：选基准，按基准把数组分成两个子数组\r\n- 解：递归地对两个子数组进行快速排序\r\n- 合：对两个子数组进行合并\r\n\r\n### 二分搜索 (详见数组搜索文档)\r\n- 从数组中的中间位置开始搜索，如果中间元素正好是目标值，则搜索结束。\r\n- 如果目标值大于或者小于中间元素，则在大于或者小于中间元素的那一半数组中搜索。\r\n\r\n### 翻转二叉树 (详见二叉树文档)\r\n> 左侧树节点、右侧树节点分开处理。\r\n\r\n### 比较是否是相同的树 (详见二叉树文档)\r\n> 左侧树节点、右侧树节点分开处理。\r\n\r\n### 对称二叉树 (详见二叉树文档)\r\n> 左侧树节点、右侧树节点分开处理。\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## 动态规划\r\n> 算法设计中的一种思想，将一个问题分解为相互重叠的子问题，通过反复求解子问题来解决原来的问题。\r\n\r\n### 斐波那契数列\r\n> 指的是这样一个数列：0、1、1、2、3、5、8、13、21、34。\r\n\r\n```\r\n// 时间复杂度 O(n) \r\n// 空间复杂度 O(n)\r\nfunction fib(n) {\r\n  let dp = [0, 1, 1];\r\n  for (let i = 3; i <= n; i++) {\r\n    // 当前值等于前两个值之和\r\n    dp[i] = dp[i - 1] + dp[i - 2];\r\n  }\r\n  return dp[n];\r\n}\r\n```\r\n### 爬楼梯\r\n> 正在爬楼梯, 需要n阶才能到达楼顶，每次只能爬 1 或者 2 个台阶, 有多少中不同的方法可以到达楼顶\r\n\r\n```\r\n// 时间复杂度 O(n) n是楼梯长度\r\n// 空间复杂度 O(1)\r\nvar climbStairs = function (n) {\r\n  const res = [];\r\n  res[0] = 1;\r\n  res[1] = 1;\r\n  for (let i = 2; i <= n; i++) {\r\n    res[i] = res[i - 1] + res[i - 2]\r\n  }\r\n  return res[n];\r\n};\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## 双指针\r\n### [盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/)\r\n- 双层循环\r\n> 所有区间计算结果的比较，取最大的值。\r\n\r\n```\r\nconst maxArea = function(height) {\r\n  let max = 0\r\n  for(let i = 0; i < height.length; i++) {\r\n    for(let j = i + 1; j < height.length; j++) {\r\n      currentValue = (j - i) * Math.min(height[i], height[j])\r\n      if (max < currentValue) {\r\n        max = currentValue\r\n      }\r\n    }\r\n  }\r\n  return max\r\n};\r\n```\r\n- [双指针](https://mp.weixin.qq.com/s/Nm4tgudd7RB3dxCy8FP8BQ)\r\n> 从起始和结束两个指针向中间压缩，比较区间的值，取最大的值。\r\n\r\n```\r\nconst maxArea = function(height) {\r\n  let max = 0\r\n  let left = 0\r\n  let right = height.length\r\n  while(left < right) {\r\n    currentValue = (right - left) * Math.min(height[left], height[right])\r\n    if (max < currentValue) {\r\n      max = currentValue\r\n    }\r\n    if (height[left] < height[right]) {\r\n      left++\r\n    } else {\r\n      right--\r\n    }\r\n  }\r\n  return max\r\n};\r\n```\r\n### [判断字符串是否为某一个字符串的子序列(顺序一致即可，不一定要是连续的)](https://leetcode-cn.com/problems/is-subsequence/)\r\n> 利用双指针遍历两个字符串，整串的指针移动，当匹配时子串的的指针向后移动，最后比较子串的指针index与子串的长度比较。\r\n\r\n```\r\nconst isSubsequence = (s, t) => {\r\n  let i = 0; // 子串的指针\r\n  let j = 0; // 整串的指针\r\n  while (i < s.length && j < t.length) {\r\n    if (s[i] == t[j]) i++;\r\n    j++;\r\n  }\r\n  return i == s.length;\r\n}\r\n```\r\n### [删除有序数组中的重复项](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)\r\n> 利用快慢指针，将后面较大的数值移动到前面，保持前面的数组为有序数组。\r\n\r\n```\r\nconst removeDuplicates = (nums) => {\r\n  if (nums.length <= 1) return nums.length;\r\n  let slow = 0, quick = 0;\r\n  while (quick < nums.length) {\r\n    while (nums[slow] === nums[quick]) quick++;\r\n    if (nums[slow] !== nums[quick] && quick < nums.length) {\r\n      slow++;\r\n      nums[slow] = nums[quick];\r\n      quick++;\r\n    }\r\n  }\r\n  return slow + 1;\r\n};\r\n```\r\n### 删除数组的重复项,返回数组的长度。不要使用额外的数组空间，必须在原地修改数组\r\n> 慢指针是i，快指针是j，如果nums[i] 等于 nums[j] 说明是相同的元素，j继续走，i还在原位，如果nums[i] 不等于 nums[j] 说明是不相同的元素，那么nums[i++] = nums[j]，j继续向前走，就相当于i指针保证它和它前面的数字都是不重复的，j就是一个遍历器。\r\n\r\n```\r\nconst removeDuplicates = (nums) => {\r\n  let i = 0;\r\n  for(let j = 1; j < nums.length; j++) {\r\n    if(nums[j] !== nums[i]) {\r\n      nums[i+1] = nums[j];\r\n      i++;\r\n    }\r\n  }\r\n  return i + 1\r\n};\r\n```\r\n### 是否为回文字符串\r\n> 双指针，头尾向中间靠拢\r\n\r\n```\r\nconst isPalindrome = (s) => {\r\n  s = s.replace(/[^\\w]/g, '').toLowerCase();\r\n  let leftPointer = 0;\r\n  let rightPointer = s.length - 1;\r\n  while(rightPointer > leftPointer) {\r\n    if(s[leftPointer++] === s[rightPointer--]) {\r\n      continue;\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n};\r\n```\r\n### 数组中字符串翻转\r\n> 利用首尾双指针进行数组值替换\r\n\r\n```\r\nconst reverseString = (s) => {\r\n  let l = 0 ;\r\n  let r = s.length - 1;\r\n  while(l < r) {\r\n    [s[l], s[r]] = [s[r], s[l]];\r\n    l++; r--;\r\n  }\r\n  return s;\r\n};\r\n```\r\n### 给定一个数组将所有0移动到数组的末尾，同时保持非零元素的相对顺序。\r\n> 用快慢指针来交换数组项的位置。\r\n\r\n```\r\nconst moveZeroes = (nums) => {\r\n  let i = j = 0;\r\n  while(i < nums.length) {\r\n    if(nums[i] !== 0) {\r\n      // 交换位置，将非0的值前移\r\n      [nums[i], nums[j]] = [nums[j], nums[i]];\r\n      j++;\r\n    }\r\n    i++;\r\n  }\r\n  return nums\r\n};\r\n```\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## 哈希表 \r\n### 哈希表 + 计数类型\r\n#### 给定一个整数数组，判断是否存在重复元素。\r\n> 根据元素出现的次数来判断是是否有重复元素。\r\n\r\n```\r\nconst containsDuplicate = (nums) => {\r\n  let map = new Map();\r\n  for(let i of nums) {\r\n    if(map.has(i)) {\r\n      return true;\r\n    } else {\r\n      map.set(i, 1);\r\n    }\r\n  }\r\n  return false;\r\n};\r\n```\r\n#### 返回字符串中第一个唯一字符的索引\r\n> 遍历字符串,用一个对象{}来记数，出现过一次就+1，遍历完毕，再次遍历字符串，看它们在之前记录的对象里的值，是否是1，是就返回下标，不是返回-1。\r\n\r\n```\r\nconst firstUniqChar = (s) => {\r\n  const map = {};\r\n  for(let v of s) {\r\n    map[v] = (map[v] || 0) + 1;\r\n  }\r\n  for(let i = 0; i < s.length; i++) {\r\n    if(map[s[i]] === 1) {\r\n      return i;\r\n    }\r\n  }\r\n  return -1;\r\n};\r\n```\r\n#### 判断是否为有效的字母异位词(两个字符串s和t，若s和t中每个字符出现的次数都相同，则称s和t互为字母异位词)\r\n> 判断两个字符串长度是否相同，如果相同根据长度进行循环，用一个对象来计数，字符串s对应的字符加1，字符串t对应的字符减1，最后所有的value都为0，表示两个字符串的字符出现次数相同。\r\n\r\n```\r\nconst isAnagram = (s, t) => {\r\n  const sLen = s.length;\r\n  const tLen = t.length;\r\n  if(sLen !== tLen) {\r\n    return false;\r\n  }\r\n  const obj = {};\r\n  for(let i = 0; i < sLen; i++) {\r\n    const currentS = s[i];\r\n    const currentT = t[i];\r\n    obj[currentS] ? obj[currentS]++ : obj[currentS] = 1;\r\n    obj[currentT] ? obj[currentT]-- : obj[currentT] = -1;\r\n  }\r\n  return Object.values(obj).every(v => v === 0);\r\n};\r\n```\r\n#### 给定一个大长度n的数组，找到在数组中出现次数大于n/2的元素。\r\n```\r\nconst majorityElement = (nums) => {\r\n  const map = {};\r\n  const n = nums.length >> 1;   // >> 是右移运算符，意思是除以2\r\n  for(let i = 0; i < nums.length; i++) {\r\n    map[nums[i]] = map[nums[i]] !== undefined ? map[nums[i]] + 1 : 1;\r\n    if(map[nums[i]] > n) {\r\n      return nums[i];\r\n    }\r\n  }\r\n}\r\n```\r\n### 哈希表 + 映射功能\r\n#### (两数之和(给定一个整数数组nums和一个整数目标值target，在该数组中找出和为目标值target的那 两个整数，并返回它们的数组下标))[https://leetcode-cn.com/problems/two-sum/]\r\n- 用 hashMap 存储遍历过的元素和对应的索引。每遍历一个元素，看看 hashMap 中是否存在满足要求的目标数字。\r\n\r\n```\r\nconst twoSum = (nums, target) => {\r\n  const map = new Map();\r\n  for(let i = 0, len = nums.length; i < len; i++) {\r\n    if(map.get(nums[i]) !== undefined) {\r\n      return [map.get(nums[i]), i];\r\n    } else {\r\n      // 存储满足和当前值相加结果匹配的数值\r\n      map.set(target - nums[i], i);\r\n    }\r\n  }\r\n  return [];\r\n};\r\n```\r\n- 双层for循环\r\n```\r\nconst twoSum = (nums, target) => {\r\n  for(let i = 0; i< nums.length; i++) {\r\n    for(let j = i + 1; j < nums.length; j++) {\r\n      if (nums[i] + nums[j] === target) {\r\n        return [i, j]\r\n      }\r\n    } \r\n  }\r\n};\r\n```\r\n#### 两个数组的交集，返回所有交集的数字\r\n- set实现，复杂度较高\r\n```\r\nconst intersection = (nums1, nums2) => {\r\n  return [...new Set(nums1)].filter(item => new Set(nums2).has(item))\r\n};\r\n```\r\n- map实现\r\n> 用一个对象去存nums1数组里的每一项，类似map[nums1[i]] = true，然后去遍历nums2，如果在map中已经有的值，类似map[nums2[i]], 就把它push到一个数组里，并且将map[nums2[i]]设为false，后面有相同的值就不push到数组了。\r\n\r\n```\r\nconst intersection = (nums1, nums2) => {\r\n  const map = {};\r\n  const ret = [];\r\n  for(let i = 0; i < nums1.length; i++) {\r\n    map[nums1[i]] = true;\r\n  }\r\n  for(let i = 0; i < nums2.length; i++) {\r\n    if(map[nums2[i]]) {\r\n      ret.push(nums2[i])\r\n      map[nums2[i]] = false;\r\n    }\r\n  }\r\n  return ret;\r\n};\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## 回溯算法\r\n> 算法设计中的一种思想，一种渐进式寻找并构建问题解决方式的策略，会先从一个可能的动作开始解决问题，如不行，就回溯选择另外一个动作，直到找到一个解。\r\n\r\n### 全排列\r\n```\r\n// 输入 [1, 2, 3]\r\n// 输出 [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\r\n\r\n// 时间复杂度 O(n!) n! = 1 * 2 * 3 * ··· * (n-1) * n;\r\n// 空间复杂度 O(n)\r\n\r\nvar permute = function (nums) {\r\n  // 存放结果\r\n  const res = [];\r\n  const backTrack = (path) => {\r\n    // 递归结束条件 \r\n    if (path.length === nums.length) {\r\n      res.push(path);\r\n      return;\r\n    }\r\n    // 遍历传入数组\r\n    nums.forEach(n => {\r\n      // 如果子数组中有这个元素就是死路，需要回溯回去走其他路\r\n      if (path.includes(n)) return;\r\n      // 加入到子数组里\r\n      backTrack(path.concat(n));\r\n    })\r\n  }\r\n\r\n  backTrack([]);\r\n  return res;\r\n};\r\n```\r\n### 子集\r\n```\r\n// 输入 [1, 2, 3]\r\n// 输出 [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]]\r\n\r\n// 时间复杂度 O(2 ^ N) 每个元素都有两种可能\r\n// 空间复杂度 O(N)\r\n\r\nvar subsets = function (nums) {\r\n  // 存放结果数组\r\n  const res = [];\r\n  const backTrack = (path, l, start) => {\r\n    // 递归结束条件\r\n    if (path.length === l) {\r\n      res.push(path);\r\n      return;\r\n    }\r\n    // 遍历输入的数组长度 起始位置是start\r\n    for (let i = start; i < nums.length; i++) {\r\n      // 递归调用 需要保证子集的有序, start为 i+1\r\n      backTrack(path.concat(nums[i]), l, i + 1);\r\n    }\r\n  };\r\n\r\n  // 遍历输入数组长度\r\n  for (let i = 0; i <= nums.length; i++) {\r\n    // 传入长度 起始索引\r\n    backTrack([], i, 0);\r\n  }\r\n  return res\r\n};\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## 复杂度\r\n### 时间复杂度\r\n> 其实就是一个函数，用大 O 表示，定义描述算法的运行时间。\r\n\r\n- O(1)\r\n```\r\nlet i = 0\r\ni += 1\r\n```\r\n- O(n) 如果是 O(1) + O(n) 则还是 O(n)\r\n```\r\nfor (let i = 0; i < n; i += 1) {\r\n  console.log(i)\r\n}\r\n```\r\n- O(n^2)  O(n) * O(n), 也就是双层循环，自此类推： O(n^3)\r\n```\r\nfor (let i = 0; i < n; i += 1) {\r\n  for (let j = 0; j < n; j += 1) {\r\n    console.log(i, j)\r\n  }\r\n}\r\n```\r\n- O(logn) 就是求 log 以 2 为底的多少次方等于 n\r\n```\r\n// 这个例子就是求2的多少次方会大于i，然后就会结束循环。 这就是一个典型的 O(logn)\r\nlet i = 1\r\nwhile (i < n) {\r\n  console.log(i)\r\n  i *= 2\r\n}\r\n```\r\n### 空间复杂度\r\n> 空间复杂度也是用大 O 表示，用来定义描述算法运行过程中临时占用的存储空间大小。\r\n\r\n- O(1)： 单个变量，所以占用永远是 O(1)\r\n```\r\nlet i = 0\r\ni += 1\r\n```\r\n- O(n) 声明一个数组， 添加 n 个值， 相当于占用了 n 个空间单元\r\n```\r\nconst arr = []\r\nfor (let i = 0; i < n; i += 1) {\r\n  arr.push(i)\r\n}\r\n```\r\n- O(n^2)： 类似一个矩阵的概念，就是二维数组的意思\r\n```\r\nconst arr = []\r\nfor (let i = 0; i < n; i += 1) {\r\n  arr.push([])\r\n  for (let j = 0; j < n; j += 1) {\r\n    arr[i].push(j)\r\n  }\r\n}\r\n```"},function(r,n,e){"use strict";e.r(n),n.default='## 字典\r\n### 两数之和\r\n```\r\n// nums = [2, 7, 11, 15] target = 9\r\n\r\n// 时间复杂度O(n) n为nums的length\r\n// 空间复杂度O(n)\r\nconst twoSum = function (nums, target) {\r\n  // 建立一个字典数据结构来保存需要的值\r\n  const map = new Map();\r\n  for (let i = 0; i < nums.length; i++) {\r\n    // 获取当前的值，和需要的值\r\n    const n = nums[i];\r\n    const n2 = target - n;\r\n    // 如字典中有需要的值，就匹配成功\r\n    if (map.has(n2)) {\r\n      return [map.get(n2), i];\r\n    } else {\r\n    // 如没有，则把需要的值添加到字典中\r\n      map.set(n, i);\r\n    }\r\n  }\r\n};\r\n```\r\n### 两个数组的交集\r\n```\r\n// nums1 = [1,2,2,1], nums2 = [2,2]\r\n// 输出：[2]\r\n\r\n// 时间复杂度 O(m + n) m为nums1长度 n为nums2长度\r\n// 空间复杂度 O(m) m为交集的数组长度\r\nconst intersection = (nums1, nums2) => {\r\n  // 创建一个字典\r\n  const map = new Map();\r\n  // 将数组1中的数字放入字典\r\n  nums1.forEach(n => map.set(n, true));\r\n  // 创建一个新数组\r\n  const res = [];\r\n  // 将数组2遍历 并判断是否在字典中\r\n  nums2.forEach(n => {\r\n    if (map.has(n)) {\r\n      res.push(n);\r\n      // 如果在字典中，则删除该数字\r\n      map.delete(n);\r\n    }\r\n  })\r\n  return res;\r\n};\r\n```\r\n### 最小覆盖字串\r\n```\r\n// 输入：s = "ADOBECODEBANC", t = "ABC"\r\n// 输出："BANC"\r\n\r\n// 时间复杂度 O(m + n) m是t的长度 n是s的长度\r\n// 空间复杂度 O(k) k是字符串中不重复字符的个数\r\nconst minWindow = function (s, t) {\r\n  // 定义双指针维护一个滑动窗口\r\n  let l = 0;\r\n  let r = 0;\r\n\r\n  // 建立一个字典\r\n  const need = new Map();\r\n  //  遍历t\r\n  for (const c of t) {\r\n    need.set(c, need.has(c) ? need.get(c) + 1 : 1)\r\n  }\r\n  let needType = need.size\r\n  // 记录最小子串\r\n  let res = ""\r\n\r\n  // 移动右指针\r\n  while (r < s.length) {\r\n    // 获取当前字符\r\n    const c = s[r];\r\n    // 如果字典里有这个字符\r\n    if (need.has(c)) {\r\n      // 减少字典里面的次数\r\n      need.set(c, need.get(c) - 1);\r\n      // 减少需要的值\r\n      if (need.get(c) === 0) needType -= 1;\r\n    }\r\n    // 如果字典中所有的值都为0了 就说明找到了一个最小子串\r\n    while (needType === 0) {\r\n      // 取出当前符合要求的子串\r\n      const newRes = s.substring(l, r + 1)\r\n      // 如果当前子串是小于上次的子串就进行覆盖\r\n      if (!res || newRes.length < res.length) res = newRes;\r\n      // 获取左指针的字符\r\n      const c2 = s[l];\r\n      // 如果字典里有这个字符\r\n      if (need.has(c2)) {\r\n        // 增加字典里面的次数\r\n        need.set(c2, need.get(c2) + 1);\r\n        // 增加需要的值\r\n        if (need.get(c2) === 1) needType += 1;\r\n      }\r\n      l += 1;\r\n    }\r\n    r += 1;\r\n  }\r\n  return res;\r\n};\r\n```'},function(r,n,e){"use strict";e.r(n),n.default="## 找规律题\r\n### 罗马数字转整数\r\n```\r\nconst romanToInt = (s) => {\r\n  const map = {\r\n    I: 1,\r\n    V: 5,\r\n    IV: 4,\r\n    IX: 9,\r\n    X: 10,\r\n    XL: 40,\r\n    XC: 90,\r\n    L: 50,\r\n    C: 100,\r\n    CD: 400,\r\n    CM: 900,\r\n    D: 500,\r\n    M: 1000,\r\n  };\r\n  let res = 0;\r\n  let index = 0;\r\n  let len = s.length;\r\n  while(index < len) {\r\n    // 判断两个的字符是否满足，不满足则使用单个字符相加\r\n    if(index + 1 < len && map[s.slice(index, index+2)]) {\r\n      res += map[s.slice(index, index+2)];\r\n      index += 2;\r\n    } else {\r\n      res += map[s.slice(index, index+1)];\r\n      index += 1;\r\n    }\r\n  }\r\n  return res;\r\n};\r\nLVIII\r\n```\r\n### 杨辉三角\r\n1. 三角中的每一行数据都依赖于上一行的数据。\r\n2. 我们首先创建队列 queue，用于存储每一行的数据，供下一行数据使用。\r\n3. 然后初始化第一行的数据 1 入队，这里需要两个 for 循环嵌套，外层的 for 循环决定最终打印的总行数，内层的 for 循环生成每行的数据。\r\n4. 在生成当前行的数据时，将队列中的数据源依次出队，然后将新生成的数据入队；并记录当前出队的数据，供生成新数据使用。\r\n\r\n```\r\nconst printYangHui = (num) => {\r\n  const queue = [];\r\n  // 存储第一行数据\r\n  queue.push(1);\r\n\r\n  for(let i = 1; i <= num; i++) {\r\n    let rowArr = [];\r\n    // 填充空格\r\n    for(let j = 0; j < Math.floor((num - i) / 2); j++) {\r\n      rowArr.push('');\r\n    }\r\n    let prev = 0;\r\n    for(let j = 0; j < i; j++) {\r\n      const num = queue.shift();\r\n      queue.push(prev + num);\r\n      rowArr.push(num);\r\n      prev = num;\r\n    }\r\n    queue.push(1);\r\n    console.log(rowArr.join(' '));\r\n  }\r\n}\r\n\r\nprintYangHui(3);\r\n```"},function(r,n,e){"use strict";e.r(n),n.default='## 数组\r\n### [找出数组中最长的连续递增序列，并返回长度](https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/)\r\n> 两个变量一个存储全局最长的长度，一个存储当前循环过程中的长度，数组前后比较进行长度变量的变化。\r\n\r\n```\r\nconst findLengthOfLCIS = function(nums) {\r\n  if (nums.length === 0) {\r\n    return 0;\r\n  }\r\n  let globalMaxLength = 1, maxLength = 1;\r\n  nums.reduce((prev, curr) => {\r\n    if (curr > prev) {\r\n      maxLength ++;\r\n    } else {\r\n      maxLength = 1;\r\n    }\r\n    globalMaxLength = Math.max(globalMaxLength, maxLength);\r\n    return curr\r\n  })\r\n  return globalMaxLength;\r\n};\r\n```\r\n### [最大子数组和](https://leetcode-cn.com/problems/maximum-subarray/)\r\n> 初始将数组每一个index对应的值存储为0，循环数组将当前index对应的值存储为当前index对应的数据和当前index对应数据和上一个index对应数据和中较大的值，存储较大的值，直到循环结束。\r\n\r\n```\r\nconst maxSubArray = (nums) => {\r\n  let maxSum = -Infinity; // 最大值\r\n  let dp = [], n = nums.length;\r\n  // 每一个index对应的初始值都为0\r\n  for (let i = -1; i < n; i++) {\r\n    dp[i] = 0;\r\n  }\r\n  for (let i = 0; i < n; i++) {\r\n    // 比较当前值和当前值与前一个值相加的结果，存储较大的值\r\n    dp[i] = Math.max(nums[i], dp[i - 1] + nums[i]);\r\n    maxSum = Math.max(maxSum, dp[i]);\r\n  }\r\n  return maxSum;\r\n};\r\n```\r\n### 版本号比较\r\n1. 版本号 v1、v2 按照符号"."分割成数组，从左右依次进行大小比较。\r\n2. v1 大于 v2 返回 1，v1 小于 v2 返回-1，v1 等于 v2 返回 0。\r\n```\r\n/*\r\n  比较版本号大小\r\n\tv1：第一个版本号\r\n\tv2：第二个版本号\r\n\t如果版本号相等，返回 0, 如果第一个版本号低于第二个，返回 -1，否则返回 1。\r\n*/\r\n\r\nfunction compareVersion(v1, v2) {\r\n\tif (!v1 && !v2) return 0;\r\n\tif (!v1) return -1;\r\n\tif (!v2) return 1;\r\n\tconst v1Stack = v1.split(\'.\');\r\n\tconst v2Stack = v2.split(\'.\');\r\n\tconst maxLen = Math.max(v1Stack.length, v2Stack.length);\r\n\r\n\tfor(let i = 0; i < maxLen; i++) {\r\n\t\t// 必须转整，否则按照字符顺序比较大小\r\n\t\tconst prevVal = ~~v1Stack[i];\r\n\t\tconst currVal = ~~v2Stack[i];\r\n\t\tif (prevVal > currVal) {\r\n\t\t\treturn 1;\r\n\t\t}\r\n\t\tif (prevVal < currVal) {\r\n\t\t\treturn -1;\r\n\t\t}\r\n\t}\r\n\treturn 0;\r\n}\r\n\r\nconsole.log(compareVersion("2.2.1", "2.2.01")); // 0\r\nconsole.log(compareVersion("2.2.1", "2.2.0")); // 1\r\nconsole.log(compareVersion("2.2.1", "2.1.9")); // 1\r\nconsole.log(compareVersion("2.2", "2.1.1")); // 1\r\nconsole.log(compareVersion("2.2", "2.2.1")); // -1\r\nconsole.log(compareVersion("2.2.3.4.5.6", "2.2.2.4.5.12")); // 1\r\nconsole.log(compareVersion("2.2.3.4.5.6", "2.2.3.4.5.12")); // -1\r\n```'},function(r,n,e){"use strict";e.r(n),n.default="## 搜索\r\n> 找出数组中某个元素的下标，js中通常使用indexOf方法进行搜索。\r\n\r\n### 顺序搜索\r\n> 就比如indexOf方法， 从头开始搜索数组中的某个元素。\r\n\r\n### 二分搜索\r\n> 数组必须是有序的，如不是则需要先进行排序。\r\n\r\n- 从数组中的中间位置开始搜索，如果中间元素正好是目标值，则搜索结束。\r\n- 如果目标值大于或者小于中间元素，则在大于或者小于中间元素的那一半数组中搜索。\r\n```\r\n// 时间复杂度：O(log n)  分割成两半的 基本都是logn\r\n// 空间复杂度：O(1)\r\nArray.prototype.binarySearch = function (item) {\r\n  // 代表数组的最小索引\r\n  let low = 0;\r\n  // 和最大索引\r\n  let higt = this.length - 1;\r\n  while (low <= higt) {\r\n    // 获取中间元素索引\r\n    const mid = (low + higt) >> 1;\r\n    const element = this[mid];\r\n    // 如果中间元素小于要查找的元素 就把最小索引更新为中间索引的下一个\r\n    if (element < item) {\r\n      low = mid + 1;\r\n    } else if (element > item) {\r\n    // 如果中间元素大于要查找的元素 就把最大索引更新为中间索引的前一个\r\n      higt = mid - 1;\r\n    } else {\r\n      // 如果中间元素等于要查找的元素 就返回索引\r\n      return mid;\r\n    }\r\n  }\r\n  return -1\r\n}\r\n```\r\n\r\n"},function(r,n,e){"use strict";e.r(n),n.default='## 栈\r\n### 十进制转二进制\r\n```\r\n// 时间复杂度 O(n) n为二进制的长度\r\n// 空间复杂度 O(n) n为二进制的长度\r\nconst dec2bin = (dec) => {\r\n  // 创建一个字符串\r\n  let res = "";\r\n\r\n  // 创建一个栈\r\n  let stack = []\r\n\r\n  // 遍历数字 如果大于0 就可以继续转换2进制\r\n  while (dec > 0) {\r\n    // 将数字的余数入栈\r\n    stack.push(dec % 2);\r\n\r\n    // 除以2\r\n    dec = dec >> 1;\r\n  }\r\n\r\n  // 取出栈中的数字\r\n  while (stack.length) {\r\n    res += stack.pop();\r\n  }\r\n\r\n  // 返回这个字符串\r\n  return res;\r\n};\r\n```\r\n### 判断html标签是否匹配\r\n1. 声明变量 stack、nodes，并从头遍历 HTML 字符串，查找字符"<"的位置。\r\n2. 如果字符"<"的位置等于 0\r\n  1. 则继续尝试匹配 HTML 结束标签，匹配成功并且与栈顶的标签名称一致，则弹出栈顶；否则报错。\r\n  2. 匹配 HTML 结束标签失败以后，则尝试匹配开始标签的起始部分，然后循环匹配标签属性对，最后匹配开始标签的结束部分。匹配完成以后，将匹配到的标签压入栈顶；并构建 node 节点数。\r\n3. 如果字符"<"的位置大于 0\r\n  1. 则 html.slice(0, pos)，创建文本节点。\r\n```\r\nfunction parseHtml(html = \'\') {\r\n\tconst startIndex = 0;\r\n\tconst endIndex = 0;\r\n\r\n\t// 匹配标签<div>、<br/>等标签的开始部分"<div、<br"\r\n\tconst startTagOpen = /^<([a-zA-Z\\d]+)/;\r\n\r\n\t// 匹配标签<div>、<br/>等标签的闭合部分">、/>"\r\n\tconst startTagClose = /^\\s*(/?)>/;\r\n\t\r\n\t// 匹配属性\r\n\tconst attribute = /^\\s*([\\w-]+)(?:="([^"]*)")?\\s*/;\r\n\r\n\t// 匹配闭合标签，例如</div>、</p>\r\n\tconst endTag = /^</([a-zA-Z\\d]+)>/;\r\n\r\n\tconst stack = [];\r\n\tconst nodes = [];\r\n\twhile(html) {\r\n\t\t// 查找<的起始位置\r\n\t\tconst index = html.indexOf(\'<\');\r\n\t\tif (index === 0) {\r\n\t\t\t// 先匹配整体结束标签，例如</div>、</p>\r\n\t\t\tlet endTagMatch = html.match(endTag);\r\n\r\n\t\t\tif (endTagMatch) {\r\n\t\t\t\tif (stack[stack.length - 1]) {\r\n\t\t\t\t\tif (stack[stack.length - 1].tag === endTagMatch[1]) {\r\n\t\t\t\t\t\t// 出栈\r\n\t\t\t\t\t\tstack.pop();\r\n\t\t\t\t\t\tadvanced(endTagMatch[0].length);\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tthrow new Error(`起始标签和结束标签不匹配: 起始标签（${stack[stack.length - 1].tag}），结束标签（${endTagMatch[0]}）`);\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthrow new Error(`${endTagMatch[0]}没有起始标签`);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// 然后匹配起始标签的开始部分，例如<div>的<div、<p>的<p、<br/>的<br\r\n\t\t\tlet startTagOpenMatch = html.match(startTagOpen);\r\n\t\t\tif (startTagOpenMatch) {\r\n\t\t\t\tconst node = {\r\n\t\t\t\t\tnodeType: 1,\r\n\t\t\t\t\ttag: startTagOpenMatch[1],\r\n\t\t\t\t\tattrs: [],\r\n\t\t\t\t\tchildren: [],\r\n\t\t\t\t};\r\n\t\t\t\tadvanced(startTagOpenMatch[0].length);\r\n\t\t\t\tlet end, attr;\r\n\t\t\t\t// 匹配标签属性列表\r\n\t\t\t\twhile(!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {\r\n\t\t\t\t\tadvanced(attr[0].length);\r\n\t\t\t\t\tnode.attrs.push({\r\n\t\t\t\t\t\tname: attr[1],\r\n\t\t\t\t\t\tvalue: attr[2],\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// 匹配起始标签的结束部分\r\n\t\t\t\tif (end) {\r\n\t\t\t\t\tif (stack.length === 0) {\r\n\t\t\t\t\t\tnodes.push(node);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tstack[stack.length - 1].children.push(node);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// 自闭和标签不加入栈中\r\n\t\t\t\t\tif (end[1] !== \'/\') {\r\n\t\t\t\t\t\tstack.push(node);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tadvanced(end[0].length);\r\n\t\t\t\t}\r\n\t\t  }\r\n\t\t} else {\r\n\t\t\t// 文本\r\n\t\t\tconst node = {\r\n\t\t\t\tnodeType: 3,\r\n\t\t\t\ttextContent: html.slice(0, index)\r\n\t\t\t};\r\n\r\n\t\t\tif (stack.length === 0) {\r\n\t\t\t\tnodes.push(node);\r\n\t\t\t} else {\r\n\t\t\t\tstack[stack.length - 1].children.push(node);\r\n\t\t\t}\r\n\t\t\tadvanced(node.textContent.length);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction advanced(n) {\r\n\t\thtml = html.substring(n);\r\n\t}\r\n\r\n\treturn nodes;\r\n}\r\nparseHtml(\'<div id="test" class="a b"></div>\');\r\nparseHtml(\'<div id="test" class="a b">Hello World</div>\');\r\nparseHtml(\'开始<div id="test" class="a b">Hello World</div>\');\r\nparseHtml(\'<div id="test" class="a b"><br class="br" />Hello World</div>\');\r\nparseHtml(\'</div>\');\r\nparseHtml(\'<div></p>\');\r\n```'},function(r,n,e){"use strict";e.r(n),n.default="## 贪心算法\r\n> 算法设计中的一种思想，期盼通过每个阶段的局部最优选择，从而达到全局的最优，但结果并不一定是最优。\r\n\r\n### 买卖股票最佳时机，给定一个数组 prices ，其中 prices[i] 是一支给定股票第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\r\n> 只要今天比昨天高就说明有利润可以卖出。\r\n\r\n```\r\nconst maxProfit = (prices) => {\r\n  let result = 0\r\n  for(let i = 1; i < prices.length; i++) {\r\n    // 今天比昨天高就卖出\r\n    if(prices[i] > prices[i-1]) {\r\n      result += prices[i] - prices[i - 1]\r\n    }\r\n  }\r\n  return result;\r\n};\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## 队列\r\n### 约瑟夫环问题\r\n> 一个数组存放了 100 个数据 0-99，要求每隔两个数删除一个数，到末尾时再循环至开头继续进行，求最后一个被删除的数字。\r\n\r\n1. 创建队列，将 0 到 99 的数字入队。\r\n2. 循环队列，依次出列队列中的数字，对当前出队的数字进行计数 index + 1。\r\n3. 判断当前出列的 index % 3 是否等于 0，如果不等于 0 则再次入队。\r\n4. 直到队列的长度为 1，退出循环，返回队列中的数字。\r\n```\r\nfunction ring(arr) {\r\n  const queue = new Queue();\r\n  arr.forEach(v => queue.enqueue(v));\r\n  let index = 0;\r\n  while(queue.size() > 1) {\r\n    const item = queue.dequeue();\r\n    if (++index % 3 !== 0) {\r\n      queue.enqueue(item);\r\n    }\r\n  }\r\n  return queue.head();\r\n}\r\n```\r\n### 斐波那契数列\r\n> 指的是这样一个数列：0、1、1、2、3、5、8、13、21、34。\r\n\r\n```\r\nfunction fiboSequence(num) {\r\n  if (num < 2) return num;\r\n  const queue = [];\r\n  queue.push(0);\r\n  queue.push(1);\r\n  for(let i = 2; i < num; i++) {\r\n    const len = queue.length;\r\n    queue.push(queue[len - 2] + queue[len  - 1]);\r\n  }\r\n  return queue;\r\n}\r\n```\r\n### 最近的请求次数\r\n```\r\nconst RecentCounter = () => {\r\n  // 初始化队列\r\n  this.q = [];\r\n};\r\n\r\n// 输入 inputs = [[],[1],[100],[3001],[3002]] 请求间隔为 3000ms\r\n// 输出 outputs = [null,1,2,3,3]   \r\n\r\n// 时间复杂度 O(n) n为剔出老请求的长度\r\n// 空间复杂度 O(n) n为最近请求的次数\r\nRecentCounter.prototype.ping = function (t) {\r\n  // 如果传入的时间小于等于最近请求的时间，则直接返回0\r\n  if (!t) return null\r\n\r\n  // 将传入的时间放入队列\r\n  this.q.push(t);\r\n\r\n  // 如果队头小于 t - 3000 则剔除队头\r\n  while (this.q[0] < t - 3000) {\r\n    this.q.shift();\r\n  }\r\n\r\n  // 返回最近请求的次数\r\n  return this.q.length;\r\n};\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## 集合\r\n### 数组去重\r\n```\r\nconst arr = [1, 1, 1, 2, 2, 3];\r\n\r\n// 去重\r\nconst arr2 = [...new Set(arr)];\r\n```\r\n### 两个数组交集\r\n```\r\n// 时间复杂度 O(n^2) n为数组长度\r\n// 空间复杂度 O(n)  n为去重后的数组长度\r\nconst intersection = (nums1, nums2) => {\r\n  // 通过数组的filter选出交集\r\n  // 然后通过 Set集合 去重 并生成数组\r\n  return [...new Set(nums1.filter(item => nums2.includes(item)))];\r\n}\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## 代理模式\r\n### 定义\r\n> 代理模式是为其它对象提供一种代理以控制这个对象的访问，具体执行的功能还是这个对象本身。\r\n\r\n### 何时使用\r\n- 模块职责单一且可复用\r\n- 两个模块间的交互需要一定限制关系\r\n### demo\r\n> 先通过一张loading图占位，然后通过异步的方式加载图片，等图片加载好了再把完成的图片加载到img标签里面。\r\n\r\n```\r\n// 本体\r\nvar imgFunc = (function() {\r\n\tvar imgNode = document.createElement('img');\r\n\tdocument.body.appendChild(imgNode);\r\n\treturn {\r\n\t\tsetSrc: function(src) {\r\n\t\t\timgNode.src = src;\r\n\t\t}\r\n\t}\r\n})();\r\n\r\n// 代理\r\nvar proxyImage = (function() {\r\n\tvar img = new Image();\r\n\timg.onload = function() {\r\n\t\timgFunc.setSrc(this.src);\r\n\t}\r\n\treturn {\r\n\t\tsetSrc: function(src) {\r\n\t\t\timgFunc.setSrc('./loading,gif');\r\n\t\t\timg.src = src;\r\n\t\t}\r\n\t}\r\n})();\r\n\r\n// 调用\r\nproxyImage.setSrc('./pic.png');\r\n```"},function(r,n,e){"use strict";e.r(n),n.default='## 单例模式\r\n### 定义\r\n> 保证一个类仅有一个实例，并提供一个访问它的全局访问点。实现的方法为先判断实例存在与否，如果存在则直接返回，如果不存在就创建了再返回，这就确保了一个类只有一个实例对象。\r\n\r\n### 场景\r\n> 弹窗，无论点击多少次，弹窗只应该被创建一次。\r\n\r\n### demo\r\n```\r\nclass CreateUser {\r\n  constructor(name) {\r\n    this.name = name;\r\n    this.getName();\r\n  }\r\n  getName() {\r\n    return this.name;\r\n  }\r\n}\r\n\r\n// 代理实现单例模式\r\nvar ProxyMode = (function() {\r\n  var instance = null;\r\n  return function(name) {\r\n    if(!instance) {\r\n      instance = new CreateUser(name);\r\n    }\r\n    return instance;\r\n  }\r\n})();\r\n\r\n// 测试单体模式的实例\r\nvar dyx = new ProxyMode("dyx");\r\nvar douyaxing = new ProxyMode("douyaxing");\r\n\r\n// 因为只实例化一次，所以两个实例是相等的\r\nconsole.log(dyx === douyaxing);  // true\r\n```\r\n\r\n'},function(r,n,e){"use strict";e.r(n),n.default="## [发布订阅和观察者模式](https://juejin.cn/post/6844904018964119566)\r\n> 观察者模式是观察者直接观察目标对象，没有中介层。而发布订阅模式多了一个中介层，发布者和订阅者依赖于中介层，并不直接通信。\r\n\r\n- 观察者模式里只有两个角色观察者和被观察者，而发布订阅模式里却不仅仅只有发布者和订阅者两个角色，还有一个中间者。\r\n- 观察者和被观察者，是松耦合的关系，发布者和订阅者，则完全不存在耦合。\r\n- 发布订阅多用于异步  观察者模式多用于同步。"},function(r,n,e){"use strict";e.r(n),n.default='## 发布订阅模式\r\n> 发布订阅模式中，包含发布者，事件调度中心，订阅者三个角色。实现的EventHandler的每一个实例就是一个事件调度中心，发布者和订阅者是松散耦合的，互不关心对方是否存在，他们关注的是事件本身。发布者借用事件调度中心提供的emit方法进行事件触发，而订阅者则通过on进行事件注册。可类比于DOM事件中的dispatchEvent和addEventListener。\r\n\r\n### demo\r\n> EventBus实现发布和订阅逻辑。\r\n\r\n```\r\ntype EventHandler = (data?: any) => void;\r\n\r\nclass EventEmitter {\r\n  handlersMapping: {\r\n    [key: string]: Array<EventHandler>;\r\n  } = {};\r\n\r\n  // 注册事件和处理函数\r\n  on(type: string, handler: EventHandler) {\r\n    let handlers = this.handlersMapping[type];\r\n    if (!handlers) {\r\n      handlers = this.handlersMapping[type] = [];\r\n    }\r\n    handlers.push(handler);\r\n  }\r\n\r\n  // 销毁事件和处理函数\r\n  off(type: string, handler: EventHandler) {\r\n    let handlers = this.handlersMapping[type] || [];\r\n    if (!handler) {\r\n      // 没有传入要销毁的方法时，清空时间对应所有方法\r\n      this.handlersMapping[type] = [];\r\n    } else {\r\n      const targetIndex = handlers.findIndex((handlerItem: EventHandler) => handlerItem === handler);\r\n      if (targetIndex !== -1) {\r\n        handlers.splice(targetIndex, 1);\r\n      }\r\n    }\r\n  }\r\n\r\n  // 触发某事件所有回调并带参数\r\n  emit(type: string, payload?: any) {\r\n    let handlers = this.handlersMapping[type] || [];\r\n    handlers.forEach(handler => handler(payload));\r\n  }\r\n}\r\n\r\nexport default new EventEmitter();\r\n\r\n// 内部组件进行监听某个事件执行在内部组件中注册处理函数，在全局组件中满足条件时触发内部组件所监听的方法\r\nconst dyxtest = () => {}\r\nuseEffect(() => {\r\n  eventBus.on("dyxtest", dyxtest);\r\n  return () => {\r\n    eventBus.off("dyxtest", dyxtest);\r\n  };\r\n}, []);\r\n\r\n// 全局组件触发\r\neventBus.emit("dyxtest");\r\n```\r\n\r\n'},function(r,n,e){"use strict";e.r(n),n.default="## 策略模式\r\n### 定义\r\n> 定义一系列的方法，把它们封装起来，并且使他们可以相互替换。将方法的使用形式的实现分离开来。\r\n\r\n### 何时使用\r\n- 各判断条件下的策略相互独立且可复用\r\n- 策略内部逻辑相对复杂\r\n- 策略需要灵活组合\r\n\r\n### demo\r\n> 一组策略（可变），策略类封装了具体的方法，并负责具体的计算过程。第二个部分是校验的方法（不变），校验的方法接收用户的调用，随后将请求委托给某一个策略。校验的方法中要维持对策略对象的引用。\r\n\r\n```\r\n// 维护权限列表\r\nconst jobList = ['FE', 'BE'];\r\n\r\n// 策略\r\nvar strategies = {\r\n  checkRole: function(value) {\r\n    return value === 'juejin';\r\n  },\r\n  checkGrade: function(value) {\r\n    return value >= 1;\r\n  },\r\n  checkJob: function(value) {\r\n    return jobList.indexOf(value) > 1;\r\n  },\r\n  checkEatType: function(value) {\r\n    return value === 'eat melons';\r\n  }\r\n};\r\n\r\n// 校验规则\r\nvar Validator = function() {\r\n  this.cache = [];\r\n\r\n  // 添加策略事件\r\n  this.add = function(value, method) {\r\n    this.cache.push(function() {\r\n      return strategies[method](value);\r\n    });\r\n  };\r\n\r\n  // 检查\r\n  this.check = function() {\r\n    for (let i = 0; i < this.cache.length; i++) {\r\n      let valiFn = this.cache[i];\r\n      var data = valiFn(); // 开始检查\r\n      if (!data) {\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  };\r\n};\r\n\r\n// 具体使用\r\nvar compose1 = function() {\r\n  var validator = new Validator();\r\n  const data1 = {\r\n    role: 'juejin',\r\n    grade: 3\r\n  };\r\n  validator.add(data1.role, 'checkRole');\r\n  validator.add(data1.grade, 'checkGrade');\r\n  const result = validator.check();\r\n  return result;\r\n};\r\n```\r\n\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## 装饰者模式\r\n### 定义\r\n> 装饰器是对类、函数、属性之类的一种装饰，可以针对其添加一些额外的行为。通俗的理解可以认为就是在原有代码外层包装了一层处理逻辑。\r\n\r\n### 对原有方法或类添加功能\r\n```\r\n// 对现有的类添加功能\r\nclass Calc {\r\n  getData() {\r\n    return {\r\n      name: 'dyx'\r\n    }\r\n  }\r\n}\r\n\r\nfunction wrap(Model, key) {\r\n  // 获取class对应的原型\r\n  let target = Model.prototype;\r\n  // 获取函数对应的描述符\r\n  let descriptor = Object.getOwnPropertyDescriptor(target, key)\r\n  // 生成新的函数，添加耗时统计逻辑\r\n  let log = function(...arg) {\r\n    let start = new Date().valueOf();\r\n    try {\r\n      return descriptor.value.apply(this, arg); // 调用之前的函数\r\n    } finally {\r\n      let end = new Date().valueOf();\r\n      console.log(`start: ${start} end: ${end} consume: ${end - start}`)\r\n    }\r\n  }\r\n  // 将修改后的函数重新定义到原型链上\r\n  Object.defineProperty(target, key, {\r\n    ...descriptor,\r\n    value: log\r\n  })\r\n}\r\nwrap(Calc, 'getData')\r\nconsole.log(new Calc().getData())\r\n```\r\n### class继承多个类\r\n```\r\nclass A {\r\n  say () {\r\n    return 1;\r\n  }\r\n}\r\n\r\nclass B {\r\n  hi () {\r\n    return 2;\r\n  }\r\n}\r\n\r\nclass C {\r\n  go () {\r\n    return 3;\r\n  }\r\n}\r\n\r\nfunction mixin(constructor) {\r\n  return function(...args) {\r\n    for (let arg of args) {\r\n      for (let key of Object.getOwnPropertyNames(arg.prototype)) {\r\n        if (key === 'constructor') continue;  // 跳过构造函数\r\n        Object.defineProperty(constructor.prototype, key, Object.getOwnPropertyDescriptor(arg.prototype, key));\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nmixin(C)(A, B)\r\nconst c = new C();\r\nconsole.log(c)\r\nconsole.log(c.say())\r\nconsole.log(c.hi())\r\nconsole.log(c.go())\r\n```\r\n### 高阶组件\r\n```\r\nimport React from 'react';\r\n\r\nconst yellowHOC = WrapperComponent => {\r\n  return class extends React.Component {\r\n    render() {\r\n      <div style={{ backgroundColor: 'yellow' }}>\r\n        <WrapperComponent {...this.props} />\r\n      </div>;\r\n    }\r\n  };\r\n};\r\n\r\nexport default yellowHOC;\r\n```\r\n\r\n"},function(r,n,e){"use strict";e.r(n),n.default="## 观察者模式\r\n> 在观察者模式中，只有两个主体，分别是目标对象Subject，观察者Observer。\r\n\r\n### demo\r\n```\r\n// 观察者\r\nclass Observer {\r\n  // 构造器，收到目标对象通知时执行\r\n  constructor(cb) {\r\n    if (typeof cb === 'function') {\r\n      this.cb = cb;\r\n    } else {\r\n      throw new Error('Observer构造器必须传入函数类型！');\r\n    }\r\n  }\r\n\r\n  // 被目标对象通知时执行\r\n  update() {\r\n    this.cb()\r\n  }\r\n}\r\n\r\n// 目标对象\r\nclass Subject {\r\n  constructor() {\r\n    // 维护观察者列表\r\n    this.observerList = []\r\n  }\r\n\r\n  // 添加一个观察者\r\n  addObserver(observer) {\r\n    this.observerList.push(observer)\r\n  }\r\n\r\n  // 通知所有的观察者\r\n  notify() {\r\n    this.observerList.forEach(observer => {\r\n      observer.update()\r\n    })\r\n  }\r\n}\r\n\r\nconst observerCallback = function() {\r\n  console.log('我被通知了')\r\n}\r\nconst observerCallback1 = function() {\r\n  console.log('我被通知了1')\r\n}\r\nconst observer = new Observer(observerCallback)\r\nconst observer1 = new Observer(observerCallback1)\r\n\r\nconst subject = new Subject();\r\nsubject.addObserver(observer);\r\nsubject.addObserver(observer1);\r\nsubject.notify();\r\n```"},function(r,n,e){"use strict";e.r(n),n.default="## 设计模式\r\n> 在面向对象软件设计的工程中，针对特定的问题简洁优雅的一种解决方案。通过设计模式可以增加代码的可重用性，可扩展性，可维护性，最终使得我们的代码高内聚、低耦合。\r\n\r\n### 设计模式的五大设计原则\r\n- 单一职责：一个程序只需要做好一件事。如果功能过于复杂就拆分开，保证每个部分的独立。\r\n- 开放封闭原则：对扩展开放，对修改封闭。增加需求时，扩展新代码，而不是修改源代码。这是软件设计的终极目标。\r\n- 里氏置换原则：子类能覆盖父类，父类能出现的地方子类也能出现。\r\n- 接口独立原则：保持接口的单一独立，避免出现“胖接口”。这点目前在TS中运用到。\r\n- 依赖倒置原则：面向接口编程，依赖于抽象而不依赖于具体。使用方只专注接口而不用关注具体类的实现。俗称“鸭子类型”\r\n### 核心\r\n> 设计模式的核心操作是去观察整个逻辑里面的变与不变，然后将变与不变分离，达到使变化的部分灵活、不变的地方稳定的目的。\r\n"},,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,function(r,n,e){"use strict";Object.defineProperty(n,"__esModule",{value:!0});n.isPC=function(){for(var r=navigator.userAgent,n=["Android","iPhone","ymbianOS","Windows Phone","iPad","iPod"],e=!0,t=0;t<n.length;t++)if(r.indexOf(n[t])>0){e=!1;break}return e}},function(r,n,e){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.default=void 0;var t,o,s=f(e(138)),a=function(){function r(r,n){for(var e=0;e<n.length;e++){var t=n[e];t.enumerable=t.enumerable||!1,t.configurable=!0,"value"in t&&(t.writable=!0),Object.defineProperty(r,t.key,t)}}return function(n,e,t){return e&&r(n.prototype,e),t&&r(n,t),n}}();e(405);var i=e(1),c=f(i),l=e(72),u=f(e(137)),d=f(e(866)),p=f(e(864)),m=f(e(44));function f(r){return r&&r.__esModule?r:{default:r}}function h(r,n){if(!(r instanceof n))throw new TypeError("Cannot call a class as a function")}function g(r,n){if(!r)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!n||"object"!=typeof n&&"function"!=typeof n?r:n}var b=s.default.SubMenu,y=(t=(0,m.default)(p.default),(0,l.withRouter)(o=t(o=function(r){function n(){return h(this,n),g(this,(n.__proto__||Object.getPrototypeOf(n)).apply(this,arguments))}return function(r,n){if("function"!=typeof n&&null!==n)throw new TypeError("Super expression must either be null or a function, not "+typeof n);r.prototype=Object.create(n&&n.prototype,{constructor:{value:r,enumerable:!1,writable:!0,configurable:!0}}),n&&(Object.setPrototypeOf?Object.setPrototypeOf(r,n):r.__proto__=n)}(n,r),a(n,[{key:"render",value:function(){var r=this.props,n=r.location.pathname,e=r.menuConfig,t=r.defaultOpenKeys,o=(e||[]).find((function(r){return(0,d.default)(r.submenu)?n===r.key:r.submenu.find((function(r){return r.key===n}))}));return o=o?(0,d.default)(o.submenu)?o.key:(0,u.default)(o.submenu.find((function(r){return r.key===n})),"key"):"",c.default.createElement("div",{styleName:"left-nav"},c.default.createElement(s.default,{mode:"inline",selectedKeys:[o],defaultOpenKeys:t||[]},(e||[]).map((function(r){return(r.submenu||[]).length>0?c.default.createElement(b,{key:r.key,title:r.label},r.submenu.map((function(r){return c.default.createElement(s.default.Item,{key:r.key},c.default.createElement(l.Link,{to:r.key,title:r.label},r.label))}))):c.default.createElement(s.default.Item,{key:r.key},c.default.createElement(l.Link,{to:r.key,title:r.label},r.label))}))))}}]),n}(i.Component))||o)||o);n.default=y},function(r,n,e){var t=e(865);"string"==typeof t&&(t=[[r.i,t,""]]);var o={hmr:!0,transform:void 0,insertInto:void 0};e(25)(t,o);t.locals&&(r.exports=t.locals)},function(r,n,e){(n=r.exports=e(24)(!1)).push([r.i,".index__left-nav--pdueK {\n  height: calc(100vh - 49px);\n  overflow-y: auto;\n  -webkit-flex-shrink: 0;\n  -ms-flex-negative: 0;\n  flex-shrink: 0;\n  border-right: 1px solid #eee;\n}\n.index__left-nav--pdueK .ant-menu {\n  width: 256px;\n}\n.index__left-nav--pdueK .ant-menu .ant-menu-item {\n  width: 100% !important;\n}\n.index__left-nav--pdueK .ant-menu .ant-menu-item a {\n  width: 100%;\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n.index__left-nav--pdueK .ant-menu-inline,\n.index__left-nav--pdueK .ant-menu-vertical,\n.index__left-nav--pdueK .ant-menu-vertical-left {\n  border: none;\n}\n.index__left-nav--pdueK .ant-menu-inline .ant-menu-item,\n.index__left-nav--pdueK .ant-menu-inline .ant-menu-submenu-title {\n  width: 100%;\n}\n@media only screen and (max-width: 700px) {\n  .index__left-nav--pdueK .ant-menu {\n    width: 100px;\n  }\n}\n",""]),n.locals={"left-nav":"index__left-nav--pdueK"}},,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,function(r,n,e){"use strict";Object.defineProperty(n,"__esModule",{value:!0});o(e(1));var t=o(e(1180));function o(r){return r&&r.__esModule?r:{default:r}}n.default={allScreen:[],partScreen:[{exact:!0,path:"/interview/:classification/:name",component:t.default}]}},function(r,n,e){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.default=void 0;var t,o=p(e(64)),s=function(){function r(r,n){for(var e=0;e<n.length;e++){var t=n[e];t.enumerable=t.enumerable||!1,t.configurable=!0,"value"in t&&(t.writable=!0),Object.defineProperty(r,t.key,t)}}return function(n,e,t){return e&&r(n.prototype,e),t&&r(n,t),n}}();e(63);var a=p(e(1)),i=p(e(44)),c=p(e(156)),l=p(e(137)),u=p(e(157)),d=p(e(1181));function p(r){return r&&r.__esModule?r:{default:r}}function m(r,n){if(!(r instanceof n))throw new TypeError("Cannot call a class as a function")}function f(r,n){if(!r)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!n||"object"!=typeof n&&"function"!=typeof n?r:n}var h=new u.default.Converter,g=e(425).keys().map((function(r){var n=r.split("/");if(3===n.length){var e=n[1],t=n[2].replace(".md","");return{key:"/interview/"+e+"/"+t,label:e+"/"+t}}})),b=(0,i.default)(d.default)(t=function(r){function n(){var r,e,t;m(this,n);for(var s=arguments.length,a=Array(s),i=0;i<s;i++)a[i]=arguments[i];return e=t=f(this,(r=n.__proto__||Object.getPrototypeOf(n)).call.apply(r,[this].concat(a))),t.copyCode=function(r){var n=r&&r.innerText;if(navigator.clipboard)navigator.clipboard.writeText(n).then((function(){o.default.success("复制成功")}),(function(r){o.default.error("复制失败")}));else{var e=document.createElement("textarea");e.value=n,e.style.position="fixed",document.body.appendChild(e),e.focus(),e.select();try{document.execCommand("copy");o.default.success("复制成功")}catch(r){o.default.error("复制失败")}document.body.removeChild(e)}},t.hightLight=function(){var r=document.getElementById("category-md").getElementsByTagName("pre"),n=document.createElement("div");n.setAttribute("class","pre-code"),n.innerText="复制",(Array.from(r)||[]).forEach((function(r){r.setAttribute("style","position: relative"),r.appendChild(n),c.default.highlightBlock(r)})),Array.from(document.querySelectorAll(".pre-code")).forEach((function(r){return r.addEventListener("click",(function(){return t.copyCode(r.previousSibling)}))}))},t.jump=function(r){t.props.history.push(g[r].key)},f(t,e)}return function(r,n){if("function"!=typeof n&&null!==n)throw new TypeError("Super expression must either be null or a function, not "+typeof n);r.prototype=Object.create(n&&n.prototype,{constructor:{value:r,enumerable:!1,writable:!0,configurable:!0}}),n&&(Object.setPrototypeOf?Object.setPrototypeOf(r,n):r.__proto__=n)}(n,r),s(n,[{key:"componentDidMount",value:function(){this.hightLight()}},{key:"componentDidUpdate",value:function(){var r=document.querySelector(".right-content");r&&(r.scrollTop=0),this.hightLight()}},{key:"componentWillUnMount",value:function(){Array.from(document.querySelectorAll(".pre-code")).removeEventListener("click",this.copyCode)}},{key:"render",value:function(){var r=this,n=(0,l.default)(this.props,"match.params.classification"),t=(0,l.default)(this.props,"match.params.name"),o=g.findIndex((function(r){return r.label===n+"/"+t})),s=o+1,i=o-1;return o===g.length-1&&(s=0),0===o&&(i=g.length-1),a.default.createElement("div",{styleName:"content"},a.default.createElement("div",{styleName:"top"},a.default.createElement("div",{onClick:function(){return r.jump(i)}},"上一篇：",g[i].label),a.default.createElement("div",{onClick:function(){return r.jump(s)}},"下一篇：",g[s].label)),a.default.createElement("div",{styleName:"category-md",dangerouslySetInnerHTML:{__html:h.makeHtml(e(1183)("./"+n+"/"+t+".md").default)},id:"category-md"}))}}]),n}(a.default.Component))||t;n.default=b},function(r,n,e){var t=e(1182);"string"==typeof t&&(t=[[r.i,t,""]]);var o={hmr:!0,transform:void 0,insertInto:void 0};e(25)(t,o);t.locals&&(r.exports=t.locals)},function(r,n,e){(n=r.exports=e(24)(!1)).push([r.i,".index__content--3YxyC {\n  width: 100%;\n}\n.index__content--3YxyC .index__top--3YZi9 {\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-box-pack: justify;\n  -webkit-justify-content: space-between;\n  -ms-flex-pack: justify;\n  justify-content: space-between;\n  -webkit-flex-wrap: wrap;\n  -ms-flex-wrap: wrap;\n  flex-wrap: wrap;\n  font-size: 14px;\n  margin-bottom: 24px;\n  color: #1890ff;\n  cursor: pointer;\n}\n.index__content--3YxyC .index__category-md--3yiT5 {\n  width: 100%;\n}\n.index__content--3YxyC .index__category-md--3yiT5 blockquote {\n  padding: 8px;\n  line-height: 24px;\n  color: #666;\n  margin: 8px 0;\n  border-left: 4px solid #cbcbcb;\n  background-color: #f8f8f8;\n}\n.index__content--3YxyC .index__category-md--3yiT5 blockquote p {\n  margin: 0;\n}\n.index__content--3YxyC .index__category-md--3yiT5 .pre-code {\n  position: absolute;\n  top: 8px;\n  right: 8px;\n  cursor: pointer;\n}\n",""]),n.locals={content:"index__content--3YxyC",top:"index__top--3YZi9","category-md":"index__category-md--3yiT5"}},function(r,n,e){var t={"./WebSocket/WebSocket.md":426,"./WebSocket/WebSocket心跳.md":427,"./babel/Babel.md":428,"./babel/Babel配置.md":429,"./cli/cli.md":430,"./css/bfc.md":431,"./css/css.md":432,"./css/css3.md":433,"./css/css选择器-child和-of-type的使用差异.md":434,"./css/css选择器.md":435,"./css/flex.md":436,"./css/scss变量.md":437,"./css/伪类伪元素.md":438,"./css/居中.md":439,"./css/换行.md":440,"./css/样式隔离.md":441,"./css/浮动.md":442,"./css/盒子模型.md":443,"./css/网页变黑白颜色.md":444,"./css/雪碧图.md":445,"./docker/docker.md":446,"./docker/docker常用命令.md":447,"./done.md":448,"./git/fetch和merge的区别.md":449,"./git/git提交规范.md":450,"./git/rebase和merge的区别.md":451,"./html/html渲染.md":452,"./html/meta.md":453,"./html/修改页签icon.md":454,"./html/页面可见性.md":455,"./html/页面生命周期.md":456,"./http/Accept系列字段.md":457,"./http/URI.md":458,"./http/dns.md":459,"./http/http.md":460,"./http/http2.md":461,"./http/https.md":462,"./http/http代理.md":463,"./http/http状态码.md":464,"./http/http缓存.md":465,"./http/http请求方法.md":466,"./http/三次握手和四次挥手.md":467,"./http/定长不定长的数据处理.md":468,"./http/队头阻塞.md":469,"./js/==和===.md":470,"./js/Array.md":471,"./js/ES6.md":472,"./js/Generator和协程.md":473,"./js/Map.md":474,"./js/Object.defineProperty.md":475,"./js/Service Worker.md":476,"./js/Set.md":477,"./js/Symbol.md":478,"./js/Web Worker.md":479,"./js/WebComponent.md":480,"./js/a == 1 && a == 2 && a == 3.md":481,"./js/arguments.md":482,"./js/async在循环中使用的问题.md":483,"./js/beforeunload事件.md":484,"./js/esModule和commonjs的区别.md":485,"./js/forEach的局限.md":486,"./js/hasOwnProperty与in的区别.md":487,"./js/js事件流.md":488,"./js/js加载方式.md":489,"./js/new操作符.md":490,"./js/promise.md":491,"./js/promiseAll控制并发.md":492,"./js/setTimeout和setInterval.md":493,"./js/this.md":494,"./js/var let const差异.md":495,"./js/事件委托.md":496,"./js/事件循环eventLoop.md":497,"./js/作用域.md":498,"./js/内存泄漏和垃圾回收.md":499,"./js/前端模块化.md":500,"./js/前端获取网络信息.md":501,"./js/前端路由.md":502,"./js/原型原型链.md":503,"./js/图像懒加载和预加载.md":504,"./js/对象创建.md":505,"./js/异步处理方案.md":506,"./js/数据类型及判断方法.md":507,"./js/浏览器页面不可见时定时器是否准时.md":508,"./js/浮点数精度丢失.md":509,"./js/深浅拷贝.md":510,"./js/渲染大量数据.md":511,"./js/箭头函数与普通函数的区别.md":512,"./js/类型转换.md":513,"./js/继承.md":514,"./js/节流与防抖.md":515,"./js/鉴权.md":516,"./js/闭包.md":517,"./js/预解析.md":518,"./js/高级函数用法.md":519,"./leetcode二叉树中等/二叉树的最近公共祖先.md":520,"./leetcode二叉树简单/二叉搜索树中的搜索.md":521,"./leetcode二叉树简单/二叉树中序遍历.md":522,"./leetcode二叉树简单/二叉树前序遍历.md":523,"./leetcode二叉树简单/二叉树后序遍历.md":524,"./leetcode二叉树简单/二叉树的最大深度.md":525,"./leetcode二叉树简单/二叉树的最小深度.md":526,"./leetcode二叉树简单/对称二叉树.md":527,"./leetcode二叉树简单/相同的树.md":528,"./leetcode二叉树简单/翻转二叉树.md":529,"./leetcode简单/两数之和.md":530,"./leetcode简单/二进制求和.md":531,"./leetcode简单/删除有序数组中的重复项.md":532,"./leetcode简单/加一.md":533,"./leetcode简单/回文数.md":534,"./leetcode简单/搜索插入位置.md":535,"./leetcode简单/最后一个单词长度.md":536,"./leetcode简单/最长公共前缀.md":537,"./leetcode简单/有效的括号.md":538,"./leetcode简单/爬楼梯.md":539,"./leetcode简单/移除数组元素.md":540,"./leetcode简单/罗马数字转整数.md":541,"./leetcode简单/设计哈希映射.md":542,"./leetcode简单/设计哈希集合.md":543,"./leetcode链表简单/二进制链表转整数.md":544,"./leetcode链表简单/从尾到头打印链表.md":545,"./leetcode链表简单/删除中间节点.md":546,"./leetcode链表简单/删除排序链表中的重复元素.md":547,"./leetcode链表简单/反转链表.md":548,"./leetcode链表简单/合并两个有序链表.md":549,"./leetcode链表简单/回文链表.md":550,"./leetcode链表简单/环形链表.md":551,"./leetcode链表简单/相交链表.md":552,"./leetcode链表简单/移除链表元素.md":553,"./leetcode链表简单/移除链表重复节点.md":554,"./leetcode链表简单/链表中倒数第k个节点.md":555,"./leetcode链表简单/链表的中间结点.md":556,"./nginx/IP黑白名单.md":557,"./nginx/gzip压缩.md":558,"./nginx/location.md":559,"./nginx/nginx.md":560,"./nginx/proxy_pass.md":561,"./nginx/root和alias.md":562,"./nginx/try_files.md":563,"./nginx/常用命令.md":564,"./nginx/常用配置.md":565,"./nginx/正向代理反向代理.md":566,"./nginx/解决跨域问题.md":567,"./nginx/负载均衡.md":568,"./nginx/配置SSL证书.md":569,"./nginx/防盗链.md":570,"./node/module.exports和exports的区别.md":571,"./node/node执行命令添加参数.md":572,"./node/nvm.md":573,"./npm/npm run xxx.md":574,"./npm/npm源管理.md":575,"./npm/npm版本符号.md":576,"./npm/package-lock.md":577,"./npm/package.md":578,"./react/Immutable Data.md":579,"./react/api.md":580,"./react/class组件的super.md":581,"./react/diff.md":582,"./react/fiber.md":583,"./react/hooks.md":584,"./react/hooks中使用防抖节流.md":585,"./react/hooks作用.md":586,"./react/jsx.md":587,"./react/jsx转换的变化.md":588,"./react/key.md":589,"./react/re-render.md":590,"./react/react-intl国际化.md":591,"./react/react-router4 Prompt实现路由跳转前的提示.md":592,"./react/react.md":593,"./react/react18变化.md":594,"./react/react18并发模式.md":595,"./react/react为什么需要一个根标签包裹.md":596,"./react/react事件机制.md":597,"./react/react性能优化.md":598,"./react/react架构.md":599,"./react/react错误捕获.md":600,"./react/redux.md":601,"./react/ref.md":602,"./react/renderProps.md":603,"./react/router.md":604,"./react/setState.md":605,"./react/state和props.md":606,"./react/useEffect和useLayoutEffect.md":607,"./react/useMemo和useCallback.md":608,"./react/不依赖客户端时间的倒计时.md":609,"./react/状态管理.md":610,"./react/生命周期.md":611,"./react/简单react.md":612,"./react/类组件中方法绑定到类实例.md":613,"./react/组件封装.md":614,"./react/组件通信.md":615,"./react/自定义hooks.md":616,"./react/虚拟DOM.md":617,"./react源码/Component.md":618,"./react源码/createElement.md":619,"./ssr/react服务端渲染.md":620,"./ssr/ssr.md":621,"./typescript/interface和type的异同.md":622,"./typescript/tsconfig.md":623,"./typescript/typescript.md":624,"./typescript/unknown和any.md":625,"./typescript/映射类型.md":626,"./typescript/泛型.md":627,"./vue/defineProperty缺陷.md":628,"./vue/vue的data是通过方法返回.md":629,"./vue/生命周期.md":630,"./vue/简易vue实现.md":631,"./webpack/chunk.md":632,"./webpack/css-loader.md":633,"./webpack/css文件提取成单独的文件.md":634,"./webpack/loader.md":635,"./webpack/output.md":636,"./webpack/output的hash.md":637,"./webpack/plugin.md":638,"./webpack/proxy.md":639,"./webpack/sourcemap.md":640,"./webpack/splitChunksPlugin.md":641,"./webpack/webpack5变化.md":642,"./webpack/webpack5搭建react+ts项目.md":643,"./webpack/webpack的作用.md":644,"./webpack/构建体积优化.md":645,"./webpack/构建时间优化.md":646,"./web安全/csrf.md":647,"./web安全/react防御xss.md":648,"./web安全/sql注入.md":649,"./web安全/xss.md":650,"./代码优化/减少if-else的使用.md":651,"./前端工程化/BFF.md":652,"./前端工程化/Eslint + Prettier + husky + lint-staged规范前端工程.md":653,"./前端工程化/browserslist.md":654,"./前端工程化/cdn.md":655,"./前端工程化/dayjs代替moment.md":656,"./前端工程化/monorepo.md":657,"./前端工程化/前端主题切换方案.md":658,"./前端工程化/前端工程化.md":659,"./前端工程化/前端规范.md":660,"./前端异常/try-catch.md":661,"./前端异常/前端异常.md":662,"./前端异常/异常处理.md":663,"./前端异常/异常监控.md":664,"./前端文件处理/ArrayBuffer.md":665,"./前端文件处理/Base64.md":666,"./前端文件处理/Blob.md":667,"./前端文件处理/File.md":668,"./前端文件处理/FileReader.md":669,"./前端文件处理/ObjectURL.md":670,"./前端文件处理/前端请求文件数据流.md":671,"./前端文件处理/大文件切片上传.md":672,"./前端文件处理/大文件断点续传.md":673,"./前端文件处理/文件上传.md":674,"./前端文件处理/文件下载.md":675,"./前端文件处理/文件预览.md":676,"./前端文件处理/格式转化.md":677,"./前端监控/sendBeacon.md":678,"./前端监控/前端监控.md":679,"./前端监控/性能数据采集.md":680,"./前端监控/接口请求错误数据采集.md":681,"./前端监控/数据上报.md":682,"./前端监控/行为数据采集.md":683,"./前端监控/解析错误信息源码.md":684,"./前端监控/错误数据采集.md":685,"./前端调试/Redux DevTools.md":686,"./前端部署/docker部署项目.md":687,"./前端部署/gitlab runner部署项目.md":688,"./前端部署/nginx配置前端项目.md":689,"./开发功能总结/react-markdown渲染markdown文件.md":690,"./微前端/qiankun微前端.md":691,"./微前端/qiankun微前端各应用分别部署.md":692,"./微前端/qiankun微前端部署同级目录.md":693,"./微前端/qiankun微前端部署非同级目录.md":694,"./微前端/微前端.md":695,"./性能优化/图片资源优化.md":696,"./性能优化/客户端优化H5加载速度.md":697,"./性能优化/性能指标.md":698,"./性能优化/网络请求优化.md":699,"./性能优化/资源体积优化.md":700,"./性能优化/项目细节优化.md":701,"./手写代码/手写ES6数组方法.md":702,"./手写代码/手写bind、call、apply.md":703,"./手写代码/手写instanceof.md":704,"./手写代码/手写promise.md":705,"./数据结构/字典.md":706,"./数据结构/栈.md":707,"./数据结构/树.md":708,"./数据结构/链表.md":709,"./数据结构/队列.md":710,"./数据结构/集合.md":711,"./数据请求/refreshToken.md":712,"./数据请求/sendBeacon.md":713,"./数据请求/数据请求.md":714,"./数据请求/数据请求轮询.md":715,"./数组排序/冒泡排序.md":716,"./数组排序/归并排序.md":717,"./数组排序/快速排序.md":718,"./数组排序/插入排序.md":719,"./数组排序/选择排序.md":720,"./构建工具/vite VS webpack.md":721,"./框架/React、Vue3、Vue2 列表的 Diff 算法对比.md":722,"./框架/react和vue的异同.md":723,"./浏览器/Cookie.md":724,"./浏览器/WebStorage.md":725,"./浏览器/回流和重绘.md":726,"./浏览器/复合图层.md":727,"./浏览器/浏览器内核(渲染进程).md":728,"./浏览器/跨域.md":729,"./浏览器/输入URL到显示.md":730,"./混合开发/JSBridge.md":731,"./混合开发/dsbridge.md":732,"./混合开发/whistle.md":733,"./混合开发/混合开发.md":734,"./移动端/像素.md":735,"./移动端/兼容问题.md":736,"./移动端/微信h5调试.md":737,"./移动端/点击问题.md":738,"./移动端/移动端适配.md":739,"./移动端/视口.md":740,"./移动端/软键盘弹起.md":741,"./算法/LRU(最少最近使用).md":742,"./算法/conclude.md":743,"./算法/分而治之.md":744,"./算法/动态规划.md":745,"./算法/双指针.md":746,"./算法/哈希表.md":747,"./算法/回溯算法.md":748,"./算法/复杂度.md":749,"./算法/字典.md":750,"./算法/找规律题.md":751,"./算法/数组.md":752,"./算法/数组搜索.md":753,"./算法/栈.md":754,"./算法/贪心算法.md":755,"./算法/队列.md":756,"./算法/集合.md":757,"./设计模式/代理模式.md":758,"./设计模式/单例模式.md":759,"./设计模式/发布订阅和观察者模式.md":760,"./设计模式/发布订阅模式.md":761,"./设计模式/策略模式.md":762,"./设计模式/装饰者模式.md":763,"./设计模式/观察者模式.md":764,"./设计模式/设计模式.md":765};function o(r){var n=s(r);return e(n)}function s(r){if(!e.o(t,r)){var n=new Error("Cannot find module '"+r+"'");throw n.code="MODULE_NOT_FOUND",n}return t[r]}o.keys=function(){return Object.keys(t)},o.resolve=s,r.exports=o,o.id=1183},function(r,n,e){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var t=e(425),o=[];t.keys().forEach((function(r){var n=r.split("/");if(3===n.length){var e=n[1],t=n[2].replace(".md",""),s=o.findIndex((function(r){return r.key===e}));s>-1?o[s].submenu.push({key:"/interview/"+e+"/"+t,label:t}):o.push({key:e,label:e,submenu:[{key:"/interview/"+e+"/"+t,label:t}]})}})),n.default=o},,,,,,,function(r,n,e){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.default=void 0;var t=Object.assign||function(r){for(var n=1;n<arguments.length;n++){var e=arguments[n];for(var t in e)Object.prototype.hasOwnProperty.call(e,t)&&(r[t]=e[t])}return r},o=function(){function r(r,n){for(var e=0;e<n.length;e++){var t=n[e];t.enumerable=t.enumerable||!1,t.configurable=!0,"value"in t&&(t.writable=!0),Object.defineProperty(r,t.key,t)}}return function(n,e,t){return e&&r(n.prototype,e),t&&r(n,t),n}}(),s=e(1),a=p(s),i=e(72),c=p(e(135)),l=p(e(136)),u=p(e(1179)),d=p(e(1184));function p(r){return r&&r.__esModule?r:{default:r}}function m(r,n){if(!(r instanceof n))throw new TypeError("Cannot call a class as a function")}function f(r,n){if(!r)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!n||"object"!=typeof n&&"function"!=typeof n?r:n}var h=function(r){function n(){return m(this,n),f(this,(n.__proto__||Object.getPrototypeOf(n)).apply(this,arguments))}return function(r,n){if("function"!=typeof n&&null!==n)throw new TypeError("Super expression must either be null or a function, not "+typeof n);r.prototype=Object.create(n&&n.prototype,{constructor:{value:r,enumerable:!1,writable:!0,configurable:!0}}),n&&(Object.setPrototypeOf?Object.setPrototypeOf(r,n):r.__proto__=n)}(n,r),o(n,[{key:"render",value:function(){return a.default.createElement(i.Switch,null,a.default.createElement(i.Redirect,{exact:!0,from:"/interview",to:d.default[0].submenu[0].key}),u.default.allScreen.map((function(r,n){return a.default.createElement(l.default,t({key:n},r))})),u.default.partScreen.map((function(r,n){return a.default.createElement(l.default,{key:n,exact:r.exact,path:r.path,routePermission:r.routePermission,render:function(n){return a.default.createElement(c.default,t({},n,{component:r.component,menuConfig:d.default,defaultOpenKeys:["js"],hiddenLeftNav:!0}))}})})),a.default.createElement(i.Redirect,{to:"/interview"}))}}]),n}(s.Component);n.default=h}])]);